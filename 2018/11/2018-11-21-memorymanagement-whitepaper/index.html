<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)"><meta name="keywords" content="jvm"><meta name="author" content="sejoung"><meta name="copyright" content="sejoung"><title>Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006) | 폭간의 기술블로그</title><link rel="shortcut icon" href="../../../my-favicon.ico"><link rel="stylesheet" href="../../../css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="https://www.googletagmanager.com/gtag/js?id=G-NVRTGLD8RZ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NVRTGLD8RZ');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Management-in-the-Java-HotSpot%E2%84%A2-Virtual-Machine-Sun-Microsystems-April-2006"><span class="toc-number">1.</span> <span class="toc-text">Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">1 Introduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Explicit-vs-Automatic-Memory-Management"><span class="toc-number">1.2.</span> <span class="toc-text">2 Explicit vs. Automatic Memory Management</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Garbage-Collection-Concepts"><span class="toc-number">1.3.</span> <span class="toc-text">3 Garbage Collection Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Desirable-Garbage-Collector-Characteristics"><span class="toc-number">1.3.1.</span> <span class="toc-text">Desirable Garbage Collector Characteristics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Design-Choices"><span class="toc-number">1.3.2.</span> <span class="toc-text">Design Choices</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Performance-Metrics"><span class="toc-number">1.3.3.</span> <span class="toc-text">Performance Metrics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Generational-Collection"><span class="toc-number">1.3.4.</span> <span class="toc-text">Generational Collection</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Garbage-Collectors-in-the-J2SE-5-0-HotSpot-JVM"><span class="toc-number">1.4.</span> <span class="toc-text">4 Garbage Collectors in the J2SE 5.0 HotSpot JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HotSpot-Generations"><span class="toc-number">1.4.1.</span> <span class="toc-text">HotSpot Generations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Garbage-Collection-Types"><span class="toc-number">1.4.2.</span> <span class="toc-text">Garbage Collection Types</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fast-Allocation"><span class="toc-number">1.4.3.</span> <span class="toc-text">Fast Allocation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Collector"><span class="toc-number">1.4.4.</span> <span class="toc-text">Serial Collector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Young-Generation-Collection-Using-the-Serial-Collector"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Young Generation Collection Using the Serial Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Old-Generation-Collection-Using-the-Serial-Collector"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Old Generation Collection Using the Serial Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#When-to-Use-the-Serial-Collector"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">When to Use the Serial Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Serial-Collector-Selection"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">Serial Collector Selection</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Collector"><span class="toc-number">1.4.5.</span> <span class="toc-text">Parallel Collector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Young-Generation-Collection-Using-the-Parallel-Collector"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">Young Generation Collection Using the Parallel Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Old-Generation-Collection-Using-the-Parallel-Collector"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">Old Generation Collection Using the Parallel Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#When-to-Use-the-Parallel-Collector"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">When to Use the Parallel Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Parallel-Collector-Selection"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">Parallel Collector Selection</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Compacting-Collector"><span class="toc-number">1.4.6.</span> <span class="toc-text">Parallel Compacting Collector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Young-Generation-Collection-Using-the-Parallel-Compacting-Collector"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">Young Generation Collection Using the Parallel Compacting Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Old-Generation-Collection-Using-the-Parallel-Compacting-Collector"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">Old Generation Collection Using the Parallel Compacting Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#When-to-Use-the-Parallel-Compacting-Collector"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">When to Use the Parallel Compacting Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Parallel-Compacting-Collector-Selection"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">Parallel Compacting Collector Selection</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Concurrent-Mark-Sweep-CMS-Collector"><span class="toc-number">1.4.7.</span> <span class="toc-text">Concurrent Mark-Sweep (CMS) Collector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Young-Generation-Collection-Using-the-CMS-Collector"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">Young Generation Collection Using the CMS Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Old-Generation-Collection-Using-the-CMS-Collector"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">Old Generation Collection Using the CMS Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Incremental-Mode"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">Incremental Mode</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#When-to-Use-the-CMS-Collector"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">When to Use the CMS Collector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CMS-Collector-Selection"><span class="toc-number">1.4.7.5.</span> <span class="toc-text">CMS Collector Selection</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Ergonomics-%E2%80%93-Automatic-Selections-and-Behavior-Tuning"><span class="toc-number">1.5.</span> <span class="toc-text">5 Ergonomics – Automatic Selections and Behavior Tuning</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Automatic-Selection-of-Collector-Heap-Sizes-and-Virtual-Machine"><span class="toc-number">1.5.1.</span> <span class="toc-text">Automatic Selection of Collector, Heap Sizes, and Virtual Machine</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Behavior-based-Parallel-Collector-Tuning"><span class="toc-number">1.5.2.</span> <span class="toc-text">Behavior-based Parallel Collector Tuning</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Maximum-Pause-Time-Goal"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Maximum Pause Time Goal</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Throughput-Goal"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Throughput Goal</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Footprint-Goal"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">Footprint Goal</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Goal-Priorities"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">Goal Priorities</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Recommendations"><span class="toc-number">1.6.</span> <span class="toc-text">6 Recommendations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#When-to-Select-a-Different-Garbage-Collector"><span class="toc-number">1.6.1.</span> <span class="toc-text">When to Select a Different Garbage Collector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Heap-Sizing"><span class="toc-number">1.6.2.</span> <span class="toc-text">Heap Sizing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tuning-Strategy-for-the-Parallel-Collector"><span class="toc-number">1.6.3.</span> <span class="toc-text">Tuning Strategy for the Parallel Collector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#What-to-Do-about-OutOfMemoryError"><span class="toc-number">1.6.4.</span> <span class="toc-text">What to Do about OutOfMemoryError</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Tools-to-Evaluate-Garbage-Collection-Performance"><span class="toc-number">1.7.</span> <span class="toc-text">7 Tools to Evaluate Garbage Collection Performance</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%93XX-PrintGCDetails-Command-Line-Option"><span class="toc-number">1.7.1.</span> <span class="toc-text">–XX:+PrintGCDetails Command Line Option</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%93XX-PrintGCTimeStamps-Command-Line-Option"><span class="toc-number">1.7.2.</span> <span class="toc-text">–XX:+PrintGCTimeStamps Command Line Option</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jmap"><span class="toc-number">1.7.3.</span> <span class="toc-text">jmap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jstat"><span class="toc-number">1.7.4.</span> <span class="toc-text">jstat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HPROF-Heap-Profiler"><span class="toc-number">1.7.5.</span> <span class="toc-text">HPROF: Heap Profiler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HAT-Heap-Analysis-Tool"><span class="toc-number">1.7.6.</span> <span class="toc-text">HAT: Heap Analysis Tool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Key-Options-Related-to-Garbage-Collection"><span class="toc-number">1.8.</span> <span class="toc-text">8 Key Options Related to Garbage Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Garbage-Collector-Selection"><span class="toc-number">1.8.1.</span> <span class="toc-text">Garbage Collector Selection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Garbage-Collector-Statistics"><span class="toc-number">1.8.2.</span> <span class="toc-text">Garbage Collector Statistics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Heap-and-Generation-Sizes"><span class="toc-number">1.8.3.</span> <span class="toc-text">Heap and Generation Sizes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Options-for-the-Parallel-and-Parallel-Compacting-Collectors"><span class="toc-number">1.8.4.</span> <span class="toc-text">Options for the Parallel and Parallel Compacting Collectors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Options-for-the-CMS-Collector"><span class="toc-number">1.8.5.</span> <span class="toc-text">Options for the CMS Collector</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EC%A1%B0"><span class="toc-number"></span> <span class="toc-text">참조</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/4936005?s=400&amp;u=a679b941fe377418e7e4efcf916c6a636d7178ee&amp;v=4"></div><div class="author-info__name text-center">sejoung</div><div class="author-info__description text-center">잘정리하자</div><div class="follow-button"><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/sejoung">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../archives"><span class="pull-left">Articles</span><span class="pull-right">711</span></a><a class="author-info-articles__tags article-meta" href="../../../tags"><span class="pull-left">Tags</span><span class="pull-right">767</span></a><a class="author-info-articles__categories article-meta" href="../../../categories"><span class="pull-left">Categories</span><span class="pull-right">72</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.naver.com/sanaes">naverblog</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.linkedin.com/in/sanaes/">linkedin</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.slideshare.net/sejoung">slideshare</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../index.html">폭간의 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="../../../categories/java/">java</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/11/2018-11-21-memorymanagement-whitepaper/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="Memory-Management-in-the-Java-HotSpot™-Virtual-Machine-Sun-Microsystems-April-2006"><a href="#Memory-Management-in-the-Java-HotSpot™-Virtual-Machine-Sun-Microsystems-April-2006" class="headerlink" title="Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)"></a>Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)</h3><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><p>Java ™ 2 Platform, Standard Edition (J2SE ™)의 장점 중 하나는 자동 메모리를 수행한다는 것입니다<br>이로써 개발자는 명시 적 메모리 관리의 복잡성으로부터 개발자를 보호합니다.<br>이 백서에서는 Java HotSpot 가상 시스템 (JVM)의 메모리 관리에 대한 전반적인 개요를 제공합니다.<br>Sun의 J2SE 5.0 릴리스. 메모리 관리를 수행 할 수있는 가비지 콜렉터에 대해 설명하고,<br>수집기 선택 및 구성 및 메모리 영역의 크기 설정에 대한 조언을 제공합니다.<br>수집기가 작동합니다. 또한 리소스로도 사용되며 가장 일반적으로 사용되는 옵션 중 일부를 나열합니다.<br>가비지 컬렉터 동작에 영향을 주며보다 자세한 문서에 대한 수많은 링크를 제공합니다.</p>
<p>섹션 2는 자동 메모리 관리 개념을 처음 접하는 독자를위한 것입니다. 간단한 토론이있다.<br>프로그래머가 데이터 공간을 명시 적으로 할당 해제하도록 요구하는 대신 이러한 관리의 이점을 누릴 수 있습니다.<br>3 장에서는 일반 가비지 콜렉션 개념, 설계 선택 및 성능에 대한 개요를 제시합니다.<br>측정 항목 또한 일반적으로 사용되는 메모리 조직을 세대라고하는 여러 영역에 도입합니다.<br>개체의 예상 수명을 기준으로합니다. 세대로의이 분리는 감소시키는 데 효과적이라는 것이 입증되었습니다.<br>가비지 수집 일시 중지 시간 및 광범위한 응용 프로그램에서의 전반적인 비용.</p>
<p>이 문서의 나머지 부분에서는 HotSpot JVM 관련 정보를 제공합니다. 섹션 4에서는 네 가지 쓰레기<br>사용 가능한 수집기 (J2SE 5.0 업데이트 6의 새로운 기능 포함) 및 생성기<br>그들 모두가 활용하는 기억 조직. 각 수집기에 대해 섹션 4는 수집 알고리즘의 유형을 요약합니다<br>사용되며 해당 수집기를 선택하는 것이 적절한시기를 지정합니다.<br>5 절에서는 J2SE 5.0 릴리스의 새로운 기술에 대해 설명합니다.이 기술은 (1) 쓰레기 자동 선택<br>콜렉터, 힙 크기 및 HotSpot JVM (클라이언트 또는 서버)을 기반으로하는 플랫폼 및 운영 체제<br>응용 프로그램이 실행 중이고, (2) 사용자 지정 원하는 동작을 기반으로하는 동적 가비지 수집 조정.<br>이 기술을 인간 공학이라고합니다.</p>
<p>6 절에서는 가비지 수집기 선택 및 구성에 대한 권장 사항을 제공합니다. 또한<br>OutOfMemoryErrors에 대해 할 일에 대한 조언. 섹션 7에서는 몇 가지 도구를 간략하게 설명합니다.<br>가비지 수집 성능을 평가하는 데 사용되며 섹션 8에서는 가장 일반적으로 사용되는 명령 줄<br>가비지 수집기 선택 및 동작과 관련된 옵션 마지막으로 섹션 9에서는보다 자세한<br>이 문서에서 다루는 다양한 주제에 대한 문서</p>
<h4 id="2-Explicit-vs-Automatic-Memory-Management"><a href="#2-Explicit-vs-Automatic-Memory-Management" class="headerlink" title="2 Explicit vs. Automatic Memory Management"></a>2 Explicit vs. Automatic Memory Management</h4><p>메모리 관리는 할당 된 객체가 더 이상 필요하지 않을 때를 인식하고 할당을 해제하는 프로세스입니다.<br>그러한 객체가 사용하는 메모리를 비우는 (freeing) 것. 일부<br>프로그래밍 언어, 메모리 관리는 프로그래머의 책임입니다. 그 업무의 복잡성<br>예기치 않은 또는 잘못된 프로그램 동작 및 충돌을 일으킬 수있는 많은 일반적인 오류가 발생합니다. 마찬가지로<br>결과적으로 개발자 시간의 대부분은 종종 디버깅에 소요되며 이러한 오류를 수정하려고합니다.<br>명시 적 메모리 관리가있는 프로그램에서 종종 발생하는 한 가지 문제는 참조가 매달려 있다는 것입니다. 그것은<br>다른 객체가 여전히 참조를 가지고있는 객체가 사용하는 공간을 할당 해제 할 수 있습니다. 오브젝트<br>(댕글 링) 참조가 원래 객체에 액세스하려고 시도하지만 공간이 새로운 객체로 재 할당되었습니다.<br>결과는 예측할 수 없으며 의도 한 것이 아닙니다.</p>
<p>명시 적 메모리 관리와 관련된 또 다른 공통적 인 문제점은 공간 누수입니다. 이러한 누출은 메모리가<br>할당되고 더 이상 참조되지는 않지만 해제되지는 않습니다. 예를 들어, 귀하가 사용하는 공간을 확보하려는 경우<br>링크 된 목록하지만 목록의 첫 번째 요소를 할당 취소 실수로, 나머지 목록 요소<br>더 이상 참조되지는 않지만 프로그램의 범위를 벗어나 사용 및 복구 할 수 없습니다. 만약<br>충분한 누수가 발생하면 사용 가능한 모든 메모리가 모두 소모 될 때까지 메모리를 계속 사용할 수 있습니다.<br>특히 현재 가장 보편적으로 사용되는 메모리 관리에 대한 대체 접근 방식<br>객체 지향 언어는 가비지 수집기라는 프로그램에 의한 자동 관리입니다. 오토매틱<br>메모리 관리는 인터페이스의 추상화 및보다 안정적인 코드를 가능하게합니다.</p>
<p>가비지 콜렉션은 매달려있는 참조 문제를 피합니다. 여전히 어딘가에서 참조 된 객체<br>쓰레기 수거되지 않으므로 무료로 간주되지 않습니다. 가비지 수집으로 공간 누출 문제 해결<br>위에서 언급 한 문제는 더 이상 참조되지 않은 모든 메모리를 자동으로 해제하기 때문입니다.</p>
<h4 id="3-Garbage-Collection-Concepts"><a href="#3-Garbage-Collection-Concepts" class="headerlink" title="3 Garbage Collection Concepts"></a>3 Garbage Collection Concepts</h4><p>가비지 컬렉터는</p>
<ul>
<li>메모리 할당</li>
<li>참조 된 객체가 메모리에 남아 있는지 확인하고, 코드 실행시 참조에서 더 이상 접근 할 수없는 객체가 사용하는 메모리를 복구합니다.</li>
</ul>
<p>참조 된 오브젝트는 라이브라고합니다. 더 이상 참조되지 않는 객체는 죽은 것으로 간주되며<br>쓰레기. 이러한 개체가 사용하는 공간을 찾아서 해제하는 작업 (교정이라고도 함)<br>쓰레기 수거라고합니다.</p>
<p>가비지 수집은 많은 메모리 할당 문제를 해결하지만 전부는 아닙니다. 예를 들어, 객체를 생성 할 수 있습니다.<br>무기한 사용할 수있는 메모리가 없어 질 때까지 계속 참조하십시오. 가비지 수집 또한<br>복잡한 작업은 자체 시간과 자원을 필요로합니다.</p>
<p>메모리를 구성하고 공간을 할당하고 할당을 해제하는 데 사용되는 정확한 알고리즘은 쓰레기로 처리됩니다.<br>콜렉터이며 프로그래머에게 숨겨져 있습니다. 공간은 일반적으로 참조 된 많은 메모리 풀에서 할당됩니다.<br>힙으로.</p>
<p>가비지 콜렉션의 타이밍은 가비지 콜렉터에 달려 있습니다. 일반적으로 전체 힙 또는 하위 부분은 다음과 같습니다.<br>그것이 채워지거나 점유의 임계 비율에 도달 할 때 수집됩니다.<br>특정 크기의 사용되지 않은 메모리 블록을 찾기 위해 할당 요청을 수행하는 작업<br>힙은 어려운 것입니다. 대부분의 동적 메모리 할당 알고리즘의 주요 문제점은<br>(아래 참조), 할당과 할당 해제를 모두 효율적으로 유지합니다.</p>
<h5 id="Desirable-Garbage-Collector-Characteristics"><a href="#Desirable-Garbage-Collector-Characteristics" class="headerlink" title="Desirable Garbage Collector Characteristics"></a>Desirable Garbage Collector Characteristics</h5><p>가비지 수집기는 안전하고 포괄적이어야합니다. 즉, 라이브 데이터를 잘못해서는 안됩니다.<br>소량의 수거주기 이상을 위해 쓰레기를 버리지 말아야합니다.</p>
<p>가비지 컬렉터가 긴 정지를 도입하지 않고 효율적으로 작동하는 것이 바람직합니다.<br>응용 프로그램이 실행되고 있지 않습니다. 그러나 대부분의 컴퓨터 관련 시스템과 마찬가지로 종종 다음과 같은 절충안이 있습니다.<br>시간, 공간 및 빈도. 예를 들어, 힙 크기가 작 으면 모음은 빠르지 만 힙이 채워집니다<br>보다 신속하게 수집 할 수 있으므로 더 자주 수집해야합니다. 반대로 대량의 힙은 채우기까지 더 오래 걸리고<br>따라서 수집 빈도는 적지 만 오랜 시간이 걸릴 수 있습니다.</p>
<p>또 다른 바람직한 가비지 콜렉터 특성은 단편화의 한계입니다. 메모리가<br>가비지 개체가 해제되면 여유 공간이 여러 영역의 작은 덩어리로 나타날 수 있으므로<br>큰 물체의 할당을 위해 사용되는 하나의 인접한 영역에 충분한 공간이 있어야합니다. 한 가지 접근법<br>단편화를 제거하는 것을 압축이라고하며, 다양한 가비지 컬렉터 디자인 중에서 논의됩니다.<br>이하.</p>
<p>확장 성 또한 중요합니다. 다중 스레드의 경우 확장 성 병목 현상이 발생해서는 안됩니다.<br>다중 프로세서 시스템의 응용 프로그램 및 콜렉션도 병목 현상이 발생하지 않아야합니다.</p>
<h5 id="Design-Choices"><a href="#Design-Choices" class="headerlink" title="Design Choices"></a>Design Choices</h5><p>가비지 수집 알고리즘을 설계하거나 선택할 때 여러 가지 선택을해야합니다</p>
<ul>
<li>Serial versus Parallel</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">serial collection을 사용하면 한 번에 한 가지만 발생합니다. 예를 들어, 여러 CPU가</span><br><span class="line">사용할 수있는 경우에만 하나만 사용하여 수집을 수행합니다.</span><br><span class="line"></span><br><span class="line">Parallel collection이 사용될 때,</span><br><span class="line">가비지 콜렉션은 CPU 마다 틀리지만 부분들로 분할되고 그 하위 부분들은 다른 곳에서 동시에 실행됩니다. </span><br><span class="line">동시 작업을 통해 수집 작업을보다 신속하게 수행 할 수 있습니다.</span><br><span class="line">약간의 추가 복잡성 및 잠재적 단편화.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Concurrent versus Stop-the-world</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">When stop-the-world garbage collection is performed, execution of the application is completely</span><br><span class="line">suspended during the collection. Alternatively, one or more garbage collection tasks can be executed</span><br><span class="line">concurrently, that is, simultaneously, with the application. Typically, a concurrent garbage collector</span><br><span class="line">does most of its work concurrently, but may also occasionally have to do a few short stop-the-world</span><br><span class="line">pauses. Stop-the-world garbage collection is simpler than concurrent collection, since the heap is</span><br><span class="line">frozen and objects are not changing during the collection. Its disadvantage is that it may be</span><br><span class="line">undesirable for some applications to be paused. Correspondingly, the pause times are shorter when</span><br><span class="line">garbage collection is done concurrently, but the collector must take extra care, as it is operating over</span><br><span class="line">objects that might be updated at the same time by the application. This adds some overhead to</span><br><span class="line">concurrent collectors that affects performance and requires a larger heap size.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Compacting versus Non-compacting versus Copying</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">세계에서 가비지 수집이 수행되면 응용 프로그램의 실행이 완전히 끝납니다.</span><br><span class="line">컬렉션 중에 일시 중지되었습니다. 또는 하나 이상의 가비지 수집 작업을 실행할 수 있습니다.</span><br><span class="line">동시에, 즉 동시에 애플리케이션과 동시에 일반적으로 동시 가비지 수집기</span><br><span class="line">대부분의 작업을 동시에 처리하지만 때로는 몇 가지 간단한 중지 작업을 수행해야 할 수도 있습니다.</span><br><span class="line">일시 중지합니다. 세계에서 가비지 수집은 동시 수집보다 간단합니다. 왜냐하면 힙이</span><br><span class="line">고정되어 있으며 오브젝트는 콜렉션 중에 변경되지 않습니다.</span><br><span class="line">단점은 일부 응용 프로그램이 일시 중지되는 것은 바람직하지 않습니다. 이에 따라 일시 중지 시간은</span><br><span class="line">가비지 콜렉션이 동시에 수행되지만 콜렉터는 더 이상주의를 기울여야합니다.</span><br><span class="line">응용 프로그램에서 동시에 업데이트 할 수있는 객체 이렇게하면</span><br><span class="line">성능에 영향을 미치고 더 큰 힙 크기가 필요한 동시 콜렉터.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Performance-Metrics"><a href="#Performance-Metrics" class="headerlink" title="Performance Metrics"></a>Performance Metrics</h5><p>다음과 같은 가비지 수집기 성능을 평가하기 위해 몇 가지 메트릭이 사용됩니다.</p>
<ul>
<li>Throughput — 오랜 시간 동안 고려한 가비지 수집에 소비되지 않은 총 시간의 백분율.</li>
<li>Garbage collection overhead — 처리량의 역수, 즉 가비지 콜렉션에 소요 된 총 시간의 백분율.</li>
<li>Pause time — 가비지 수집이 진행되는 동안 응용 프로그램 실행이 중지되는 시간입니다.</li>
<li>Frequency of collection — 응용 프로그램 실행과 관련하여 수집이 이루어지는 빈도</li>
<li>Footprint — 힙 크기와 같은 크기 측정 단위입니다.</li>
<li>Promptness — 객체가 쓰레기가되고 메모리가 사용 가능하게 될 때까지의 시간.</li>
</ul>
<p>대화 형 응용 프로그램은 일시 중지 시간이 짧을 수 있지만 전반적인 실행 시간은<br>비대화 형 실시간 응용 프로그램은 가비지 수집 모두에서 작은 상한선을 요구합니다.<br>휴지기 및 수집기에서 소비 한 시간의 비율을 나타냅니다. 작은 풋 프린트가 메인 일 수 있습니다.<br>소형 개인용 컴퓨터 또는 임베디드 시스템에서 실행되는 응용 프로그램에 대한 우려.</p>
<h5 id="Generational-Collection"><a href="#Generational-Collection" class="headerlink" title="Generational Collection"></a>Generational Collection</h5><p>generational collection이라는 기술이 사용되면 메모리는 여러 세대로 나누어집니다.<br>다른 연령대의 개체를 보유하는 풀. 예를 들어, 가장 널리 사용되는 구성에는 두 세대가 있습니다.<br>하나는 젊은 물건을위한 것이고 다른 하나는 오래된 물건을위한 것입니다.</p>
<p>서로 다른 세대의 가비지 컬렉션을 수행하기 위해 서로 다른 알고리즘을 사용할 수 있습니다. 각 알고리즘은<br>특정 세대에 대해 일반적으로 관찰되는 특성을 기반으로 최적화됩니다. 세대 별 쓰레기<br>수집은 약한 세대 가설로 알려진 다음 관찰을 이용한다.<br>Java 프로그래밍 언어를 포함한 여러 프로그래밍 언어로 작성된 응용 프로그램 :</p>
<ul>
<li>할당 된 대부분의 객체는 오랫동안 참조되지 않고 (라이브로 간주됩니다.) 즉, 젊은 나이에 죽습니다.</li>
<li>나이가 많은 개체에서 어린 개체로의 참조가 거의 없습니다.</li>
</ul>
<p>젊은 세대 컬렉션은 상대적으로 빈번하게 발생하며 효율적이고 빠릅니다. 젊은 세대<br>공간은 일반적으로 작으며 더 이상 참조되지 않는 많은 객체를 포함 할 가능성이 높습니다.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_01.jpg" alt="그림1"></p>
<p>일부 젊은 세대 컬렉션에서 생존하는 객체는 결국 컬렉션으로 승격되거나 종신됩니다.<br>구세대. 그림 1을 보자.이 세대는 일반적으로 젊은 세대와 그 점유보다 크다.<br>더 천천히 자랍니다. 결과적으로 구세대 컬렉션은 드물게 발생하지만 오래 걸립니다.<br>완전한.</p>
<p>젊은 세대를 위해 선택한 가비지 수집 알고리즘은 일반적으로 젊은 세대부터 속도에 프리미엄을 부여합니다.<br>세대 컬렉션은 빈번합니다. 반면, 구세대는 일반적으로 알고리즘에 의해 관리됩니다<br>왜냐하면 구세대가 대부분의 힙과 구세대를 차지하기 때문입니다.<br>알고리즘은 낮은 쓰레기 밀도에서 잘 작동해야합니다.</p>
<h4 id="4-Garbage-Collectors-in-the-J2SE-5-0-HotSpot-JVM"><a href="#4-Garbage-Collectors-in-the-J2SE-5-0-HotSpot-JVM" class="headerlink" title="4 Garbage Collectors in the J2SE 5.0 HotSpot JVM"></a>4 Garbage Collectors in the J2SE 5.0 HotSpot JVM</h4><p>Java HotSpot 가상 머신에는 J2SE 5.0 업데이트 6부터 4 개의 가비지 콜렉터가 포함되어 있습니다. 모든 콜렉터는<br>세대. 이 섹션에서는 콜렉션의 세대와 유형을 설명하고 오브젝트가 왜<br>할당은 종종 빠르고 효율적입니다. 그런 다음 각 콜렉터에 대한 자세한 정보를 제공합니다.</p>
<h5 id="HotSpot-Generations"><a href="#HotSpot-Generations" class="headerlink" title="HotSpot Generations"></a>HotSpot Generations</h5><p>Java HotSpot 가상 시스템의 메모리는 다음 세 세대로 구성됩니다. 젊은 세대, 오래된 세대<br>세대, 그리고 영구 세대. 대부분의 객체는 처음에는 젊은 세대에 할당됩니다. 오래 된<br>세대에는 몇 가지 젊은 세대 컬렉션에서 살아남은 객체뿐만 아니라<br>구세대에 직접 할당 할 수있는 큰 개체. 영구 세대는<br>JVM은 클래스와 메소드를 설명하는 객체와 같이 가비지 컬렉터를 관리하는 것이 편리하다고 판단하고,<br>클래스 및 메서드 자체도 포함됩니다</p>
<p>젊은 세대는 그림 2와 같이 에덴 (Eden)이라고 불리는 영역과 2 개의 작은 생존 공간으로 구성됩니다.<br>대부분의 객체는 처음에 Eden에 할당됩니다. (언급했듯이, 몇 개의 커다란 객체는<br>오래된 세대.) 생존자 공간은 적어도 한 세대의 젊은 세대 컬렉션에서 살아남은 물체를 보유합니다<br>따라서 “충분히 오래되었다”고 간주되기 전에 죽을 기회가 더 주어졌습니다.<br>구세대. 주어진 시간에 생존 공간 중 하나 (그림에서 From라고 표시됨)에는 이러한 객체가 저장되어 있으며,<br>다른 하나는 비어 있고 다음 수집까지 사용되지 않은 채로 남아 있습니다.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_02.jpg" alt="그림2"></p>
<h5 id="Garbage-Collection-Types"><a href="#Garbage-Collection-Types" class="headerlink" title="Garbage Collection Types"></a>Garbage Collection Types</h5><p>젊은 세대가 가득 차면 젊은 세대 컬렉션 (때로는 소규모 컬렉션이라고도 함)<br>그 세대의 일이 수행됩니다. 오래되거나 영구적 인 세대가 가득 차면, 전체로 알려진 것<br>컬렉션 (때로는 주요 컬렉션이라고 함)이 일반적으로 수행됩니다. 즉, 모든 세대가 수집됩니다.<br>일반적으로 젊은 세대는 먼저 수집 된 알고리즘을 사용하여 수집됩니다.<br>왜냐하면 일반적으로 젊은 세대에서 쓰레기를 식별하는 가장 효율적인 알고리즘이기 때문입니다.<br>그러면 주어진 콜렉터에 대한 구 세대 콜렉션 알고리즘이라고하는 것은<br>오래되고 영구적 인 세대. 압축이 발생하면 각 세대가 개별적으로 압축됩니다.</p>
<p>때로는 구세대가 너무 커서 전체로부터 승격 될 수있는 모든 물건을 받아 들일 수 없습니다.<br>어린 세대가 먼저 모아 진다면 젊은 세대는 옛 세대로. 이 경우,<br>CMS 수집기, 젊은 세대 수집 알고리즘이 실행되지 않습니다. 대신, 구세대 컬렉션<br>알고리즘은 전체 힙에서 사용됩니다. (CMS 구 세대 알고리즘은 특별한 경우입니다.<br>젊은 세대를 모으십시오.)</p>
<h5 id="Fast-Allocation"><a href="#Fast-Allocation" class="headerlink" title="Fast Allocation"></a>Fast Allocation</h5><p>아래의 가비지 컬렉터 설명에서 볼 수 있듯이 많은 경우에 큰 연속 블록이 있습니다<br>객체를 할당 할 수있는 메모리의 양. 이러한 블록의 할당은 간단하며<br>범프 - 포인터 기술. 즉, 이전에 할당 된 객체의 끝은 항상 추적됩니다. 때<br>새로운 할당 요청을 만족해야 할 필요가있는 것은 객체가 적합 할지를 검사하는 것이다.<br>그렇다면 포인터를 업데이트하고 객체를 초기화합니다.</p>
<p>다중 스레드 응용 프로그램의 경우 할당 작업이 다중 스레드 안전해야합니다. 전역 잠금이 사용 된 경우<br>이를 보장하면 세대에 할당하면 병목 현상이 발생하고 성능이 저하됩니다. 대신,<br>HotSpot JVM은 Thread-Local Allocation Buffers (TLABs)라는 기술을 채택했습니다. 이것은 향상시킨다.<br>각 스레드에게 자신의 버퍼를 제공함으로써 멀티 스레딩 할당 처리량 (즉,<br>세대). 하나의 쓰레드 만이 각 TLAB에 할당 될 수 있기 때문에, 할당은<br>어떠한 잠금도 요구하지 않고 bump-the-pointer 기술을 활용하여 신속하게 배치 할 수 있습니다. 드문 경우지만,<br>스레드가 TLAB를 채우고 새 스레드를 가져와야하는 경우 동기화를 사용해야합니다. 몇 가지 기술<br>TLAB의 사용으로 인한 공간 낭비를 최소화하기 위해 사용됩니다. 예를 들어, TLAB는 할당 자<br>평균적으로 에덴의 1 % 미만을 낭비합니다. TLAB 사용과 선형 할당의 조합은<br>bump-the-pointer 기술은 각 할당을 효율적으로 수행 할 수 있으며 약 10 개의 기본 명령어 만 필요합니다.</p>
<h5 id="Serial-Collector"><a href="#Serial-Collector" class="headerlink" title="Serial Collector"></a>Serial Collector</h5><p>시리얼 콜렉터를 사용하면 젊은 세대와 구형 콜렉션 모두가 순차적으로 (단일 CPU를 사용하여), 중단 세계에서<br>유행. 즉, 수집이 진행되는 동안 응용 프로그램 실행이 중지됩니다.</p>
<h6 id="Young-Generation-Collection-Using-the-Serial-Collector"><a href="#Young-Generation-Collection-Using-the-Serial-Collector" class="headerlink" title="Young Generation Collection Using the Serial Collector"></a>Young Generation Collection Using the Serial Collector</h6><p>그림 3은 직렬 콜렉터를 사용하는 젊은 세대 콜렉션의 작동을 보여줍니다. 라이브<br>Eden의 객체는 그림에서 To라는 레이블이 붙은 초기 비어있는 생존 공간으로 복사됩니다 (예외는 제외).<br>너무 커서 To 공간에 편안하게 맞출 수 없습니다. 이러한 객체는 이전 객체에 직접 복사됩니다.<br>세대. 점령 된 생존자 공간에있는 살아있는 물체 (From 레이블)는 여전히 비교적 젊다.<br>다른 생존자 공간에도 복사되는 반면 상대적으로 오래된 개체는 구형 개체로 복사됩니다.<br>세대. 참고 : To 공간이 가득차면 Eden 또는 From의 라이브 객체가<br>그들이 살아남은 젊은 세대 컬렉션과는 상관없이 그곳에 복사되어 있습니다. 어떤<br>Eden에 남아있는 객체 또는 실제 객체를 복사 한 후 From 공간은 정의에 따라 다릅니다.<br>살아 있고 검사 할 필요가 없습니다. (이 쓰레기 개체는 그림에서 X로 표시되어 있습니다.<br>사실 수집가는 이러한 객체를 검사하거나 표시하지 않습니다.)</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_03.jpg" alt="그림3"></p>
<p>젊은 세대 컬렉션이 완료되면 에덴과 이전에 점령 된 생존자 공간은 모두<br>비어 있고 오직 이전의 빈 생존자 공간 만이 살아있는 물체를 포함합니다. 이 시점에서, 생존자<br>공백은 스왑 역할을합니다. 그림 4를 참조하십시오.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_04.jpg" alt="그림4"></p>
<h6 id="Old-Generation-Collection-Using-the-Serial-Collector"><a href="#Old-Generation-Collection-Using-the-Serial-Collector" class="headerlink" title="Old Generation Collection Using the Serial Collector"></a>Old Generation Collection Using the Serial Collector</h6><p>연속 수집기를 사용하면 오래되고 영구적 인 세대가 마크 스윕 콤팩트를 통해 수집됩니다.<br>수집 알고리즘. 마크 단계에서 수집기는 어떤 객체가 아직 살아 있는지 식별합니다. 스윕<br>단계가 “쓰레기”를 식별하여 세대를 뒤덮습니다. 콜렉터는 슬라이딩을 수행합니다.<br>압축 (compaction), 살아있는 물체를 구 세대 공간의 시작 부분으로 밀어 낸다.<br>영구 생성), 반대쪽 끝의 단일 연속 청크에 여유 공간을 남겨 둡니다. 만나다<br>그림 5. 압축을 통해 이전 또는 영구 세대에 대한 향후 할당이<br>빠르고 범프 - 포인터 기법.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_05.jpg" alt="그림5"></p>
<h6 id="When-to-Use-the-Serial-Collector"><a href="#When-to-Use-the-Serial-Collector" class="headerlink" title="When to Use the Serial Collector"></a>When to Use the Serial Collector</h6><p>직렬 콜렉터는 클라이언트 스타일의 시스템에서 실행되는 대부분의 어플리케이션에 적합한 콜렉터입니다.<br>낮은 일시 정지 시간을 요구하지 않습니다. 오늘날의 하드웨어에서 직렬 수집기는<br>64MB 힙과 상대적으로 짧은 최악의 사례로 많은 사소한 애플리케이션을 효율적으로 관리합니다.<br>전체 수집을 위해 0.5 초 미만의 일시 중지</p>
<h6 id="Serial-Collector-Selection"><a href="#Serial-Collector-Selection" class="headerlink" title="Serial Collector Selection"></a>Serial Collector Selection</h6><p>J2SE 5.0 릴리스에서는 시리얼 콜렉터가 자동으로 기본 가비지 콜렉터로 선택됩니다.<br>제 5 절에서 설명 된 것처럼 서버 클래스 머신이 아닌 머신. 다른 머신에서는 직렬<br>수집기는 -XX : + UseSerialGC 명령 줄 옵션을 사용하여 명시 적으로 요청할 수 있습니다.</p>
<h5 id="Parallel-Collector"><a href="#Parallel-Collector" class="headerlink" title="Parallel Collector"></a>Parallel Collector</h5><p>요즘 많은 Java 응용 프로그램은 많은 실제 메모리와 여러 CPU가있는 시스템에서 실행됩니다. 그만큼<br>병렬 수집기 (throughput collector라고도 함)는 사용 가능한<br>CPU가 유휴 상태를 유지하는 대신 가비지 수집 작업 만 수행합니다.</p>
<h6 id="Young-Generation-Collection-Using-the-Parallel-Collector"><a href="#Young-Generation-Collection-Using-the-Parallel-Collector" class="headerlink" title="Young Generation Collection Using the Parallel Collector"></a>Young Generation Collection Using the Parallel Collector</h6><p>병렬 수집기는 병렬 처리기가 사용하는 젊은 세대 수집 알고리즘의 병렬 버전을 사용합니다.<br>직렬 수집기. 그것은 여전히 ​​세계와 복사 수집가이지만, 젊은 세대를 수행<br>많은 CPU를 사용하여 병렬로 수집하면 가비지 콜렉션 오버 헤드가 줄어들어 애플리케이션 처리량이 증가합니다<br>그림 6은 직렬 수집기와 병렬 젊은 세대를위한 수집가.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_06.jpg" alt="그림6"></p>
<h6 id="Old-Generation-Collection-Using-the-Parallel-Collector"><a href="#Old-Generation-Collection-Using-the-Parallel-Collector" class="headerlink" title="Old Generation Collection Using the Parallel Collector"></a>Old Generation Collection Using the Parallel Collector</h6><p>병렬 수집기에 대한 이전 세대 가비지 수집은 동일한 직렬 마크 - 스위프 컴 팩트를 사용하여 수행됩니다.<br>수집 알고리즘을 직렬 수집기로 사용합니다.</p>
<h6 id="When-to-Use-the-Parallel-Collector"><a href="#When-to-Use-the-Parallel-Collector" class="headerlink" title="When to Use the Parallel Collector"></a>When to Use the Parallel Collector</h6><p>병렬 수집기의 이점을 누릴 수있는 응용 프로그램은 병렬 수집기 이상을 실행하는 시스템에서 실행되는 응용 프로그램입니다.<br>하나의 CPU이고 일시적인 시간 제약이 없습니다. 드문 경우지만 오래된 세대이기 때문에<br>콜렉션은 계속 발생합니다. 병렬 수집기가 종종 적합한 응용 사례<br>일괄 처리, 대금 청구, 급여 지불, 과학 계산 등을 수행하는 업무를 포함합니다.</p>
<p>병렬 압축 수집기 (다음에 설명 됨)를 병렬로 선택하는 것이 좋습니다<br>컬렉터, 왜냐하면 전자는 젊은 세대뿐만 아니라 모든 세대의 평행 컬렉션을 수행하기 때문입니다.<br>세대.</p>
<h6 id="Parallel-Collector-Selection"><a href="#Parallel-Collector-Selection" class="headerlink" title="Parallel Collector Selection"></a>Parallel Collector Selection</h6><p>J2SE 5.0 릴리스에서는 병렬 수집기가 자동으로 기본 가비지 수집기로 선택됩니다.<br>서버 클래스 기계 (5 절에서 정의 됨). 다른 컴퓨터에서 병렬 수집기는 명시 적으로<br>-XX : + UseParallelGC 명령 줄 옵션을 사용하여 요청합니다.</p>
<h5 id="Parallel-Compacting-Collector"><a href="#Parallel-Compacting-Collector" class="headerlink" title="Parallel Compacting Collector"></a>Parallel Compacting Collector</h5><p>병렬 압축 수집기는 J2SE 5.0 업데이트 6에 도입되었습니다.<br>수집기는 이전 세대의 가비지 수집을위한 새로운 알고리즘을 사용한다는 것입니다. 참고 : 결국, 병렬<br>compacting collector가 병렬 수집기를 대체 할 것입니다.</p>
<h6 id="Young-Generation-Collection-Using-the-Parallel-Compacting-Collector"><a href="#Young-Generation-Collection-Using-the-Parallel-Compacting-Collector" class="headerlink" title="Young Generation Collection Using the Parallel Compacting Collector"></a>Young Generation Collection Using the Parallel Compacting Collector</h6><p>평행 집진기를위한 젊은 세대 가비지 수집은<br>알고리즘을 병렬 수집기를 사용하는 젊은 세대 수집 용 알고리즘으로</p>
<h6 id="Old-Generation-Collection-Using-the-Parallel-Compacting-Collector"><a href="#Old-Generation-Collection-Using-the-Parallel-Compacting-Collector" class="headerlink" title="Old Generation Collection Using the Parallel Compacting Collector"></a>Old Generation Collection Using the Parallel Compacting Collector</h6><p>평행 압축 수집기로, 오래되고 영구적 인 세대는 세계에서 모아집니다.<br>슬라이딩 압축을 통한 대부분의 병렬 방식. 수집기는 세 단계를 사용합니다. 첫째, 각각<br>세대는 논리적으로 고정 된 크기의 영역으로 나뉩니다. 마킹 단계에서 라이브 개체의 초기 집합<br>응용 프로그램 코드에서 직접 접근 할 수있는 가비지 수집 스레드는 가비지 수집 스레드로 나뉘며 그 다음 모두<br>라이브 오브젝트는 병렬로 표시됩니다. 객체가 실시간으로 식별되면 해당 객체가있는 지역의 데이터가<br>개체의 크기와 위치에 대한 정보로 업데이트됩니다.</p>
<p>요약 단계는 객체가 아닌 영역에서 작동합니다. 이전 컬렉션의 압축으로 인해<br>전형적으로 각 세대의 왼쪽 부분의 일부는 밀도가 높고 대부분 생중계가 포함됩니다.<br>사물. 이러한 고밀도 지역에서 복구 할 수있는 공간의 크기는 비용의 가치가 없습니다.<br>그들을 압축. 따라서 요약 단계가 수행하는 첫 번째 작업은 지역의 밀도를 검사하는 것입니다.<br>맨 왼쪽에서부터 복구 할 수있는 공간에 도달 할 때까지 왼쪽 맨 처음부터 시작합니다.<br>그 지역 오른쪽에있는 지역은 그 지역을 압축하는 데 드는 비용이 든다. 왼쪽 영역<br>그 점의 조밀 한 접두어로 언급되고, 아무 영역도 그 지역에서 움직이지 않는다. 지역<br>그 지점의 오른쪽에 모든 죽은 공간을 제거, 압축됩니다. 요약 단계는 다음을 계산합니다.<br>압축 된 각 영역에 대한 라이브 데이터의 첫 번째 바이트의 새 위치를 저장합니다. 참고 : 요약<br>단계는 현재 직렬 단계로 구현됩니다. 병렬화는 가능하지만 중요하지는 않습니다.<br>성능을 마킹 및 압축 단계의 병렬화로 나타냅니다.</p>
<p>압축 단계에서 가비지 콜렉션 스레드는 요약 데이터를 사용하여<br>채워질 필요가 있고 스레드는 독립적으로 데이터를 영역에 복사 할 수 있습니다. 이것은 힙을 생성합니다.<br>한쪽 끝은 조밀하게 채워져 있고, 다른 쪽 끝에는 하나의 커다란 빈 블록이 있습니다.</p>
<h6 id="When-to-Use-the-Parallel-Compacting-Collector"><a href="#When-to-Use-the-Parallel-Compacting-Collector" class="headerlink" title="When to Use the Parallel Compacting Collector"></a>When to Use the Parallel Compacting Collector</h6><p>병렬 수집기와 마찬가지로 병렬 압축 수집기는 실행되는 응용 프로그램에 유용합니다<br>둘 이상의 CPU가있는 기계에서. 또한 구 세대 컬렉션의 병렬 작업<br>일시 정지 시간을 줄이고 병렬 압축 수집기를 병렬보다 더 적합하게 만듭니다<br>콜렉터는 일시 중지 시간 제한이있는 응용 프로그램에 사용됩니다. 병렬 압축 수집기는<br>단일 응용 프로그램이없는 대규모 공유 시스템 (예 : SunRays)에서 실행되는 응용 프로그램에 적합해야합니다.<br>오랜 시간 동안 여러 CPU를 독점해야합니다. 그런 기계에서,<br>가비지 콜렉션에 사용되는 스레드 수 줄이기 (-XX : ParallelGCThreads &#x3D; n<br>명령 행 옵션) 또는 다른 콜렉터를 선택하십시오.</p>
<h6 id="Parallel-Compacting-Collector-Selection"><a href="#Parallel-Compacting-Collector-Selection" class="headerlink" title="Parallel Compacting Collector Selection"></a>Parallel Compacting Collector Selection</h6><p>병렬 압축 수집기를 사용하려면 다음을 지정하여 선택해야합니다.<br>명령 줄 옵션 -XX : + UseParallelOldGC.</p>
<h5 id="Concurrent-Mark-Sweep-CMS-Collector"><a href="#Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="Concurrent Mark-Sweep (CMS) Collector"></a>Concurrent Mark-Sweep (CMS) Collector</h5><p>많은 어플리케이션에서 종단 간 처리량은 빠른 응답 시간만큼 중요하지 않습니다. 젊은 세대<br>컬렉션은 일반적으로 긴 일시 중지를 발생시키지 않습니다. 그러나 오래된 컬렉션은 드물 긴하지만<br>특히 큰 힙이 포함될 때 긴 일시 중지를 부과하십시오. 이 문제를 해결하기 위해 HotSpot JVM에는<br>(CMS) 콜렉터라고하는 콜렉터 (저 대기 시간 콜렉터라고도 함)가 있습니다.</p>
<h6 id="Young-Generation-Collection-Using-the-CMS-Collector"><a href="#Young-Generation-Collection-Using-the-CMS-Collector" class="headerlink" title="Young Generation Collection Using the CMS Collector"></a>Young Generation Collection Using the CMS Collector</h6><p>CMS 수집기는 병렬 수집기와 동일한 방식으로 새 세대를 수집합니다</p>
<h6 id="Old-Generation-Collection-Using-the-CMS-Collector"><a href="#Old-Generation-Collection-Using-the-CMS-Collector" class="headerlink" title="Old Generation Collection Using the CMS Collector"></a>Old Generation Collection Using the CMS Collector</h6><p>CMS 콜렉터를 사용하는 대부분의 구 세대 콜렉션은 다음과 동시에 수행됩니다<br>응용 프로그램의 실행</p>
<p>CMS 수집기의 수집주기는 초기 표시라고하는 짧은 일시 중지로 시작됩니다.<br>응용 프로그램 코드에서 직접 도달 할 수있는 초기 라이브 객체 집합을 식별합니다. 그때,<br>병행 마킹 단계에서 콜렉터는 전이되는 모든 실시간 객체를 표시합니다<br>이 집합에서 도달 할 수 있습니다. 응용 프로그램이 실행되고 참조 필드를 업데이트하기 때문에<br>마킹 단계가 진행 중입니다. 모든 라이브 개체가 마지막 단계에서 표시되도록 보장되어 있지는 않습니다.<br>동시 마킹 단계. 이를 처리하기 위해 응용 프로그램은 remark라고하는 두 번째 일시 중지를 위해 다시 중지합니다.<br>동시 마킹 중에 수정 된 객체를 다시 방문하여 마킹을 마무리합니다.<br>단계. 발언 일시 중지가 초기 표시보다 상당하기 때문에 여러 스레드가 실행됩니다.<br>병렬로 연결하면 효율이 향상됩니다.</p>
<p>발언 단계가 끝나면 힙의 모든 활성 객체가 표시되도록 보장되므로<br>후속 동시 스위프 단계는 식별 된 모든 쓰레기를 회수합니다. 그림 7<br>직렬 마크 - 스윕 - 콤팩트를 사용한 구 세대 컬렉션 간의 차이점<br>수집기 및 CMS 수집기.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_07.jpg" alt="그림7"></p>
<p>발언 단계에서 객체를 다시 방문하는 것과 같은 일부 작업은 작업량을 증가시킵니다.<br>컬렉터가해야 할 일은 오버 헤드가 증가하기 때문입니다. 이것은 대부분의 콜렉터에게 일반적인 트레이드 오프입니다.<br>일시 중지 시간을 줄이려고 시도하십시오.</p>
<p>CMS 수집기는 압축되지 않는 유일한 수집기입니다. 즉, 공간이 확보 된 후<br>죽은 물체가 점령 한 경우 살아있는 물체를 구세대의 한쪽 끝으로 이동시키지 않습니다. 그림 8을 참조하십시오.</p>
<p><img src="https://sejoung.github.io/images/2018_11_21_08.jpg" alt="그림8"></p>
<p>이렇게하면 시간이 절약되지만 여유 공간이 인접하지 않기 때문에 콜렉터는 더 이상 간단한 공간을 사용할 수 없습니다.<br>포인터는 다음 객체가 할당 될 수있는 다음 자유 위치를 가리킨다. 대신 지금은<br>무료 목록을 사용해야합니다. 즉, 할당되지 않은 영역을 함께 연결하는 몇 가지 목록을 만듭니다.<br>메모리를 할당하고 개체를 할당해야 할 때마다 적절한 목록 (<br>메모리 필요) 개체를 보유 할 수있을만큼 큰 영역을 검색해야합니다. 결과적으로 할당<br>구세대에 들어가는 것은 단순한 범프 - 포인터 기법을 사용하는 것보다 비용이 많이 든다.<br>이것은 또한 젊은 세대 컬렉션에 추가 오버 헤드를 부과한다.<br>세대는 젊은 세대 컬렉션에서 대상을 홍보 할 때 발생합니다.</p>
<p>CMS 수집기의 또 다른 단점은 다른 힙 크기보다 큰 힙 크기에 대한 요구 사항입니다<br>수집가. 응용 프로그램이 마킹 단계에서 실행되도록 허용되면 응용 프로그램을 계속 실행할 수 있습니다.<br>메모리를 할당함으로써 잠재적으로 구세대를 계속 성장시킬 수 있습니다. 또한, 비록<br>수집기가 표시 단계에서 모든 활성 객체를 식별 할 수 있도록 보장합니다. 일부 객체는<br>그 단계의 쓰레기는 다음 세대 컬렉션까지 회수되지 않습니다. 이러한<br>개체를 부동 쓰레기(floating garbage)라고합니다.</p>
<p>마지막으로, 단편화는 압축 부족으로 인해 발생할 수 있습니다. 단편화를 다루기 위해 CMS<br>수집기는 인기있는 객체 크기를 추적하고 미래의 수요를 예측하며 자유 블록을 분할하거나 결합 할 수 있습니다.<br>수요를 충족하다.</p>
<p>다른 콜렉터와 달리 CMS 콜렉터는 이전 세대 컬렉션이 시작될 때 이전 세대 컬렉션을 시작하지 않습니다.<br>세대가 가득 차게된다. 대신 컬렉션을 시작하여 컬렉션을 완료 할 수 있도록 시도합니다.<br>그 일이 있기 전에. 그렇지 않으면 CMS 수집기가 더 많은 시간을 소비하는 세계로 돌아갑니다.<br>병렬 및 직렬 수집기에서 사용하는 마크 스윕 콤팩트 알고리즘. 이를 피하기 위해 CMS<br>컬렉터는 이전 수집 시간에 대한 통계 및 이전 수집 시간에 대한 통계를 기반으로 한 번에 시작됩니다.<br>세대가 점령된다. CMS 수집기는 이전 버전의<br>세대는 초기 인력이라는 것을 능가합니다. 시작 인원의 가치는<br>명령 줄 옵션 -XX : CMSInitiatingOccupancyFraction &#x3D; n으로 설정합니다. 여기서 n은 a입니다.<br>구세대의 비율. 기본값은 68입니다.</p>
<p>요약하면, 병렬 수집기에 비해 CMS 수집기는 이전 세대의 일시 중지를 줄입니다.<br>때로는 극적으로 - 젊은 세대가 약간 더 길어 지기도하지만,<br>처리량 및 여분의 힙 크기 요구 사항이 있습니다.</p>
<h6 id="Incremental-Mode"><a href="#Incremental-Mode" class="headerlink" title="Incremental Mode"></a>Incremental Mode</h6><p>CMS 수집기는 동시 단계가 점진적으로 수행되는 모드에서 사용할 수 있습니다. 이<br>모드는 주기적으로 동시 실행을 중지하여 긴 동시 발생 단계의 영향을 줄이는 것을 의미합니다.<br>단계를 수행하여 응용 프로그램에 대한 처리를 다시 수행하십시오. 수집기에 의해 수행 된 작업은 작은<br>젊은 세대 컬렉션 사이에 예정된 시간대. 이 기능은<br>동시 콜렉터가 제공하는 낮은 일시 정지 시간을 필요로하는 어플리케이션은 시스템에서 실행됩니다<br>적은 수의 프로세서 (예 : 1 또는 2)를 사용합니다. 이 모드의 사용법에 대한 자세한 내용은<br>9 절에서 언급 한 “5.0 Java ™ 가상 시스템으로 가비지 수집 조정”문서</p>
<h6 id="When-to-Use-the-CMS-Collector"><a href="#When-to-Use-the-CMS-Collector" class="headerlink" title="When to Use the CMS Collector"></a>When to Use the CMS Collector</h6><p>응용 프로그램에서 더 이상 가비지 수집을 일시 중지해야 할 필요가있을 때 CMS 수집기를 사용하십시오.<br>응용 프로그램이 실행 중일 때 프로세서 자원을 가비지 수집기와 공유하십시오. (그것 때문에<br>동시성으로 인해 CMS 수집기는 수집주기 동안 CPU주기를 응용 프로그램에서 제거합니다.<br>일반적으로 수명이 긴 데이터 세트 (대형 구형 세대)가 상대적으로 많은 응용 프로그램과<br>두 개 이상의 프로세서가있는 컴퓨터에서 실행되는 경우이 수집기의 사용으로 이익을 얻는 경향이 있습니다. 예제<br>웹 서버가 될 것입니다. 일시 중지 시간이 짧은 모든 애플리케이션에 대해 CMS 수집기를 고려해야합니다.<br>요구 사항. 또한 오래된 세대의 겸손한 대화 형 응용 프로그램에서도 좋은 결과를 얻을 수 있습니다.<br>단일 프로세서의 크기.</p>
<h6 id="CMS-Collector-Selection"><a href="#CMS-Collector-Selection" class="headerlink" title="CMS Collector Selection"></a>CMS Collector Selection</h6><p>CMS 수집기를 사용하려면 명령 줄을 지정하여 명시 적으로 선택해야합니다<br>옵션 -XX : + UseConcMarkSweepGC. 증분 모드로 실행하려면 해당 옵션을 활성화하십시오.<br>모드는 -XX : + CMSIncrementalMode 옵션을 통해</p>
<h4 id="5-Ergonomics-–-Automatic-Selections-and-Behavior-Tuning"><a href="#5-Ergonomics-–-Automatic-Selections-and-Behavior-Tuning" class="headerlink" title="5 Ergonomics – Automatic Selections and Behavior Tuning"></a>5 Ergonomics – Automatic Selections and Behavior Tuning</h4><p>J2SE 5.0 릴리스에서는 가비지 수집기, 힙 크기 및 HotSpot 가상 시스템 (클라이언트 또는<br>서버)는 응용 프로그램이있는 플랫폼 및 운영 체제를 기반으로 자동 선택됩니다<br>달리는. 이러한 자동 선택은 다양한 유형의 응용 프로그램 요구 사항에 더 잘 부합하며<br>이전 릴리스보다 명령 줄 옵션이 적습니다.</p>
<p>또한 동적 가비지 콜렉션의 새로운 f}이 병렬 가비지 콜렉터에 추가되었습니다. 와<br>이 접근 방식에서는 사용자가 원하는 동작을 지정하고 가비지 수집기가<br>요청 된 동작을 얻기위한 힙 영역. 플랫폼 종속적 인 조합<br>기본 선택 및 원하는 동작을 사용하는 가비지 콜렉션 튜닝을 인체 공학이라고합니다. 그만큼<br>인체 공학의 목표는 최소한의 명령 행 튜닝으로 JVM에서 우수한 성능을 제공하는 것입니다.</p>
<h5 id="Automatic-Selection-of-Collector-Heap-Sizes-and-Virtual-Machine"><a href="#Automatic-Selection-of-Collector-Heap-Sizes-and-Virtual-Machine" class="headerlink" title="Automatic Selection of Collector, Heap Sizes, and Virtual Machine"></a>Automatic Selection of Collector, Heap Sizes, and Virtual Machine</h5><p>서버급 컴퓨터는 다음과 같이 정의됩니다.</p>
<ul>
<li>2 개 이상의 물리적 프로세서</li>
<li>2 개 이상의 기가 바이트 실제 메모리</li>
</ul>
<p>이 서버 클래스 시스템의 정의는 모든 플랫폼에 적용됩니다. 단, 32 비트 플랫폼에서는<br>버전의 Windows 운영 체제.</p>
<p>서버급 시스템이 아닌 시스템에서 JVM, 가비지 콜렉터 및 힙 크기의 기본값은 다음과 같습니다.</p>
<ul>
<li>the client JVM</li>
<li>the serial garbage collector</li>
<li>Initial heap size of 4MB</li>
<li>Maximum heap size of 64MB</li>
</ul>
<p>서버 클래스 시스템에서 명시 적으로 -client를 지정하지 않으면 JVM은 항상 서버 JVM입니다.<br>명령 행 옵션을 사용하여 클라이언트 JVM을 요청하십시오. 서버 JVM을 실행하는 서버 클래스 시스템에서 기본값<br>가비지 수집기는 병렬 수집기입니다. 그렇지 않은 경우 기본값은 직렬 콜렉터입니다</p>
<p>병렬 가비지 컬렉터가있는 JVM (클라이언트 또는 서버)을 실행하는 서버 클래스 시스템에서 기본값<br>초기 힙 크기와 최대 힙 크기는 다음과 같습니다.</p>
<ul>
<li>물리적 메모리의 1 &#x2F; 64th의 초기 힙 크기, 최대 1GB. 서버 클래스 컴퓨터는 최소한 2GB의 메모리를 가지며 2 &#x2F; 64GB는 32MB이기 때문에 최소 초기 힙 크기는 32MB입니다.</li>
<li>실제 메모리의 1&#x2F;4 크기의 최대 힙 크기 (최대 1GB).</li>
</ul>
<p>그렇지 않은 경우 서버가 아닌 시스템과 동일한 기본 크기가 사용됩니다 (4MB 초기 힙 크기 및 64MB<br>최대 힙 크기). 디폴트 값은 항상 명령 행 옵션에 의해 대체 될 수 있습니다. 관련 옵션은 다음과 같습니다.<br>섹션 8에 나와 있습니다.</p>
<h5 id="Behavior-based-Parallel-Collector-Tuning"><a href="#Behavior-based-Parallel-Collector-Tuning" class="headerlink" title="Behavior-based Parallel Collector Tuning"></a>Behavior-based Parallel Collector Tuning</h5><p>J2SE 5.0 릴리스에서는 병렬 가비지 수집기에 대해 새로운 튜닝 방법이 추가되었습니다.<br>가비지 수집과 관련하여 응용 프로그램의 원하는 동작 명령 행 옵션은<br>최대 일시 중지 시간 및 응용 프로그램 처리량에 대한 목표 측면에서 원하는 동작.</p>
<h6 id="Maximum-Pause-Time-Goal"><a href="#Maximum-Pause-Time-Goal" class="headerlink" title="Maximum Pause Time Goal"></a>Maximum Pause Time Goal</h6><p>최대 일시 중지 시간 목표는 명령 줄 옵션으로 지정됩니다.</p>
<p>-XX:MaxGCPauseMillis&#x3D;n</p>
<p>이것은 병렬 수집기에 대한 힌트로 해석되어 n 밀리 초 이하의 일시 중지 시간은<br>원하는. 병렬 수집기는 힙 크기 및 기타 가비지 수집 관련 매개 변수를 조정합니다.<br>가비지 콜렉션 일시 중지를 n 밀리 초보다 짧게 유지하려고 시도합니다. 이러한 조정은<br>가비지 수집기로 인해 응용 프로그램의 전체 처리량이 감소하고 일부 경우에는<br>원하는 일시 중지 시간 목표를 달성 할 수 없습니다.</p>
<p>최대 일시 중지 시간 목표는 각 세대에 개별적으로 적용됩니다. 일반적으로 목표가 충족되지 않으면,<br>목표를 달성하려는 시도에서 세대가 더 작아진다. 최대 일시 중지 시간 목표는 다음에 의해 설정되지 않습니다.<br>태만.</p>
<h6 id="Throughput-Goal"><a href="#Throughput-Goal" class="headerlink" title="Throughput Goal"></a>Throughput Goal</h6><p>처리량 목표는 가비지 콜렉션을 수행하는 데 소요되는 시간과 소요 시간으로 측정됩니다<br>가비지 수집 (응용 프로그램 시간이라고 함) 외부. 목표는 명령 행에 의해 지정됩니다.<br>option</p>
<p>-XX:GCTimeRatio&#x3D;n</p>
<p>신청 시간에 대한 가비지 수집 시간의 비율은</p>
<p>1 &#x2F; (1 + n)</p>
<p>예를 들어 -XX : GCTimeRatio &#x3D; 19는 가비지 수집을위한 총 시간의 5 %를 설정합니다. 그만큼<br>기본 목표는 1 %입니다 (예 : n &#x3D; 99). 쓰레기 수거에 소비 된 시간은 모든 세대의 총 시간입니다.<br>처리량 목표를 달성하지 못하면 세대의 크기가<br>응용 프로그램이 콜렉션 사이에서 실행할 수있는 시간을 늘리십시오. 더 큰 세대는<br>채우다.</p>
<h6 id="Footprint-Goal"><a href="#Footprint-Goal" class="headerlink" title="Footprint Goal"></a>Footprint Goal</h6><p>처리량 및 최대 일시 중지 시간 목표를 충족하면 가비지 수집기가 크기를 줄입니다.<br>목표 중 하나 (항상 처리량 목표)를 충족시킬 수 없을 때까지 힙을 그렇지 않은 목표<br>만나는 것은 그 다음 해결된다.</p>
<h6 id="Goal-Priorities"><a href="#Goal-Priorities" class="headerlink" title="Goal Priorities"></a>Goal Priorities</h6><p>병렬 가비지 컬렉터는 최대 중지 시간 목표를 먼저 충족 시키려고 시도합니다. 만난 후에 만<br>처리량 목표를 처리합니까? 마찬가지로 풋 프린트 목표는 처음 두 개 이후에만 고려됩니다.<br>목표를 달성했다.</p>
<h4 id="6-Recommendations"><a href="#6-Recommendations" class="headerlink" title="6 Recommendations"></a>6 Recommendations</h4><p>이전 섹션에서 설명한 인간 공학은 자동 가비지 컬렉터, 가상 시스템 및<br>응용 프로그램의 큰 비율에 대해 합리적인 힙 크기 선택. 따라서, 초기 권장 사항<br>가비지 컬렉터를 선택하고 구성하는 것은 아무 것도하지 않는 것입니다! 즉, 특정 사용법을 지정하지 마십시오.<br>가비지 수집기 등. 시스템이 플랫폼 및 운영 체제를 기반으로 자동 선택을하도록합니다.<br>귀하의 응용 프로그램이 실행되고 있습니다. 그런 다음 응용 프로그램을 테스트하십시오. 성능이 충분히 만족 스럽다면<br>높은 처리량과 충분히 낮은 일시 중지 시간이 완료되었습니다. 문제를 해결하거나 수정할 필요가 없습니다.<br>가비지 컬렉터 옵션.</p>
<p>반면에 응용 프로그램에서 가비지 수집과 관련된 성능 문제가있는 것으로 보인다면<br>가장 먼저 할 수있는 일은 기본적으로 선택된 가비지 컬렉터가 적절한 지 생각하는 것입니다.<br>귀하의 응용 프로그램 및 플랫폼 특성을 고려하십시오. 그렇지 않은 경우 명시 적으로 콜렉터를 선택하십시오.<br>적절하며 성능이 수용 가능한지 여부를 확인하십시오.</p>
<p>7 절에서 설명 된 것과 같은 도구를 사용하여 성능을 측정하고 분석 할 수 있습니다.<br>결과에서 힙 크기 또는 가비지 수집을 제어하는 ​​옵션 수정 옵션을 고려할 수 있습니다<br>행동. 가장 일반적으로 지정된 옵션 중 일부는 섹션 8에 나와 있습니다. 참고 : 최상의 접근 방식<br>퍼포먼스 튜닝은 먼저 측정하고 나서 튜닝하는 것입니다. 코드가 수행되는 방식과 관련된 테스트를 사용하여 측정<br>실제로 사용됩니다. 또한 응용 프로그램 데이터 세트, 하드웨어 등등 과부하가 걸리기 때문에 과도하게 최적화해야합니다.<br>가비지 컬렉터 구현! - 시간이 지나면 바뀔 수도 있습니다.<br>이 섹션에서는 가비지 수집기 선택 및 힙 크기 지정에 대한 정보를 제공합니다. 그런 다음<br>병렬 쓰레기 수거자를 조정하기위한 제안 사항 및 수행 할 작업과 관련된 조언<br>OutOfMemoryErrors.</p>
<h5 id="When-to-Select-a-Different-Garbage-Collector"><a href="#When-to-Select-a-Different-Garbage-Collector" class="headerlink" title="When to Select a Different Garbage Collector"></a>When to Select a Different Garbage Collector</h5><p>4 절에서는 각 수집기에 대해 해당 수집기의 사용을 권장하는 상황을 설명합니다. 섹션 5<br>직렬 또는 병렬 수집기가 기본적으로 자동 선택되는 플랫폼을 설명합니다.<br>응용 프로그램 또는 환경 특성이 기본값과 다른 수집기 인 경우<br>다음 명령 행 옵션 중 하나를 통해 콜렉터에게 명시 적으로 요청하십시오.</p>
<p>–XX:+UseSerialGC<br>–XX:+UseParallelGC<br>–XX:+UseParallelOldGC<br>–XX:+UseConcMarkSweepGC</p>
<h5 id="Heap-Sizing"><a href="#Heap-Sizing" class="headerlink" title="Heap Sizing"></a>Heap Sizing</h5><p>섹션 5는 초기 힙 크기와 기본 힙 크기를 알려줍니다. 그 크기는 많은 사람들에게 좋을 수 있습니다.<br>그러나 성능 문제 (7 절 참조) 또는 OutOfMemoryError<br>(이 섹션의 뒷부분에서 설명 함)은 특정 세대 또는 전체 힙 크기에 문제가 있음을 나타내며,<br>섹션 8에 지정된 명령 행 옵션을 통해 크기를 수정할 수 있습니다. 예를 들어, 기본 최대 값<br>비 서버급 시스템에서 64MB의 힙 크기는 종종 너무 작기 때문에 -Xmx를 사용하여 더 큰 크기를 지정할 수 있습니다.<br>선택권. 긴 일시 중지 시간에 문제가없는 한 힙에 가능한 한 많은 메모리를 부여하십시오.<br>처리량은 사용 가능한 메모리 양에 비례합니다. 충분한 사용 가능한 메모리가 가장 많습니다.<br>15 권장 사항 Sun Microsystems, Inc.</p>
<p>가비지 수집 성능에 영향을 미치는 중요한 요소.</p>
<p>총 힙에 제공 할 수있는 총 메모리 양을 결정한 후에는<br>다른 세대의 크기를 조정합니다. 가비지 수집에 영향을 미치는 두 번째로 영향력있는 요소<br>성능은 젊은 세대에게 할당 된 힙의 비율입니다. 문제가없는 한<br>지나치게 오래된 세대 컬렉션 또는 일시 중지 시간은 젊은 세대에게 충분한 메모리를 제공합니다. 하나,<br>직렬 콜렉터를 사용할 때는 젊은 세대에 총 힙 크기의 절반 이상을 부여하지 마십시오.</p>
<p>병렬 가비지 수집기 중 하나를 사용하는 경우, 가비지 수집기 대신 원하는 동작을 지정하는 것이 바람직합니다.<br>정확한 힙 크기 값. 수집기가 자동으로 동적으로 힙 크기를 수정하여<br>그 행동은 다음에 설명됩니다.</p>
<h5 id="Tuning-Strategy-for-the-Parallel-Collector"><a href="#Tuning-Strategy-for-the-Parallel-Collector" class="headerlink" title="Tuning Strategy for the Parallel Collector"></a>Tuning Strategy for the Parallel Collector</h5><p>선택한 가비지 수집기 (자동 또는 명시 적으로)가 병렬 수집기 또는 병렬 압축 인 경우<br>그런 다음 처리량 목표 (섹션 5 참조)를 지정하여 애플리케이션에 충분합니다.<br>기본값보다 큰 힙이 필요하다는 것을 알지 못하는 경우 힙의 최대 값을 선택하지 마십시오.<br>최대 힙 크기. 힙은 선택한 처리량 목표를 지원하는 크기로 증가하거나 축소됩니다.<br>초기화 중 및 응용 프로그램 동작이 변경되는 동안 힙 크기의 일부 진동은<br>기대된다.</p>
<p>힙이 최대 값까지 증가하면 대부분의 경우 처리량 목표를 충족시킬 수 없습니다.<br>그 최대 크기. 최대 크기를 플랫폼의 총 실제 메모리에 가까운 값으로 설정하십시오.<br>하지만 그것은 응용 프로그램의 교환을 일으키지 않습니다. 응용 프로그램을 다시 실행하십시오. 처리량 목표가<br>여전히 충족되지 않으면 응용 프로그램 시간의 목표가 플랫폼의 사용 가능한 메모리에 비해 너무 높습니다.</p>
<p>처리량 목표를 달성 할 수 있지만 너무 긴 일시 중지가있는 경우 최대 일시 중지 시간 목표를 선택하십시오.<br>최대 일시 중지 시간 목표를 선택하면 처리량 목표를 달성하지 못할 수 있으므로 값을 선택하십시오.<br>이는 응용 프로그램에 대한 적절한 절충안입니다.</p>
<p>가비지 컬렉터가 경쟁 목표를 만족 시키려고 시도 할 때 힙의 크기는 진동합니다.<br>응용 프로그램이 안정된 상태에 도달했습니다. 처리량 목표를 달성하라는 압력 (큰<br>힙)은 최대 휴지 시간 및 최소 풋 프린트에 대한 목표와 경쟁합니다 (둘 다<br>작은 힙).</p>
<h5 id="What-to-Do-about-OutOfMemoryError"><a href="#What-to-Do-about-OutOfMemoryError" class="headerlink" title="What to Do about OutOfMemoryError"></a>What to Do about OutOfMemoryError</h5><p>많은 개발자가 해결해야하는 한 가지 일반적인 문제는 다음과 같이 끝나는 응용 프로그램의 문제입니다.<br>java.lang.OutOfMemoryError. 이 오류는 할당 할 공간이 충분하지 않을 때 발생합니다.<br>목적. 즉, 가비지 수집은 새로운 객체를 수용 할 수있는 추가 공간을 만들 수 없으며<br>힙을 더 이상 확장 할 수 없습니다. OutOfMemoryError는 반드시 메모리 누수를 의미하지는 않습니다. 그만큼<br>문제는 단순히 구성 문제 일 수 있습니다. 예를 들어 지정된 힙 크기 (또는 그렇지 않은 경우 기본 크기)<br>지정된) 응용 프로그램에 충분하지 않습니다.</p>
<p>OutOfMemoryError 진단의 첫 번째 단계는 전체 오류 메시지를 검사하는 것입니다. 예외적으로<br>추가 정보는 “java.lang.OutOfMemoryError”다음에 제공됩니다. 여기에 몇 가지 공통점이있다.<br>그 추가 정보가 무엇인지, 그것이 무엇을 의미하는지, 그리고 그것에 대해 어떻게해야하는지에 대한 예 :</p>
<ul>
<li>Java heap space</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이는 힙에서 오브젝트를 할당 할 수 없음을 나타냅니다. 이 문제는 단지 구성 일 수 있습니다.</span><br><span class="line">문제. 예를 들어, -Xmx에 의해 지정된 최대 힙 크기</span><br><span class="line">명령 줄 옵션 (또는 기본적으로 선택)은 응용 프로그램에 충분하지 않습니다. 그것은 또한</span><br><span class="line">더 이상 필요하지 않은 객체가 가비지 수집 될 수 없다는 표시</span><br><span class="line">응용 프로그램이 실수로 해당 응용 프로그램에 대한 참조를 보유하고 있습니다. HAT 도구 (7 절 참조)를 사용하여</span><br><span class="line">도달 가능한 모든 객체를보고 어떤 참조가 각 객체를 활성 상태로 유지하는지 이해합니다. 다른 하나</span><br><span class="line">이 오류의 잠재적 인 원인은 응용 프로그램에서 최종자를 과도하게 사용하여</span><br><span class="line">파이널 라이저를 호출하는 스레드는 큐에 파이널 라이저를 추가하는 속도를 따라갈 수 없습니다. 그만큼</span><br><span class="line">jconsole 관리 도구를 사용하여 보류중인 객체 수를 모니터 할 수 있습니다.</span><br><span class="line">마무리.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>PermGen space</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이것은 영구 세대가 꽉 찼음을 나타냅니다. 앞에서 설명했듯이 그것은 힙 영역입니다</span><br><span class="line">여기서 JVM은 메타 데이터를 저장합니다. 응용 프로그램이 많은 수의 클래스를로드하면</span><br><span class="line">영구적 인 세대를 늘려야 할 수도 있습니다. 명령 행을 지정하여 그렇게 할 수 있습니다</span><br><span class="line">옵션 -XX : MaxPermSize = n, 여기서 n은 크기를 지정합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Requested array size exceeds VM limit</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이것은 응용 프로그램이 힙 크기보다 큰 배열을 할당하려고 시도했음을 나타냅니다. 에 대한</span><br><span class="line">예를 들어, 응용 프로그램이 512MB의 배열을 할당하려고 시도하지만 최대 힙 크기가 256MB 인 경우,</span><br><span class="line">그러면이 오류가 발생합니다. 대부분의 경우 문제는 힙 크기가 너무 크거나</span><br><span class="line">작거나 버그로 인해 응용 프로그램에서 크기가 계산 된 배열을 만들려고합니다.</span><br><span class="line">잘못 거대한.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>섹션 7에 설명 된 도구 중 일부는 OutOfMemoryError 문제를 진단하는 데 사용할 수 있습니다. 소량의<br>이 작업을위한 가장 유용한 도구는 HAT (힙 분석 도구), jconsole 관리 도구 및<br>jmap 도구를 -histo 옵션과 함께 사용하십시오.</p>
<h4 id="7-Tools-to-Evaluate-Garbage-Collection-Performance"><a href="#7-Tools-to-Evaluate-Garbage-Collection-Performance" class="headerlink" title="7 Tools to Evaluate Garbage Collection Performance"></a>7 Tools to Evaluate Garbage Collection Performance</h4><p>다양한 진단 및 모니터링 도구를 사용하여 가비지 수집 성능을 평가할 수 있습니다. 이 구역<br>그 중 일부에 대한 간략한 개요를 제공합니다. 자세한 내용은의 “도구 및 문제 해결”링크를 참조하십시오.<br>섹션 9.</p>
<h5 id="–XX-PrintGCDetails-Command-Line-Option"><a href="#–XX-PrintGCDetails-Command-Line-Option" class="headerlink" title="–XX:+PrintGCDetails Command Line Option"></a>–XX:+PrintGCDetails Command Line Option</h5><p>가비지 콜렉션에 대한 초기 정보를 얻는 가장 쉬운 방법 중 하나는 명령 행을 지정하는 것입니다<br>옵션 -XX : + PrintGCDetails. 모든 콜렉션에 대해 이것은 결과와 같은 정보를 출력합니다.<br>다양한 세대의 가비지 콜렉션 전후의 라이브 오브젝트 크기,<br>각 세대, 그리고 수집에 소요 된 시간.</p>
<h5 id="–XX-PrintGCTimeStamps-Command-Line-Option"><a href="#–XX-PrintGCTimeStamps-Command-Line-Option" class="headerlink" title="–XX:+PrintGCTimeStamps Command Line Option"></a>–XX:+PrintGCTimeStamps Command Line Option</h5><p>이 명령은 각 콜렉션의 시작 부분에 타임 스탬프를 출력하고,<br>명령 줄 옵션 -XX : + PrintGCDetails가 사용됩니다. 타임 스탬프는 쓰레기 상관 관계를 도울 수 있습니다.<br>다른 기록 된 이벤트와 함께 수집 로그.</p>
<h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h5><p>jmap은 Solaris ™ 운영 환경 및 Linux (Windows는 제외)에 포함 된 명령 줄 유틸리티입니다.<br>Java Development Kit (JDK ™)의 릴리스. 실행중인 JVM 또는 코어 파일에 대한 메모리 관련 통계를 인쇄합니다. 그 경우<br>명령 줄 옵션없이 사용되면로드 된 공유 객체 목록을 인쇄합니다.<br>Solaris pmap 유틸리티 출력. 보다 자세한 정보는 -heap, -histo 또는 -permstat 옵션을 사용할 수 있습니다.</p>
<p>-heap 옵션은 가비지 콜렉터의 이름을 포함하는 정보를 얻는 데 사용됩니다.<br>알고리즘 별 세부 정보 (예 : 병렬 가비지 수집에 사용되는 스레드 수), 힙<br>구성 정보 및 힙 사용 요약</p>
<p>-histo 옵션을 사용하여 클래스 힙의 히스토그램을 얻을 수 있습니다. 각 클래스에 대해 숫자를 인쇄합니다.<br>힙에있는 인스턴스 수, 해당 개체에서 소비 한 총 메모리 크기 (바이트) 및<br>정규화 된 클래스 이름. 히스토그램은 힙 사용 방법을 이해할 때 유용합니다.</p>
<p>영구 생성의 크기를 구성하는 것은 동적으로 생성하는 응용 프로그램에 중요 할 수 있습니다<br>많은 수의 클래스 (예 : Java Server Pages ™ 및 웹 컨테이너)를로드합니다. 응용 프로그램이로드되는 경우<br>“너무 많은”클래스가 있으면 OutOfMemoryError가 발생합니다. jmap 명령에 대한 -permstat 옵션은 다음을 수행 할 수 있습니다.<br>영구 생성에서 개체에 대한 통계를 가져 오는 데 사용됩니다.</p>
<h5 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h5><p>jstat 유틸리티는 HotSpot JVM에 내장 된 도구를 사용하여 성능 정보를 제공합니다<br>실행중인 응용 프로그램의 자원 소비. 이 도구는 성능 문제를 진단 할 때 사용할 수 있습니다.<br>특히 힙 크기 조정 및 가비지 수집과 관련된 문제가 있습니다. 많은 옵션 중 일부는 인쇄 할 수 있습니다.<br>쓰레기 수거 행동 및 다양한 세대의 수용력과 사용량에 관한 통계.</p>
<h5 id="HPROF-Heap-Profiler"><a href="#HPROF-Heap-Profiler" class="headerlink" title="HPROF: Heap Profiler"></a>HPROF: Heap Profiler</h5><p>HPROF는 JDK 5.0과 함께 제공되는 간단한 프로파일 러 에이전트입니다. 동적으로 링크 된 라이브러리로,<br>JVM (Java Virtual Machine Tools Interface)을 사용하는 JVM 프로파일 링 정보를 파일에 기록하거나<br>ASCII 또는 2 진 형식의 소켓에 연결하십시오. 이 정보는 프로파일 러 프런트 엔드 도구로 추가 처리 할 수 ​​있습니다.</p>
<p>HPROF는 CPU 사용량, 힙 할당 통계 및 모니터 경합 프로파일을 표시 할 수 있습니다. 에서<br>또한 완전한 힙 덤프를 출력하고 Java의 모든 모니터 및 스레드 상태를보고 할 수 있습니다<br>가상 기기. HPROF는 성능, 잠금 경합, 메모리 누수 및 기타 문제를 분석 할 때 유용합니다.<br>HPROF 문서에 대한 링크는 9 절을 참조하십시오.</p>
<h5 id="HAT-Heap-Analysis-Tool"><a href="#HAT-Heap-Analysis-Tool" class="headerlink" title="HAT: Heap Analysis Tool"></a>HAT: Heap Analysis Tool</h5><p>힙 분석 도구 (HAT)는 의도하지 않은 개체 보존을 디버그하는 데 유용합니다. 이 용어는 객체를 설명하는 데 사용됩니다.<br>더 이상 필요하지 않지만 살아있는 객체로부터의 어떤 경로를 통한 참조로 인해 유지됩니다. HAT는<br>HPROF를 사용하여 생성 된 힙 (heap) 스냅 샷의 객체 토폴로지를 찾아 볼 수있는 편리한 방법입니다. 도구<br>“루트 집합에서이 객체로의 모든 참조 경로 표시”를 포함한 많은 쿼리를 허용합니다.<br>HAT 문서에 대한 링크는 9 페이지를 참조하십시오.</p>
<h4 id="8-Key-Options-Related-to-Garbage-Collection"><a href="#8-Key-Options-Related-to-Garbage-Collection" class="headerlink" title="8 Key Options Related to Garbage Collection"></a>8 Key Options Related to Garbage Collection</h4><p>가비지 콜렉터를 선택하거나 힙이나 생성 크기를 지정하거나,<br>가비지 수집 동작을 수정하고 가비지 수집 통계를 얻을 수 있습니다. 이 섹션에서는<br>가장 일반적으로 사용되는 옵션. 다양한 옵션에 대한 자세한 목록과 자세한 정보는<br>주 : 지정하는 숫자는 메가 바이트의 경우 “m”또는 “M”으로 끝나며, 메가 바이트의 경우 “k”또는 “K”로 끝날 수 있습니다.<br>킬로바이트, “g”또는 “G”(기가 바이트).</p>
<h5 id="Garbage-Collector-Selection"><a href="#Garbage-Collector-Selection" class="headerlink" title="Garbage Collector Selection"></a>Garbage Collector Selection</h5><table>
<thead>
<tr>
<th>Option</th>
<th>Garbage Collector Selected</th>
</tr>
</thead>
<tbody><tr>
<td>–XX:+UseSerialGC</td>
<td>Serial</td>
</tr>
<tr>
<td>–XX:+UseParallelGC</td>
<td>Parallel</td>
</tr>
<tr>
<td>–XX:+UseParallelOldGC</td>
<td>Parallel compacting</td>
</tr>
<tr>
<td>–XX:+UseConcMarkSweepGC</td>
<td>Concurrent mark–sweep (CMS)</td>
</tr>
</tbody></table>
<h5 id="Garbage-Collector-Statistics"><a href="#Garbage-Collector-Statistics" class="headerlink" title="Garbage Collector Statistics"></a>Garbage Collector Statistics</h5><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>–XX:+PrintGC</td>
<td>Outputs basic information at every garbage collection.</td>
</tr>
<tr>
<td>–XX:+PrintGCDetails</td>
<td>Outputs more detailed information at every garbage collection.</td>
</tr>
<tr>
<td>–XX:+PrintGCTimeStamps</td>
<td>Outputs a time stamp at the start of each garbage collection event. Used with –XX:+PrintGC or –XX:+PrintGCDetails to show when each garbage collection begins.</td>
</tr>
</tbody></table>
<h5 id="Heap-and-Generation-Sizes"><a href="#Heap-and-Generation-Sizes" class="headerlink" title="Heap and Generation Sizes"></a>Heap and Generation Sizes</h5><table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>–Xmsn</td>
<td>Initial heap size of 1&#x2F;64th of the physical memory, up to 1GB. (Note that the minimum initial heap size is 32MB, since a server-class machine is defined to have at least 2GB of memory and 1&#x2F;64th of 2GB is 32MB.)</td>
<td>Initial size, in bytes, of the heap.</td>
</tr>
<tr>
<td>–Xmxn</td>
<td>Maximum heap size of 1&#x2F;4th of the physical memory, up to 1GB.</td>
<td>Maximum size, in bytes, of the heap.</td>
</tr>
<tr>
<td>–XX:MinHeapFreeRatio&#x3D;minimum and –XX:MaxHeapFreeRatio&#x3D;maximum</td>
<td>40 (min) 70 (max)</td>
<td>Target range for the proportion of free space to total heap size. These are applied per generation. For example, if minimum is 30 and the percent of free space in a generation falls below 30%, the size of the generation is expanded so as to have 30% of the space free. Similarly, if maximum is 60 and the percent of free space exceeds 60%, the size of the generation is shrunk so as to have only 60% of the space free.</td>
</tr>
<tr>
<td>–XX:NewSize&#x3D;n</td>
<td>Platform–dependent</td>
<td>Default initial size of the new (young) generation, in bytes.</td>
</tr>
<tr>
<td>–XX:NewRatio&#x3D;n</td>
<td>2 on client JVM, 8 on server JVM</td>
<td>Ratio between the young and old generations. For example, if n is 3, then the ratio is 1:3 and the combined size of Eden and the survivor spaces is one fourth of the total size of the young and old generations.</td>
</tr>
<tr>
<td>–XX:SurvivorRatio&#x3D;n</td>
<td>32</td>
<td>Ratio between each survivor space and Eden. For example, if n is 7, each survivor space is one–ninth of the young generation (not one–eighth, because there are two survivor spaces).</td>
</tr>
<tr>
<td>–XX:MaxPermSize&#x3D;n</td>
<td>Platform–dependent</td>
<td>Maximum size of the permanent generation.</td>
</tr>
</tbody></table>
<h5 id="Options-for-the-Parallel-and-Parallel-Compacting-Collectors"><a href="#Options-for-the-Parallel-and-Parallel-Compacting-Collectors" class="headerlink" title="Options for the Parallel and Parallel Compacting Collectors"></a>Options for the Parallel and Parallel Compacting Collectors</h5><table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>–XX:ParallelGCThreads&#x3D;n</td>
<td>The number of CPUs</td>
<td>Number of garbage collector threads.</td>
</tr>
<tr>
<td>–XX:MaxGCPauseMillis&#x3D;n</td>
<td>No default</td>
<td>Indicates to the collector that pause times of n milliseconds or less are desired.</td>
</tr>
<tr>
<td>–XX:GCTimeRatio&#x3D;n</td>
<td>99</td>
<td>Number that sets a goal that 1&#x2F;(1+n) of the total time be spent on garbage collection.</td>
</tr>
</tbody></table>
<h5 id="Options-for-the-CMS-Collector"><a href="#Options-for-the-CMS-Collector" class="headerlink" title="Options for the CMS Collector"></a>Options for the CMS Collector</h5><table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>–XX:+CMSIncrementalMode</td>
<td>Disabled</td>
<td>Enables a mode in which the concurrent phases are done incrementally, periodically stopping the concurrent phase to yield back the processor to the application.</td>
</tr>
<tr>
<td>–XX:+CMSIncrementalPacing</td>
<td>Disabled</td>
<td>Enables automatic control of the amount of work the CMS collector is allowed to do before giving up the processor, based on application behavior.</td>
</tr>
<tr>
<td>–XX:ParallelGCThreads&#x3D;n</td>
<td>The number of CPUs</td>
<td>Number of garbage collector threads for the parallel young generation collections and for the parallel parts of the old generation collections.</td>
</tr>
</tbody></table>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf">memorymanagement-whitepaper</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../tags/jvm/">jvm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../2018-11-21-Avoid_finalizers_and_cleaners/"><i class="fa fa-chevron-left">  </i><span>아이템 8. Finalizer와 Cleaner의 사용은 피하라</span></a></div><div class="next-post pull-right"><a href="../2018-11-20-Types_Of_References_In_Java/"><span>자바의 레퍼런스 타입</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://sejoung.github.io/2018/11/2018-11-21-memorymanagement-whitepaper/';
  this.page.identifier = '2018/11/2018-11-21-memorymanagement-whitepaper/';
  this.page.title = 'Memory Management in the Java HotSpot™ Virtual Machine(Sun Microsystems April 2006)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'kimsejoung' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://kimsejoung.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2023 By sejoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="../../../js/third-party/anime.min.js"></script><script src="../../../js/third-party/jquery.min.js"></script><script src="../../../js/third-party/jquery.fancybox.min.js"></script><script src="../../../js/third-party/velocity.min.js"></script><script src="../../../js/third-party/velocity.ui.min.js"></script><script src="../../../js/utils.js?version=1.7.0"></script><script src="../../../js/fancybox.js?version=1.7.0"></script><script src="../../../js/sidebar.js?version=1.7.0"></script><script src="../../../js/copy.js?version=1.7.0"></script><script src="../../../js/fireworks.js?version=1.7.0"></script><script src="../../../js/transition.js?version=1.7.0"></script><script src="../../../js/scroll.js?version=1.7.0"></script><script src="../../../js/head.js?version=1.7.0"></script><script src="../../../js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>