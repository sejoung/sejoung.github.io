<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Tue, 07 Feb 2023 15:17:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>10장 알림 시스템 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/</guid>
      <pubDate>Tue, 07 Feb 2023 15:04:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="10장-알림-시스템-설계"><a href="#10장-알림-시스템-설계" class="headerlink" title="10장 알림 시스템 설계"></a>10장 알림 시스템 설계</h2><p>알림 시스템</p><ul><li>모바일 푸시 알림</li><li>SMS 메시지</li><li>이메일</li></ul><h3 id="알림-유형별-지원-방안"><a href="#알림-유형별-지원-방안" class="headerlink" title="알림 유형별 지원 방안"></a>알림 유형별 지원 방안</h3><ul><li>IOS 푸시 알림<ul><li>알림 제공자 : 애플 푸시 알림 서비스(APNS)<ul><li>단말 토큰</li><li>페이로드</li></ul></li><li>APNS : 애플이 제공하는 원격 서비스</li><li>IOS 단말</li></ul></li><li>안드로이드 푸시 알림<ul><li>FCM : firebase cloud messaging</li></ul></li><li>SMS 메시지<ul><li>트월리오</li><li>넥스모</li></ul></li><li>이메일<ul><li>샌드그리드</li><li>메일침프</li></ul></li></ul><h3 id="연락처-정보-수집-절차"><a href="#연락처-정보-수집-절차" class="headerlink" title="연락처 정보 수집 절차"></a>연락처 정보 수집 절차</h3><p>알림을 보낼려면 모바일 단말 토큰, 전화번호, 이메일 주소등의 정보가 필요하다 수집 방법을 고민할 필요가 있다</p><h3 id="알림-전송-및-수신-절차"><a href="#알림-전송-및-수신-절차" class="headerlink" title="알림 전송 및 수신 절차"></a>알림 전송 및 수신 절차</h3><ul><li>알림 시스템</li><li>제3자 서비스</li><li>IOS, AOS, SMS, 이메일 단말</li><li>문제점<ul><li>SPOF</li><li>규모 확장성</li><li>성능 병목</li></ul></li><li>메시지 큐</li><li>캐시</li><li>알림 서버</li><li>데이터베이스</li><li>worker 서버</li></ul><h3 id="상세설계"><a href="#상세설계" class="headerlink" title="상세설계"></a>상세설계</h3><ul><li>안정성<ul><li>데이터 손실 방지<ul><li>재시도 메커니즘이 존재해야 됨</li></ul></li><li>알림 중복 전송 방지<ul><li>분산 시스템 특성상 가끔 같은 알림이 중복 전송됨</li></ul></li><li>알림 템플릿</li><li>알림 설정</li><li>전송률 제한</li><li>재시도 방법</li><li>푸시 알람과 보안</li><li>큐 모니터링</li><li>이벤트 추적</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장 웹 크롤러 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/</guid>
      <pubDate>Tue, 07 Feb 2023 14:06:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="9장-웹-크롤러-설계"><a href="#9장-웹-크롤러-설계" class="headerlink" title="9장 웹 크롤러 설계"></a>9장 웹 크롤러 설계</h2><p>웹 크롤러는 로봇 또는 스파이더라고도 부른다 검색엔진에 널리 쓰이는 기술로 웹에 새로 올라오거나 갱신된 컨텐츠를 찾는것이 주된 일이다.</p><p>크롤러의 용도</p><ul><li>검색 엔진 인덱싱</li><li>웹 아카이빙</li><li>웹 마이닝</li><li>웹 모니터링</li></ul><p>크롤러의 속성</p><ul><li>규모 확장성</li><li>안정성</li><li>예절</li><li>확장성</li></ul><p>시작 URL 집합</p><ul><li>크롤러가 크롤링을 시작하는 출발점</li><li>시작 URL은 조금 창의적으로 접근 해야될수도 있다.</li><li>주제별로 다른 URL을 사용</li></ul><p>미수집 URL 저장소</p><ul><li>크롤러 상태<ul><li>다운로드할 URL<ul><li>이 내용을 저장하는 저장소</li></ul></li><li>다운로드된 URL</li></ul></li><li>예의<ul><li>너무 많은 요청은 무례한 일이다(DDOS)</li></ul></li></ul><p>HTML 다운로더</p><ul><li>웹페이지를 다운로드하는 컴포넌트</li></ul><p>도메인 이름 변환기</p><ul><li>URL을 IP 주소로 변환 하는 절차가 필요함</li></ul><p>콘텐츠 파서</p><ul><li>웹페이지를 다운로드 하면 파싱과 검증 절차를 거쳐야됨</li></ul><p>중복 콘텐츠인가</p><ul><li>웹페이지에 중복된 컨텐츠가 많다.</li></ul><p>콘텐츠 저장소</p><ul><li>데이터 양이 너무 많으므로 대부분의 콘텐츠는 디스크에 저장한다</li><li>인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄일 것이다</li></ul><p>URL 추출기</p><ul><li>링크를 골라내는 역활</li></ul><p>URL 필터</p><ul><li>특정 콘텐츠 타입이나 파일 확장자를 갖는 URL</li><li>접속 오류 URL</li><li>접근 제외 목록에 포함된 URL</li></ul><p>DFS : 깊이 우선 탐색법</p><ul><li>그래프의 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어렵다</li></ul><p>BFS : 너비 우선 탐색법</p><ul><li>문제점<ul><li>한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.</li><li>표준적 BFS 알고리즘은 URL 간에 우선순위를 두지 않는다</li></ul></li></ul><p>성능 최적화</p><ul><li>분산 크롤링</li><li>도메인 이름 변환 결과 캐시</li><li>지역성</li><li>짧은 타임아웃</li></ul><p>안정성</p><ul><li>안정 해시 : 다운로더 서버들에 부하를 분산할 때 적용 가능한 기술</li><li>크롤링 상태 및 수집 데이터 저장</li><li>예외 처리</li><li>데이터 검증</li></ul><p>문제 있는 콘텐츠 감지 및 회피</p><ul><li>중복 콘텐츠</li><li>거미 덫</li><li>데이터 노이즈</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 4 오류</title>
      <link>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/</guid>
      <pubDate>Sun, 05 Feb 2023 14:22:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-4-오류"><a href="#CHAPTER-4-오류" class="headerlink" title="CHAPTER 4 오류"></a>CHAPTER 4 오류</h2><p>코드가 실행되는 환경은 불완전 하다. 사용자가 잘못된 입력을 제공하고, 외부 시스템이 다운되며, 자신이 작성한 코드와 다른 개발자가 작성한 코드가 종종 버그를 가질수 있다.</p><p>오류에 대해서 특히 어떻게 알리고 대처해야 하는지 논의해봐야 골치만 아픈 복잡한 문제다.</p><h3 id="복구-가능성"><a href="#복구-가능성" class="headerlink" title="복구 가능성"></a>복구 가능성</h3><p>복구 가능한 오류</p><ul><li>네트워크 오류</li><li>잘못된 사용자 입력</li><li>중요하지 않은 작업 오류</li></ul><p>복구할 수 없는 오류</p><ul><li>코드와 함께 추가되어야 하는 리소스가 없다</li><li>잘못된 입력 인수로 호출</li><li>일부 필요한 상태를 사전에 초기화 하지 않음</li></ul><p>신속한 실패와 요란한 실패</p><p>호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다</p><p>다른 코드가 자신이 작성한 코드를 호출하는 것과 관련해 다음과 같은 사항을 신중하게 고려해야 한다</p><ul><li>오류로부터 복구하기를 호출하는 쪽에서 원하는가</li><li>만약 그렇다면 오류를 처리할 필요가 있다는 것을 호출하는 쪽에서는 어떻게 알 수 있을까?</li></ul><p>호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라</p><h3 id="견고성-vs-실패"><a href="#견고성-vs-실패" class="headerlink" title="견고성 vs 실패"></a>견고성 vs 실패</h3><p>오류가 발생될때 다음 중 하나를 선택해야 한다</p><ul><li>실패 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다</li><li>오류를 처리하고 계속 진행한다</li></ul><p>신속하게 실패하라</p><ul><li>신속하게 실패하기는 가능한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것</li><li>호출하는 쪽에서 오류를 복구할수 있는 기회를 최대한 제공</li><li>복구 할수 없는 오류일 경우 개발자에게 문제를 신속하게 파악하고 해결할수 있는 기회를 제공</li></ul><p>요란하게 실패하라</p><ul><li>오류가 발생하는데도 아무도 모르는 상황을 막고자 하는 법</li></ul><p>복구 가능성의 범위</p><ul><li>오류가 발견되면 오류를 기록하고 모니터링 해야 된다</li><li>복구할수 있는 또는 복구할수 없는 범위가 틀려질수 있다</li></ul><p>오류를 숨기지 않음</p><ul><li>호출하는 쪽에서 복구하고자 할 수도 있는 오류를 숨기면 호출하는 쪽에서 오류로부터 복구할 수 있는 기회를 없에는 것이다</li><li>복구할수 없는 오류를 숨기면 프로그래밍 오류가 감취진다</li><li>오류를 숨기면 호출하는 쪽에서 실제코드가 잘 작동하고 있다고 가정하지만 실제코드는 작동하지 않을수 있다</li></ul><p>오류가 발생했다는 사실을 숨길수 있는 방법</p><ul><li>기본값 반환<ul><li>오류가 발생했을때 기본값을 반환하는것</li><li>요란한 실패의 원리를 위반 하는것</li></ul></li><li>널 객체 패턴<ul><li>개념적으로 기본값 반환가 유사</li></ul></li><li>아무것도 하지 않음<ul><li>코드가 하는 일에 대해 개발자가 가지고 있는 정신 모델과 코드가 실제로 수행하는 것 사이의 불일치를 일으킬 가능성이 높다</li></ul></li></ul><h3 id="오류-전달-방법"><a href="#오류-전달-방법" class="headerlink" title="오류 전달 방법"></a>오류 전달 방법</h3><p>오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.</p><p>오류를 알리는 방법</p><ul><li>명시적 방법<ul><li>검사 예외<ul><li>명시적으로 오류를 전달하는 방법</li><li>호출하는쪽에서 강제적으로 인식함</li></ul></li><li>널 반환 유형(널 안정성의 경우)<ul><li>널값이 의미하는 바를 설명하기 위해 주석문이나 문서를 추가해야 된다</li><li>널 안정성(?)을 지원하기 때문에 호출하는 쪽에서 널인지 반듯이 확인 해야된다</li></ul></li><li>옵셔널 반환 유형</li><li>리절트 반환 유형<ul><li>널값이나 옵셔널 타입을 반환할때 문제 중하나는 오류 정보를 전달할수 없다는것</li><li>값을 얻을수 없음을 알릴 뿐만 아니라 값을 얻을 수 없는 이유까지 알려주면 유용하다</li></ul></li><li>아웃컴 반환 유형(반환값 확인이 필수인 경우)<ul><li>호출하는쪽에서 반환값을 강제적으로 확인해야 된다면 이것은 오류를 알리는 명백한 방법이다.</li><li>컴파일러가 경고를 생성하도록 함수를 표시할수 있다</li></ul></li><li>스위프트 오류</li></ul></li><li>암시적 방법<ul><li>비검사 예외<ul><li>세부조항일 뿐 오류를 암시적으로 알리는 방법</li><li>호출하는 쪽에서 예외가 발생할수도 있다는걸 몰라도 된다</li></ul></li><li>매직값 반환(피해야 한다)<ul><li>매직값은 코드 계약의 명백한 부분을 통해 호출하는 쪽에 알릴 수 없어서 예상을 벗어나는 결과를 가져올수 있고 버그로 이어질수 있다.</li><li>오류를 알리는 좋은 방법이 아니다</li></ul></li><li>프로미스 또는 퓨처<ul><li>프로미스와 퓨처는 오류 상태도 전달할수 있다.</li><li>호출하는 쪽에서 잠재적인 오류 시나리오를 완전히 알지 못하기 때문에 암시적인 방법</li><li>리절트 유형의 프로미스를 반환하면 명시적이지만 코드가 복잡해지기 때문에 모든 사람이 다 이렇게 사용하지 않을것이다</li></ul></li><li>어서션</li><li>체크(구현에 따라 틀려짐)</li><li>패닉</li></ul></li></ul><h3 id="복구할-수-없는-오류의-전달"><a href="#복구할-수-없는-오류의-전달" class="headerlink" title="복구할 수 없는 오류의 전달"></a>복구할 수 없는 오류의 전달</h3><ul><li>비검사 예외를 발생</li><li>프로그램이 패닉이 되도록</li><li>체크나 어셔션의 사용</li></ul><h3 id="호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달"><a href="#호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달" class="headerlink" title="호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달"></a>호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달</h3><p>비검사 예외를 사용해야 한다는 주장</p><ul><li>코드 구조 개선<ul><li>대부분의 오류 처리가 상위 계층에서 이루어질 수 있기 때문에 비검사 예외를 발생시키면 구조 개선을 할수 있다.</li></ul></li><li>개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함<ul><li>너무 많은 명시적 오류 전달을 접하면 결국 잘못된 일을 한다고 주장</li></ul></li></ul><p>명시적 기법을 사용해야 한다는 주장</p><ul><li>매끄러운 오류 처리<ul><li>비검사 예외를 사용한다면 모든 오류를 매끄럽게 처리할 수있는 단일 계층을 갖기 어렵다</li></ul></li><li>실수로 오류를 무시할 수 없다<ul><li>잘못된일이 기본적으로 혹은 실수로 인해 일어나지 않는다</li></ul></li><li>개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함<ul><li>비검사 예외는 코드베이스 전반에 걸쳐 제대로 문서화가 된다는 보장이 없고 개인적인 경험을 비추어 보아 문서화되지 않는 경우가 많다.</li></ul></li></ul><p>필자는 명시적인 방식을 선호</p><h3 id="컴파일러-경고를-무시하지-말라"><a href="#컴파일러-경고를-무시하지-말라" class="headerlink" title="컴파일러 경고를 무시하지 말라"></a>컴파일러 경고를 무시하지 말라</h3><p>컴파일러 경고는 어떤식으로든 코드가 의심스러우면 표시하는데 이것은 버그에 대한 조기 경고</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li><li><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/CheckReturnValue.html">jsr305 CheckReturnValue</a></li><li><a href="https://jcp.org/en/jsr/detail?id=305">jsr305</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async_function</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 3 다른 개발자와 코드 계약</title>
      <link>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/</guid>
      <pubDate>Sun, 05 Feb 2023 13:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-3-다른-개발자와-코드-계약"><a href="#CHAPTER-3-다른-개발자와-코드-계약" class="headerlink" title="CHAPTER 3 다른 개발자와 코드 계약"></a>CHAPTER 3 다른 개발자와 코드 계약</h2><p><code>예측 가능한 코드를 작성하라, 코드를 오용하기 어렵게 만들라</code> 두가지 원칙은 다른 사람이 작성한 코드와 상호작용할 때 일어날수 있는 일과 관련 있다</p><h3 id="자신의-코드와-다른-개발자의-코드"><a href="#자신의-코드와-다른-개발자의-코드" class="headerlink" title="자신의 코드와 다른 개발자의 코드"></a>자신의 코드와 다른 개발자의 코드</h3><p>1인 개발자 회사에서 일하지 않는한 다른 개발자들을 고려하지 않고는 고품질 코드를 작성할 수 없다</p><p>코드를 작성할때 고려할것 </p><ul><li>자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다<ul><li>자신은 문제를 해결하기 위해 몇시간 또는 몇일을 보냈지만 수정하는 사람은 충분한 시간을 갖지 못했던 사람이 수정해야 된다.</li></ul></li><li>다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다<ul><li>문제가 생기면 컴파일이 중지 되거나 테스트가 실패하도록 만드는것이 병합을 중지시킬수 있는 일이다</li></ul></li><li>시간이 지남에 따라 자신의 코드를 기억하지 못한다<ul><li>코드는 이해하기 쉬어야 하고 잘작동 하던 코드에 버그가 발생하는것이 어려워야 된다 다른 사람에게 호의를 베푸는것이고 미래의 자신을 위한 길이기도 하다</li></ul></li></ul><h3 id="여러분이-작성한-코드의-사용법을-다른-사람들은-어떻게-아는가"><a href="#여러분이-작성한-코드의-사용법을-다른-사람들은-어떻게-아는가" class="headerlink" title="여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?"></a>여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?</h3><ul><li>여러 가지 상황에서 어떤 함수를 호출해야 하는지</li><li>클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지</li><li>어떤 값을 인수로 사용해야 하는지</li><li>코드가 수행하는 동작이 무엇인지</li><li>어떤 값을 반환하는지</li></ul><p>코드가 어떻게 사용해야 하는지 알아내는 방법</p><ul><li>함수, 클래스, 열거형 등의 이름을 살펴본다<ul><li>이름을 잘짓는것이 다른 개발자가 어떻게 사용해야 하는지 가장 잘 전달할수 있는 방법이다.</li></ul></li><li>함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다<ul><li>유형 시스템을 사용하는 언어로 코드를 작성하는것은 오용하거나 오작동하지 못하게 하기 위한 좋은 방법이다.</li></ul></li><li>함수&#x2F;클래스 수준의 문서나 주석문을 읽어본다.<ul><li>함수및 클래스 수준의 비공식 주석문</li><li>자바독과 같은 좀더 공식적인 코드 내 문서</li><li>외부문서</li><li>단점<ul><li>다른 개발자가 이 문서들을 읽을 것이라는 보장이 없으며 실제로 읽지 않을 떄가 많다</li><li>설령 읽더라도 잘못 해석할 수 있다</li><li>문서의 업데이트가 제대로 안 될수 있다</li></ul></li></ul></li><li>직접 와서 묻거나 채팅&#x2F;이메일을 통해 문의한다<ul><li>단점<ul><li>코드를 많이 작성할수록 질문에 답하는 데 더 많은 시간을 써야 할 것이다</li><li>코드작성자가 휴가를 가면 물어볼사람이 없다</li><li>1년이 지나면 자기 자신도 그 코드를 기억하지 못한다 그래서 제한된 기간 동안만 효과가 있다.</li><li>코드를 작성한 사람이 회사를 떠날수도 있는데 그러면 코드를 사용하는 방법에 대한 지식이 사라져 버린다.</li></ul></li></ul></li><li>여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.<ul><li>코드의 양이 많으면 효과를 얻기 힘들다</li><li>추상화 계층을 만드는 데 있어 요점은 개발자가 한 번에 몇 가지 개념만 처리해야 하고 그 문제가 어떻게 해결되었는지 정확히 알지 못하더라고 하위 문제에 대한 해결책을 사용할수 있어야 된다</li></ul></li></ul><h3 id="코드-계약"><a href="#코드-계약" class="headerlink" title="코드 계약"></a>코드 계약</h3><p>계약에 의한 프로그래밍 또는 계약에 의한 디자인</p><p>코드의 계약에 대한 용어의 범주</p><ul><li>선결 조건 : 코드를 호출하기 전에 사실이어야 하는것</li><li>사후 조건 : 코드가 호출된 후에 사실이어야 하는것</li><li>불변 사항 : 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항</li></ul><p>어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대해 생각하는 것이 중요하다</p><p>계약이 명확한 부분</p><ul><li>함수와 클래스 이름</li><li>인자 유형</li><li>반환 유형</li><li>검사 예외(checked exception)</li></ul><p>세부 조항</p><ul><li>주석문과 문서</li><li>비검사 예외(unchecked exception)</li></ul><p>세부조항에 너무 의존하지 말라</p><ul><li>세부조항은 일반적으로 코드 계약을 전달하기 위해 신뢰할 만한 방법이 아니다</li><li>세부조항을 제거하는 방법<ul><li>정적팩토리 함수</li><li>상태나 가변성이 클래스 외부로 노출되는 것을 없엔다</li></ul></li></ul><h3 id="체크-및-어서션"><a href="#체크-및-어서션" class="headerlink" title="체크 및 어서션"></a>체크 및 어서션</h3><p>컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.</p><p>컴파일러를 사용하여 계약을 강제할수 있는 실질적인 방법이 없는 상황이 더러 있다.<br>이러한 경우 런타임 검사를 통해 계약을 확인하는 것이 아예 계약을 확인하지 않는 것보다 낫다.</p><p>체크 </p><ul><li>코드 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다.</li><li>체크는 신속한 실패와 밀접한 관계가 있다.</li></ul><p>체크가 계약조건에 따라 구분 되는 범주</p><ul><li>전제 조건 검사 : 입력 인수 확인, 일부 코드가 실행전에 유효한 상태인지 확인하는 경우</li><li>사후 상태 검사 : 반환값이 올바르거나 일부 코드 실행후 유효한 상태인지 확인하는 경우</li></ul><p>체크의 효과는 보장 되지 않는다</p><ul><li>테스트하기가 불분명한 상황에서 확인 중인 조건이 위반된다면, 코드가 배포되고 사용자가 사용하기 전까지 버그가 미노출</li><li>체크가 잘 작동해서 실패가 명백함에도 불구하고 아무도 알아차리지 못할 위험이 있다. 예외가 일어나더라고 시스템 작동이 엄추지 않게 상위 수준에서 예외가 처리되어<br>로그가 잘 기록 되어도 개발자가 신경쓰지 못하면 아무도 알아차리지 못 한다.</li></ul><p>코드에 체크가 많이 있으면 세부 조항을 없에는 것에 대해 고려해봐야 되는 신호일지도 모른다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장 URL 단축기 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/</guid>
      <pubDate>Mon, 30 Jan 2023 06:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="8장-URL-단축기-설계"><a href="#8장-URL-단축기-설계" class="headerlink" title="8장 URL 단축기 설계"></a>8장 URL 단축기 설계</h2><ul><li>API 엔드포인트<ul><li>URL 단축용 엔드포인트</li><li>URL 리다이렉션 엔드포인트</li></ul></li><li>URL 리다이렉션<ul><li>301 Moved Permanently : Location 헤더가 가르키는 주소로 영구 이동됨</li><li>302 Found : Location 헤더가 가르키는 주소로 일시적으로 이동</li></ul></li><li>URL 단축</li><li>해시함수<ul><li>해시길이 : 10 + 26 + 26 &#x3D; 62</li><li>해시 함수<ul><li>crc23</li><li>md5</li><li>sha-1</li><li>base62 : 흔히 사용하는 접근법 사용할수 있는 갯수가 62개라서 사용</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장 분산 시스템을 위한 유일 ID 생성기 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/</guid>
      <pubDate>Mon, 30 Jan 2023 01:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="7장-분산-시스템을-위한-유일-ID-생성기-설계"><a href="#7장-분산-시스템을-위한-유일-ID-생성기-설계" class="headerlink" title="7장 분산 시스템을 위한 유일 ID 생성기 설계"></a>7장 분산 시스템을 위한 유일 ID 생성기 설계</h2><p>분산 시스템에서 유일성이 보장되는 id를 만드는 방법</p><ul><li>다중 마스터 복제(multi-master replication)<ul><li>데이터 베이스의 auto_increment 기능을 활용함, 서버 마다 증가하는 값을 다르게 셋팅함</li><li>단점<ul><li>여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다</li><li>ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할수 없다</li><li>서버를 추가하거나 삭제할때 잘 동작하도록 만들기 어렵다</li></ul></li></ul></li><li>UUID(universally unique identifier)<ul><li>유일성이 보장되는 ID를 만드는 간단한 방법</li><li>장점<ul><li>만드는것이 단순하다 서버사이에 조율이 필요없고 동기화 이슈도 없다</li><li>각 서버가 자기가 쓸 ID를 알아서 만드는 구조이며 확장도 쉽다</li></ul></li><li>단점<ul><li>ID가 128바이트로 길다</li><li>ID를 시간순으로 정렬할 수 없다</li><li>ID에 숫자아닌 값이 포함될 수 있다</li></ul></li></ul></li><li>티켓 서버(ticket server)<ul><li>키를 만들어내는 중앙집중식 서버를 한대만 사용하는것</li><li>장점<ul><li>유일성이 보장 되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다</li><li>구현하기 쉽고 중소 규모 애플리케이션에게 적합</li></ul></li><li>단점<ul><li>티켓 서버가 SPOF 가 된다 해당 시스템이 장애면 해당 시스템을 사용하는 모든서버가 영향을 받음</li></ul></li></ul></li><li>트위터 스토우플레이크(Snowflake) 접근법<ul><li>사인 비트 + 타임스탬프 + 데이터센터 ID + 머신 ID + 일련 번호</li><li>사인 비트 : 1 비트 할당</li><li>타임 스템프 : 41 비트 할당</li><li>데이터 센터 ID : 5 비트 할당 32개 데이터 센터를 지원</li><li>서버 ID : 5 비트 할당, 데이터센터당 32개 서버를 지원</li><li>일련번호 : 12 비트 할당, 1밀리초가 경과될때 0으로 초기화</li></ul></li></ul><p>추가 논의 사항</p><ul><li>시계 동기화<ul><li>NTP</li></ul></li><li>각 섹션의 길이 최적화<ul><li>동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 섹션의 길이를 줄이고 타임스탬프 섹션의 길이를 늘리는 방법</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장 키-값 저장소 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/</guid>
      <pubDate>Sun, 29 Jan 2023 07:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="6장-키-값-저장소-설계"><a href="#6장-키-값-저장소-설계" class="headerlink" title="6장 키-값 저장소 설계"></a>6장 키-값 저장소 설계</h2><p>키-값 저장소는 키-값 데이터베이스라고도 불리는 비관계형 데이터베이스다<br>키는 유일해야 되며 성능상의 이슈로 키는 짧을수록 좋다<br>값은 보통 무엇이 오던 상관하지 않는다</p><p>분산 키-값 저장소는 분산 해시 테이블이라고도 불린다.</p><h3 id="CAP-정리"><a href="#CAP-정리" class="headerlink" title="CAP 정리"></a>CAP 정리</h3><p>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계 하는것은 불가능하다</p><ul><li>데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 된다</li><li>가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받아야 된다</li><li>파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생겨도 시스템은 계속 동작해야 된다</li></ul><p>핵심 컴포넌트 </p><ul><li>데이터 파티션<ul><li>데이터를 여러서버에 고르게 분산할 수 있는가</li><li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가</li><li>안정해시가 적합한기술</li></ul></li><li>데이터 다중화(replication)<ul><li>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화 필요가 있다.</li><li>가상 노드를 사용할때도 물리서버의 중복 선택되지 않도록 해야 된다</li><li>DR도 고려</li></ul></li><li>일관성(consistency)<ul><li>여러 노드에 다중화된 데이터는 적절히 동기화 해야 된다.</li><li>정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기&#x2F;쓰기 연산 모두에 일관성을 보장할수 있다</li><li>N &#x3D; 사본 갯수</li><li>W &#x3D; 쓰기 연산에 정족수</li><li>R &#x3D; 읽기 연산에 대한 정족수</li><li>R &#x3D; 1, W&#x3D;N : 빠른 읽기 연산에 최적화된 시스템</li><li>W &#x3D; 1, R&#x3D;N : 빠른 쓰기 연산에 최적화된 시스템</li><li>W + R &gt; N : 강한 일관성이 보장됨 (보통 N&#x3D;3, W&#x3D;R&#x3D;2)</li><li>W + R &lt;&#x3D; N : 강한 일관성이 보장되지 않음</li></ul></li><li>일관성 불일치 해소(inconsistency resolution)<ul><li>강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.</li><li>약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못한다.</li><li>최종 일관성 : 약한 일관성의 한 형태로 갱신 결과가 결국에는 모든 사본에 반영되는 모델</li><li>방법<ul><li>데이터 버저닝 : 변경 될때 마다 데이터의 새로운 버전을 만드는것</li><li>벡터 시계 : 서버:버전의 순서쌍을 데이터에 매단것<ul><li>단점<ul><li>충돌 감지 및 해소 로직이 클라이언트에 들어간다.</li><li>서버:버전의 순서쌍이 굉장히 빨리 늘어난다.</li></ul></li></ul></li></ul></li></ul></li><li>장애 처리<ul><li>장애감지<ul><li>모든 노드에 멀티캐스팅 채널을 구축하는것이 가장 손쉬운 방법, 서버가 많으면 비효율적</li><li>가십 프로토콜 같은 분산형 장애 감지 솔루션을 채낵하는것이 효율적</li></ul></li><li>장애해소<ul><li>일시적 장애처리<ul><li>엄격한 정족수 접근법을 쓰면 읽기와 쓰기 연산을 금지</li><li>느슨한 정족수 접근법은 이 조건을 완화하여 가용성을 높인다<ul><li>임시위탁 : 장애가 났을때 다른서버가 잠시 맡아 처리한다</li></ul></li></ul></li><li>영구적 장애처리<ul><li>반 엔트로피 프로토콜 구현 사본 동기화</li></ul></li><li>데이터 센터 장애처리</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장 안정 해시 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/</guid>
      <pubDate>Sun, 29 Jan 2023 07:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="5장-안정-해시-설계"><a href="#5장-안정-해시-설계" class="headerlink" title="5장 안정 해시 설계"></a>5장 안정 해시 설계</h2><p>수평적 규모 확장성을 달성하기 위해서 요청 또는 데이터를 서버에 균등하게 나누는게 중요하다</p><h3 id="해시키-재배치-문제"><a href="#해시키-재배치-문제" class="headerlink" title="해시키 재배치 문제"></a>해시키 재배치 문제</h3><p>n개의 캐시서버의 부하를 균등하게 나누는 보편적인 방법은 </p><p>serverindex &#x3D; hash(key) % n(서버 갯수)</p><p>위에 방법은 서버 풀이 고정되어 있을때 그리고 데이터 분포가 균등할때 잘 동작한다<br>하지만 서버가 추가되거나 삭제 될때는 대부분의 키가 재분배 해야 되는 문제가 생긴다.</p><h3 id="안정해시"><a href="#안정해시" class="headerlink" title="안정해시"></a>안정해시</h3><p>안정해시는 해시테이블의 크기가 조절될때 평균적으로 오직 k&#x2F;n개의 키만 재배치하는 해시 기술이다.</p><ul><li><p>해시 공간과 해시 링</p><ul><li>해시 공간을 구부리면 해시 링이 만들어 진다.</li></ul></li><li><p>해시 서버</p><ul><li>서버는 해시 링에 특정 위치에 존재한다.</li></ul></li><li><p>해시 키</p><ul><li>해시 키는 특정 방향으로 가장 가까운 서버에 값을 저장한다.</li></ul></li><li><p>서버 조회</p><ul><li>특정 위치에 가장 가까운 서버에게 질의 한다</li></ul></li><li><p>서버 추가</p><ul><li>추가가 되도 특정 위치의 해시 키만 다른 서버에 저장된다.</li></ul></li><li><p>서버 제거</p><ul><li>제거시에도 첫번째 만나는 서버에만 저장하면 된다.</li></ul></li><li><p>기본 구현법의 두 가지 문제</p><ul><li>기본 구현법<ul><li>서버와 키를 균등 분포 해시 함수를 사용해서 링에 배치한다</li><li>키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.</li></ul></li><li>두 가지 문제<ul><li>서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는게 불가능하다</li><li>키의 균등 분포를 달성하기가 어렵다</li></ul></li><li>해결 방법 <ul><li>가상 노드 또는 복제 기법</li></ul></li></ul></li><li><p>가상 노드</p><ul><li>실제 노드 또는 서버를 가리키는 노드로써 하나의 서버는 링 위에 여러 개 가상 노드를 가질 수 있다. 가상노드의 갯수를 늘리면 키의 분포는 점점 균등해진다 표준 편차가 작아져 데이터가 고르 분배</li><li>시스템 요구 사항에 맞춰 가상 노드 개수를 적절히 조정해야 된다.</li></ul></li><li><p>재배치할 키 결정</p><ul><li>서버가 추가 되거나 저거되면 데이터 일부는 재배치 해야 된다</li><li>삭제된 노드 반시계 방향에 있는 최초 서버 와 시계 방향 첫번째 서버사이에 키들은 재배치 되어야 된다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 2 추상화 계층</title>
      <link>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/</guid>
      <pubDate>Fri, 27 Jan 2023 19:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-2-추상화-계층"><a href="#CHAPTER-2-추상화-계층" class="headerlink" title="CHAPTER 2 추상화 계층"></a>CHAPTER 2 추상화 계층</h2><ul><li>문제와 하위 문제를 어떻게 해결하는가도 중요하지만 그것들을 해결하는 코드를 어떻게 구성하는가도 중요하다</li><li>코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다</li></ul><h3 id="널값-및-의사코드-규약"><a href="#널값-및-의사코드-규약" class="headerlink" title="널값 및 의사코드 규약"></a>널값 및 의사코드 규약</h3><p>많은 프로그래밍 언어에는 값(또는 참조&#x2F;포인터)이 없다는 개념을 가지고 있다 이 개념을 표현하기 위해 넣 null 값을 사용한다.</p><ul><li>값이 제공되지 않거나 함수가 원하는 결과를 반환할수 없는 경우가 자주 발생함 값이 없다 또는 부재한다는 이 개념은 유용하다</li><li>값이 널일수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다</li></ul><p>널 안전성, 보이드 안정성 대한 생각이 점점 추진력을 얻고 있다.</p><p>최근에 몇년간 새로 등장한 중요한 언어들 대부분은 널 안전성을 지원한다.</p><p>사용하는 언어가 널 안전성을 지원하지 않으면 널값을 사용하는 되신 옵셔널 타입을 사용하는것이 좋다</p><h3 id="왜-추상화-계층을-만드는가"><a href="#왜-추상화-계층을-만드는가" class="headerlink" title="왜 추상화 계층을 만드는가?"></a>왜 추상화 계층을 만드는가?</h3><p>하나의 문제가 있을 때 이 문제와 하위 문제에 대한 해결책이 일련의 층을 형성한다고 생각할수 있다. 이것을 추상화 계층이라고 한다</p><p>같은 층위 내에서는 쉽게 이해할 수있는 몇개의 개념만 다루기 때문에 개별 코드가 복잡해 보이지 않을것 이다<br>소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야한다<br>비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로 복잡한 문제를 쉽게 해결 가능하다.</p><p>추상화 계층 및 코드 품질의 핵심 요소</p><ul><li>가독성<ul><li>깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다</li></ul></li><li>모듈화<ul><li>추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기 매우 쉽다</li></ul></li><li>재사용성 및 일반화성<ul><li>하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기 쉬워진다.</li></ul></li><li>테스트 용이성<ul><li>신뢰할수 있는 코드를 작성하고자 한다면 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인 해야 된다.</li><li>코드가 추상호 계층으로 깨끗하게 분활 되면 하위 문제에 대한 해결책을 테스트하는것이 쉬워진다.</li></ul></li></ul><h3 id="코드의-계층"><a href="#코드의-계층" class="headerlink" title="코드의 계층"></a>코드의 계층</h3><p>대부분의 프로그래밍 언어는 코드를 다른 단위로 나누기 위해 몇 가지 언어 요소를 자유롭게 사용할 수 있다</p><ul><li>함수</li><li>클래스(및 구조체나 믹스인과 같이 클래스와 비슷한 요소도 가능)</li><li>인터페이스</li><li>패키지, 네임스페이스, 모듈</li></ul><p>API 및 구현 세부사항</p><ul><li>코드를 호출할 때 볼 수 있는 내용<ul><li>퍼블릭 클래스, 인터페이스 및 함수</li><li>이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념</li><li>코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 정보(예: 호출순서)</li></ul></li><li>우리가 작성한 코드도 미니 API를 노출하는 것으로 생각하면 유용할때가 있다.</li></ul><p>함수</p><ul><li>각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다</li><li>함수를 작성하기 위한 좋은 전략<ul><li>단일 업무 수행</li><li>잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성</li></ul></li><li>함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다</li></ul><p>클래스</p><ul><li>단일 클래스의 이상적인 크기<ul><li>줄수 : 한 클래스의 코드는 300줄이 넘지 않아야 된다.<ul><li>300줄 보다 긴 클래스는 너무 많은 개념을 다룬다고 생각해서 분리해야 된다</li><li>그렇다고 해서 300줄 이하의 모든 클래스가 적절한 크기임을 보장하지 않음</li></ul></li><li>응집력 : 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지 보여주는 척도 좋은 클래스는 응집력이 강하다<ul><li>순차적 응집력 : 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다</li><li>기능적 응집력: 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할때 발생</li></ul></li><li>관심사의 분리 : 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙</li></ul></li><li>코드 계층 및 클래스 생성과 관련한 네가지 핵심요소<ul><li>코드 가독성</li><li>코드 모듈화</li><li>코드 재사용성 및 일반화</li><li>테스트 용이성 및 적절한 테스트</li></ul></li><li>저품질 코드의 근거<ul><li>코드를 읽을 수 없다</li><li>코드가 특별히 모듈화되어 있지 않다</li><li>코드를 재사용할 수 없다</li><li>코드를 일반화할 수 없다</li><li>코드를 제대로 테스트하기 어렵다</li></ul></li><li>코드 개선 방법<ul><li>하위 문제의 해결책을 자체 클래스로 분할하여 개선</li><li>의존성 주입을 활용한다</li><li>이점<ul><li>코드가 좀 더 모듈화되고 재구성할 수 있게 됨</li><li>코드의 재사용성이 좀 더 높아짐</li><li>코드의 테스트 용이성이 좀 더 높아짐</li></ul></li></ul></li></ul><p>인터페이스</p><ul><li>계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출 되지 않도록 하기 위해 사용할 수 있는 한가지 접근법은 잍터페이스를 통해 노출 여부를 결정하는것</li><li>추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스는 매우 유용한 도구다</li><li>모든것을 위한 인터페이스?<ul><li>장점<ul><li>퍼블릭 API를 명확하게 보여준다</li><li>한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다</li><li>테스트를 쉽게 할수 있다</li><li>같은 클래스로 두가지 하위 문제를 해결할 수 있다</li></ul></li><li>단점<ul><li>더 많은 작업이 필요하다</li><li>코드가 복잡해질 수 있다</li></ul></li></ul></li></ul><p>층이 너무 얇아질 때</p><ul><li>코드를 별개의 계층으로 할때 단점<ul><li>클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는코드로 인해 코드양이 늘어난다</li><li>로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다</li><li>인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현을 사용되는지 파악하는데 노력이 필요</li></ul></li><li></li></ul><h3 id="마이크로서비스는-어떤가"><a href="#마이크로서비스는-어떤가" class="headerlink" title="마이크로서비스는 어떤가?"></a>마이크로서비스는 어떤가?</h3><p>마이크로 서비스도 여전히 그 내부에서 적절한 추상화 계층을 고려하는것이 유용하다</p><p>마이크로 서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만 서비스를 위해 여러하위 문제를 해결 하는것은 변하지 않는다</p><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다</li><li>특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌수 있다</li><li>코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li><li><a href="https://en.wikipedia.org/wiki/Void_safety">Void_safety</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 코드 품질</title>
      <link>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/</guid>
      <pubDate>Fri, 27 Jan 2023 11:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-1-코드-품질"><a href="#CHAPTER-1-코드-품질" class="headerlink" title="CHAPTER 1 코드 품질"></a>CHAPTER 1 코드 품질</h2><p>고품질 코드는</p><ul><li>좀 더 신뢰할 수 있다</li><li>유지보수가 쉽다</li><li>버그가 적은 소프트웨어를 생산</li></ul><p>좋은 코드는 좋은 소프트웨어를 만들기 위한 유일한 조건은 아니지만 중요한 조건중에 하나다</p><h3 id="코드는-어떻게-소프트웨어가-되는가"><a href="#코드는-어떻게-소프트웨어가-되는가" class="headerlink" title="코드는 어떻게 소프트웨어가 되는가"></a>코드는 어떻게 소프트웨어가 되는가</h3><ul><li>코드베이스 : 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소</li><li>코드 제출 : 코드 커밋 or mr(pr)</li><li>코드 리뷰 : 코드 제출 전에 다른 프로그래머가 리뷰 해주는것</li><li>제출 전 검사 : 병합전 훅, 병합전 점검, 커밋전 점검 이라고 하며 테스트가 실패하거나 컴파일 되지 않으면 병합되지 않도록 차단한다</li><li>배포 : 소프트웨어는 코드베이스의 스냅샷을 기반으로 빌드된다.</li><li>프로덕션 : 실제 서비드되는 환경을 가르킨다.</li></ul><h3 id="코드-품질의-목표"><a href="#코드-품질의-목표" class="headerlink" title="코드 품질의 목표"></a>코드 품질의 목표</h3><ul><li>안전하고</li><li>실제로 작동하고</li><li>고장 나지 않고</li><li>예측 가능한 행동을하는</li></ul><p>필자가 생각하는 상위수준의 목표</p><ul><li>작동해야 한다<ul><li>문제를 해결하기위해 목적한 대로 동작해야 된다</li></ul></li><li>작동이 멈춰서는 안 된다<ul><li>코드는 다른 코드에 의존할 수 있는데, 그 코드가 수정되고 변경될 수 있다.</li><li>새로운 기능이 필요할 때 코드를 수정해야 할 수도 있다.</li><li>해결해야 될 문제는 시간이 지남에 따라 변경 된다.</li></ul></li><li>변화하는 요구 사항에 적응해야 한다<ul><li>시나리오 A : 모든 요구사항이 어떻게 변할지 정확히 예측하고 잠재적인 변화를 모두 수용하기 위한 코드를 설계하려고 노력한다</li><li>시나리오 B : 요구사항이 변할 수 있다는 사실을 완전히 무시한다. 현재의 요구 사항만 충족시키기 위한 코드만 작성하고 적응력 높은 코드를 작성하기 위한 노력은 하지 않는다.</li><li>두개의 시나리오는 서로 대립하는 극단을 보여준다 두가지 사이에 어떤 지점을 선택해서 개발해야 된다</li></ul></li><li>이미 존재하는 기능을 또다시 구현해서는 안 된다<ul><li>시간과 노력을 절약한다</li><li>버그 가능성을 줄여준다</li><li>기존 전문지식을 활용한다</li><li>코드가 이해하기 쉽다</li></ul></li></ul><h3 id="코드-품질의-핵심-요소"><a href="#코드-품질의-핵심-요소" class="headerlink" title="코드 품질의 핵심 요소"></a>코드 품질의 핵심 요소</h3><ul><li>코드는 읽기 쉬워야 한다<ul><li>코드가 하는일</li><li>어떻게 그 일을 수행하는지</li><li>어떤 것을 필요로 하는지</li><li>코드 실행 결과물</li></ul></li><li>코드는 예측 가능해야 한다<ul><li>코드가 예상을 벗어나면 명백하게 이상한 일이 발견되기 전까지 시스템은 계속 비정상적으로 작동한다.</li></ul></li><li>코드를 오용하기 어렵게 만들라<ul><li>tv 제조 업체는 전원 코드와 HDMI 케이블을 잘못 꽃게 하지 않게 모양을 틀리게 만들었다(요즘 노트북은 모두 USB-C….)</li><li>코드 계약은 근본적으로 코드 오용을 어럽게 만들어주는 기술 이다.</li></ul></li><li>코드를 모듈화하라<ul><li>모듈화는 개체나 시스템의 구성 요소가 독립적으로 교환되거나 교체될 수 있음을 의미한다.</li></ul></li><li>코드를 재사용 가능하고 일반화할 수 있게 작성하라<ul><li>재사용성 : 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있음</li><li>일반화성 : 개념적으로 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미</li><li>모듈화된 코드 역시 더 높은 재사용성과 일반화성을 갖는다</li></ul></li><li>테스트가 용이한 코드를 작성하고 제대로 테스트하라<ul><li>버그나 제대로 동작하지 않는 기능을 갖는 코드가 코드베이스에 병합되지 않도록 방지</li><li>버그나 제대로 동작하지 않는 기능을 갖는 코드가 베포되지 않도록 막고 서비스 환경에서 실행되지 않도록 보장</li><li>테스트 : 코드 혹은 소프트웨어 전체를 테스트하는 것과 관련이 있다<ul><li>단위 테스트 : 일반적으로 개별 함수나 클래스와 같은 작은 단위의 코드를 테스트한다.</li><li>통합 테스트 : 시스템은 일반적으로 여러 구성 요소, 모듈, 하위 시스템으로 구성된다 이러한 하위시스템을 연결하는 과정을 통합이라고 한다</li><li>종단간 테스트 : 이 테스트는 처음부터 끝까지 전체 소프트웨어 시스템에서 작동 흐름을 테스트 한다.</li></ul></li><li>테스트 용이성 : 실제 코드가 얼마나 테스트하기 적합한지를 나타낸다</li></ul></li></ul><h3 id="고품질-코드-작성은-일정을-지연시키는가"><a href="#고품질-코드-작성은-일정을-지연시키는가" class="headerlink" title="고품질 코드 작성은 일정을 지연시키는가?"></a>고품질 코드 작성은 일정을 지연시키는가?</h3><ul><li>단기적으로는 고품질 코드를 작성하는데 시간이 더 걸릴수 있다</li><li>중장기적으로는 개발 시간을 단축시켜준다.</li></ul><p><code>서두르지 않으면 더 빠르다</code></p><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>좋은 소프트웨어를 만들려면 고품질 코드를 작성해야 한다</li><li>실제 서비스 환경에서 실행되는 소프트웨어가 되기 전에 코드는 일반적으로 여러 단계의 검사와 테스트를 통과해야 한다</li><li>버그나 제대로 동작하지 않는 기능이 사용자에게 제공되거나 비즈니스에 중요한 시스템에서 실행 되는 것을 이러한 검사를 통해 막을수 있다</li><li>테스트는 코드를 작성하는 모든 단계에서 고려하는 것이 좋다. 코드를 다 작성하고 난 후에 고려 하는 것이 아니다</li><li>고품질 코드를 작성하면 처음에는 시간이 오래 걸리지만 중장기적으로 개발 시간이 단축되는 경우가 많다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장 처리율 제한 장치 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/</guid>
      <pubDate>Thu, 26 Jan 2023 12:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="4장-처리율-제한-장치-설계"><a href="#4장-처리율-제한-장치-설계" class="headerlink" title="4장 처리율 제한 장치 설계"></a>4장 처리율 제한 장치 설계</h2><h3 id="토큰-버킷-알고리즘"><a href="#토큰-버킷-알고리즘" class="headerlink" title="토큰 버킷 알고리즘"></a>토큰 버킷 알고리즘</h3><p>인자</p><ul><li>버킷 크기</li><li>토큰 공급율</li></ul><p>장점</p><ul><li>구현이 쉽다</li><li>메모리 사용 측면에서도 효율적이다.</li><li>짧은 시간에 집중되는 트래픽도 처리가능하다</li></ul><p>단점</p><ul><li>버킷 크기와 토큰 공급률이라는 두개의 인자를 가지고 있는데 이값을 적절하게 튜닝하는게 어렵다.</li></ul><h3 id="누출-버킷-알고리즘"><a href="#누출-버킷-알고리즘" class="headerlink" title="누출 버킷 알고리즘"></a>누출 버킷 알고리즘</h3><p>토큰 버킷 알고리즘이랑 비슷하지만 요청 처리율이 고정되어 있다. 보통 큐로 많이 구현한다.</p><p>인자</p><ul><li>버킷 크기</li><li>처리율</li></ul><p>장점</p><ul><li>큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.</li><li>고정된 처리율을 갖고 있기 때문에 안정적 출력이 필요한 경우에 적합하다</li></ul><p>단점</p><ul><li>단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게 되고 그요청들을 제때 처리 못하면 최신요청은 버려지게 된다.</li><li>두개의 인자를 가지고 있는 데 이를 올바르게 튜닝하기 어렵다.</li></ul><h3 id="고정-원도-카운터-알고리즘"><a href="#고정-원도-카운터-알고리즘" class="headerlink" title="고정 원도 카운터 알고리즘"></a>고정 원도 카운터 알고리즘</h3><ul><li>타임라인을 고정된 간격의 원도로 나누고 각 원도우 마다 카운터를 붙힌다.</li><li>요청이 접수될 떄마다 카운터의 값은 1씩 증가한다.</li><li>카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 윈도우가 열릴때 까지 버려진다.</li></ul><p>장점</p><ul><li>메모리 효율이 좋다</li><li>이해하기 쉽다</li><li>원도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기 적합하다.</li></ul><p>단점</p><ul><li>원도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우 기대했던 시스템 처리 한도보다 많은 양의 요청을 처리한다.</li></ul><h3 id="이동-원도-로깅-알고리즘"><a href="#이동-원도-로깅-알고리즘" class="headerlink" title="이동 원도 로깅 알고리즘"></a>이동 원도 로깅 알고리즘</h3><p>고정 원도 카운터 알고리즘에 중대한 문제가 있는데 원도우 경계 부근에 트래픽이 집중 되는 경우 시스템에서 설정한 한도 보다 많은 요청을 처리하는것이다.</p><p>이동 원도 로깅 알고리즘은 이 문제를 해결한다.</p><ul><li>이 알고리즘은 요청의 타임스템프를 추적한다. 타임스템프 데이터는 보통 레디스의 정렬 집합(sorted set) 같은 캐시에 저장한다.</li><li>새 요청이 오면 만료된 타임스템프는 제거 한다. 만료된 타임스템프는 그값이 현재 원도우 시작시점보다 오래된 타임스템프를 말한다.</li><li>새 요청의 타임스템프를 로그에 추가 한다.</li><li>로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다 그렇지 않으면 요청은 버린다.</li></ul><p>장점</p><ul><li>이 알고리즘이 구현하는 처리율 제한 메커니즘은 아주 정교하다. 어느 순간의 원도를 보더라도 허용되는 요청의 개수는 시스템 처리한도를 넘지 않는다.</li></ul><p>단점</p><ul><li>이 알고리즘은 다량의 메모리를 사용하는데 거부된 요청의 타임 스템프도 보관하기 때문이다.</li></ul><h3 id="이동-원도-카운터-알고리즘"><a href="#이동-원도-카운터-알고리즘" class="headerlink" title="이동 원도 카운터 알고리즘"></a>이동 원도 카운터 알고리즘</h3><p>이동 원도 카운터 알고리즘은 고정 원도 카운터 알고리즘 과 이동 원도 로깅 알고리즘을 결합한 것이다.</p><p>고정 원도우 카운터 알고리즘 처럼 원도우의 카운터를 추적하고 제한 하는데 현재 타임스템프 기반으로 추적하면 이전 요청의 가중치를 부여하여 트레픽 폭주를 완화 한다.</p><p>장점</p><ul><li>이전 시간대의 평균 처리율에 따라 현재 원도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘대응한다.</li><li>메모리 효율이 좋다.</li></ul><p>단점</p><ul><li>직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.</li></ul><h3 id="분산-환경의-처리율-제한장치의-구현"><a href="#분산-환경의-처리율-제한장치의-구현" class="headerlink" title="분산 환경의 처리율 제한장치의 구현"></a>분산 환경의 처리율 제한장치의 구현</h3><ul><li><p>경쟁조건(race condition)</p><ul><li>병행성이 심한 환경에서 경쟁 조건 이슈가 발생할수 있다.</li><li>가장 널리 알려진 해결책은 락이다. 하지만 시스템 성능을 상당히 떨어뜨린다.</li><li>락 대신 해결 방법 루아 스크립트, sorted set 사용</li></ul></li><li><p>동기화(synchronization)</p><ul><li>처리율 제한장치를 여러대 쓸때 동기화 이슈가 발생<ul><li>sticky session 을 활용해 같은 처리율 장치로 전달하는 방법도 있다</li><li>다른 방법은 중앙집중식 데이터 저장소를 활용하는것이다.(ex. redis)</li></ul></li></ul></li><li><p>경성(hard) 또는 연성(soft) 처리율 제한</p><ul><li>경성 처리율 제한 : 절대 임계치를 넘을수 없다</li><li>연성 처리율 제한 : 잠시 동안은 임계치를 넘을수 있다.</li></ul></li><li><p>다양한 계층에서의 처리율 제한</p><ul><li>iptables를 사용하면 ip에 처리율 제한을 걸수도 있다.<ul><li>connlimit 모듈</li><li>limit 모듈</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li><li><a href="https://spring.io/blog/2021/04/05/api-rate-limiting-with-spring-cloud-gateway">API Rate Limiting with Spring Cloud Gateway</a></li><li><a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket</a></li><li><a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky bucket</a></li><li><a href="https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm">How to Design a Scalable Rate Limiting Algorithm with Kong API</a></li><li><a href="https://doublem.org/api-gateway-basic/">API Gateway Throttling 구현</a></li><li><a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-02.html">RateLimit Header Fields for HTTP</a></li><li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">RateLimit header fields for HTTP datatracker</a></li><li><a href="https://www.netfilter.org/projects/iptables/index.html">The netfilter.org “iptables” project</a></li><li><a href="https://thelowedown.wordpress.com/2008/07/03/iptables-how-to-use-the-limits-module/">iptables: How to use the limits module</a></li><li><a href="https://nginxstore.com/blog/kubernetes/microservices-march-protect-kubernetes-apis-with-rate-limiting/">자습서-NGINX Ingress Controller 속도 제한 설정</a></li><li><a href="https://istio.io/latest/docs/tasks/policy-enforcement/rate-limit/">Enabling Rate Limits using Envoy</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장 시스템 설계 면접 공략법</title>
      <link>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/</guid>
      <pubDate>Fri, 20 Jan 2023 06:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="3장-시스템-설계-면접-공략법"><a href="#3장-시스템-설계-면접-공략법" class="headerlink" title="3장 시스템 설계 면접 공략법"></a>3장 시스템 설계 면접 공략법</h2><h3 id="효과적-면접을-위한-4단계-접근법"><a href="#효과적-면접을-위한-4단계-접근법" class="headerlink" title="효과적 면접을 위한 4단계 접근법"></a>효과적 면접을 위한 4단계 접근법</h3><ul><li>문제 이해 및 설계 범위 확정<ul><li>깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하라<ul><li>구체적으로 어떤 기능들을 만들어야 하나?</li><li>제품 사용자 수는 얼마나 되나?</li><li>회사의 규모는 얼마나 빨리 커지리라 예상되나?</li><li>회사가 주로 사용하는 기술 스택은 무엇인가?</li><li>설계를 단순화 하기위해 활용할수 있는 기존 서비스로는 어떤것이 있나?</li></ul></li></ul></li><li>개략적인 설계안 제시 및 동의 구하기<ul><li>설계안에 대한 최초 청사진을 제시하고 의견을 구하라</li><li>화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라</li><li>시스템 규모에 관계된 제약사항을 만족하는지 개략적으로 계산해 보어라 계산과정을 소리내어 설명하라</li></ul></li><li>상세 설계<ul><li>시스템에서 전반적으로 달성해야할 목표와 기능확인</li><li>전체 설계의 개략적 청사진 마련</li><li>해당 청사진에 대한 면접관의 의견청휘</li><li>상세 설계에서 집중해야 할 영역들 확인</li></ul></li><li>마무리<ul><li>시스템 병목구간 혹은 좀더 개선가능한 지점을 찾아내라</li><li>만든 설계를 한번 다시 요약해주는 것도 도움이 될 수 있다.</li><li>오류가 발생하면 무슨 일이 생기는지 따져보면 흥미롭다</li><li>운영이슈도 논의할 가치가 충분하다.</li><li>미래에 닥칠 규모 확장 요구에 어떻게 대처할 것인지도 흥미로운 주제다</li><li>필요하지만 다루지 못했던 세부적 개선사항들을 제안 할수 있다.</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장 개략적인 규모 추정</title>
      <link>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_2/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_2/</guid>
      <pubDate>Fri, 20 Jan 2023 06:22:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="2장-개략적인-규모-추정"><a href="#2장-개략적인-규모-추정" class="headerlink" title="2장 개략적인 규모 추정"></a>2장 개략적인 규모 추정</h2><ul><li><p>2의 제곱수 : 데이터 볼륨의 단위 1바이트, 1킬로바이트, 1메가바이트…</p></li><li><p>응답 지연값 : 구글의 제프 딘이 응답지연값을 공개한것이 있다.</p><ul><li>메모리는 빠르지만 디스크는 아직도 느리다</li><li>디스크 탐색(seek)는 가능한 피하라</li><li>단순한 압축 알고리즘은 빠르다.</li><li>데이터를 인터넷으로 전송하기 전에 가능하면 압축하라</li><li>데이터 센터는 보통 여러 지역에 분산되어 있고 센터들 간에 데이터를 주고 받는데 시간이 걸린다</li></ul></li><li><p>가용성에 관계된 수치들</p><ul><li>SLA</li><li>QPS</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장 사용자 수에 따른 규모 확장성</title>
      <link>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/</guid>
      <pubDate>Thu, 19 Jan 2023 02:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="1장-사용자-수에-따른-규모-확장성"><a href="#1장-사용자-수에-따른-규모-확장성" class="headerlink" title="1장 사용자 수에 따른 규모 확장성"></a>1장 사용자 수에 따른 규모 확장성</h2><ul><li><p>단일 서버 -&gt; 데이터베이스 분리 -&gt; 수평적 확장 vs 수직적 확장</p></li><li><p>수직적 확장 : 스케일업</p><ul><li>단점 : 한계가 존재함, 장애 복구에 대한 방안이나 다중화 방안을 제시하지 않는다.</li></ul></li><li><p>수평적 확장 : 스케일 아웃</p></li><li><p>로드벨런서 : L2(Data link 계층을 사용, Mac주소 기반 부하 분산), L3(Network 계층을 사용, IP주소 기반 부하 분산),<br>L4(Transport 계층을 사용, Port 기반 부하 분산), L7(Application 계층을 사용, 요청(URL) 기반 부하 분산)</p></li><li><p>데이터 베이스 다중화 : master - slave 방식</p><ul><li>쓰기는 마스터 읽기는 슬레이브로 부하 분산이되어 성능이 좋아진다.</li><li>분산저장해서 하나가 파괴되어도 다른 DB로 작업 할수 있어서 가용성과 안정성이 높아진다.</li></ul></li><li><p>캐쉬 : 값비싼 연산 결과를 메모리안에 두고 빨리 처리 될수 있도록 하는 저장소이다. </p><ul><li>캐쉬 계층 : 데이터가 잠시 보관 되는 곳으로 DB 보다 훨씬 빠르다.</li><li>읽기 주도형 캐쉬 전략(read-through caching strategy) </li><li>데이터 갱신은 자주 일어나지 않지만 참조가 빈번이 일어날때</li><li>영속적으로 보관할때는 캐시가 좋지는 않다.</li><li>캐시에 보관된 데이터는 어떻게 만료되는지 고려 해야 된다.</li><li>일관성은 어떻게 유지해야 되는지 고려해야 된다.</li><li>장애에는 어떻게 대응 해야 되는지 고려해야 된다</li><li>캐시 메모리의 크기를 고려해야 된다.</li><li>데이터 방출 정책이 무엇인지 고려해야 된다. LRU, LFU, FIFO</li></ul></li><li><p>CDN : 정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크</p><ul><li>비용 문제를 고려하자</li><li>적절한 만료 시한 설정</li><li>CDN 장애에 대한 대처 방안</li></ul></li><li><p>무상태(stateless) 웹 계층</p><ul><li>상태 정보 의존적인 아키텍처(세션 데이터 사용)</li><li>무상태 아키텍처 : 상태 정보는 공유 저장소로 부터 가지고 온다.</li></ul></li><li><p>데이터 센터</p><ul><li>장애가 없는 상황에서 사용자는 지리적으로 가까운 데이터 센터를 이용한다 (geoDNS-routing, geo-routing)</li><li>다중 데이터 센터 아키텍처 <ul><li>트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법</li><li>데이터 동기화 : 데이터 센터마다 별도의 데이터 베이스를 사용하는 상황</li><li>테스트 와 배포 : 여러 위치에 배포하고 테스트 해야 되는 상황</li></ul></li></ul></li><li><p>메시지 큐 : 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트</p><ul><li>생산자&#x2F;소비자</li><li>서버간의 느슨한 결합</li></ul></li><li><p>로그, 메트릭 그리고 자동화</p><ul><li>로그 : 에러 로그를 모니터링하는것이 중요하다.</li><li>메트릭 : 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 언을 수도 있고 시스템의 현재 상태를 손쉽게 파악할수 있다.<ul><li>호스트 단위 메트릭</li><li>종합 메트릭</li><li>핵심 비지니스 메트릭</li></ul></li><li>자동화 : 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 사용해야 된다.</li></ul></li><li><p>데이터 베이스의 규모확장</p><ul><li>수직적 확장 : 스케일업, 기존 서버에 더많은 또는 고성능의 자원을 증설하는 방법<ul><li>하드웨어에는 한계가 있다.</li><li>SPOF 로 인한 위험성이 크다</li><li>비용이 많이 든다.</li></ul></li><li>수평적 확장 : 수평적 확장은 샤딩이라고도 부르는데 더 많은 서버를 추가함으로써 성능을 향상시킬수 있다.<ul><li>대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술이다.</li><li>샤딩 전략<ul><li>가장 중요한건 샤딩 키(파티션 키)<ul><li>데이터 재샤딩</li><li>유명인사 문제</li><li>조인과 비정규화</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li><li><a href="https://martinfowler.com/eaaCatalog/">Catalog of Patterns of Enterprise Application Architecture</a></li><li><a href="https://www.youtube.com/watch?v=cflK7FTGPlg">[우아한테크세미나] 200507 우아한CRUD by 정상혁&amp;이명현님</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql (mariaDB) HikariCP 성능 튜닝</title>
      <link>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/</guid>
      <pubDate>Mon, 09 Jan 2023 09:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mysql-mariaDB-HikariCP-성능-튜닝&quot;&gt;&lt;a href=&quot;#mysql-mariaDB-HikariCP-성능-튜닝&quot; class=&quot;headerlink&quot; title=&quot;mysql (mariaDB) HikariCP 성능 튜닝&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mysql-mariaDB-HikariCP-성능-튜닝"><a href="#mysql-mariaDB-HikariCP-성능-튜닝" class="headerlink" title="mysql (mariaDB) HikariCP 성능 튜닝"></a>mysql (mariaDB) HikariCP 성능 튜닝</h1><h2 id="HikariCP-설정"><a href="#HikariCP-설정" class="headerlink" title="HikariCP 설정"></a>HikariCP 설정</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">hikari:</span></span><br><span class="line">        <span class="attr">data-source-properties:</span></span><br><span class="line">            <span class="attr">cachePrepStmts:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">prepStmtCacheSize:</span> <span class="number">250</span></span><br><span class="line">            <span class="attr">prepStmtCacheSqlLimit:</span> <span class="number">2048</span></span><br><span class="line">            <span class="attr">useServerPrepStmts:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">useLocalSessionState:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">cacheResultSetMetadata:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">cacheServerConfiguration:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">elideSetAutoCommits:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">maintainTimeStats:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration">HikariCP MySQL-Configuration</a></li><li><a href="https://cdn.oreillystatic.com/en/assets/1/event/21/Connector_J%20Performance%20Gems%20Presentation.pdf">Connector&#x2F;J Performance Gems slide</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql (mariaDB) 성능 튜닝 (performance tuning)</title>
      <link>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/</guid>
      <pubDate>Sat, 07 Jan 2023 02:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mysql-mariaDB-성능-튜닝-performance-tuning&quot;&gt;&lt;a href=&quot;#mysql-mariaDB-성능-튜닝-performance-tuning&quot; class=&quot;headerlink&quot; title=&quot;mysql (mariaDB) 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mysql-mariaDB-성능-튜닝-performance-tuning"><a href="#mysql-mariaDB-성능-튜닝-performance-tuning" class="headerlink" title="mysql (mariaDB) 성능 튜닝 (performance tuning)"></a>mysql (mariaDB) 성능 튜닝 (performance tuning)</h1><h2 id="DB-server-성능-튜닝"><a href="#DB-server-성능-튜닝" class="headerlink" title="DB server 성능 튜닝"></a>DB server 성능 튜닝</h2><ul><li>max_connections : 데이터베이스 서버에 대한 최대 동시 연결 수를 제어합니다.<br>이 값을 너무 낮게 설정하면 연결 오류가 발생할 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용하여 전체 성능이 저하될 수 있습니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size(MyISAM 전용 설정) : 인덱스 블록에 사용되는 버퍼의 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 더 많은 디스크 읽기가 발생하고 성능이 느려질 수 있으며, 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.<br>이 값을 너무 낮게 설정하면 연결 오류가 발생할 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용하여 전체 성능이 저하될 수 있습니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%key_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>query_cache_size : SELECT 쿼리 결과를 저장하는 데 사용되는 캐시 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 캐시 미스가 더 자주 발생하고 성능이 느려질 수 있으며, 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.</p></li><li><p>innodb_buffer_pool_size : InnoDB 스토리지 엔진에서 사용하는 버퍼 풀의 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 디스크 읽기 빈도가 높아지고 성능이 저하될 수 있으며, 너무 높게 설정하면 메모리를 너무 많이 사용할 수 있습니다.</p></li><li><p>join_buffer_size : 적절한 인덱스가 없는 조인에 사용되는 버퍼의 크기를 제어합니다. (Block Nested-Loop Join Algorithm)<br>이 값을 너무 낮게 설정하면 이러한 조인 유형의 성능이 느려질 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%join_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>sort_buffer_size : MySQL에서 인덱스 없이 정렬을 수행할 경우 디스크 버퍼에서 데이터를 정렬한다. (Block Nested-Loop Join Algorithm)<br>보통 MySQL에서 부하가 많이 생기는 작업이 정렬인데, sort_buffer_size를 통해 정렬에 얼마만큼의 메모리 공간을 할당할지 정할 수 있다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>innodb_flush_log_at_trx_commit : 기본값인 1로 설정하면 각 트랜잭션 커밋에서 로그 버퍼가 플러시됩니다.<br>이 설정은 데이터베이스 ACID 를 유지하는 데 도움이 됩니다.준수합니다. 기본 설정인 1을 유지하는 것이 좋습니다.<br>기본값이 아닌 값(0 또는 2)으로 변경하면 innodb_flush_log_at_trx_commitDML(데이터 조작 언어) 대기 시간을 줄이는 데 도움이 되지만 로그 레코드의 내구성이 저하됩니다.<br>이러한 내구성 부족으로 인해 데이터베이스 ACID는 비준수 상태가 됩니다.</p></li><li><p>connect_timeout : mysqld 서버가 접속실패로 응답하기 전에 연결 패킷을 기다리는 시간(초). 기본값은 10 초입니다.<br>connect_timeout값을 늘리면 클라이언트에서 Lost Connection 오류가 자주 발생하는 경우 도움이 될 수 있습니다.<br><code>Lost connection to MySQL server at &#39;XXX&#39;, system error: errno.</code></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%connect_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>lock_wait_timeout : 메타 데이터 잠금 획득 시도에 대한 제한 시간 (초)을 지정합니다. 허용되는 값의 범위는 1-31536000 (1 년)입니다. 기본값은 31536000입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%lock_wait_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>net_read_timeout : 네트워크 접속을 통해서 클라이언트가 서버에서 데이터를 받을 때 abort(중지)될때까지 기다리는 시간입니다. 여기에서 네트워크 접속이란 TCP&#x2F;IP 접속을 얘기합니다.<br>Unix socket file(로컬 서버에서의 접속), named pipe, 공유된 메모리를 통해 접속된 연결은 아닙니다. 기본값은 30초 입니다. 서버가 클라이언트로부터 읽혀질때 net_read_timeout값은 abort(중지)를 제어합니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%net_read_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>net_write_timeout : 네트워크 접속을 통해서 클라이언트가 서버에 데이터 쓸 때 abort(중지)될때까지 기다리는 시간입니다. 여기에서 네트워크 접속이란 TCP&#x2F;IP 접속을 얘기합니다.<br>Unix socket file(로컬 서버에서의 접속), named pipe, 공유된 메모리를 통해 접속된 연결은 아닙니다. 기본값은 60초 입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%net_write_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>wait_timeout : 비 대화식(non interactive) 연결에서 서버가 활동을 닫기 전에 서버가 대기하는 시간 (초)입니다.<br>스레드 시작시 wait_timeout 값은 클라이언트 유형에 따라 전역 wait_timeout 값 또는 전역 interactive_timeout 값에서 초기화됩니다(CLIENT_INTERACTIVE 연결 옵션으로 mysql_real_connect()에 정의 됨).<br>interactive_timeout도 참조합니다. 기본값은 28800초 입니다. 클라이언트의 최대 연결시간  최대 연결시간</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%wait_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>interactive_timeout : 서버가 대화식 연결을 닫기 전에 활동을 기다리는 시간 (초)입니다.<br>대화 형 클라이언트는 mysql_real_connect ()에 CLIENT_INTERACTIVE 옵션을 사용하는 클라이언트로 정의됩니다. wait_timeout도 참조하십시오. 기본값은 28800초 입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%interactive_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>table_lock_wait_timeout : 테이블 락을 중단하기까지 대기하는 시간</p></li><li><p>thread_pool_idle_timeout : 마리아DB파라미터 입니다. 기본값은 60초입니다. idle 상태인 쓰레드를 정리하기 전에 대기하는 시간(초)입니다.</p></li></ul><h3 id="Aurora-MySQL-버전-3-파라미터"><a href="#Aurora-MySQL-버전-3-파라미터" class="headerlink" title="Aurora MySQL 버전 3 파라미터"></a>Aurora MySQL 버전 3 파라미터</h3><ul><li>innodb_flush_log_at_trx_commit : 무조건 1로 셋팅 되어 있다.</li><li>max_connections : 인스턴스 사이즈에 의해서 계산된다.</li><li>query_cache_size : 수식에 의해 결정 된다.</li><li>innodb_buffer_pool_size : 수식에 의해 결정 된다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Performance.html">Managing performance and scaling for Amazon Aurora MySQL</a></li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.BestPractices.html#AuroraMySQL.BestPractices.Avoiding">AuroraMySQL BestPractices</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Reference.html">AuroraMySQL.Reference</a></li><li><a href="https://myinfrabox.tistory.com/192">MySQL Timeout 종류</a></li><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bomyzzang&logNo=221550485417">MySQL 서버의 time out 설정</a></li><li><a href="https://lee-seul.github.io/backend/2019/03/09/mysql-setting.html">알아두면 좋은 MySQL 설정들</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">Nested-Loop Join Algorithms</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html">mysql Server System Variables</a></li><li><a href="https://aws.amazon.com/ko/rds/instance-types/">Amazon RDS 인스턴스 유형</a></li><li><a href="http://small-dbtalk.blogspot.com/2015/01/lockwaittimeout-default_9.html">lock_wait_timeout 의 Default 값이 불러일으키는 문제점</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html">Server Status Variables</a></li><li><a href="http://www.ezmeta.co.kr/page/?p=3025">MySQL 기본적인 모니터링 방법과 Connection과 Memory 튜닝 방법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 42: compareTo의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/</guid>
      <pubDate>Fri, 06 Jan 2023 13:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-42-compareT
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-42-compareTo의-규약을-지켜라"><a href="#아이템-42-compareTo의-규약을-지켜라" class="headerlink" title="아이템 42: compareTo의 규약을 지켜라"></a>아이템 42: compareTo의 규약을 지켜라</h2><p>compareTo는 Any에 있는 메소드가 아니라 부등식으로 변환되는 연산자이다.</p><ul><li>비대칭적 동작: a≥b 이고 b≥a 라면 a&#x3D;&#x3D;b이다.</li><li>연속적 동작: a≥b 이고 b≥c라면 a≥c이다.</li><li>코넥스적 동작(connex relation): a≥b 또는 b≥a 중에 적어도 하나는 반드시 항상 true여야 한다. 관계가 없다면 고전적 정렬 알고리즘(퀵, 삽입)을 사용할 수 없고, 위상 정렬만 사용할 수 있다.</li></ul><h3 id="compareTo를-따로-정의해야-할까"><a href="#compareTo를-따로-정의해야-할까" class="headerlink" title="compareTo를 따로 정의해야 할까?"></a>compareTo를 따로 정의해야 할까?</h3><p>일반적으로는 거의 없다. sortedBy(단일 키), sortedWith(여러 키)로 정렬할 수 있기 때문이다.</p><h3 id="compareTo-구현하기"><a href="#compareTo-구현하기" class="headerlink" title="compareTo 구현하기"></a>compareTo 구현하기</h3><ul><li>compareTo를 구현할 때 유용하게 활용할 수 있는 톱레벨 함수가 있음</li><li>두 값을 단순하게 비교하기만 한다면, compareValues 함수를 다움과 같이 활용</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> surname: String</span><br><span class="line">): Comparable&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">User</span>)</span></span>: <span class="built_in">Int</span> = compareValues(surname, other.surname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수가 다음 값을 리턴해야 한다는 것을 기억</p><ul><li>0: 리시버와 other 가 같온 경우</li><li>양수: 리시버가 other 보다 큰 경우</li><li>음수: 리시버가 other 보다 작은 경우</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 41: hashCode의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/</guid>
      <pubDate>Thu, 05 Jan 2023 12:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-41-hashCode
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-41-hashCode의-규약을-지켜라"><a href="#아이템-41-hashCode의-규약을-지켜라" class="headerlink" title="아이템 41: hashCode의 규약을 지켜라"></a>아이템 41: hashCode의 규약을 지켜라</h2><h3 id="해시-테이블"><a href="#해시-테이블" class="headerlink" title="해시 테이블"></a>해시 테이블</h3><ul><li>Map, Set : 컬렉션에 요소를 빠르게 추가하고 컬렉션에서 요소를 빠르게 추출해야한다고 할때 사용할 수 있는 자료구조</li><li>Map, Set은 중복 비허용</li><li>성능을 좋게 만드는 해결 방법 해시 테이블</li><li>해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요하고 이 함수를 해시함수라고한다</li><li>같은 요소라면 같은 숫자를 리턴한다.</li></ul><p>해시함수의 특징</p><ul><li>빠르다</li><li>충돌이 적다</li></ul><p>해시함수 </p><ul><li>해시함수는 각각의 요소에 특정한 숫자를 할당하고 이를 기반으로 요소를 다른 버킷에 넣는다.</li><li>해시 함수의 기본적인 조건에 의해서 같은 요소는 항상 동일한 버킷에 넣게 된다.</li></ul><p>코틀린은 해시 코드를 만들 때 hashCode 함수를 이용한다.</p><h3 id="가변성과-관련된-문제"><a href="#가변성과-관련된-문제" class="headerlink" title="가변성과 관련된 문제"></a>가변성과 관련된 문제</h3><ul><li>요소를 추가될 때만 해시 코드를 계산</li><li>요소가 변경되어도 해시코드는 계산되지 않으며, 배킷 재배치도 이뤄지지 않는다. 따라서 Set과 Map의 키로 mutable 요소를 사용하면 안되고 사용하더라도 요소를 변경해서는 안된다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FullName</span></span>(</span><br><span class="line">   <span class="keyword">var</span> name: String,</span><br><span class="line">   <span class="keyword">var</span> surname: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = FullName(<span class="string">&quot;Maja&quot;</span>, <span class="string">&quot;Markiewicz&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> s = mutableSetOf&lt;FullName&gt;()</span><br><span class="line">s.add(person)</span><br><span class="line">person.surname = <span class="string">&quot;Moskała&quot;</span></span><br><span class="line"></span><br><span class="line">print(person) <span class="comment">// FullName(name=Maja, surname=Moskała)</span></span><br><span class="line">print(person <span class="keyword">in</span> s) <span class="comment">// false</span></span><br><span class="line">print(s.first() == person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="hashCode의-규약"><a href="#hashCode의-규약" class="headerlink" title="hashCode의 규약"></a>hashCode의 규약</h3><ul><li>어떤 객체를 변경하지 않았다면 hashCode는 여러 번 호출해도 그 결과가 항상 같아야 한다</li><li>eqauls 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 한다</li><li></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 40: equals 의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</guid>
      <pubDate>Wed, 04 Jan 2023 12:52:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-40-equals-의
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-40-equals-의-규약을-지켜라"><a href="#아이템-40-equals-의-규약을-지켜라" class="headerlink" title="아이템 40: equals 의 규약을 지켜라"></a>아이템 40: equals 의 규약을 지켜라</h2><h3 id="동등성"><a href="#동등성" class="headerlink" title="동등성"></a>동등성</h3><p>코틀린에는 두 가지 종류의 동등성(equality)이 있다.</p><ul><li>구조적 동등성(structural equality) : equals 메서드와 이를 기반으로 만들어진 &#x3D;&#x3D; 연산자(!&#x3D; 포함)로 확인하는 동등성이다.</li><li>레퍼런스적 동등성(referential equality**) : &#x3D;&#x3D;&#x3D; 연산자(!&#x3D;&#x3D; 포함)로 확인하는 동등성이다.</li></ul><p>equals 는 모든 클래스의 슈퍼클래스인 Any 에 구현되어 있으므로, 모든 객체에서 사용할 수 있다.<br>다만, 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않는다.</p><p>“”.equals(1) 은 가능하지만, “” &#x3D;&#x3D; 1 은 불가능하다.</p><p>같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있다.</p><h3 id="equals-가-필요한-이유"><a href="#equals-가-필요한-이유" class="headerlink" title="equals 가 필요한 이유"></a>equals 가 필요한 이유</h3><p>Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 &#x3D;&#x3D;&#x3D; 처럼 두 인스턴스가 완전히 같은 객체인지를 비교한다.</p><p>이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미한다.</p><p>data 한정자를 붙여서 데이터 클래스로 정의하면, 두 객체가 기본 생성자와 프로퍼티가 같다면 동등성으로 동작한다.</p><p>모든 프로퍼티가 아닌 일부 프로퍼티로만 동등성을 비교 할때는 데이터 클래스에서 동등성 비교 대상이 아닌 프로퍼티를 생성자 프로퍼티가 아닌 클래스 프로퍼티로 선언하면 된다.</p><p>기본 생성자에 선언되지 않은 프로퍼티는 copy() 메서드로 복사되지 않는다.</p><h3 id="equals-를-직접-구현해야-하는-경우"><a href="#equals-를-직접-구현해야-하는-경우" class="headerlink" title="equals 를 직접 구현해야 하는 경우"></a>equals 를 직접 구현해야 하는 경우</h3><ul><li>기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우</li><li>일부 프로퍼티만으로 비교해야 하는 경우</li><li>data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우</li></ul><p>equals 구현하기</p><ul><li>특별한 이유가 없는 이상, 직접 equals 를 구현하는 것은 좋지 않다.</li><li>만약 상속을 한다면, 서브클래스에서 equals 가 작동하는 방식을 변경하면 안 된다는 것을 기억하자.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</guid>
      <pubDate>Tue, 03 Jan 2023 13:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-39-태그-클래스보다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-39-태그-클래스보다는-클래스-계층을-사용하라"><a href="#아이템-39-태그-클래스보다는-클래스-계층을-사용하라" class="headerlink" title="아이템 39: 태그 클래스보다는 클래스 계층을 사용하라"></a>아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</h2><p>상수(constant) 모드를 가진 클래스를 많이 볼수 있다. 이러한 상수 모드를 태그(tag)라고 부르며 태크를 포함한 클래스를 태그 클래스라고 부른다.</p><p>태그 클래스는 서로다른 책임을 한 클래스에 태그로 넣는 문제를 가진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value: T? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> matcher: Matcher</span><br><span class="line">)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>?)</span></span> = <span class="keyword">when</span>(matcher) &#123;</span><br><span class="line">        Matcher.EQUAL -&gt; value == <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.NOT_EQUAL -&gt; value != <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.LIST_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">        Matcher.LIST_NOT_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">        EQUAL,</span><br><span class="line">        NOT_EQUAL,</span><br><span class="line">        LIST_EMPTY,</span><br><span class="line">        LIST_NOT_EMPTY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">equal</span><span class="params">(value: <span class="type">T</span>)</span></span> = </span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEqual</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.NOT_EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">emptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_EMPTY)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEmptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_NOT_EMPTY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>태그 클래스의 단점</p><ul><li>한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가된다.</li><li>여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있다. (value는 LIST_EMPTY, LIST_NOT_EMPTY일때 사용 안됨)</li><li>요소가 여러 목적을 가지고 요소를 여러 방법으로 설정할 수 있는 경우 상태의 일관성과 정확성을 지키기 어렵다.</li><li>팩토리 메소드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 어렵다.</li></ul><p>코틀린에서는 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용한다. 한 클래스에 여러 모드를 만드는 방법 대신에 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Equal</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value == <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEqual</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value != <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sealed-한정자"><a href="#sealed-한정자" class="headerlink" title="sealed 한정자"></a>sealed 한정자</h3><p>sealed 한정자를 반드시 사용해야 하는 것은 아니다. 대신 abstract 한정자를 사용할 수도 있지만 sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한한다.</p><p>sealed class 의 장점</p><ul><li>외부에서 추가적인 서브클래스를 만들 수 없으므로 타입이 추가되지 않는 것이 보장된다. 따라서 when을 사용할 때 else 브랜치를 만들 필요가 없다.</li><li>위 장점을 이용해 새로운 기능을 쉽게 추가할 수 있으며 when 구문에서 처리하는 것을 잊어버리지 않을 수 있다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> ValueMatcher<span class="type">&lt;T&gt;</span>.<span class="title">reversed</span><span class="params">()</span></span>: ValueMatcher&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.EmptyList -&gt; ValueMatcher.EmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEmptyList -&gt; ValueMatcher.NotEmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.Equal -&gt; ValueMatcher.Equal&lt;T&gt;(value)</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEqual -&gt; ValueMatcher.NotEqual&lt;T&gt;(value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>클래스의 서브 클래스를 제어하려면 sealed 한정자를 사용하고 abstract는 상속과 관련된 설계를 할 때 사용한다.</p><h3 id="태그-클래스와-상태-패턴의-차이"><a href="#태그-클래스와-상태-패턴의-차이" class="headerlink" title="태그 클래스와 상태 패턴의 차이"></a>태그 클래스와 상태 패턴의 차이</h3><p>태그 클래스와 상태 패턴(state pattern)을 혼동하면 안된다. 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkoutState</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepareState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExerciseState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="keyword">object</span> DoneState : WorkoutState()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Exercise&gt;</span>.<span class="title">toStates</span><span class="params">()</span></span>: List&lt;WorkoutState&gt; = </span><br><span class="line">    flatMap &#123; exercise -&gt; </span><br><span class="line">        listOf(PrepareState(exercise), ExerciseState(exercise))</span><br><span class="line">    &#125; + DoneState</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkoutPresenter</span></span>( <span class="comment">/*...*/</span> ) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: WorkoutState = states.first()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차이점</p><ul><li>상태는 더 많은 책임을 가진 클래스이다</li><li>상태는 변경할 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
