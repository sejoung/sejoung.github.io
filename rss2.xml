<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Fri, 20 Jan 2023 06:03:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>1장 사용자 수에 따른 규모 확장성</title>
      <link>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/</guid>
      <pubDate>Thu, 19 Jan 2023 02:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="1장-사용자-수에-따른-규모-확장성"><a href="#1장-사용자-수에-따른-규모-확장성" class="headerlink" title="1장 사용자 수에 따른 규모 확장성"></a>1장 사용자 수에 따른 규모 확장성</h2><ul><li><p>단일 서버 -&gt; 데이터베이스 분리 -&gt; 수평적 확장 vs 수직적 확장</p></li><li><p>수직적 확장 : 스케일업</p><ul><li>단점 : 한계가 존재함, 장애 복구에 대한 방안이나 다중화 방안을 제시하지 않는다.</li></ul></li><li><p>수평적 확장 : 스케일 아웃</p></li><li><p>로드벨런서 : L2(Data link 계층을 사용, Mac주소 기반 부하 분산), L3(Network 계층을 사용, IP주소 기반 부하 분산),<br>L4(Transport 계층을 사용, Port 기반 부하 분산), L7(Application 계층을 사용, 요청(URL) 기반 부하 분산)</p></li><li><p>데이터 베이스 다중화 : master - slave 방식</p><ul><li>쓰기는 마스터 읽기는 슬레이브로 부하 분산이되어 성능이 좋아진다.</li><li>분산저장해서 하나가 파괴되어도 다른 DB로 작업 할수 있어서 가용성과 안정성이 높아진다.</li></ul></li><li><p>캐쉬 : 값비싼 연산 결과를 메모리안에 두고 빨리 처리 될수 있도록 하는 저장소이다. </p><ul><li>캐쉬 계층 : 데이터가 잠시 보관 되는 곳으로 DB 보다 훨씬 빠르다.</li><li>읽기 주도형 캐쉬 전략(read-through caching strategy) </li><li>데이터 갱신은 자주 일어나지 않지만 참조가 빈번이 일어날때</li><li>영속적으로 보관할때는 캐시가 좋지는 않다.</li><li>캐시에 보관된 데이터는 어떻게 만료되는지 고려 해야 된다.</li><li>일관성은 어떻게 유지해야 되는지 고려해야 된다.</li><li>장애에는 어떻게 대응 해야 되는지 고려해야 된다</li><li>캐시 메모리의 크기를 고려해야 된다.</li><li>데이터 방출 정책이 무엇인지 고려해야 된다. LRU, LFU, FIFO</li></ul></li><li><p>CDN : 정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크</p><ul><li>비용 문제를 고려하자</li><li>적절한 만료 시한 설정</li><li>CDN 장애에 대한 대처 방안</li></ul></li><li><p>무상태(stateless) 웹 계층</p><ul><li>상태 정보 의존적인 아키텍처(세션 데이터 사용)</li><li>무상태 아키텍처 : 상태 정보는 공유 저장소로 부터 가지고 온다.</li></ul></li><li><p>데이터 센터</p><ul><li>장애가 없는 상황에서 사용자는 지리적으로 가까운 데이터 센터를 이용한다 (geoDNS-routing, geo-routing)</li><li>다중 데이터 센터 아키텍처 <ul><li>트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법</li><li>데이터 동기화 : 데이터 센터마다 별도의 데이터 베이스를 사용하는 상황</li><li>테스트 와 배포 : 여러 위치에 배포하고 테스트 해야 되는 상황</li></ul></li></ul></li><li><p>메시지 큐 : 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트</p><ul><li>생산자&#x2F;소비자</li><li>서버간의 느슨한 결합</li></ul></li><li><p>로그, 메트릭 그리고 자동화</p><ul><li>로그 : 에러 로그를 모니터링하는것이 중요하다.</li><li>메트릭 : 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 언을 수도 있고 시스템의 현재 상태를 손쉽게 파악할수 있다.<ul><li>호스트 단위 메트릭</li><li>종합 메트릭</li><li>핵심 비지니스 메트릭</li></ul></li><li>자동화 : 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 사용해야 된다.</li></ul></li><li><p>데이터 베이스의 규모확장</p><ul><li>수직적 확장 : 스케일업, 기존 서버에 더많은 또는 고성능의 자원을 증설하는 방법<ul><li>하드웨어에는 한계가 있다.</li><li>SPOF 로 인한 위험성이 크다</li><li>비용이 많이 든다.</li></ul></li><li>수평적 확장 : 수평적 확장은 샤딩이라고도 부르는데 더 많은 서버를 추가함으로써 성능을 향상시킬수 있다.<ul><li>대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술이다.</li><li>샤딩 전략<ul><li>가장 중요한건 샤딩 키(파티션 키)<ul><li>데이터 재샤딩</li><li>유명인사 문제</li><li>조인과 비정규화</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li><li><a href="https://martinfowler.com/eaaCatalog/">Catalog of Patterns of Enterprise Application Architecture</a></li><li><a href="https://www.youtube.com/watch?v=cflK7FTGPlg">[우아한테크세미나] 200507 우아한CRUD by 정상혁&amp;이명현님</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-19-system_design_interview_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql (mariaDB) HikariCP 성능 튜닝</title>
      <link>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/</guid>
      <pubDate>Mon, 09 Jan 2023 09:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mysql-mariaDB-HikariCP-성능-튜닝&quot;&gt;&lt;a href=&quot;#mysql-mariaDB-HikariCP-성능-튜닝&quot; class=&quot;headerlink&quot; title=&quot;mysql (mariaDB) HikariCP 성능 튜닝&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mysql-mariaDB-HikariCP-성능-튜닝"><a href="#mysql-mariaDB-HikariCP-성능-튜닝" class="headerlink" title="mysql (mariaDB) HikariCP 성능 튜닝"></a>mysql (mariaDB) HikariCP 성능 튜닝</h1><h2 id="HikariCP-설정"><a href="#HikariCP-설정" class="headerlink" title="HikariCP 설정"></a>HikariCP 설정</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">hikari:</span></span><br><span class="line">        <span class="attr">data-source-properties:</span></span><br><span class="line">            <span class="attr">cachePrepStmts:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">prepStmtCacheSize:</span> <span class="number">250</span></span><br><span class="line">            <span class="attr">prepStmtCacheSqlLimit:</span> <span class="number">2048</span></span><br><span class="line">            <span class="attr">useServerPrepStmts:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">useLocalSessionState:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">cacheResultSetMetadata:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">cacheServerConfiguration:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">elideSetAutoCommits:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">maintainTimeStats:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration">HikariCP MySQL-Configuration</a></li><li><a href="https://cdn.oreillystatic.com/en/assets/1/event/21/Connector_J%20Performance%20Gems%20Presentation.pdf">Connector&#x2F;J Performance Gems slide</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-09-mysql_performance_tuning_HikariCP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql (mariaDB) 성능 튜닝 (performance tuning)</title>
      <link>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/</guid>
      <pubDate>Sat, 07 Jan 2023 02:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mysql-mariaDB-성능-튜닝-performance-tuning&quot;&gt;&lt;a href=&quot;#mysql-mariaDB-성능-튜닝-performance-tuning&quot; class=&quot;headerlink&quot; title=&quot;mysql (mariaDB) 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mysql-mariaDB-성능-튜닝-performance-tuning"><a href="#mysql-mariaDB-성능-튜닝-performance-tuning" class="headerlink" title="mysql (mariaDB) 성능 튜닝 (performance tuning)"></a>mysql (mariaDB) 성능 튜닝 (performance tuning)</h1><h2 id="DB-server-성능-튜닝"><a href="#DB-server-성능-튜닝" class="headerlink" title="DB server 성능 튜닝"></a>DB server 성능 튜닝</h2><ul><li>max_connections : 데이터베이스 서버에 대한 최대 동시 연결 수를 제어합니다.<br>이 값을 너무 낮게 설정하면 연결 오류가 발생할 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용하여 전체 성능이 저하될 수 있습니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size(MyISAM 전용 설정) : 인덱스 블록에 사용되는 버퍼의 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 더 많은 디스크 읽기가 발생하고 성능이 느려질 수 있으며, 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.<br>이 값을 너무 낮게 설정하면 연결 오류가 발생할 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용하여 전체 성능이 저하될 수 있습니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%key_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>query_cache_size : SELECT 쿼리 결과를 저장하는 데 사용되는 캐시 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 캐시 미스가 더 자주 발생하고 성능이 느려질 수 있으며, 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.</p></li><li><p>innodb_buffer_pool_size : InnoDB 스토리지 엔진에서 사용하는 버퍼 풀의 크기를 제어합니다.<br>이 값을 너무 낮게 설정하면 디스크 읽기 빈도가 높아지고 성능이 저하될 수 있으며, 너무 높게 설정하면 메모리를 너무 많이 사용할 수 있습니다.</p></li><li><p>join_buffer_size : 적절한 인덱스가 없는 조인에 사용되는 버퍼의 크기를 제어합니다. (Block Nested-Loop Join Algorithm)<br>이 값을 너무 낮게 설정하면 이러한 조인 유형의 성능이 느려질 수 있고 너무 높게 설정하면 너무 많은 메모리를 사용할 수 있습니다.</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%join_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>sort_buffer_size : MySQL에서 인덱스 없이 정렬을 수행할 경우 디스크 버퍼에서 데이터를 정렬한다. (Block Nested-Loop Join Algorithm)<br>보통 MySQL에서 부하가 많이 생기는 작업이 정렬인데, sort_buffer_size를 통해 정렬에 얼마만큼의 메모리 공간을 할당할지 정할 수 있다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>innodb_flush_log_at_trx_commit : 기본값인 1로 설정하면 각 트랜잭션 커밋에서 로그 버퍼가 플러시됩니다.<br>이 설정은 데이터베이스 ACID 를 유지하는 데 도움이 됩니다.준수합니다. 기본 설정인 1을 유지하는 것이 좋습니다.<br>기본값이 아닌 값(0 또는 2)으로 변경하면 innodb_flush_log_at_trx_commitDML(데이터 조작 언어) 대기 시간을 줄이는 데 도움이 되지만 로그 레코드의 내구성이 저하됩니다.<br>이러한 내구성 부족으로 인해 데이터베이스 ACID는 비준수 상태가 됩니다.</p></li><li><p>connect_timeout : mysqld 서버가 접속실패로 응답하기 전에 연결 패킷을 기다리는 시간(초). 기본값은 10 초입니다.<br>connect_timeout값을 늘리면 클라이언트에서 Lost Connection 오류가 자주 발생하는 경우 도움이 될 수 있습니다.<br><code>Lost connection to MySQL server at &#39;XXX&#39;, system error: errno.</code></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%connect_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>lock_wait_timeout : 메타 데이터 잠금 획득 시도에 대한 제한 시간 (초)을 지정합니다. 허용되는 값의 범위는 1-31536000 (1 년)입니다. 기본값은 31536000입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%lock_wait_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>net_read_timeout : 네트워크 접속을 통해서 클라이언트가 서버에서 데이터를 받을 때 abort(중지)될때까지 기다리는 시간입니다. 여기에서 네트워크 접속이란 TCP&#x2F;IP 접속을 얘기합니다.<br>Unix socket file(로컬 서버에서의 접속), named pipe, 공유된 메모리를 통해 접속된 연결은 아닙니다. 기본값은 30초 입니다. 서버가 클라이언트로부터 읽혀질때 net_read_timeout값은 abort(중지)를 제어합니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%net_read_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>net_write_timeout : 네트워크 접속을 통해서 클라이언트가 서버에 데이터 쓸 때 abort(중지)될때까지 기다리는 시간입니다. 여기에서 네트워크 접속이란 TCP&#x2F;IP 접속을 얘기합니다.<br>Unix socket file(로컬 서버에서의 접속), named pipe, 공유된 메모리를 통해 접속된 연결은 아닙니다. 기본값은 60초 입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%net_write_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>wait_timeout : 비 대화식(non interactive) 연결에서 서버가 활동을 닫기 전에 서버가 대기하는 시간 (초)입니다.<br>스레드 시작시 wait_timeout 값은 클라이언트 유형에 따라 전역 wait_timeout 값 또는 전역 interactive_timeout 값에서 초기화됩니다(CLIENT_INTERACTIVE 연결 옵션으로 mysql_real_connect()에 정의 됨).<br>interactive_timeout도 참조합니다. 기본값은 28800초 입니다. 클라이언트의 최대 연결시간  최대 연결시간</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%wait_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>interactive_timeout : 서버가 대화식 연결을 닫기 전에 활동을 기다리는 시간 (초)입니다.<br>대화 형 클라이언트는 mysql_real_connect ()에 CLIENT_INTERACTIVE 옵션을 사용하는 클라이언트로 정의됩니다. wait_timeout도 참조하십시오. 기본값은 28800초 입니다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%interactive_timeout%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>table_lock_wait_timeout : 테이블 락을 중단하기까지 대기하는 시간</p></li><li><p>thread_pool_idle_timeout : 마리아DB파라미터 입니다. 기본값은 60초입니다. idle 상태인 쓰레드를 정리하기 전에 대기하는 시간(초)입니다.</p></li></ul><h3 id="Aurora-MySQL-버전-3-파라미터"><a href="#Aurora-MySQL-버전-3-파라미터" class="headerlink" title="Aurora MySQL 버전 3 파라미터"></a>Aurora MySQL 버전 3 파라미터</h3><ul><li>innodb_flush_log_at_trx_commit : 무조건 1로 셋팅 되어 있다.</li><li>max_connections : 인스턴스 사이즈에 의해서 계산된다.</li><li>query_cache_size : 수식에 의해 결정 된다.</li><li>innodb_buffer_pool_size : 수식에 의해 결정 된다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Performance.html">Managing performance and scaling for Amazon Aurora MySQL</a></li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.BestPractices.html#AuroraMySQL.BestPractices.Avoiding">AuroraMySQL BestPractices</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Reference.html">AuroraMySQL.Reference</a></li><li><a href="https://myinfrabox.tistory.com/192">MySQL Timeout 종류</a></li><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bomyzzang&logNo=221550485417">MySQL 서버의 time out 설정</a></li><li><a href="https://lee-seul.github.io/backend/2019/03/09/mysql-setting.html">알아두면 좋은 MySQL 설정들</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">Nested-Loop Join Algorithms</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html">mysql Server System Variables</a></li><li><a href="https://aws.amazon.com/ko/rds/instance-types/">Amazon RDS 인스턴스 유형</a></li><li><a href="http://small-dbtalk.blogspot.com/2015/01/lockwaittimeout-default_9.html">lock_wait_timeout 의 Default 값이 불러일으키는 문제점</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html">Server Status Variables</a></li><li><a href="http://www.ezmeta.co.kr/page/?p=3025">MySQL 기본적인 모니터링 방법과 Connection과 Memory 튜닝 방법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-07-mysql_performance_tuning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 42: compareTo의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/</guid>
      <pubDate>Fri, 06 Jan 2023 13:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-42-compareT
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-42-compareTo의-규약을-지켜라"><a href="#아이템-42-compareTo의-규약을-지켜라" class="headerlink" title="아이템 42: compareTo의 규약을 지켜라"></a>아이템 42: compareTo의 규약을 지켜라</h2><p>compareTo는 Any에 있는 메소드가 아니라 부등식으로 변환되는 연산자이다.</p><ul><li>비대칭적 동작: a≥b 이고 b≥a 라면 a&#x3D;&#x3D;b이다.</li><li>연속적 동작: a≥b 이고 b≥c라면 a≥c이다.</li><li>코넥스적 동작(connex relation): a≥b 또는 b≥a 중에 적어도 하나는 반드시 항상 true여야 한다. 관계가 없다면 고전적 정렬 알고리즘(퀵, 삽입)을 사용할 수 없고, 위상 정렬만 사용할 수 있다.</li></ul><h3 id="compareTo를-따로-정의해야-할까"><a href="#compareTo를-따로-정의해야-할까" class="headerlink" title="compareTo를 따로 정의해야 할까?"></a>compareTo를 따로 정의해야 할까?</h3><p>일반적으로는 거의 없다. sortedBy(단일 키), sortedWith(여러 키)로 정렬할 수 있기 때문이다.</p><h3 id="compareTo-구현하기"><a href="#compareTo-구현하기" class="headerlink" title="compareTo 구현하기"></a>compareTo 구현하기</h3><ul><li>compareTo를 구현할 때 유용하게 활용할 수 있는 톱레벨 함수가 있음</li><li>두 값을 단순하게 비교하기만 한다면, compareValues 함수를 다움과 같이 활용</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> surname: String</span><br><span class="line">): Comparable&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">User</span>)</span></span>: <span class="built_in">Int</span> = compareValues(surname, other.surname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수가 다음 값을 리턴해야 한다는 것을 기억</p><ul><li>0: 리시버와 other 가 같온 경우</li><li>양수: 리시버가 other 보다 큰 경우</li><li>음수: 리시버가 other 보다 작은 경우</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-06-effective_kotlin_item_42/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 41: hashCode의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/</guid>
      <pubDate>Thu, 05 Jan 2023 12:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-41-hashCode
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-41-hashCode의-규약을-지켜라"><a href="#아이템-41-hashCode의-규약을-지켜라" class="headerlink" title="아이템 41: hashCode의 규약을 지켜라"></a>아이템 41: hashCode의 규약을 지켜라</h2><h3 id="해시-테이블"><a href="#해시-테이블" class="headerlink" title="해시 테이블"></a>해시 테이블</h3><ul><li>Map, Set : 컬렉션에 요소를 빠르게 추가하고 컬렉션에서 요소를 빠르게 추출해야한다고 할때 사용할 수 있는 자료구조</li><li>Map, Set은 중복 비허용</li><li>성능을 좋게 만드는 해결 방법 해시 테이블</li><li>해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요하고 이 함수를 해시함수라고한다</li><li>같은 요소라면 같은 숫자를 리턴한다.</li></ul><p>해시함수의 특징</p><ul><li>빠르다</li><li>충돌이 적다</li></ul><p>해시함수 </p><ul><li>해시함수는 각각의 요소에 특정한 숫자를 할당하고 이를 기반으로 요소를 다른 버킷에 넣는다.</li><li>해시 함수의 기본적인 조건에 의해서 같은 요소는 항상 동일한 버킷에 넣게 된다.</li></ul><p>코틀린은 해시 코드를 만들 때 hashCode 함수를 이용한다.</p><h3 id="가변성과-관련된-문제"><a href="#가변성과-관련된-문제" class="headerlink" title="가변성과 관련된 문제"></a>가변성과 관련된 문제</h3><ul><li>요소를 추가될 때만 해시 코드를 계산</li><li>요소가 변경되어도 해시코드는 계산되지 않으며, 배킷 재배치도 이뤄지지 않는다. 따라서 Set과 Map의 키로 mutable 요소를 사용하면 안되고 사용하더라도 요소를 변경해서는 안된다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FullName</span></span>(</span><br><span class="line">   <span class="keyword">var</span> name: String,</span><br><span class="line">   <span class="keyword">var</span> surname: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = FullName(<span class="string">&quot;Maja&quot;</span>, <span class="string">&quot;Markiewicz&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> s = mutableSetOf&lt;FullName&gt;()</span><br><span class="line">s.add(person)</span><br><span class="line">person.surname = <span class="string">&quot;Moskała&quot;</span></span><br><span class="line"></span><br><span class="line">print(person) <span class="comment">// FullName(name=Maja, surname=Moskała)</span></span><br><span class="line">print(person <span class="keyword">in</span> s) <span class="comment">// false</span></span><br><span class="line">print(s.first() == person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="hashCode의-규약"><a href="#hashCode의-규약" class="headerlink" title="hashCode의 규약"></a>hashCode의 규약</h3><ul><li>어떤 객체를 변경하지 않았다면 hashCode는 여러 번 호출해도 그 결과가 항상 같아야 한다</li><li>eqauls 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 한다</li><li></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-05-effective_kotlin_item_41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 40: equals 의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</guid>
      <pubDate>Wed, 04 Jan 2023 12:52:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-40-equals-의
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-40-equals-의-규약을-지켜라"><a href="#아이템-40-equals-의-규약을-지켜라" class="headerlink" title="아이템 40: equals 의 규약을 지켜라"></a>아이템 40: equals 의 규약을 지켜라</h2><h3 id="동등성"><a href="#동등성" class="headerlink" title="동등성"></a>동등성</h3><p>코틀린에는 두 가지 종류의 동등성(equality)이 있다.</p><ul><li>구조적 동등성(structural equality) : equals 메서드와 이를 기반으로 만들어진 &#x3D;&#x3D; 연산자(!&#x3D; 포함)로 확인하는 동등성이다.</li><li>레퍼런스적 동등성(referential equality**) : &#x3D;&#x3D;&#x3D; 연산자(!&#x3D;&#x3D; 포함)로 확인하는 동등성이다.</li></ul><p>equals 는 모든 클래스의 슈퍼클래스인 Any 에 구현되어 있으므로, 모든 객체에서 사용할 수 있다.<br>다만, 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않는다.</p><p>“”.equals(1) 은 가능하지만, “” &#x3D;&#x3D; 1 은 불가능하다.</p><p>같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있다.</p><h3 id="equals-가-필요한-이유"><a href="#equals-가-필요한-이유" class="headerlink" title="equals 가 필요한 이유"></a>equals 가 필요한 이유</h3><p>Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 &#x3D;&#x3D;&#x3D; 처럼 두 인스턴스가 완전히 같은 객체인지를 비교한다.</p><p>이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미한다.</p><p>data 한정자를 붙여서 데이터 클래스로 정의하면, 두 객체가 기본 생성자와 프로퍼티가 같다면 동등성으로 동작한다.</p><p>모든 프로퍼티가 아닌 일부 프로퍼티로만 동등성을 비교 할때는 데이터 클래스에서 동등성 비교 대상이 아닌 프로퍼티를 생성자 프로퍼티가 아닌 클래스 프로퍼티로 선언하면 된다.</p><p>기본 생성자에 선언되지 않은 프로퍼티는 copy() 메서드로 복사되지 않는다.</p><h3 id="equals-를-직접-구현해야-하는-경우"><a href="#equals-를-직접-구현해야-하는-경우" class="headerlink" title="equals 를 직접 구현해야 하는 경우"></a>equals 를 직접 구현해야 하는 경우</h3><ul><li>기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우</li><li>일부 프로퍼티만으로 비교해야 하는 경우</li><li>data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우</li></ul><p>equals 구현하기</p><ul><li>특별한 이유가 없는 이상, 직접 equals 를 구현하는 것은 좋지 않다.</li><li>만약 상속을 한다면, 서브클래스에서 equals 가 작동하는 방식을 변경하면 안 된다는 것을 기억하자.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</guid>
      <pubDate>Tue, 03 Jan 2023 13:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-39-태그-클래스보다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-39-태그-클래스보다는-클래스-계층을-사용하라"><a href="#아이템-39-태그-클래스보다는-클래스-계층을-사용하라" class="headerlink" title="아이템 39: 태그 클래스보다는 클래스 계층을 사용하라"></a>아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</h2><p>상수(constant) 모드를 가진 클래스를 많이 볼수 있다. 이러한 상수 모드를 태그(tag)라고 부르며 태크를 포함한 클래스를 태그 클래스라고 부른다.</p><p>태그 클래스는 서로다른 책임을 한 클래스에 태그로 넣는 문제를 가진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value: T? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> matcher: Matcher</span><br><span class="line">)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>?)</span></span> = <span class="keyword">when</span>(matcher) &#123;</span><br><span class="line">        Matcher.EQUAL -&gt; value == <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.NOT_EQUAL -&gt; value != <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.LIST_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">        Matcher.LIST_NOT_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">        EQUAL,</span><br><span class="line">        NOT_EQUAL,</span><br><span class="line">        LIST_EMPTY,</span><br><span class="line">        LIST_NOT_EMPTY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">equal</span><span class="params">(value: <span class="type">T</span>)</span></span> = </span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEqual</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.NOT_EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">emptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_EMPTY)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEmptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_NOT_EMPTY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>태그 클래스의 단점</p><ul><li>한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가된다.</li><li>여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있다. (value는 LIST_EMPTY, LIST_NOT_EMPTY일때 사용 안됨)</li><li>요소가 여러 목적을 가지고 요소를 여러 방법으로 설정할 수 있는 경우 상태의 일관성과 정확성을 지키기 어렵다.</li><li>팩토리 메소드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 어렵다.</li></ul><p>코틀린에서는 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용한다. 한 클래스에 여러 모드를 만드는 방법 대신에 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Equal</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value == <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEqual</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value != <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sealed-한정자"><a href="#sealed-한정자" class="headerlink" title="sealed 한정자"></a>sealed 한정자</h3><p>sealed 한정자를 반드시 사용해야 하는 것은 아니다. 대신 abstract 한정자를 사용할 수도 있지만 sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한한다.</p><p>sealed class 의 장점</p><ul><li>외부에서 추가적인 서브클래스를 만들 수 없으므로 타입이 추가되지 않는 것이 보장된다. 따라서 when을 사용할 때 else 브랜치를 만들 필요가 없다.</li><li>위 장점을 이용해 새로운 기능을 쉽게 추가할 수 있으며 when 구문에서 처리하는 것을 잊어버리지 않을 수 있다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> ValueMatcher<span class="type">&lt;T&gt;</span>.<span class="title">reversed</span><span class="params">()</span></span>: ValueMatcher&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.EmptyList -&gt; ValueMatcher.EmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEmptyList -&gt; ValueMatcher.NotEmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.Equal -&gt; ValueMatcher.Equal&lt;T&gt;(value)</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEqual -&gt; ValueMatcher.NotEqual&lt;T&gt;(value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>클래스의 서브 클래스를 제어하려면 sealed 한정자를 사용하고 abstract는 상속과 관련된 설계를 할 때 사용한다.</p><h3 id="태그-클래스와-상태-패턴의-차이"><a href="#태그-클래스와-상태-패턴의-차이" class="headerlink" title="태그 클래스와 상태 패턴의 차이"></a>태그 클래스와 상태 패턴의 차이</h3><p>태그 클래스와 상태 패턴(state pattern)을 혼동하면 안된다. 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkoutState</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepareState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExerciseState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="keyword">object</span> DoneState : WorkoutState()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Exercise&gt;</span>.<span class="title">toStates</span><span class="params">()</span></span>: List&lt;WorkoutState&gt; = </span><br><span class="line">    flatMap &#123; exercise -&gt; </span><br><span class="line">        listOf(PrepareState(exercise), ExerciseState(exercise))</span><br><span class="line">    &#125; + DoneState</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkoutPresenter</span></span>( <span class="comment">/*...*/</span> ) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: WorkoutState = states.first()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차이점</p><ul><li>상태는 더 많은 책임을 가진 클래스이다</li><li>상태는 변경할 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/</guid>
      <pubDate>Tue, 03 Jan 2023 12:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-38-연산-또는-액션
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라"><a href="#아이템-38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라" class="headerlink" title="아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라"></a>아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라</h2><p>대부분의 프로그래밍 언어에서는 함수 타입이 없다. 그래서 액션을 전달할때 메서드가 하나만 있는 인터페이스를 전달한다<br>이러한 인터페이스를 SAM(Single-Abstract Method)이라 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clicked</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClick</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setOnClickListener(<span class="keyword">object</span> : OnClick &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clicked</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>파라미터 전달 방법</p><ul><li><p>람다 표현식 또는 익명 함수로 전달</p></li><li><p>함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달</p></li><li><p>선언된 함수 타입을 구현한 객체로 전달</p></li></ul><p>SAM의 장점이 아규먼트에 이름이 붙어있다고 말하는 경우도 있지만, type alias를 이용해 함수 타입도 이름을 붙여 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Onclick = (View) -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="keyword">typealias</span> OnClick = (view: View) -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>람다 표현식을 사용할 때는 아규먼트 분해(destructure argument)도 사용할 수 있다.</p><h3 id="언제-SAM을-사용해야-할까"><a href="#언제-SAM을-사용해야-할까" class="headerlink" title="언제 SAM을 사용해야 할까?"></a>언제 SAM을 사용해야 할까?</h3><p>코틀린이 아닌 다른 언어에서 사용할 클래스를 설계하는 경우라면 SAM을 사용하는것이 좋다.</p><p>함수 타입으로 사용할떄 단점</p><ul><li>함수 타입으로 만들어진 클래스는 자바에서 type alias과 IDE의 지원을 제대로 받을 수 없다.</li><li>다른 언어(자바 등)에서 코틀린의 함수 타입을 사용하려면 Unit을 명시적으로 리턴하는 함수가 필요하다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 37: 데이터 집합표현에 data 한정자를 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/</guid>
      <pubDate>Mon, 02 Jan 2023 12:47:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-37-데이터-집합표현
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-37-데이터-집합표현에-data-한정자를-사용하라"><a href="#아이템-37-데이터-집합표현에-data-한정자를-사용하라" class="headerlink" title="아이템 37: 데이터 집합표현에 data 한정자를 사용하라"></a>아이템 37: 데이터 집합표현에 data 한정자를 사용하라</h2><p>떄로는 데이터를 한번에 전달해야 되는데 이럴때는 data 한정자를 사용해서 class를 만들면 좋다</p><ul><li>toString</li><li>equals와 hashcode</li><li>copy : immutable 클래스를 만들때 유용하다.</li><li>compoentN : 위치 기반 클래스 해체를 할수 있게 도와준다.</li></ul><h3 id="위치-기반-해체"><a href="#위치-기반-해체" class="headerlink" title="위치 기반 해체"></a>위치 기반 해체</h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ul><li>변수명을 원하는대로 지정할수 있다.</li></ul><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ul><li>위치를 잘못 지정하면 잘못 해체된다.</li><li>해체 할때 생성자의 프로퍼티 명과 동일하게 해주는게 좋다 IDE의 경고 메시지를 받을수 있다.</li><li>값을 하나만 갖는 데이터 클래스는 해체하지 말자 읽는사람에게 혼동을 줄수 있다</li></ul><h3 id="튜플-대신-데이터-클래스-사용하기"><a href="#튜플-대신-데이터-클래스-사용하기" class="headerlink" title="튜플 대신 데이터 클래스 사용하기"></a>튜플 대신 데이터 클래스 사용하기</h3><p>Pair 와 Triple은 코틀린에 마지막 남은 튜플</p><p>데이터 클래스가 튜플보다 항상 나아서 사라짐</p><p>튜플의 사용 용도</p><ul><li>값에 간단하게 이름을 붙일때</li><li>미리 알수 없는 집합을 표현할때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 36: 상속보다는 컴포지션을 사용하라</title>
      <link>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</guid>
      <pubDate>Fri, 30 Dec 2022 02:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-36-상속보다는-컴포
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-36-상속보다는-컴포지션을-사용하라"><a href="#아이템-36-상속보다는-컴포지션을-사용하라" class="headerlink" title="아이템 36: 상속보다는 컴포지션을 사용하라"></a>아이템 36: 상속보다는 컴포지션을 사용하라</h2><p>단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 한다.</p><h3 id="간단한-행위-재사용"><a href="#간단한-행위-재사용" class="headerlink" title="간단한 행위 재사용"></a>간단한 행위 재사용</h3><p>상속의 단점</p><ul><li>상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면 거대한 Base 클래스를 만들게 되고 복잡한 계층 구조가 만들어 진다.</li><li>상속은 클래스의 모든것을 가지고 오게 된다. 불필요한 함수를 갖는 클래스가 만들어진다.</li><li>상속은 이해하기 어렵다.</li></ul><p>컴포지션을 사용하는것은 객체를 프로퍼티로 갖고 함수를 호출하는 형태로 재사용하는 것을 의미 한다.</p><h3 id="모든것을-가지고-올-수밖에-없는-상속"><a href="#모든것을-가지고-올-수밖에-없는-상속" class="headerlink" title="모든것을 가지고 올 수밖에 없는 상속"></a>모든것을 가지고 올 수밖에 없는 상속</h3><p>상속은 슈퍼클래스의 매서드, 제약, 행위 등 모든 것을 가지고 온다. 객체의 계층구조를 나타낼 때 굉장히 좋은 도구</p><p>하지만 그래서 단점도 존재 한다. 필요 없는 매소드는 오버라이딩 해서 처리해야 된다.(인터페이스 분리 원칙의 위배)</p><h3 id="캡슐화를-깨는-상속"><a href="#캡슐화를-깨는-상속" class="headerlink" title="캡슐화를 깨는 상속"></a>캡슐화를 깨는 상속</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt; : <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위임 패턴, 포워딩 매소드 </p><p>위임 패턴을 쉽게 구현할수 있는 문법을 제공해 준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableSet&lt;T&gt; = mutableSetOf()</span><br><span class="line">) : MutableSet&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="오버라이딩-제한하기"><a href="#오버라이딩-제한하기" class="headerlink" title="오버라이딩 제한하기"></a>오버라이딩 제한하기</h3><p>개발자가 상속용으로 설계 되지 않은 클래스의 상속을 막을려면 final 키워드를 붙히면 된다.<br>하지만 어떤 이유에서 상속은 허용하지만 메소드의 오버라이딩만 제한하고 싶을때는 open 키워드를 사용하면 된다.</p><p>open 클래스는 open된 메소드만 오버라이딩 가능하다.</p><p>정리 </p><ul><li><p>컴포지션은 더 안전하다.</p></li><li><p>컴포지션이 더 유연하다.</p></li><li><p>컴포지션이 더 명시적이다.</p></li><li><p>컴포지션은 생각보다 번거롭다.</p></li><li><p>다형성을 가지기 어렵다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스용 유용한 툴</title>
      <link>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</guid>
      <pubDate>Fri, 09 Dec 2022 05:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스용-유용한-툴&quot;&gt;&lt;a href=&quot;#쿠버네티스용-유용한-툴&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스용 유용한 툴&quot;&gt;&lt;/a&gt;쿠버네티스용 유용한 툴&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://minikub
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스용-유용한-툴"><a href="#쿠버네티스용-유용한-툴" class="headerlink" title="쿠버네티스용 유용한 툴"></a>쿠버네티스용 유용한 툴</h1><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a> : 로컬에서 쿠버네티스 테스트용</li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a> : 쿠버네티스 네임스페이스&#x2F;컨텍스트 변경</li><li><a href="https://k9scli.io/">k9s</a> : 쿠버네티스 커멘드라인 gui tool</li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a> : 쿠버네티스 IDE</li><li><a href="https://www.telepresence.io/">telepresence</a> : 원격 개발 환경을 설정할 수 있는 오픈 소스 도구</li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a> : 명령 줄 플러그인</li><li><a href="https://github.com/yannh/kubeconform">kubeconform</a> : 쿠버네티스 yml 검증</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a></li><li><a href="https://k9scli.io/">k9s</a></li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a></li><li><a href="https://www.telepresence.io/">telepresence</a></li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 속성 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</guid>
      <pubDate>Tue, 06 Dec 2022 02:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-속성-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-속성-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 속성 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 속성 테스트&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-속성-테스트"><a href="#쿠버네티스-워크로드-크론잡-속성-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 속성 테스트"></a>쿠버네티스 워크로드 크론잡 속성 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cron-job-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">    <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">failedJobsHistoryLimit:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때 완료되거나 실패한 pod를 정리하는 속성</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때까지 잡이 끝나지 않을때 종료하는 옵션</span></span><br><span class="line">            <span class="comment">## type: Failed 와 reason: DeadlineExceeded 로 표시됨</span></span><br><span class="line">            <span class="attr">activeDeadlineSeconds:</span> <span class="number">200</span></span><br><span class="line">            <span class="comment">## backoffLimit 에 도달하면 작업은 실패한것으로 간주한다.</span></span><br><span class="line">            <span class="attr">backoffLimit:</span> <span class="number">10</span></span><br><span class="line">            <span class="comment">## 병렬실행 관련 옵션</span></span><br><span class="line">            <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">            <span class="comment">## 완료</span></span><br><span class="line">            <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">concurrency-policy-forbid-test</span></span><br><span class="line">                          <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">                          <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;job start&#x27;;sleep 140; echo &#x27;job end&#x27;&quot;</span>]</span><br><span class="line">                    <span class="comment">## 재시작 정책 Never, OnFailure</span></span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create -f cronjob.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</guid>
      <pubDate>Mon, 05 Dec 2022 03:23:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-테스트"><a href="#쿠버네티스-워크로드-크론잡-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 테스트"></a>쿠버네티스 워크로드 크론잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                      <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                      <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobTemplate 아래는 job 과 완전 똑같은 스팩이다. 바로 직전에 테스트 해본 잡을 가지고 테스트 해보면 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/#disqus_thread</comments>
    </item>
    
    <item>
      <title>argo workflows 설치</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</guid>
      <pubDate>Mon, 05 Dec 2022 02:53:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;argo-workflows-설치&quot;&gt;&lt;a href=&quot;#argo-workflows-설치&quot; class=&quot;headerlink&quot; title=&quot;argo workflows 설치&quot;&gt;&lt;/a&gt;argo workflows 설치&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="argo-workflows-설치"><a href="#argo-workflows-설치" class="headerlink" title="argo workflows 설치"></a>argo workflows 설치</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><p><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a><br>최신 릴리즈 버전을 인스톨 한다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create namespace argo</span><br><span class="line">kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v3.3.10/install.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment \</span><br><span class="line">  argo-server \</span><br><span class="line">  --namespace argo \</span><br><span class="line">  --type=&#x27;json&#x27; \</span><br><span class="line">  -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/args&quot;, &quot;value&quot;: [</span><br><span class="line">  &quot;server&quot;,</span><br><span class="line">  &quot;--auth-mode=server&quot;</span><br><span class="line">]&#125;]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>아래처럼 포트 포워딩후에 <a href="https://localhost:2746/">https://localhost:2746/</a> 접속한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argo port-forward deployment/argo-server 2746:2746</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</guid>
      <pubDate>Fri, 02 Dec 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하기 위해
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-잡-테스트"><a href="#쿠버네티스-워크로드-잡-테스트" class="headerlink" title="쿠버네티스 워크로드 잡 테스트"></a>쿠버네티스 워크로드 잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml</span><br></pre></td></tr></table></figure><p>위 처럼 간단하게 테스트 해볼수 있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                  <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                  <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">            <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/concepts/workloads/controllers/job/">kubernetes job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 33: 생성자 대신 팩토리 함수를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-33-생성자-대신-팩토리-함
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-33-생성자-대신-팩토리-함수를-사용하라"><a href="#아이템-33-생성자-대신-팩토리-함수를-사용하라" class="headerlink" title="아이템 33: 생성자 대신 팩토리 함수를 사용하라"></a>아이템 33: 생성자 대신 팩토리 함수를 사용하라</h2><p>생성자 역활을 대신해주는 함수를 팩토리 함수</p><p>팩토리 함수의 장점</p><ul><li>함수의 이름을 붙일수 있다</li><li>함수가 원하는 타입을 리턴할 수 있다</li><li>호출될때 마다 새객체를 만들 필요가 없다</li><li>아직 존재하지 않는 객체를 리턴할 수 있다</li><li>객체 외부에 팩토리 함수를 만들면 가시성을 원하는 대로 조정할수 있다</li><li>팩토리 함수는 인라인으로 만들수 있으며 그 파라미터들을 reified로 만들수 있다</li><li>생성자로 만들기 복잡한 객체도 만들수 있다</li><li>원하는 때에 생성자를 호출할수 있다</li></ul><p>팩토리 함수의 제약</p><p>서브클레스 생성에는 슈퍼클래스 생성자가 필요하기 때문에 서브 클래스를 만들어 낼수 없다.</p><h3 id="Companion-객체-팩토리-함수"><a href="#Companion-객체-팩토리-함수" class="headerlink" title="Companion 객체 팩토리 함수"></a>Companion 객체 팩토리 함수</h3><p>자바의 정적 팩토리 함수</p><p>c++ 이름을 가진 생성자</p><p>많이 사용되는 함수 이름</p><ul><li>from : 파라미터를 하나 받고, 같은 타입의 인스턴스를 하나 리턴하는 타입의 변환 함수</li><li>of : 파라미터를 여러개 받고, 이를 통합하여 인스턴스를 만들어 주는 함수</li><li>valueOf : from 또는 of 와 비슷한 기능을 하면서 의미를 조금 더 쉽게 읽을수 있게 이름을 붙힘 함수</li><li>instance or getInstance : 싱글턴으로 인스턴스 하나를 리턴하는 함수</li><li>createInstance : instance or getInstance 처럼 동작하지만 싱글턴이 적용되지 않아 매번 인스턴스를 새롭게 만드는 함수</li><li>getType : getInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li><li>newType : createInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li></ul><p>추상 Companion 객체 팩토리는 값을 가질수 있다 캐싱을 구현 하거나 테스트를 위한 가짜 객체 생성할수 있다.</p><h3 id="확장-팩토리-함수"><a href="#확장-팩토리-함수" class="headerlink" title="확장 팩토리 함수"></a>확장 팩토리 함수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Tool.Companion.<span class="title">createBigTool</span><span class="params">()</span></span> : BigTool&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>companion 객체가 존재할 때, 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때 사용</li></ul><h3 id="톱레벨-팩토리-함수"><a href="#톱레벨-팩토리-함수" class="headerlink" title="톱레벨 팩토리 함수"></a>톱레벨 팩토리 함수</h3><ul><li>대표적인 예 listOf, setOf, mapOf</li><li>public 톱 레벨 함수는 모든곳에서 사용할 수 있으므로 ide가 제공하는 팁을 복잡하게 만드는 단점</li></ul><h3 id="가짜-생성자"><a href="#가짜-생성자" class="headerlink" title="가짜 생성자"></a>가짜 생성자</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">4</span>) &#123;<span class="string">&quot;User<span class="variable">$it</span>&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">List</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">size:<span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">init</span>: (<span class="type">index</span>:<span class="type">Int</span>)-&gt;<span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; = MutableList(size,<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">invoke</span><span class="params">(size: <span class="type">Int</span>, generator: (<span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span>: Tree &lt;T&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>invoke 연산자를 갖는 companion 객체를 사용할 수도 있는데 추천 하지 않는 방식이다</p><ul><li>인터페이스를 위한 생성자를 만들고 싶을때</li><li>reified 타입 아규먼트를 갖게 하고 싶을때</li></ul><h3 id="팩토리-클래스의-메서드"><a href="#팩토리-클래스의-메서드" class="headerlink" title="팩토리 클래스의 메서드"></a>팩토리 클래스의 메서드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SutudentsFactory</span></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> nextId = <span class="number">0</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">(name:<span class="type">String</span>,surname:<span class="type">String</span> = Student(nextId++,name,surname)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>팩토리 클래스는 프로퍼티를 가질 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-34-기본-생성자에-이름-있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라"><a href="#아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라" class="headerlink" title="아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라"></a>아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</h2><p>기본 생성자 : 객체를 정의하고 생성하는 방법을 지정할때 사용하는 가장 기본적인 방법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> surname: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(<span class="string">&quot;Zola&quot;</span>, <span class="string">&quot;Gianfranco&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="점층적-생성자-패턴-telescoping-constructor-pattern"><a href="#점층적-생성자-패턴-telescoping-constructor-pattern" class="headerlink" title="점층적 생성자 패턴(telescoping constructor pattern)"></a>점층적 생성자 패턴(telescoping constructor pattern)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size: String</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheess: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>, bacon: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size</span><br><span class="line">        <span class="keyword">this</span>.cheess = cheess</span><br><span class="line">        <span class="keyword">this</span>.olives = olives</span><br><span class="line">        <span class="keyword">this</span>.bacon = bacon</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, olives, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String): <span class="keyword">this</span>(size, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>코틀린은 디폴트 아규먼트(default argument)를 사용할 수 있기 때문에 아래처럼 사용할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="빌더-패턴-builder-pattern"><a href="#빌더-패턴-builder-pattern" class="headerlink" title="빌더 패턴(builder pattern)"></a>빌더 패턴(builder pattern)</h3><p>자바에서는 네임드 파라미터(named parameter)와 디폴트 아규먼트(default argument)를 사용할 수 없다. 그래서 빌더 패턴을 사용한다.</p><p>빌더 패턴의 장점</p><ul><li>파라미터에 이름을 가진다.</li><li>파라미터를 원하는 순서대로 지정</li><li>디폴트 값을 지정</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> size: String) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> olives: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setCheese</span><span class="params">(value: <span class="type">Int</span>)</span></span>: Builder = apply &#123;</span><br><span class="line">            cheese = value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = Pizza(size, cheese, olives, bacon)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린은 빌더 패턴을 사용하는것 보다 네임드 파라미터를 사용하는게 좋다.</p><p>값의 의미를 묶어서 지정할때나 특정값을 누적하는 형태로 사용될때 빌더 패턴을 이용하는것이 나을수도 있는데<br>코틀린에서는 DSL 빌더를 이용해서 구현하는것을 더 좋게 본다(?)</p><p>빌더 패턴은 다음과 같은 경우에만 사용</p><ul><li>빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때</li><li>디폴트 아규먼트와 DSL을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API를 설계할 때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-35-복잡한-객체를-생성하기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라"><a href="#아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라" class="headerlink" title="아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라"></a>아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</h2><p>함수 타입의 몇가지 예</p><ul><li>()-&gt;Unit : 아규먼트를 갖지 않고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Unit : Int를 아규먼트로 받고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Int : Int를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int, Int)-&gt;Int : Int 2개를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int)-&gt;()-&gt;Unit : Int를 아규먼트로 받고, 다른 함수를 리턴하는 함수 이때 다른함수는 아규먼트로 아무것도 받지 않고 Unit을 리턴</li><li>(()-&gt;Unit)-&gt;Unit : 다른 함수를 아규먼트로 받고, Unit을 리턴하는 함수</li></ul><p>함수 타입을 만드는 기본적인 방법</p><ul><li>람다 표현식</li><li>익명함수</li><li>함수 레퍼런스</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> plus1: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;a, b -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="title">fun</span><span class="params">(a, b)</span></span> = a + b</span><br><span class="line"><span class="keyword">val</span> plus3: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = ::plus</span><br><span class="line"><span class="keyword">val</span> plus4 = &#123;a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus5 = <span class="function"><span class="title">fun</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>함수타입은 함수를 나타내는 객체를 표현하는 타입</p><p>확장함수(리시버를 가진 함수타입)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">myPlus</span><span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br><span class="line"><span class="keyword">val</span> myPlus: <span class="built_in">Int</span>.(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"><span class="keyword">val</span> myPlus = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 호출 방법</p><ul><li>일반적인 객체처럼 invoke 메서드를 사용</li><li>확장 함수가 아닌 함수처럼 사용</li><li>일반적인 확장함수처럼 사용</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPlus.invoke(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">myPlus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1.</span>myPlus(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 가장 중요한 특징은 this의 참조 대상을 변경할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> surname: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User().apply &#123; </span><br><span class="line">    name = <span class="string">&quot;sejoung&quot;</span></span><br><span class="line">    surname = <span class="string">&quot;kim&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DSL-의-사용"><a href="#DSL-의-사용" class="headerlink" title="DSL 의 사용"></a>DSL 의 사용</h3><ul><li>복잡한 자료구조</li><li>계층적인 구조</li><li>거대한 양의 데이터</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 32: 추상화 규약을 지켜라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</guid>
      <pubDate>Mon, 26 Sep 2022 12:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-32-추상화-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-32-추상화-규약을-지켜라"><a href="#아이템-32-추상화-규약을-지켜라" class="headerlink" title="아이템 32: 추상화 규약을 지켜라"></a>아이템 32: 추상화 규약을 지켜라</h2><p>규약은 개발자들의 단순한 합의 무언가를 할 수 있다는 것이 그것을 해도 괜찮다는 의미는 아니다.</p><h3 id="상속된-규약"><a href="#상속된-규약" class="headerlink" title="상속된 규약"></a>상속된 규약</h3><p>클래스를 상속하거나 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 된다.</p><p>프로그램을 안정적으로 유지하고 싶으면 규약을 지켜야 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 31: 문서로 규약을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</guid>
      <pubDate>Fri, 23 Sep 2022 04:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-31-문서로-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-31-문서로-규약을-정의하라"><a href="#아이템-31-문서로-규약을-정의하라" class="headerlink" title="아이템 31: 문서로 규약을 정의하라"></a>아이템 31: 문서로 규약을 정의하라</h2><p>함수가 무슨일을 하는지 명확하게 설명하고 싶다면 KDoc 주석을 붙혀주는것이 좋다.</p><p>일반적인 문제는 행위가 문서화 되지 않고 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 현재 구현에만 의존하게 된다.<br>이러한 문제는 예상되는 행위를 문서화만 잘해도 해소 된다.</p><h3 id="규약-정의하기"><a href="#규약-정의하기" class="headerlink" title="규약 정의하기"></a>규약 정의하기</h3><ul><li>이름: 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할수 있다.</li><li>주석과 문서: 필요한 모든규약을 적을수 있는 강력한 방법</li><li>타입: 타입은 객체에 대한 많은것을 알려준다. 자주 사용하는 타입의 경우는 타입만 보아도 어떻게 사용하는지 유추할수 있지만 일부타입은 문서를 추가해야된다.</li></ul><h3 id="주석을-써야-될까"><a href="#주석을-써야-될까" class="headerlink" title="주석을 써야 될까?"></a>주석을 써야 될까?</h3><p>자바 커뮤니티 초기에 문학적 프로그래밍(literate programming)이라는 개념이 인기였다.<br>10년이 지난 후에는 주석 없이도 읽을수 있는 코드를 작성해야 하는 프로그래밍 방식으로 바뀜</p><p>극단적인것은 언제나 좋지 않다.</p><h3 id="타입-시스템과-예측"><a href="#타입-시스템과-예측" class="headerlink" title="타입 시스템과 예측"></a>타입 시스템과 예측</h3><p>타입 계층은 객체와 관련된 아주 중요한 정보이다.</p><p>클래스가 어떤 동작을 할것이라 예측 되면 그서브 클래스에도 이를 보장해야된다. - 리스코프 치환의 원칙</p><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>요소, 특히 외부 API를 구현할 때는 규약을 잘정리 해야된다.</p><p>규약은 이름, 문서, 주석, 타입을 통해 구현될수 있다.</p><p>규약은 단순 합의이지만 그 합의를 존중한다면 큰 문제는 없을것이다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
