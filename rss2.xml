<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Fri, 30 Dec 2022 03:01:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>이펙티브 코틀린 아이템 36: 상속보다는 컴포지션을 사용하라</title>
      <link>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</guid>
      <pubDate>Fri, 30 Dec 2022 02:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-36-상속보다는-컴포
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-36-상속보다는-컴포지션을-사용하라"><a href="#아이템-36-상속보다는-컴포지션을-사용하라" class="headerlink" title="아이템 36: 상속보다는 컴포지션을 사용하라"></a>아이템 36: 상속보다는 컴포지션을 사용하라</h2><p>단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 한다.</p><h3 id="간단한-행위-재사용"><a href="#간단한-행위-재사용" class="headerlink" title="간단한 행위 재사용"></a>간단한 행위 재사용</h3><p>상속의 단점</p><ul><li>상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면 거대한 Base 클래스를 만들게 되고 복잡한 계층 구조가 만들어 진다.</li><li>상속은 클래스의 모든것을 가지고 오게 된다. 불필요한 함수를 갖는 클래스가 만들어진다.</li><li>상속은 이해하기 어렵다.</li></ul><p>컴포지션을 사용하는것은 객체를 프로퍼티로 갖고 함수를 호출하는 형태로 재사용하는 것을 의미 한다.</p><h3 id="모든것을-가지고-올-수밖에-없는-상속"><a href="#모든것을-가지고-올-수밖에-없는-상속" class="headerlink" title="모든것을 가지고 올 수밖에 없는 상속"></a>모든것을 가지고 올 수밖에 없는 상속</h3><p>상속은 슈퍼클래스의 매서드, 제약, 행위 등 모든 것을 가지고 온다. 객체의 계층구조를 나타낼 때 굉장히 좋은 도구</p><p>하지만 그래서 단점도 존재 한다. 필요 없는 매소드는 오버라이딩 해서 처리해야 된다.(인터페이스 분리 원칙의 위배)</p><h3 id="캡슐화를-깨는-상속"><a href="#캡슐화를-깨는-상속" class="headerlink" title="캡슐화를 깨는 상속"></a>캡슐화를 깨는 상속</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt; : <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위임 패턴, 포워딩 매소드 </p><p>위임 패턴을 쉽게 구현할수 있는 문법을 제공해 준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableSet&lt;T&gt; = mutableSetOf()</span><br><span class="line">) : MutableSet&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="오버라이딩-제한하기"><a href="#오버라이딩-제한하기" class="headerlink" title="오버라이딩 제한하기"></a>오버라이딩 제한하기</h3><p>개발자가 상속용으로 설계 되지 않은 클래스의 상속을 막을려면 final 키워드를 붙히면 된다.<br>하지만 어떤 이유에서 상속은 허용하지만 메소드의 오버라이딩만 제한하고 싶을때는 open 키워드를 사용하면 된다.</p><p>open 클래스는 open된 메소드만 오버라이딩 가능하다.</p><p>정리 </p><ul><li><p>컴포지션은 더 안전하다.</p></li><li><p>컴포지션이 더 유연하다.</p></li><li><p>컴포지션이 더 명시적이다.</p></li><li><p>컴포지션은 생각보다 번거롭다.</p></li><li><p>다형성을 가지기 어렵다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스용 유용한 툴</title>
      <link>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</guid>
      <pubDate>Fri, 09 Dec 2022 05:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스용-유용한-툴&quot;&gt;&lt;a href=&quot;#쿠버네티스용-유용한-툴&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스용 유용한 툴&quot;&gt;&lt;/a&gt;쿠버네티스용 유용한 툴&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://minikub
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스용-유용한-툴"><a href="#쿠버네티스용-유용한-툴" class="headerlink" title="쿠버네티스용 유용한 툴"></a>쿠버네티스용 유용한 툴</h1><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a> : 로컬에서 쿠버네티스 테스트용</li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a> : 쿠버네티스 네임스페이스&#x2F;컨텍스트 변경</li><li><a href="https://k9scli.io/">k9s</a> : 쿠버네티스 커멘드라인 gui tool</li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a> : 쿠버네티스 IDE</li><li><a href="https://www.telepresence.io/">telepresence</a> : 원격 개발 환경을 설정할 수 있는 오픈 소스 도구</li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a> : 명령 줄 플러그인</li><li><a href="https://github.com/yannh/kubeconform">kubeconform</a> : 쿠버네티스 yml 검증</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a></li><li><a href="https://k9scli.io/">k9s</a></li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a></li><li><a href="https://www.telepresence.io/">telepresence</a></li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 속성 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</guid>
      <pubDate>Tue, 06 Dec 2022 02:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-속성-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-속성-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 속성 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 속성 테스트&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-속성-테스트"><a href="#쿠버네티스-워크로드-크론잡-속성-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 속성 테스트"></a>쿠버네티스 워크로드 크론잡 속성 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cron-job-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">    <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">failedJobsHistoryLimit:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때 완료되거나 실패한 pod를 정리하는 속성</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때까지 잡이 끝나지 않을때 종료하는 옵션</span></span><br><span class="line">            <span class="comment">## type: Failed 와 reason: DeadlineExceeded 로 표시됨</span></span><br><span class="line">            <span class="attr">activeDeadlineSeconds:</span> <span class="number">200</span></span><br><span class="line">            <span class="comment">## backoffLimit 에 도달하면 작업은 실패한것으로 간주한다.</span></span><br><span class="line">            <span class="attr">backoffLimit:</span> <span class="number">10</span></span><br><span class="line">            <span class="comment">## 병렬실행 관련 옵션</span></span><br><span class="line">            <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">            <span class="comment">## 완료</span></span><br><span class="line">            <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">concurrency-policy-forbid-test</span></span><br><span class="line">                          <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">                          <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;job start&#x27;;sleep 140; echo &#x27;job end&#x27;&quot;</span>]</span><br><span class="line">                    <span class="comment">## 재시작 정책 Never, OnFailure</span></span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create -f cronjob.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</guid>
      <pubDate>Mon, 05 Dec 2022 03:23:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-테스트"><a href="#쿠버네티스-워크로드-크론잡-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 테스트"></a>쿠버네티스 워크로드 크론잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                      <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                      <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobTemplate 아래는 job 과 완전 똑같은 스팩이다. 바로 직전에 테스트 해본 잡을 가지고 테스트 해보면 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/#disqus_thread</comments>
    </item>
    
    <item>
      <title>argo workflows 설치</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</guid>
      <pubDate>Mon, 05 Dec 2022 02:53:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;argo-workflows-설치&quot;&gt;&lt;a href=&quot;#argo-workflows-설치&quot; class=&quot;headerlink&quot; title=&quot;argo workflows 설치&quot;&gt;&lt;/a&gt;argo workflows 설치&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="argo-workflows-설치"><a href="#argo-workflows-설치" class="headerlink" title="argo workflows 설치"></a>argo workflows 설치</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><p><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a><br>최신 릴리즈 버전을 인스톨 한다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create namespace argo</span><br><span class="line">kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v3.3.10/install.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment \</span><br><span class="line">  argo-server \</span><br><span class="line">  --namespace argo \</span><br><span class="line">  --type=&#x27;json&#x27; \</span><br><span class="line">  -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/args&quot;, &quot;value&quot;: [</span><br><span class="line">  &quot;server&quot;,</span><br><span class="line">  &quot;--auth-mode=server&quot;</span><br><span class="line">]&#125;]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>아래처럼 포트 포워딩후에 <a href="https://localhost:2746/">https://localhost:2746/</a> 접속한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argo port-forward deployment/argo-server 2746:2746</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</guid>
      <pubDate>Fri, 02 Dec 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하기 위해
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-잡-테스트"><a href="#쿠버네티스-워크로드-잡-테스트" class="headerlink" title="쿠버네티스 워크로드 잡 테스트"></a>쿠버네티스 워크로드 잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml</span><br></pre></td></tr></table></figure><p>위 처럼 간단하게 테스트 해볼수 있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                  <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                  <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">            <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/concepts/workloads/controllers/job/">kubernetes job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 33: 생성자 대신 팩토리 함수를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-33-생성자-대신-팩토리-함
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-33-생성자-대신-팩토리-함수를-사용하라"><a href="#아이템-33-생성자-대신-팩토리-함수를-사용하라" class="headerlink" title="아이템 33: 생성자 대신 팩토리 함수를 사용하라"></a>아이템 33: 생성자 대신 팩토리 함수를 사용하라</h2><p>생성자 역활을 대신해주는 함수를 팩토리 함수</p><p>팩토리 함수의 장점</p><ul><li>함수의 이름을 붙일수 있다</li><li>함수가 원하는 타입을 리턴할 수 있다</li><li>호출될때 마다 새객체를 만들 필요가 없다</li><li>아직 존재하지 않는 객체를 리턴할 수 있다</li><li>객체 외부에 팩토리 함수를 만들면 가시성을 원하는 대로 조정할수 있다</li><li>팩토리 함수는 인라인으로 만들수 있으며 그 파라미터들을 reified로 만들수 있다</li><li>생성자로 만들기 복잡한 객체도 만들수 있다</li><li>원하는 때에 생성자를 호출할수 있다</li></ul><p>팩토리 함수의 제약</p><p>서브클레스 생성에는 슈퍼클래스 생성자가 필요하기 때문에 서브 클래스를 만들어 낼수 없다.</p><h3 id="Companion-객체-팩토리-함수"><a href="#Companion-객체-팩토리-함수" class="headerlink" title="Companion 객체 팩토리 함수"></a>Companion 객체 팩토리 함수</h3><p>자바의 정적 팩토리 함수</p><p>c++ 이름을 가진 생성자</p><p>많이 사용되는 함수 이름</p><ul><li>from : 파라미터를 하나 받고, 같은 타입의 인스턴스를 하나 리턴하는 타입의 변환 함수</li><li>of : 파라미터를 여러개 받고, 이를 통합하여 인스턴스를 만들어 주는 함수</li><li>valueOf : from 또는 of 와 비슷한 기능을 하면서 의미를 조금 더 쉽게 읽을수 있게 이름을 붙힘 함수</li><li>instance or getInstance : 싱글턴으로 인스턴스 하나를 리턴하는 함수</li><li>createInstance : instance or getInstance 처럼 동작하지만 싱글턴이 적용되지 않아 매번 인스턴스를 새롭게 만드는 함수</li><li>getType : getInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li><li>newType : createInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li></ul><p>추상 Companion 객체 팩토리는 값을 가질수 있다 캐싱을 구현 하거나 테스트를 위한 가짜 객체 생성할수 있다.</p><h3 id="확장-팩토리-함수"><a href="#확장-팩토리-함수" class="headerlink" title="확장 팩토리 함수"></a>확장 팩토리 함수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Tool.Companion.<span class="title">createBigTool</span><span class="params">()</span></span> : BigTool&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>companion 객체가 존재할 때, 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때 사용</li></ul><h3 id="톱레벨-팩토리-함수"><a href="#톱레벨-팩토리-함수" class="headerlink" title="톱레벨 팩토리 함수"></a>톱레벨 팩토리 함수</h3><ul><li>대표적인 예 listOf, setOf, mapOf</li><li>public 톱 레벨 함수는 모든곳에서 사용할 수 있으므로 ide가 제공하는 팁을 복잡하게 만드는 단점</li></ul><h3 id="가짜-생성자"><a href="#가짜-생성자" class="headerlink" title="가짜 생성자"></a>가짜 생성자</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">4</span>) &#123;<span class="string">&quot;User<span class="variable">$it</span>&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">List</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">size:<span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">init</span>: (<span class="type">index</span>:<span class="type">Int</span>)-&gt;<span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; = MutableList(size,<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">invoke</span><span class="params">(size: <span class="type">Int</span>, generator: (<span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span>: Tree &lt;T&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>invoke 연산자를 갖는 companion 객체를 사용할 수도 있는데 추천 하지 않는 방식이다</p><ul><li>인터페이스를 위한 생성자를 만들고 싶을때</li><li>reified 타입 아규먼트를 갖게 하고 싶을때</li></ul><h3 id="팩토리-클래스의-메서드"><a href="#팩토리-클래스의-메서드" class="headerlink" title="팩토리 클래스의 메서드"></a>팩토리 클래스의 메서드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SutudentsFactory</span></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> nextId = <span class="number">0</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">(name:<span class="type">String</span>,surname:<span class="type">String</span> = Student(nextId++,name,surname)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>팩토리 클래스는 프로퍼티를 가질 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-34-기본-생성자에-이름-있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라"><a href="#아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라" class="headerlink" title="아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라"></a>아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</h2><p>기본 생성자 : 객체를 정의하고 생성하는 방법을 지정할때 사용하는 가장 기본적인 방법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> surname: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(<span class="string">&quot;Zola&quot;</span>, <span class="string">&quot;Gianfranco&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="점층적-생성자-패턴-telescoping-constructor-pattern"><a href="#점층적-생성자-패턴-telescoping-constructor-pattern" class="headerlink" title="점층적 생성자 패턴(telescoping constructor pattern)"></a>점층적 생성자 패턴(telescoping constructor pattern)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size: String</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheess: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>, bacon: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size</span><br><span class="line">        <span class="keyword">this</span>.cheess = cheess</span><br><span class="line">        <span class="keyword">this</span>.olives = olives</span><br><span class="line">        <span class="keyword">this</span>.bacon = bacon</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, olives, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String): <span class="keyword">this</span>(size, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>코틀린은 디폴트 아규먼트(default argument)를 사용할 수 있기 때문에 아래처럼 사용할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="빌더-패턴-builder-pattern"><a href="#빌더-패턴-builder-pattern" class="headerlink" title="빌더 패턴(builder pattern)"></a>빌더 패턴(builder pattern)</h3><p>자바에서는 네임드 파라미터(named parameter)와 디폴트 아규먼트(default argument)를 사용할 수 없다. 그래서 빌더 패턴을 사용한다.</p><p>빌더 패턴의 장점</p><ul><li>파라미터에 이름을 가진다.</li><li>파라미터를 원하는 순서대로 지정</li><li>디폴트 값을 지정</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> size: String) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> olives: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setCheese</span><span class="params">(value: <span class="type">Int</span>)</span></span>: Builder = apply &#123;</span><br><span class="line">            cheese = value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = Pizza(size, cheese, olives, bacon)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린은 빌더 패턴을 사용하는것 보다 네임드 파라미터를 사용하는게 좋다.</p><p>값의 의미를 묶어서 지정할때나 특정값을 누적하는 형태로 사용될때 빌더 패턴을 이용하는것이 나을수도 있는데<br>코틀린에서는 DSL 빌더를 이용해서 구현하는것을 더 좋게 본다(?)</p><p>빌더 패턴은 다음과 같은 경우에만 사용</p><ul><li>빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때</li><li>디폴트 아규먼트와 DSL을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API를 설계할 때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-35-복잡한-객체를-생성하기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라"><a href="#아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라" class="headerlink" title="아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라"></a>아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</h2><p>함수 타입의 몇가지 예</p><ul><li>()-&gt;Unit : 아규먼트를 갖지 않고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Unit : Int를 아규먼트로 받고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Int : Int를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int, Int)-&gt;Int : Int 2개를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int)-&gt;()-&gt;Unit : Int를 아규먼트로 받고, 다른 함수를 리턴하는 함수 이때 다른함수는 아규먼트로 아무것도 받지 않고 Unit을 리턴</li><li>(()-&gt;Unit)-&gt;Unit : 다른 함수를 아규먼트로 받고, Unit을 리턴하는 함수</li></ul><p>함수 타입을 만드는 기본적인 방법</p><ul><li>람다 표현식</li><li>익명함수</li><li>함수 레퍼런스</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> plus1: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;a, b -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="title">fun</span><span class="params">(a, b)</span></span> = a + b</span><br><span class="line"><span class="keyword">val</span> plus3: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = ::plus</span><br><span class="line"><span class="keyword">val</span> plus4 = &#123;a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus5 = <span class="function"><span class="title">fun</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>함수타입은 함수를 나타내는 객체를 표현하는 타입</p><p>확장함수(리시버를 가진 함수타입)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">myPlus</span><span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br><span class="line"><span class="keyword">val</span> myPlus: <span class="built_in">Int</span>.(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"><span class="keyword">val</span> myPlus = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 호출 방법</p><ul><li>일반적인 객체처럼 invoke 메서드를 사용</li><li>확장 함수가 아닌 함수처럼 사용</li><li>일반적인 확장함수처럼 사용</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPlus.invoke(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">myPlus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1.</span>myPlus(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 가장 중요한 특징은 this의 참조 대상을 변경할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> surname: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User().apply &#123; </span><br><span class="line">    name = <span class="string">&quot;sejoung&quot;</span></span><br><span class="line">    surname = <span class="string">&quot;kim&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DSL-의-사용"><a href="#DSL-의-사용" class="headerlink" title="DSL 의 사용"></a>DSL 의 사용</h3><ul><li>복잡한 자료구조</li><li>계층적인 구조</li><li>거대한 양의 데이터</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 32: 추상화 규약을 지켜라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</guid>
      <pubDate>Mon, 26 Sep 2022 12:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-32-추상화-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-32-추상화-규약을-지켜라"><a href="#아이템-32-추상화-규약을-지켜라" class="headerlink" title="아이템 32: 추상화 규약을 지켜라"></a>아이템 32: 추상화 규약을 지켜라</h2><p>규약은 개발자들의 단순한 합의 무언가를 할 수 있다는 것이 그것을 해도 괜찮다는 의미는 아니다.</p><h3 id="상속된-규약"><a href="#상속된-규약" class="headerlink" title="상속된 규약"></a>상속된 규약</h3><p>클래스를 상속하거나 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 된다.</p><p>프로그램을 안정적으로 유지하고 싶으면 규약을 지켜야 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 31: 문서로 규약을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</guid>
      <pubDate>Fri, 23 Sep 2022 04:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-31-문서로-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-31-문서로-규약을-정의하라"><a href="#아이템-31-문서로-규약을-정의하라" class="headerlink" title="아이템 31: 문서로 규약을 정의하라"></a>아이템 31: 문서로 규약을 정의하라</h2><p>함수가 무슨일을 하는지 명확하게 설명하고 싶다면 KDoc 주석을 붙혀주는것이 좋다.</p><p>일반적인 문제는 행위가 문서화 되지 않고 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 현재 구현에만 의존하게 된다.<br>이러한 문제는 예상되는 행위를 문서화만 잘해도 해소 된다.</p><h3 id="규약-정의하기"><a href="#규약-정의하기" class="headerlink" title="규약 정의하기"></a>규약 정의하기</h3><ul><li>이름: 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할수 있다.</li><li>주석과 문서: 필요한 모든규약을 적을수 있는 강력한 방법</li><li>타입: 타입은 객체에 대한 많은것을 알려준다. 자주 사용하는 타입의 경우는 타입만 보아도 어떻게 사용하는지 유추할수 있지만 일부타입은 문서를 추가해야된다.</li></ul><h3 id="주석을-써야-될까"><a href="#주석을-써야-될까" class="headerlink" title="주석을 써야 될까?"></a>주석을 써야 될까?</h3><p>자바 커뮤니티 초기에 문학적 프로그래밍(literate programming)이라는 개념이 인기였다.<br>10년이 지난 후에는 주석 없이도 읽을수 있는 코드를 작성해야 하는 프로그래밍 방식으로 바뀜</p><p>극단적인것은 언제나 좋지 않다.</p><h3 id="타입-시스템과-예측"><a href="#타입-시스템과-예측" class="headerlink" title="타입 시스템과 예측"></a>타입 시스템과 예측</h3><p>타입 계층은 객체와 관련된 아주 중요한 정보이다.</p><p>클래스가 어떤 동작을 할것이라 예측 되면 그서브 클래스에도 이를 보장해야된다. - 리스코프 치환의 원칙</p><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>요소, 특히 외부 API를 구현할 때는 규약을 잘정리 해야된다.</p><p>규약은 이름, 문서, 주석, 타입을 통해 구현될수 있다.</p><p>규약은 단순 합의이지만 그 합의를 존중한다면 큰 문제는 없을것이다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 30: 요소의 가시성을 최소화하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/</guid>
      <pubDate>Thu, 22 Sep 2022 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-30-요소의-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-30-요소의-가시성을-최소화하라"><a href="#아이템-30-요소의-가시성을-최소화하라" class="headerlink" title="아이템 30: 요소의 가시성을 최소화하라"></a>아이템 30: 요소의 가시성을 최소화하라</h2><p>API를 설계할때 간결한 API를 선호하는 이유</p><ul><li>작은 인터페이스는 배우기 쉽고 유지하기 쉽다.</li><li>기능이 많은 클래스보다 작은 클래스이 이해하기 쉽다.</li><li>유지보수가 편하다.</li></ul><p>변경을 가할떄는 기존것을 숨기는것 보다 새로운것을 만드는것이 편하다 그래서 가시성을 최소화 시키는것이 좋다.<br>그리고 갑자기 가시성을 제한하면 다른곳에서 사용이 어렵다. 따라서 처음엔 작은 API로 개발을 강제하는것이 좋다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableSet&lt;T&gt; = mutableSetOf()</span><br><span class="line">) : MutableSet&lt;T&gt; <span class="keyword">by</span> innerSet&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="가시성-한정자-사용하기"><a href="#가시성-한정자-사용하기" class="headerlink" title="가시성 한정자 사용하기"></a>가시성 한정자 사용하기</h3><p>클래스의 맴버의 경우</p><ul><li>public(default): 어디에서나 볼 수 있다.</li><li>private: 클래스 내부에서만 볼 수 있다.</li><li>protected: 클래스와 서브클래스 내부에서만 볼 수 있다.</li><li>internal: 모듈 내부에서만 볼 수 있다.</li></ul><p>톱레벨 요소</p><ul><li>public(default): 어디에서나 볼 수 있다.</li><li>private: 같은 파일 내부에서만 볼 수 있다.</li><li>internal: 모듈 내부에서만 볼 수 있다.</li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><ul><li>인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.</li><li>최대한 제한이 되어 있어야 변경하기 쉽다.</li><li>클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.</li><li>가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 29: 외부 API를 랩(wrap)해서 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/</guid>
      <pubDate>Wed, 21 Sep 2022 01:05:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-29-외부-A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-29-외부-API를-랩-wrap-해서-사용하라"><a href="#아이템-29-외부-API를-랩-wrap-해서-사용하라" class="headerlink" title="아이템 29: 외부 API를 랩(wrap)해서 사용하라"></a>아이템 29: 외부 API를 랩(wrap)해서 사용하라</h2><p>랩(wrap) 해서 API를 사용할떄 장점</p><ul><li>문제가 있다면 래버(wrapper)만 변경하면 되서 변화에 쉽게 대응 할수 있다.</li><li>프로젝트 스타일에 맞춰서 API의 형태를 조절할수 있다.</li><li>특정 라이브러리에서 문제가 발생하면 래퍼를 수정해서 다른 라이브러리를 사용하도록 쉽게 바꿀수 있다.</li><li>필요한 경우 쉽게 동작을 추가하거나 수정할수 있다.</li></ul><p>단점 </p><ul><li>래퍼를 따로 정의해야 된다.</li><li>다른 개발자가 프로젝트를 다룰 때 어떤 래퍼들이 있는지 따로 확인해야 한다.</li><li>래퍼들은 프로젝트 내부에서만 유효하므로 문제가 생겨도 질문 할수가 없다.</li></ul><p>라이브러리가 안정적인지 확인할수 있는 가장 기본적은 휴리스틱은 버전 번호화 사용자 수이다.<br>사용자가 많을수록 안정적이다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 28: API 안정성을 확인하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/</guid>
      <pubDate>Tue, 20 Sep 2022 00:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-28-API-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-28-API-안정성을-확인하라"><a href="#아이템-28-API-안정성을-확인하라" class="headerlink" title="아이템 28: API 안정성을 확인하라"></a>아이템 28: API 안정성을 확인하라</h2><p>시멘틱 버저닝</p><ul><li>MAJOR 버전: 호환되지 않는 수준의 API 변경</li><li>MINOR 버전: 이전 변경과 호환되는 기능을 추가</li><li>PATCH 버전: 간단한 버그 수정</li></ul><p>어노테이션 </p><ul><li>@Experimental: 안정적이지 않음</li><li>@Deprecated: 더 이상 사용되지 않음 (단, 사용자가 적용할 시간을 주자)<ul><li>ReplaceWith: 다른 것으로 대체 되었으면 표시해주는것이 좋음</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/</guid>
      <pubDate>Mon, 19 Sep 2022 05:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-27-변화로부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-27-변화로부터-코드를-보호하려면-추상화를-사용하라"><a href="#아이템-27-변화로부터-코드를-보호하려면-추상화를-사용하라" class="headerlink" title="아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라"></a>아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라</h2><h3 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> MAX_THREADS = <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>이름을 붙일 수 있다.</li><li>나중에 값을 쉽게 변경 가능하다.</li></ul><h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>일반적인 알고리즘을 함수로 추출 하면 코드를 항상 기억해 두지 않아도 된다</p><p>함수의 단점</p><ul><li>함수는 상태를 유지 하지 않는다.</li><li>함수 시그니처를 변경하면 프로그램 전체에 큰영향을 줄수 있다.</li></ul><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>클래스가 함수보다 더 강력한 이유</p><ul><li>상태를 가질 수 있고, 많은 함수를 가질 수 있다</li><li>의존성 주입 프레임워크를 이용하면 클래스 생성을 위임할 수도 있다.</li><li>mock 객체를 활용해서 테스트할 수 있다.</li></ul><h3 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h3><ul><li>코틀린은 거의 모든 것을 인터페이스로 표현한다.</li><li>인터페이스 뒤에 객체를 숨겨 구현을 추상화하고 사용자가 추상화된 것에만 의존하도록 만들어서 결합을 줄인다.</li><li>테스트 시 모킹보다 간단하게 인터페이스 페이킹을 사용할 수 있다.</li></ul><h3 id="추상화-문제"><a href="#추상화-문제" class="headerlink" title="추상화 문제"></a>추상화 문제</h3><p>추상화는 자유를 주지만 코드를 이해하고 수정하기 어렵게 만든다.</p><p>너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려워진다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li><li><a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">fizzbuzz enterprise edition</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 26: 함수 내부의 추상화 레벨을 통일하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/</guid>
      <pubDate>Fri, 16 Sep 2022 13:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;p&gt;추상화란 : 복잡한 자료, 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><p>추상화란 : 복잡한 자료, 모듈, 시스템 등으로 부터 핵심적인 개념 또는 기능을 간추려 내는것을 말한다.</p><p>추상화를 설계한다는 것은 단순하게 모듈 또는 라이브러리로 분리한다는 의미가 아니라 함수를 정의할 때는 그 구현을 함수 시그니처 뒤에 숨기게 되는데 이것이 바로 추상화다.</p><p>추상화의 목적</p><ul><li>복잡성을 숨기기 위해</li><li>코드를 체계화하기 위해</li><li>만드는 사람에게 변화의 자유를 주기 위해</li></ul><h2 id="아이템-26-함수-내부의-추상화-레벨을-통일하라"><a href="#아이템-26-함수-내부의-추상화-레벨을-통일하라" class="headerlink" title="아이템 26: 함수 내부의 추상화 레벨을 통일하라"></a>아이템 26: 함수 내부의 추상화 레벨을 통일하라</h2><p>계층이 잘 분리 되면 장점</p><ul><li>어떤 계층에서 작업할 때 그아래의 계층은 이미 완성되어 있으므로 해당 계층만 생각하면 된다.</li></ul><h3 id="추상화-레벨"><a href="#추상화-레벨" class="headerlink" title="추상화 레벨"></a>추상화 레벨</h3><p>프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현한다.</p><h3 id="추상화-레벨-통일"><a href="#추상화-레벨-통일" class="headerlink" title="추상화 레벨 통일"></a>추상화 레벨 통일</h3><p>코드도 추상화를 계층처럼 만들어 사용할수 있다.</p><p>함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있다. 이를 추상화 레벨 통일 SLA 원칙이라고 부른다.</p><p>함수는 간단해야 된다. 함수는 작아야 하며 최소한의 책임만을 가져야 된다 단일책임 원칙</p><h3 id="프로그램-아키텍처의-추상-레벨"><a href="#프로그램-아키텍처의-추상-레벨" class="headerlink" title="프로그램 아키텍처의 추상 레벨"></a>프로그램 아키텍처의 추상 레벨</h3><p>추상화를 구분하면 서브 시스템의 세부사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 가질수 있다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_25/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_25/</guid>
      <pubDate>Fri, 16 Sep 2022 13:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-재사용성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-재사용성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(재사용성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(재사용성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-25-공통-모듈을-추출해서-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-재사용성"><a href="#이펙티브-코틀린-재사용성" class="headerlink" title="이펙티브 코틀린(재사용성)"></a>이펙티브 코틀린(재사용성)</h1><h2 id="아이템-25-공통-모듈을-추출해서-여러-플랫폼에서-재사용하라"><a href="#아이템-25-공통-모듈을-추출해서-여러-플랫폼에서-재사용하라" class="headerlink" title="아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라"></a>아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라</h2><p>코틀린은 멀티플랫폼을 지원해서 코드를 서로 다른 플랫폼에서 공유가 가능하다<br>공통 모듈을 추출해서 재사용하면 좋다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 24: 제네렉 타입과 variance 한정자를 활용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-15-effective_kotlin_item_24/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-15-effective_kotlin_item_24/</guid>
      <pubDate>Thu, 15 Sep 2022 11:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-재사용성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-재사용성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(재사용성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(재사용성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-24-제네렉-타입과-vari
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-재사용성"><a href="#이펙티브-코틀린-재사용성" class="headerlink" title="이펙티브 코틀린(재사용성)"></a>이펙티브 코틀린(재사용성)</h1><h2 id="아이템-24-제네렉-타입과-variance-한정자를-활용하라"><a href="#아이템-24-제네렉-타입과-variance-한정자를-활용하라" class="headerlink" title="아이템 24: 제네렉 타입과 variance 한정자를 활용하라"></a>아이템 24: 제네렉 타입과 variance 한정자를 활용하라</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span>&lt;<span class="type">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위에 코드에서 파라미터 T는 variance 한정자(out 또는 in)이 없으므로 기본적으로 invariant(불공변성) 입니다.<br>제네릭 타입으로 들어가는 타입들이 서로 관련성이 없다는 의미</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> anys: Cup&lt;Any&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 오류</span></span><br><span class="line">    <span class="keyword">val</span> nothings: Cup&lt;<span class="built_in">Nothing</span>&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 오류</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 어떠한 관련성을 원한다면 out 또는 in 이라는 variance 한정자를 붙혀야 된다.</p><p>out 은 타입파라미터를 covariant(공변성)로 만든다. A가 B의 서브타입일때 Cup<A> 가 Cup<B>의 서브타입이라는것을 의미</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span>&lt;<span class="type">out T</span>&gt;</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Puppy</span>: <span class="type">Dog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> b: Cup&lt;Dog&gt; = Cup&lt;Puppy&gt;() <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">val</span> a: Cup&lt;Puppy&gt; = Cup&lt;Dog&gt;() <span class="comment">// 오류 </span></span><br><span class="line">    <span class="keyword">val</span> anys: Cup&lt;Any&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">val</span> nothings: Cup&lt;<span class="built_in">Nothing</span>&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 오류</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in 한정자는 반대 의미 in 한정자는 타입 파라미터를 contravariant(반변성)으로 만든다. A가 B의 서브타입일때 Cup<A>가 Cup<B>의 슈퍼타입</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span>&lt;<span class="type">out T</span>&gt;</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Puppy</span>: <span class="type">Dog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> b: Cup&lt;Dog&gt; = Cup&lt;Puppy&gt;() <span class="comment">// 오류</span></span><br><span class="line">    <span class="keyword">val</span> a: Cup&lt;Puppy&gt; = Cup&lt;Dog&gt;() <span class="comment">// OK </span></span><br><span class="line">    <span class="keyword">val</span> anys: Cup&lt;Any&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 오류</span></span><br><span class="line">    <span class="keyword">val</span> nothings: Cup&lt;<span class="built_in">Nothing</span>&gt; = Cup&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 타입은 파라미터 유형과 리턴 타입에 따라서 관계가 달라진다.</p><ul><li>코틀린 함수의 타입의 모든 파라미터 타입은 contravariant(반공변성)</li><li>코틀린 함수의 타입의 모든 리턴 타입은 covariant(공변성)</li><li>함수 타입을 사용할 때는 자동으로 variance 한정자가 사용</li></ul><p>(Tin, Tin2) -&gt; Tout</p><p>자바의 배열은 covariant(공변성)이다. 이런 특성 때문에 다음과 같은 문제가 발생</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Object[] objs = numbers;</span><br><span class="line">object[<span class="number">2</span>] = <span class="string">&quot;B&quot;</span>; <span class="comment">// Runtime에 ArrayStoreException이 발생</span></span><br></pre></td></tr></table></figure><ul><li>코틀린은 위와 같은 결함을 해결하기 위해 Array를 invariant(무공변성)으로 만들었다. 따라서 Array를 Array등으로 변경할 수 없다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//선언 부분에 사용</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> value: T)</span><br><span class="line"><span class="keyword">val</span> box1: Box&lt;String&gt; = Box(<span class="string">&quot;Box&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> box2: Box&lt;Any&gt; = box1</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T)</span><br><span class="line"><span class="keyword">val</span> box1: Box&lt;String&gt; = Box(<span class="string">&quot;Box&quot;</span>)</span><br><span class="line"><span class="comment">// 사용하는 부분에 사용</span></span><br><span class="line"><span class="keyword">val</span> box2: Box&lt;<span class="keyword">out</span> Any&gt; = box1</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-15-effective_kotlin_item_24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 23: 타입 파라미터의 섀도잉을 피하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-14-effective_kotlin_item_23/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-14-effective_kotlin_item_23/</guid>
      <pubDate>Wed, 14 Sep 2022 13:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-재사용성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-재사용성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(재사용성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(재사용성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-23-타입-파라미터의-섀도잉
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-재사용성"><a href="#이펙티브-코틀린-재사용성" class="headerlink" title="이펙티브 코틀린(재사용성)"></a>이펙티브 코틀린(재사용성)</h1><h2 id="아이템-23-타입-파라미터의-섀도잉을-피하라"><a href="#아이템-23-타입-파라미터의-섀도잉을-피하라" class="headerlink" title="아이템 23: 타입 파라미터의 섀도잉을 피하라"></a>아이템 23: 타입 파라미터의 섀도잉을 피하라</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTree</span><span class="params">(name: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>지역 파라미터가 외부 스코프에 있는 프로퍼티를 가린다. 이를 새도잉이라고 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tree</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Birch</span>: <span class="type">Tree</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spruce</span>: <span class="type">Tree</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span>&lt;<span class="type">T: Tree</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Tree&gt;</span> <span class="title">addTree</span><span class="params">(tree: <span class="type">T</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forest = Forest&lt;Birch&gt;()</span><br><span class="line">forest.addTree(Birch())</span><br><span class="line">forest.addTree(Spruce())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위와 같이 선언하면 타입 파라미터가 새도잉된다.</p><p>하지만 위처럼 독립적으로 동작합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span>&lt;<span class="type">T: Tree</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTree</span><span class="params">(tree: <span class="type">T</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forest = Forest&lt;Birch&gt;()</span><br><span class="line">forest.addTree(Birch())</span><br><span class="line">forest.addTree(Spruce()) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>위처럼 선언해야 의도한 방식대로 동작할것입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span>&lt;<span class="type">T: Tree</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;ST: T&gt;</span> <span class="title">addTree</span><span class="params">(tree: <span class="type">ST</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>독립적으로 선언하고 싶으면 이름을 아에 다르게 선언하는것이 좋다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-14-effective_kotlin_item_23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-06-effective_kotlin_item_22/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-06-effective_kotlin_item_22/</guid>
      <pubDate>Tue, 06 Sep 2022 05:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-재사용성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-재사용성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(재사용성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(재사용성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-22-일반적인-알고리즘을-구
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-재사용성"><a href="#이펙티브-코틀린-재사용성" class="headerlink" title="이펙티브 코틀린(재사용성)"></a>이펙티브 코틀린(재사용성)</h1><h2 id="아이템-22-일반적인-알고리즘을-구현할-때-제네릭을-사용하라"><a href="#아이템-22-일반적인-알고리즘을-구현할-때-제네릭을-사용하라" class="headerlink" title="아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라"></a>아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라</h2><p>타입 아규먼트를 사용하는 함수를 제네릭 함수라고 부른다.(예 stdlib에 있는 filter 함수)</p><p>타입 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 정확하게 추측할수 있다.</p><h3 id="제네릭-제한"><a href="#제네릭-제한" class="headerlink" title="제네릭 제한"></a>제네릭 제한</h3><p>타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는것</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAdapter</span>&lt;<span class="type">T : ItemAdapter</span>&gt;</span>(...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">sorted</span><span class="params">()</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-06-effective_kotlin_item_22/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
