<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Fri, 29 Dec 2023 01:26:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>11장: 코드 구조 따르기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</guid>
      <pubDate>Fri, 29 Dec 2023 00:56:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-코드-구조-따르기&quot;&gt;&lt;a href=&quot;#11장-코드-구조-따르기&quot; class=&quot;headerlink&quot; title=&quot;11장: 코드 구조 따르기&quot;&gt;&lt;/a&gt;11장: 코드 구조 따르기&lt;/h1&gt;&lt;p&gt;소프트웨어는 현실 세계의 한 측면에 대한 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-코드-구조-따르기"><a href="#11장-코드-구조-따르기" class="headerlink" title="11장: 코드 구조 따르기"></a>11장: 코드 구조 따르기</h1><p>소프트웨어는 현실 세계의 한 측면에 대한 모델 입니다</p><h2 id="범위와-출처에-따른-구조-분류"><a href="#범위와-출처에-따른-구조-분류" class="headerlink" title="범위와 출처에 따른 구조 분류"></a>범위와 출처에 따른 구조 분류</h2><p>구조의 분류를 4가지로 나눈다 </p><ul><li>딤간</li><li>팀내</li><li>코드에 있는 경우</li><li>사람에 있는 경우</li></ul><p>매크로 아키텍처는 팀 간 구조에 관한 것<br>마이크로 아키텍처는 팀 내 구조에 관한것</p><p>조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있다 - 콘웨이 법칙</p><h2 id="행위를-코드화하는-세-가지-방법"><a href="#행위를-코드화하는-세-가지-방법" class="headerlink" title="행위를 코드화하는 세 가지 방법"></a>행위를 코드화하는 세 가지 방법</h2><ul><li>제어 흐름</li><li>데이터 구조</li><li>데이터</li></ul><h3 id="데이터에-행위-코드화하기"><a href="#데이터에-행위-코드화하기" class="headerlink" title="데이터에 행위 코드화하기"></a>데이터에 행위 코드화하기</h3><p>코드를 캡슐화해야 하지만 변경점을 노출 하지 않아야 한다</p><h2 id="구조-노출을-위한-코드-추가"><a href="#구조-노출을-위한-코드-추가" class="headerlink" title="구조 노출을 위한 코드 추가"></a>구조 노출을 위한 코드 추가</h2><h2 id="예측-대신-관찰-그리고-경험적-기술-사용"><a href="#예측-대신-관찰-그리고-경험적-기술-사용" class="headerlink" title="예측 대신 관찰, 그리고 경험적 기술 사용"></a>예측 대신 관찰, 그리고 경험적 기술 사용</h2><ul><li>변경되지 않으면 아무것도 하지 말아라</li><li>예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리팩터링 해라</li><li>그렇지 않으면 과거에 발생한 변경 유형을 적용해 리팩터링 해라</li></ul><h2 id="코드를-이해하지-않고도-안전성을-확보하는-방안"><a href="#코드를-이해하지-않고도-안전성을-확보하는-방안" class="headerlink" title="코드를 이해하지 않고도 안전성을 확보하는 방안"></a>코드를 이해하지 않고도 안전성을 확보하는 방안</h2><h3 id="테스트를-통한-안전성-확보"><a href="#테스트를-통한-안전성-확보" class="headerlink" title="테스트를 통한 안전성 확보"></a>테스트를 통한 안전성 확보</h3><h3 id="숙달을-통한-안전성-확보"><a href="#숙달을-통한-안전성-확보" class="headerlink" title="숙달을 통한 안전성 확보"></a>숙달을 통한 안전성 확보</h3><h3 id="도구의-지원을-통한-안전성-확보"><a href="#도구의-지원을-통한-안전성-확보" class="headerlink" title="도구의 지원을 통한 안전성 확보"></a>도구의 지원을 통한 안전성 확보</h3><h3 id="공식-인증을-통한-안전성-확보"><a href="#공식-인증을-통한-안전성-확보" class="headerlink" title="공식 인증을 통한 안전성 확보"></a>공식 인증을 통한 안전성 확보</h3><h3 id="내결함성을-통한-안전성-확보"><a href="#내결함성을-통한-안전성-확보" class="headerlink" title="내결함성을 통한 안전성 확보"></a>내결함성을 통한 안전성 확보</h3><h2 id="활용되지-않은-구조-이용"><a href="#활용되지-않은-구조-이용" class="headerlink" title="활용되지 않은 구조 이용"></a>활용되지 않은 구조 이용</h2><h3 id="추출-및-캡슐화에-공백-활용"><a href="#추출-및-캡슐화에-공백-활용" class="headerlink" title="추출 및 캡슐화에 공백 활용"></a>추출 및 캡슐화에 공백 활용</h3><h3 id="통합에-중복-코드-활용"><a href="#통합에-중복-코드-활용" class="headerlink" title="통합에 중복 코드 활용"></a>통합에 중복 코드 활용</h3><h3 id="캡슐화로-공통-접사-활용"><a href="#캡슐화로-공통-접사-활용" class="headerlink" title="캡슐화로 공통 접사 활용"></a>캡슐화로 공통 접사 활용</h3><h3 id="동적-실행으로-런타임-유형-활용"><a href="#동적-실행으로-런타임-유형-활용" class="headerlink" title="동적 실행으로 런타임 유형 활용"></a>동적 실행으로 런타임 유형 활용</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장: 코드 추가에 대한 두려움 떨쳐내기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</guid>
      <pubDate>Thu, 28 Dec 2023 06:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-코드-추가에-대한-두려움-떨쳐내기&quot;&gt;&lt;a href=&quot;#10장-코드-추가에-대한-두려움-떨쳐내기&quot; class=&quot;headerlink&quot; title=&quot;10장: 코드 추가에 대한 두려움 떨쳐내기&quot;&gt;&lt;/a&gt;10장: 코드 추가에 대한 두려움 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-코드-추가에-대한-두려움-떨쳐내기"><a href="#10장-코드-추가에-대한-두려움-떨쳐내기" class="headerlink" title="10장: 코드 추가에 대한 두려움 떨쳐내기"></a>10장: 코드 추가에 대한 두려움 떨쳐내기</h1><p>코드 추가가 두려운 경우는 비현실적인 목표나 코드가 비용을 추가해서이다</p><h2 id="불확실성-받아들이기-위험-감수"><a href="#불확실성-받아들이기-위험-감수" class="headerlink" title="불확실성 받아들이기: 위험 감수"></a>불확실성 받아들이기: 위험 감수</h2><p>겁을 먹으면 효과적으로 일할 수 없다. 지식을 구축하는 가장 효과적인 방법은 실험이지만 거기에는 요기가 필요하다</p><h2 id="두려움-극복을-위한-스파이크-사용"><a href="#두려움-극복을-위한-스파이크-사용" class="headerlink" title="두려움 극복을 위한 스파이크 사용"></a>두려움 극복을 위한 스파이크 사용</h2><p>스파이크는 자신감과 함께 첫 번째 실제버전을 더 좋게 만드는 데 사용할 수 있는 지식을 제공한다</p><p>이해관계자는 제품이 코드나 기능이 아니라 지식이라는 것을 인지할 필요가 있다</p><h2 id="낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정"><a href="#낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정" class="headerlink" title="낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정"></a>낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정</h2><p>비기능적 요구사항에 개발자 시간의 20%를 할당할것</p><h2 id="불완전성에-대한-두려움-극복을-위한-점진적-개선"><a href="#불완전성에-대한-두려움-극복을-위한-점진적-개선" class="headerlink" title="불완전성에 대한 두려움 극복을 위한 점진적 개선"></a>불완전성에 대한 두려움 극복을 위한 점진적 개선</h2><p>가면 증후군은 스스로 자격이 없는 사람으로 간주하여 누군가 자신을 사기꾼으로 폭로할까 봐 두려워하는 것</p><p>개발자의 삶에 맞춘 최적화</p><h2 id="복사-및-붙여넣기가-속도에-미치는-영향"><a href="#복사-및-붙여넣기가-속도에-미치는-영향" class="headerlink" title="복사 및 붙여넣기가 속도에 미치는 영향"></a>복사 및 붙여넣기가 속도에 미치는 영향</h2><p>코드복제시 고려해야할 사항</p><ul><li>코드를 공유하면 코드가 사용되는 모든 위치에 영향을 미치기 쉽다</li><li>전역적인 동작 변경 속도가 높다는 것은 코드의 여러 다른 위치에 동시에 영향을 줄수 있다</li></ul><p>복사된 코드는 완전히 분리되므로 한곳을 위해 다른 곳을 손상시킬 위험이 없기 때문에 실험과 변경이 더 안전 하다</p><h2 id="확장성을-통한-추가에-의한-변경"><a href="#확장성을-통한-추가에-의한-변경" class="headerlink" title="확장성을 통한 추가에 의한 변경"></a>확장성을 통한 추가에 의한 변경</h2><p>코드를 추가하는 또 다른 방법은 확장성을 이용하는것</p><ul><li>우발적 복잡성 : 도메인에 관련 되지 않은 복잡성</li><li>본질적 복잡성 : 도메인으로 부터 상속된 일부 복잡성</li></ul><h2 id="추가에-의한-변경으로-이전-버전과의-호환성-확보"><a href="#추가에-의한-변경으로-이전-버전과의-호환성-확보" class="headerlink" title="추가에 의한 변경으로 이전 버전과의 호환성 확보"></a>추가에 의한 변경으로 이전 버전과의 호환성 확보</h2><p>어떤 버전이 최신 버전인지 쉽게 알 수 있도록 일관된 명명 체계를 사용하는 것이 좋다</p><h2 id="기능-토글-켜기-x2F-끄기-로-추가에-의한-변경"><a href="#기능-토글-켜기-x2F-끄기-로-추가에-의한-변경" class="headerlink" title="기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경"></a>기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경</h2><p>기능 토글의 이면에 있는 개념 : 최소 요구사항은 컴파일이 되어야 된다</p><h2 id="‘추상화를-통한-분기’로-추가에-의한-변경"><a href="#‘추상화를-통한-분기’로-추가에-의한-변경" class="headerlink" title="‘추상화를 통한 분기’로 추가에 의한 변경"></a>‘추상화를 통한 분기’로 추가에 의한 변경</h2><p>클래스로 타입 코드 대체 패턴을 사용해서 추상화를 통한 분기를 사용한다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장: 코드 삭제의 미학</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</guid>
      <pubDate>Thu, 28 Dec 2023 00:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-코드-삭제의-미학&quot;&gt;&lt;a href=&quot;#9장-코드-삭제의-미학&quot; class=&quot;headerlink&quot; title=&quot;9장: 코드 삭제의 미학&quot;&gt;&lt;/a&gt;9장: 코드 삭제의 미학&lt;/h1&gt;&lt;p&gt;시간이나 노력을 들였기 때문에 어떤 것에 가치를 부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-코드-삭제의-미학"><a href="#9장-코드-삭제의-미학" class="headerlink" title="9장: 코드 삭제의 미학"></a>9장: 코드 삭제의 미학</h1><p>시간이나 노력을 들였기 때문에 어떤 것에 가치를 부여하는 것을 메몰 비용의 오류(sunk-cost fallacy)라고 합니다.</p><p>단 한 가지만 말하라면 바로 적은 것이 더 낫다</p><h2 id="다음-시대는-코드를-지우는-시대일-것이다"><a href="#다음-시대는-코드를-지우는-시대일-것이다" class="headerlink" title="다음 시대는 코드를 지우는 시대일 것이다"></a>다음 시대는 코드를 지우는 시대일 것이다</h2><p>우리는 아직 코드 삭제에 익숙하지 않는다 이것이 다음에 해결해야 할 큰 과제 라고 생각한다</p><h2 id="복잡성을-제거하기-위한-코드-삭제"><a href="#복잡성을-제거하기-위한-코드-삭제" class="headerlink" title="복잡성을 제거하기 위한 코드 삭제"></a>복잡성을 제거하기 위한 코드 삭제</h2><p>기능을 추가하고 테스트를 수행하며 다 많은 코너 케이스(복합 경계 조건)을 처리함에 따라 시간이 지날수록 성장하는 것이 바로 시스템 특징</p><ul><li>도메인 복잡성: 도메인이 기본적으로 가지고 있는것</li><li>부수적 복잡성: 도메인이 요구하지 않았지만 우연히 추가된 모든 복잡성</li></ul><h3 id="경험-부족으로-인한-기술적-무지"><a href="#경험-부족으로-인한-기술적-무지" class="headerlink" title="경험 부족으로 인한 기술적 무지"></a>경험 부족으로 인한 기술적 무지</h3><p>기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상된다</p><p>공동 프로그래밍 : 모든 아이디어가 코드에 적용되기 전에 다른 사람의 두뇌를 거쳐야 한다</p><h3 id="시간-압박으로-인한-기술적-낭비"><a href="#시간-압박으로-인한-기술적-낭비" class="headerlink" title="시간 압박으로 인한 기술적 낭비"></a>시간 압박으로 인한 기술적 낭비</h3><p>부수적 복잡성의 가장 단순한 유형은 기술적 낭비의 가장 일반적인것은 시간 압박에서 시작된다</p><h3 id="환경에-따른-기술적-부채"><a href="#환경에-따른-기술적-부채" class="headerlink" title="환경에 따른 기술적 부채"></a>환경에 따른 기술적 부채</h3><p>기술부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것</p><h3 id="성장에-따른-기술적-장애물"><a href="#성장에-따른-기술적-장애물" class="headerlink" title="성장에 따른 기술적 장애물"></a>성장에 따른 기술적 장애물</h3><p>기술적 장애물(technical drag)dms roqkfdmf ejelrp aksemsms ahems rjt</p><p>사용하지 않으면 기능은 퇴화한다</p><h2 id="친밀도에-따른-코드-분류"><a href="#친밀도에-따른-코드-분류" class="headerlink" title="친밀도에 따른 코드 분류"></a>친밀도에 따른 코드 분류</h2><p>댄 노스는 약 6주가 지나면 코드가 알 수 없는 범주로 빠르게 이동하면서 해당 코드와 친밀도가 떨어지기 시작한다고 사례를 들어 주장함<br>유지 시간의 한계가 몇 개월이 아닌 몇주 단위여야 한다</p><h2 id="레거시-시스템에서의-코드-삭제"><a href="#레거시-시스템에서의-코드-삭제" class="headerlink" title="레거시 시스템에서의 코드 삭제"></a>레거시 시스템에서의 코드 삭제</h2><p>레거시 코드의 일반적인 정의는 수정하기가 겁나는 코드(서커스 팩터 circus factor 의 결과)이다</p><h3 id="스트랭글러-무화과나무-패턴"><a href="#스트랭글러-무화과나무-패턴" class="headerlink" title="스트랭글러 무화과나무 패턴"></a>스트랭글러 무화과나무 패턴</h3><p>숙주는 레거시 시스템</p><h3 id="코드-개선을-위한-스트랭글러-무화과나무-패턴-사용"><a href="#코드-개선을-위한-스트랭글러-무화과나무-패턴-사용" class="headerlink" title="코드 개선을 위한 스트랭글러 무화과나무 패턴 사용"></a>코드 개선을 위한 스트랭글러 무화과나무 패턴 사용</h3><p>호출의 빈도는 일반적으로 그것이 얼마나 중요한지를 나타내는 좋은 지표</p><h2 id="동결된-프로젝트에서-코드-삭제"><a href="#동결된-프로젝트에서-코드-삭제" class="headerlink" title="동결된 프로젝트에서 코드 삭제"></a>동결된 프로젝트에서 코드 삭제</h2><p>코드에는 사용하지 않는 다는 표시가 없어서 변경할때 마다 고려하고 유지 해야 한다</p><h3 id="바람직한-결과를-기본값으로-설정"><a href="#바람직한-결과를-기본값으로-설정" class="headerlink" title="바람직한 결과를 기본값으로 설정"></a>바람직한 결과를 기본값으로 설정</h3><p>유지기간을 정해 놓고 그 기간이 지나면 코드를 삭제한다</p><h3 id="스파이크와-스태빌라이즈-안정화-로-낭비-줄이기"><a href="#스파이크와-스태빌라이즈-안정화-로-낭비-줄이기" class="headerlink" title="스파이크와 스태빌라이즈(안정화)로 낭비 줄이기"></a>스파이크와 스태빌라이즈(안정화)로 낭비 줄이기</h3><p>빠르게 구현하고 코드를 얼마나 사용하는지 측정하고 사용하면 유지하고 사용하지 않으면 삭제한다</p><h2 id="버전-관리에서-브랜치-삭제"><a href="#버전-관리에서-브랜치-삭제" class="headerlink" title="버전 관리에서 브랜치 삭제"></a>버전 관리에서 브랜치 삭제</h2><p>브랜치는 시간이 지나면 축적되는데 이것은 불필요한 복잡성을 추가한다</p><h3 id="브랜치-제한으로-낭비-최소화"><a href="#브랜치-제한으로-낭비-최소화" class="headerlink" title="브랜치 제한으로 낭비 최소화"></a>브랜치 제한으로 낭비 최소화</h3><p>협업 방법인 칸반을 적용할수 있다</p><h2 id="코드-문서-삭제"><a href="#코드-문서-삭제" class="headerlink" title="코드 문서 삭제"></a>코드 문서 삭제</h2><p>문서는 정확히 3가지 조건을 충족해야 함</p><ul><li>관련성</li><li>정확성</li><li>발견 가능성</li></ul><h3 id="지식을-문서화하는-방법을-결정하는-알고리즘"><a href="#지식을-문서화하는-방법을-결정하는-알고리즘" class="headerlink" title="지식을 문서화하는 방법을 결정하는 알고리즘"></a>지식을 문서화하는 방법을 결정하는 알고리즘</h3><p>문서화하는 것이 의미가 있는지 여부 결정</p><ul><li>문서화 대상이 자주 바뀌지 않는지</li><li>드물게 사용하는 경우 문서화</li><li>자동화 할수 있음 자동화</li><li>아니면 외워라</li></ul><h2 id="테스트-코드-삭제"><a href="#테스트-코드-삭제" class="headerlink" title="테스트 코드 삭제"></a>테스트 코드 삭제</h2><h3 id="낙관적-테스트-삭제"><a href="#낙관적-테스트-삭제" class="headerlink" title="낙관적 테스트 삭제"></a>낙관적 테스트 삭제</h3><p>항상 참인 것은 삭제 해라</p><h3 id="비관적-테스트-삭제"><a href="#비관적-테스트-삭제" class="headerlink" title="비관적 테스트 삭제"></a>비관적 테스트 삭제</h3><p>항상 거짓인 것은 삭제 해라</p><h3 id="불안정-테스트-수정-또는-삭제"><a href="#불안정-테스트-수정-또는-삭제" class="headerlink" title="불안정 테스트 수정 또는 삭제"></a>불안정 테스트 수정 또는 삭제</h3><p>성공 실패를 반복하면서 예측할수 없는 테스트(불안정 테스트)는 삭제해라</p><h3 id="복잡한-테스트를-제거하기-위한-코드-리팩터링"><a href="#복잡한-테스트를-제거하기-위한-코드-리팩터링" class="headerlink" title="복잡한 테스트를 제거하기 위한 코드 리팩터링"></a>복잡한 테스트를 제거하기 위한 코드 리팩터링</h3><p>테스트를 리팩터링해야 한다는 것은 테스트 중인 코드에 적절한 아키텍처가 없다는 것</p><h3 id="속도를-높이는-테스트-문화"><a href="#속도를-높이는-테스트-문화" class="headerlink" title="속도를 높이는 테스트 문화"></a>속도를 높이는 테스트 문화</h3><p>느린 테스트와 빠른 테스트를 구분하고 가능한 자주 빠른 테스트를 진행하라</p><h2 id="설정-코드-삭제"><a href="#설정-코드-삭제" class="headerlink" title="설정 코드 삭제"></a>설정 코드 삭제</h2><p>완벽하게 만들 수 없다면 최소한 설정이 가능하게 만들어라</p><h3 id="설정의-예상-수명으로-범위-지정"><a href="#설정의-예상-수명으로-범위-지정" class="headerlink" title="설정의 예상 수명으로 범위 지정"></a>설정의 예상 수명으로 범위 지정</h3><ul><li>실험을 위한 설정 : 베타 테스트 또는 A&#x2F;B 테스트</li><li>과도기 적인 설정 : 릴리즈와 뱊호를 연결하는 것</li><li>영구적인 설정 : 사용량을 증가시키거나 유지보수가 간편해야 하기 때문에 특별하다<h2 id="라이브러리-제거를-위한-코드-삭제"><a href="#라이브러리-제거를-위한-코드-삭제" class="headerlink" title="라이브러리 제거를 위한 코드 삭제"></a>라이브러리 제거를 위한 코드 삭제</h2></li></ul><p>라이브러리를 사용하는것은 양날의 검</p><h3 id="외부-라이브러리에-대한-의존도-제한"><a href="#외부-라이브러리에-대한-의존도-제한" class="headerlink" title="외부 라이브러리에 대한 의존도 제한"></a>외부 라이브러리에 대한 의존도 제한</h3><p>고통스러울수록 더 시도하라</p><h2 id="작동-중인-기능에서-코드-삭제"><a href="#작동-중인-기능에서-코드-삭제" class="headerlink" title="작동 중인 기능에서 코드 삭제"></a>작동 중인 기능에서 코드 삭제</h2><p>코드는 부채이다 코드를 삭제하면 부채를 감소시킬수 있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장: 주석 자제하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</guid>
      <pubDate>Wed, 27 Dec 2023 05:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-주석-자제하기&quot;&gt;&lt;a href=&quot;#8장-주석-자제하기&quot; class=&quot;headerlink&quot; title=&quot;8장: 주석 자제하기&quot;&gt;&lt;/a&gt;8장: 주석 자제하기&lt;/h1&gt;&lt;p&gt;메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-주석-자제하기"><a href="#8장-주석-자제하기" class="headerlink" title="8장: 주석 자제하기"></a>8장: 주석 자제하기</h1><p>메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지 않는 주석을 대상으로 함</p><p>주석을 없에는것이 좋을수 있는 이유</p><ul><li>코드가 명확하고 좋은 타입명과 변수명을 사용하는 경우</li><li>주석은 컴파일러가 확인하지 않으므로 특히 코드가 수정된 후에는 주석이 맞다고 보장할 수 없다</li></ul><p>주석이 스멜을 가진 코드 위에 탈취제처럼 자주 사용된다 주석을 달기보다 코드를 정리해야 된다</p><p>일반적인 문제는 이해할 수 없는 코드를 작성한 작성자가 주석으로 어떻게든 명확하고 분명하게 표현할 수 있다고 생각한다는 것</p><p>코드가 표현할 수 없는 것만 주석으로 처리하십시오</p><h2 id="오래된-주석-제거"><a href="#오래된-주석-제거" class="headerlink" title="오래된 주석 제거"></a>오래된 주석 제거</h2><p>해당 주석은 잘못된 정보를 제공하거나 이해하는데 더 방해를 한다</p><h2 id="주석-처리된-코드-제거"><a href="#주석-처리된-코드-제거" class="headerlink" title="주석 처리된 코드 제거"></a>주석 처리된 코드 제거</h2><p>버전 관리를 하기 때문에 주석으로 코드를 관리 할 필요가 더이상 불필요하다</p><h2 id="불필요한-주석-제거"><a href="#불필요한-주석-제거" class="headerlink" title="불필요한 주석 제거"></a>불필요한 주석 제거</h2><p>코드가 주석만큼 읽기 쉬울때 해당 주석을 불필요한 주석이라고 한다</p><h2 id="메서드의-이름으로-주석-대신하기"><a href="#메서드의-이름으로-주석-대신하기" class="headerlink" title="메서드의 이름으로 주석 대신하기"></a>메서드의 이름으로 주석 대신하기</h2><p>일부 주석은 기능보다는 코드를 문서화한다. 메서드 명으로 해당 주석을 대신한다</p><h3 id="계획을-위한-주석-사용"><a href="#계획을-위한-주석-사용" class="headerlink" title="계획을 위한 주석 사용"></a>계획을 위한 주석 사용</h3><p>주석으로 계획을 세울수도 있지만 구현후에는 불필요한 주석일수 있다</p><h2 id="불변속성을-문서화한-주석-유지"><a href="#불변속성을-문서화한-주석-유지" class="headerlink" title="불변속성을 문서화한 주석 유지"></a>불변속성을 문서화한 주석 유지</h2><ul><li><p>주석을 코드를 바꿀수 있는지?</p></li><li><p>검증하기 위한 자동화된 테스트를 만들 수 있는지?</p></li><li><p>위에 두개를 모두 실행할수 없으면 주석을 유지해야 한다</p></li></ul><h3 id="프로세스의-불변속성"><a href="#프로세스의-불변속성" class="headerlink" title="프로세스의 불변속성"></a>프로세스의 불변속성</h3><p>나무를 심기에 가장 좋은 때는 20년 전이었다. 두 번째로 좋은 때는 바로 지금이다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장: 컴파일러와의 협업</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/</guid>
      <pubDate>Wed, 27 Dec 2023 04:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;7장-컴파일러와의-협업&quot;&gt;&lt;a href=&quot;#7장-컴파일러와의-협업&quot; class=&quot;headerlink&quot; title=&quot;7장: 컴파일러와의 협업&quot;&gt;&lt;/a&gt;7장: 컴파일러와의 협업&lt;/h1&gt;&lt;p&gt;컴파일러에 익숙해지면 컴파일러와 함께 정확성에 대한
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="7장-컴파일러와의-협업"><a href="#7장-컴파일러와의-협업" class="headerlink" title="7장: 컴파일러와의 협업"></a>7장: 컴파일러와의 협업</h1><p>컴파일러에 익숙해지면 컴파일러와 함께 정확성에 대한 책임을 공유함으로써 컴파일러를 팀원으로 받아들이고 컴파일러가 소프트웨어를 제대로 빌드하는데 도움이 되게 해야 된다</p><h2 id="컴파일러에-대해-알아보기"><a href="#컴파일러에-대해-알아보기" class="headerlink" title="컴파일러에 대해 알아보기"></a>컴파일러에 대해 알아보기</h2><p>컴파일러는 의심이 가면 물어보라 라는 일번적인 관용구를 따른다</p><h3 id="약점-정지-문제는-컴파일-시-알-수-있는-것을-제한한다"><a href="#약점-정지-문제는-컴파일-시-알-수-있는-것을-제한한다" class="headerlink" title="약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다"></a>약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다</h3><p>런타임 동안 어떤 일이 일어날지 정확히 말할 수 없는 이유를 정지문제(halting problem)라고 한다</p><p>일반적으로 프로그램은 근본적으로 예측이 불가능하다</p><p>컴파일러는 프로그램이 안전하다고 보장할 수 없는 경우 허용하지 않습니다 이를 보수적 분성(conservative analysis)이라고 한다</p><h3 id="장점-도달성-검증은-메서드의-반환을-보장한다"><a href="#장점-도달성-검증은-메서드의-반환을-보장한다" class="headerlink" title="장점: 도달성 검증은 메서드의 반환을 보장한다"></a>장점: 도달성 검증은 메서드의 반환을 보장한다</h3><p>switch문의 경우 모든 case문이 컴파일러에 의해 도달 가능한지 검사한다 이를 완전 검사(exhaustive check)라고 한다</p><h3 id="장점-확정-할당은-초기화되지-않은-변수에-대한-접근을-막는다"><a href="#장점-확정-할당은-초기화되지-않은-변수에-대한-접근을-막는다" class="headerlink" title="장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다"></a>장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다</h3><p>확정 할당 분석(definite assignment analysis)은 변수가 초기화되지 않은 상태로 사용되는지 검사한다</p><h3 id="장점-접근-제어로-데이터-캡슐화를-지원한다"><a href="#장점-접근-제어로-데이터-캡슐화를-지원한다" class="headerlink" title="장점: 접근 제어로 데이터 캡슐화를 지원한다"></a>장점: 접근 제어로 데이터 캡슐화를 지원한다</h3><p>민감한 메서드가 있을 경우 접근 제어자를 사용하여 외부에서 접근하지 못하게 할 수 있다</p><h3 id="장점-타입-형-검사기는-속성을-보증한다"><a href="#장점-타입-형-검사기는-속성을-보증한다" class="headerlink" title="장점: 타입(형) 검사기는 속성을 보증한다"></a>장점: 타입(형) 검사기는 속성을 보증한다</h3><ul><li>대여타입(Rust)</li><li>다형성 타입 유추(Ocaml, F#)</li><li>타입 클래스(하스켈)</li><li>유니언 타입과 교차 타입(타입스크립트)</li><li>종속 타입(coq 와 Agda)</li></ul><h3 id="약점-null을-역참조하면-애플리케이션이-손상된다"><a href="#약점-null을-역참조하면-애플리케이션이-손상된다" class="headerlink" title="약점: null을 역참조하면 애플리케이션이 손상된다"></a>약점: null을 역참조하면 애플리케이션이 손상된다</h3><p>너무 적게 확인하는 것보다 너무 많이 확인하는 것이 낫다</p><h3 id="약점-산술-오류는-오버플로나-손상을-일으킨다"><a href="#약점-산술-오류는-오버플로나-손상을-일으킨다" class="headerlink" title="약점: 산술 오류는 오버플로나 손상을 일으킨다"></a>약점: 산술 오류는 오버플로나 손상을 일으킨다</h3><p>0으로 나누기 또는 나머지 연산 이를 산술적 오류(arithmetic error)라고 한다</p><h3 id="약점-아웃-오브-바운드-오류는-애플리케이션을-손상시킨다"><a href="#약점-아웃-오브-바운드-오류는-애플리케이션을-손상시킨다" class="headerlink" title="약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다"></a>약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다</h3><p>범위네 있지 않은 인덱스에 접근하려고 하면 아웃-오브-바운드 오류(out-of-bounds error)가 발생한다</p><h3 id="무한루프는-애플리케이션을-지연시킨다"><a href="#무한루프는-애플리케이션을-지연시킨다" class="headerlink" title="무한루프는 애플리케이션을 지연시킨다"></a>무한루프는 애플리케이션을 지연시킨다</h3><p>컴파일러는 해당 값을 찾아 내지 못한다</p><h3 id="약점-교착-상태-및-경쟁-상태로-인해-의도하지-않은-동작이-발생한다"><a href="#약점-교착-상태-및-경쟁-상태로-인해-의도하지-않은-동작이-발생한다" class="headerlink" title="약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다"></a>약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다</h3><p>멀티스레딩에서 비롯됨 변경 가능한 데이터를 공유하는 여러 스레드가 있으면 문제의 홍수가 발생함</p><h2 id="컴파일러-사용"><a href="#컴파일러-사용" class="headerlink" title="컴파일러 사용"></a>컴파일러 사용</h2><p>소프트웨어 개발과 건축을 비유하긴 하는데 우리 분야에서 가장 해로운 비유 프로그래밍은 건축이 아닌 여러 단계의 커뮤니케이션</p><ul><li>컴퓨터와 의사소통(코드를 짤때)</li><li>다른 개발자와 의사소통(코드를 읽을때)</li><li>컴파일러와 의사소통(코드를 컴파일할때)</li></ul><p>데이터 구조는 시간이 정지된 알고리즘이다</p><h3 id="컴파일러-활용"><a href="#컴파일러-활용" class="headerlink" title="컴파일러 활용"></a>컴파일러 활용</h3><ul><li>컴파일러 TODO 리스트로 안정성 확보</li><li>순서 강제화를 이용한 안정성 확보</li><li>캡슐화를 강제를 통한 안정성 확보</li><li>컴파일러로 사용하지 않는 코드 감지</li><li>확정 값을 통한 안정성 확보</li></ul><h3 id="컴파일러와-싸우지-말-것"><a href="#컴파일러와-싸우지-말-것" class="headerlink" title="컴파일러와 싸우지 말 것"></a>컴파일러와 싸우지 말 것</h3><ul><li>타입</li><li>형 변환</li><li>동적 타입</li><li>런타임 타입</li><li>게으름</li><li>기본값</li><li>상속</li><li>처리를 강제하지 않은 예외</li><li>아키텍처</li></ul><h2 id="컴파일러-신뢰하기"><a href="#컴파일러-신뢰하기" class="headerlink" title="컴파일러 신뢰하기"></a>컴파일러 신뢰하기</h2><p>컴파일러에게 해준 만큼 돌려받을수 있다</p><h3 id="컴파일러에게-불변속성-가르치기"><a href="#컴파일러에게-불변속성-가르치기" class="headerlink" title="컴파일러에게 불변속성 가르치기"></a>컴파일러에게 불변속성 가르치기</h3><p>이길수 없으면 같은 편으로 만들어라</p><h3 id="컴파일러의-경고에-주의를-기울일-것"><a href="#컴파일러의-경고에-주의를-기울일-것" class="headerlink" title="컴파일러의 경고에 주의를 기울일 것"></a>컴파일러의 경고에 주의를 기울일 것</h3><p>정보 피로(alarm fatigue)는 경고를 무시하게 만든다</p><h2 id="컴파일러만-신뢰할-것"><a href="#컴파일러만-신뢰할-것" class="headerlink" title="컴파일러만 신뢰할 것"></a>컴파일러만 신뢰할 것</h2><p>만일 당신이 이 방에서 가장 똑똑한 사람이라면 당신은 잘못된 방에 있는 것이다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장: 데이터 보호</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/</guid>
      <pubDate>Wed, 27 Dec 2023 01:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;6장-데이터-보호&quot;&gt;&lt;a href=&quot;#6장-데이터-보호&quot; class=&quot;headerlink&quot; title=&quot;6장: 데이터 보호&quot;&gt;&lt;/a&gt;6장: 데이터 보호&lt;/h1&gt;&lt;p&gt;데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="6장-데이터-보호"><a href="#6장-데이터-보호" class="headerlink" title="6장: 데이터 보호"></a>6장: 데이터 보호</h1><p>데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지역에만 영향을 주게 만드는데 중점</p><h2 id="getter-없이-캡슐화하기"><a href="#getter-없이-캡슐화하기" class="headerlink" title="getter 없이 캡슐화하기"></a>getter 없이 캡슐화하기</h2><h3 id="규칙-getter와-setter를-사용하지-말-것"><a href="#규칙-getter와-setter를-사용하지-말-것" class="headerlink" title="규칙: getter와 setter를 사용하지 말 것"></a>규칙: getter와 setter를 사용하지 말 것</h3><p>부울(Boolean)이 아닌 필드에 setter나 getter를 사용하지 말 것</p><p>필드를 비공개로 하는 것의 가장 큰 장점은 그렇게 하는 것이 푸시 기반(push-base) 아키텍처를 장려하기 때문</p><p>디미터 법칙에서 유래</p><h3 id="규칙-적용하기"><a href="#규칙-적용하기" class="headerlink" title="규칙 적용하기"></a>규칙 적용하기</h3><h3 id="리팩터링-패턴-getter와-setter-제거하기"><a href="#리팩터링-패턴-getter와-setter-제거하기" class="headerlink" title="리팩터링 패턴: getter와 setter 제거하기"></a>리팩터링 패턴: getter와 setter 제거하기</h3><p>기능을 데이터에 더 가깝게 이동하여 getter와 setter를 제거할수 있다</p><h3 id="마지막-getter-삭제"><a href="#마지막-getter-삭제" class="headerlink" title="마지막 getter 삭제"></a>마지막 getter 삭제</h3><h2 id="간단한-데이터-캡슐화하기"><a href="#간단한-데이터-캡슐화하기" class="headerlink" title="간단한 데이터 캡슐화하기"></a>간단한 데이터 캡슐화하기</h2><h3 id="규칙-공통-접사를-사용하지-말-것"><a href="#규칙-공통-접사를-사용하지-말-것" class="headerlink" title="규칙: 공통 접사를 사용하지 말 것"></a>규칙: 공통 접사를 사용하지 말 것</h3><p>코드에 공통 접두사나 접미사가 있는 메서드나 변수가 없어야 된다</p><p>클래스를 사용해서 메서드와 변수를 그룹하하면 공통 접두사나 접미사를 제거할 수 있다</p><p>단일 책임 원칙을 따르는 클래스를 만들어야 한다</p><h3 id="리팩터링-패턴-데이터-캡슐화"><a href="#리팩터링-패턴-데이터-캡슐화" class="headerlink" title="리팩터링 패턴: 데이터 캡슐화"></a>리팩터링 패턴: 데이터 캡슐화</h3><p>변수와 메서드를 클래스로 옴기는 작업</p><h2 id="순서에-존재하는-불변속성-제거하기"><a href="#순서에-존재하는-불변속성-제거하기" class="headerlink" title="순서에 존재하는 불변속성 제거하기"></a>순서에 존재하는 불변속성 제거하기</h2><p>무언가가 다른 것보다 먼저 호출되어야 할때 그것을 순서 불변속성(sequence invariance)이라고 한다</p><h3 id="리팩터링-패턴-순서-강제화"><a href="#리팩터링-패턴-순서-강제화" class="headerlink" title="리팩터링 패턴: 순서 강제화"></a>리팩터링 패턴: 순서 강제화</h3><p>생성자를 먼저 호출하지 않는 것은 불가능 하기 때문에 이불변속성이 제거된다 이 리팩터링을 순서 강제화라고 한다</p><h2 id="열거형을-제거하는-또-다른-방법"><a href="#열거형을-제거하는-또-다른-방법" class="headerlink" title="열거형을 제거하는 또 다른 방법"></a>열거형을 제거하는 또 다른 방법</h2><h3 id="비공개-생성자를-통한-열거"><a href="#비공개-생성자를-통한-열거" class="headerlink" title="비공개 생성자를 통한 열거"></a>비공개 생성자를 통한 열거</h3><h3 id="숫자를-클래스에-다시-매핑하기"><a href="#숫자를-클래스에-다시-매핑하기" class="headerlink" title="숫자를 클래스에 다시 매핑하기"></a>숫자를 클래스에 다시 매핑하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li><li><a href="https://github.com/Neppord/FantasyBattle-Refactoring-Kata">Fantasy Battle Refactoring Kata</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장: 유사한 코드 융합하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/</guid>
      <pubDate>Wed, 27 Dec 2023 00:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;5장-유사한-코드-융합하기&quot;&gt;&lt;a href=&quot;#5장-유사한-코드-융합하기&quot; class=&quot;headerlink&quot; title=&quot;5장: 유사한 코드 융합하기&quot;&gt;&lt;/a&gt;5장: 유사한 코드 융합하기&lt;/h1&gt;&lt;h2 id=&quot;유사한-클래스-통합하기&quot;&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="5장-유사한-코드-융합하기"><a href="#5장-유사한-코드-융합하기" class="headerlink" title="5장: 유사한 코드 융합하기"></a>5장: 유사한 코드 융합하기</h1><h2 id="유사한-클래스-통합하기"><a href="#유사한-클래스-통합하기" class="headerlink" title="유사한 클래스 통합하기"></a>유사한 클래스 통합하기</h2><h3 id="리팩터링-패턴-유사-클래스-통합"><a href="#리팩터링-패턴-유사-클래스-통합" class="headerlink" title="리팩터링 패턴: 유사 클래스 통합"></a>리팩터링 패턴: 유사 클래스 통합</h3><p>일련의 상수 메서드를 공통으로 가진 두개 이상의 클래스에서 이 일련의 상수 메서드가 클래스에 따라 다른 값을 반환 할 때마다<br>이 리팩터링 패턴을 사용해 통합할수 있다</p><h2 id="단순한-조건-통합하기"><a href="#단순한-조건-통합하기" class="headerlink" title="단순한 조건 통합하기"></a>단순한 조건 통합하기</h2><p>단순한 조건은 통합한다 이건 어떠한 판단을 하지 않아도 처리할수 있는 리팩토링이다</p><h3 id="리팩터링-패턴-if-문-결합"><a href="#리팩터링-패턴-if-문-결합" class="headerlink" title="리팩터링 패턴: if 문 결합"></a>리팩터링 패턴: if 문 결합</h3><p>연속적인 if문을 결합해서 통합한다 || 연산자를 사용해서 통합한다</p><h2 id="복잡한-조건-통합하기"><a href="#복잡한-조건-통합하기" class="headerlink" title="복잡한 조건 통합하기"></a>복잡한 조건 통합하기</h2><h3 id="조건을-위한-산술-규칙-사용"><a href="#조건을-위한-산술-규칙-사용" class="headerlink" title="조건을 위한 산술 규칙 사용"></a>조건을 위한 산술 규칙 사용</h3><p>|| 연산자는 + 처럼 동작하고 &amp;&amp; 연산자는 * 처럼 동작한다</p><p>그렇게 생각하면 결합법칙, 교환법칙, 분배법칙을 고려할수 있다</p><h3 id="규칙-순수-조건-사용"><a href="#규칙-순수-조건-사용" class="headerlink" title="규칙: 순수 조건 사용"></a>규칙: 순수 조건 사용</h3><p>조건은 항상 순수 조건이어야 한다 순수라는 말은 조건에 부수적인 동작이 없다는 뜻이다</p><p>명령에서 질의 분리라는 일반적인 스멜에서 비론된다</p><h3 id="조건-산술-적용"><a href="#조건-산술-적용" class="headerlink" title="조건 산술 적용"></a>조건 산술 적용</h3><p>익숙한 산술 법칙을 사용해서 단순화 하고 다시 코드를 변환할수 있다</p><h2 id="클래스-간의-코드-통합"><a href="#클래스-간의-코드-통합" class="headerlink" title="클래스 간의 코드 통합"></a>클래스 간의 코드 통합</h2><h3 id="클래스-관계를-묘사하기-위한-UML-클래스-다이어그램-소개"><a href="#클래스-관계를-묘사하기-위한-UML-클래스-다이어그램-소개" class="headerlink" title="클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개"></a>클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개</h3><p>전체 프로그램에 대한 클래스 다이어그램을 만드는 것은 순식간에 거대해져서 도움이 되지 않는다<br>주로 디자인 패턴이나 소프트웨어 아키텍처의 작은 부분을 설명하는데 사용하기 때문에 중요한 메서드만 포함한다</p><h3 id="리팩터링-패턴-전략-패턴의-도입"><a href="#리팩터링-패턴-전략-패턴의-도입" class="headerlink" title="리팩터링 패턴: 전략 패턴의 도입"></a>리팩터링 패턴: 전략 패턴의 도입</h3><p>많은 패턴이 전략 패턴의 다른 형태이다 전략이 필드를 가지고 있는 경우 이를 상태 패턴이라고 한다</p><h3 id="규칙-구현체가-하나뿐인-인터페이스를-만들지-말-것"><a href="#규칙-구현체가-하나뿐인-인터페이스를-만들지-말-것" class="headerlink" title="규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것"></a>규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것</h3><p>구현 클래스가 하나밖에 없는 인터페이스는 가독성에 도움이 되지 않는다<br>인터페이스는 변형을 전제로 하는데 아무것도 없다면 오히려 가독성을 방해할수 있다</p><p>구현클래스를 수정하는 경우 인터페이스도 수정해야 해서 오버헤드를 발생시킨다</p><h3 id="리팩터링-패턴-구현에서-인터페이스-추출"><a href="#리팩터링-패턴-구현에서-인터페이스-추출" class="headerlink" title="리팩터링 패턴: 구현에서 인터페이스 추출"></a>리팩터링 패턴: 구현에서 인터페이스 추출</h3><p>단순한 리팩터링 인터페이스를 만드는 것을 필요할때 까지 연기할수 있어서 유용하다</p><h2 id="유사-함수-통합하기"><a href="#유사-함수-통합하기" class="headerlink" title="유사 함수 통합하기"></a>유사 함수 통합하기</h2><h2 id="유사한-코드-통합하기"><a href="#유사한-코드-통합하기" class="headerlink" title="유사한 코드 통합하기"></a>유사한 코드 통합하기</h2><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장: 타입 코드 처리하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/</guid>
      <pubDate>Tue, 26 Dec 2023 05:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;4장-타입-코드-처리하기&quot;&gt;&lt;a href=&quot;#4장-타입-코드-처리하기&quot; class=&quot;headerlink&quot; title=&quot;4장: 타입 코드 처리하기&quot;&gt;&lt;/a&gt;4장: 타입 코드 처리하기&lt;/h1&gt;&lt;h2 id=&quot;간단한-if-문-리팩터링&quot;&gt;&lt;a h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="4장-타입-코드-처리하기"><a href="#4장-타입-코드-처리하기" class="headerlink" title="4장: 타입 코드 처리하기"></a>4장: 타입 코드 처리하기</h1><h2 id="간단한-if-문-리팩터링"><a href="#간단한-if-문-리팩터링" class="headerlink" title="간단한 if 문 리팩터링"></a>간단한 if 문 리팩터링</h2><h3 id="규칙-if-문에서-else를-사용하지-말-것"><a href="#규칙-if-문에서-else를-사용하지-말-것" class="headerlink" title="규칙: if 문에서 else를 사용하지 말 것"></a>규칙: if 문에서 else를 사용하지 말 것</h3><p>결정은 어렵다 if문은 검사 로 간주 if-else 를 사용하면 의사결정으로 간주</p><h3 id="규칙-적용"><a href="#규칙-적용" class="headerlink" title="규칙 적용"></a>규칙 적용</h3><p>클래스로 타입 코드 대체 한다</p><h3 id="리팩터링-패턴-클래스로-타입-코드-대체"><a href="#리팩터링-패턴-클래스로-타입-코드-대체" class="headerlink" title="리팩터링 패턴: 클래스로 타입 코드 대체"></a>리팩터링 패턴: 클래스로 타입 코드 대체</h3><p>클래스로 타입 코드를 바꾼다</p><h3 id="클래스로-코드-이관하기"><a href="#클래스로-코드-이관하기" class="headerlink" title="클래스로 코드 이관하기"></a>클래스로 코드 이관하기</h3><p>클래스로 메소드를 이관 시키면 if문을 제거 할수 있다</p><h3 id="리팩터링-패턴-클래스로의-코드-이관"><a href="#리팩터링-패턴-클래스로의-코드-이관" class="headerlink" title="리팩터링 패턴: 클래스로의 코드 이관"></a>리팩터링 패턴: 클래스로의 코드 이관</h3><p>클래스로 타입코드 대체 패턴의 자연스러운 연장선</p><h3 id="불필요한-메서드-인라인화"><a href="#불필요한-메서드-인라인화" class="headerlink" title="불필요한 메서드 인라인화"></a>불필요한 메서드 인라인화</h3><p>함수를 호출하는 곳으로 변경 처리 </p><p>메서드 인라인화 패턴은 매서드 추출과 정확히 반대</p><h3 id="리팩터링-패턴-메서드의-인라인화"><a href="#리팩터링-패턴-메서드의-인라인화" class="headerlink" title="리팩터링 패턴: 메서드의 인라인화"></a>리팩터링 패턴: 메서드의 인라인화</h3><p>메서드 인라인화를 수행할 때는 모든 호출 측을 수정하여 원래 메서드를 제거 해야 한다</p><p>호출 또는 전달 한가지만 할것</p><h2 id="긴-if-문의-리팩터링"><a href="#긴-if-문의-리팩터링" class="headerlink" title="긴 if 문의 리팩터링"></a>긴 if 문의 리팩터링</h2><p>메서드를 클래스로 이관하고 메서드를 전문화 시킨다</p><ul><li>일반성 제거</li><li>리팩터링 패턴: 메서드 전문화<h3 id="규칙-switch를-사용하지-말-것"><a href="#규칙-switch를-사용하지-말-것" class="headerlink" title="규칙: switch를 사용하지 말 것"></a>규칙: switch를 사용하지 말 것</h3></li></ul><p>default 케이스가 없고 모든 case에 반환값이 있는 경우가 아니라면 switch문은 사용하지 말아야 한다</p><h3 id="if-제거하기"><a href="#if-제거하기" class="headerlink" title="if 제거하기"></a>if 제거하기</h3><h2 id="코드-중복-처리"><a href="#코드-중복-처리" class="headerlink" title="코드 중복 처리"></a>코드 중복 처리</h2><h3 id="인터페이스-대신-추상-클래스를-사용할-수는-없을까"><a href="#인터페이스-대신-추상-클래스를-사용할-수는-없을까" class="headerlink" title="인터페이스 대신 추상 클래스를 사용할 수는 없을까?"></a>인터페이스 대신 추상 클래스를 사용할 수는 없을까?</h3><p>사용할수 있다 하지만 몇가지 단점도 있다 인터페이스를 사용하면 개발자가 능동적으로 무엇을 해야 한다 하지만 추상클래스는 그냥 넘어 갈수 있다</p><h3 id="규칙-인터페이스에서만-상속받을-것"><a href="#규칙-인터페이스에서만-상속받을-것" class="headerlink" title="규칙: 인터페이스에서만 상속받을 것"></a>규칙: 인터페이스에서만 상속받을 것</h3><h3 id="클래스에-있는-코드의-중복은-다-무엇일까"><a href="#클래스에-있는-코드의-중복은-다-무엇일까" class="headerlink" title="클래스에 있는 코드의 중복은 다 무엇일까?"></a>클래스에 있는 코드의 중복은 다 무엇일까?</h3><h2 id="복잡한-if-체인-구문-리팩터링"><a href="#복잡한-if-체인-구문-리팩터링" class="headerlink" title="복잡한 if 체인 구문 리팩터링"></a>복잡한 if 체인 구문 리팩터링</h2><h2 id="필요-없는-코드-제거하기"><a href="#필요-없는-코드-제거하기" class="headerlink" title="필요 없는 코드 제거하기"></a>필요 없는 코드 제거하기</h2><h3 id="리팩터링-패턴-삭제-후-컴파일하기"><a href="#리팩터링-패턴-삭제-후-컴파일하기" class="headerlink" title="리팩터링 패턴: 삭제 후 컴파일하기"></a>리팩터링 패턴: 삭제 후 컴파일하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>pyproject.toml</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-pyproject/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-pyproject/</guid>
      <pubDate>Tue, 26 Dec 2023 02:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;pyproject-toml&quot;&gt;&lt;a href=&quot;#pyproject-toml&quot; class=&quot;headerlink&quot; title=&quot;pyproject.toml&quot;&gt;&lt;/a&gt;pyproject.toml&lt;/h1&gt;&lt;p&gt;pyproject.tomlPEP 518 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="pyproject-toml"><a href="#pyproject-toml" class="headerlink" title="pyproject.toml"></a>pyproject.toml</h1><p>pyproject.tomlPEP 518 에 정의되고 PEP 621 및 PEP 660 에서 확장된 새로운 구성 파일입니다.<br>빌드 시스템 요구 사항을 저장하도록 설계되었지만 Python 프로젝트에 대한 모든 도구 구성을 저장할 수도 있어 필요하거나<br>setup.cfg다른 도구 관련 파일을 대체할 수도 있습니다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/carlosperate/awesome-pyproject">Awesome pyproject.toml</a></li><li><a href="https://peps.python.org/pep-0518/">PEP 518 – Specifying Minimum Build System Requirements for Python Projects</a></li><li><a href="https://peps.python.org/pep-0621/">PEP 621 – Storing project metadata in pyproject.toml</a></li><li><a href="https://peps.python.org/pep-0660/">PEP 660 – Editable installs for pyproject.toml based builds (wheel based)</a></li><li><a href="https://packaging.python.org/en/latest/guides/writing-pyproject-toml/">Writing your pyproject.toml</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-pyproject/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장: 긴 코드 조각내기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/</guid>
      <pubDate>Tue, 26 Dec 2023 01:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;3장-긴-코드-조각내기&quot;&gt;&lt;a href=&quot;#3장-긴-코드-조각내기&quot; class=&quot;headerlink&quot; title=&quot;3장: 긴 코드 조각내기&quot;&gt;&lt;/a&gt;3장: 긴 코드 조각내기&lt;/h1&gt;&lt;p&gt;DRY(Don’t Repeat Yourself)&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="3장-긴-코드-조각내기"><a href="#3장-긴-코드-조각내기" class="headerlink" title="3장: 긴 코드 조각내기"></a>3장: 긴 코드 조각내기</h1><p>DRY(Don’t Repeat Yourself)</p><p>KISS(Keep it simple, stupid)</p><p>위에 지침을 따라도 코드는 쉽게 지저분해지고 혼란스러울수 있다</p><p>메서드 추출로 가독성을 올린다</p><h2 id="첫-번째-규칙-왜-다섯-줄인가"><a href="#첫-번째-규칙-왜-다섯-줄인가" class="headerlink" title="첫 번째 규칙: 왜 다섯 줄인가?"></a>첫 번째 규칙: 왜 다섯 줄인가?</h2><p>이 지침을 엄수하는것으로 엄청난 개선이다</p><h3 id="규칙-다섯-줄-제한"><a href="#규칙-다섯-줄-제한" class="headerlink" title="규칙: 다섯 줄 제한"></a>규칙: 다섯 줄 제한</h3><p>메서드는 {}를 제외하고 5줄 이상이 되면 안된다</p><p>메서드가 길다는것 자체가 코드 스멜이다</p><p>관심을 가지지 않으면 시간이 지남에 따라 더많은 기능이 추가 되면서 메서드가 커지는 경향</p><h2 id="함수-분해를-위한-리팩터링-패턴-소개"><a href="#함수-분해를-위한-리팩터링-패턴-소개" class="headerlink" title="함수 분해를 위한 리팩터링 패턴 소개"></a>함수 분해를 위한 리팩터링 패턴 소개</h2><p>작게 잘라서 이해하기 쉽게 하나씩 처리</p><h3 id="리팩터링-패턴-메서드-추출"><a href="#리팩터링-패턴-메서드-추출" class="headerlink" title="리팩터링 패턴: 메서드 추출"></a>리팩터링 패턴: 메서드 추출</h3><p>메서드 추출은 한 메서드의 일부를 취해서 자체 메서드로 추출 한다</p><h2 id="추상화-수준을-맞추기-위한-함수-분해"><a href="#추상화-수준을-맞추기-위한-함수-분해" class="headerlink" title="추상화 수준을 맞추기 위한 함수 분해"></a>추상화 수준을 맞추기 위한 함수 분해</h2><h3 id="규칙-호출-또는-전달-한-가지만-할-것"><a href="#규칙-호출-또는-전달-한-가지만-할-것" class="headerlink" title="규칙: 호출 또는 전달, 한 가지만 할 것"></a>규칙: 호출 또는 전달, 한 가지만 할 것</h3><p>함수 내에서는 객체에 있는 메서드를 호출하거나 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안된다</p><p>함수의 내용은 동일한 추상화 수준에 있어야 한다는 그 자체가 스멜일 정도로 강력하다</p><h2 id="좋은-함수-이름의-속성"><a href="#좋은-함수-이름의-속성" class="headerlink" title="좋은 함수 이름의 속성"></a>좋은 함수 이름의 속성</h2><p>좋은 이름이 가져야할 속성</p><ul><li>정직해야 한다. 함수의 의도를 설명해야 한다</li><li>완전해야 한다. 함수가 하는 모든것을 담아야 한다</li><li>도메인에서 일하는 사람이 이해할 수 있어야 한다</li></ul><h2 id="너무-많은-일을-하는-함수-분리하기"><a href="#너무-많은-일을-하는-함수-분리하기" class="headerlink" title="너무 많은 일을 하는 함수 분리하기"></a>너무 많은 일을 하는 함수 분리하기</h2><h3 id="규칙-if-문은-함수의-시작에만-배치"><a href="#규칙-if-문은-함수의-시작에만-배치" class="headerlink" title="규칙: if 문은 함수의 시작에만 배치"></a>규칙: if 문은 함수의 시작에만 배치</h3><p>함수는 한가지 일만 해야 된다는것을 알아야 됨</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장: 리팩터링 깊게 들여다보기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/</guid>
      <pubDate>Fri, 22 Dec 2023 01:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;2장-리팩터링-깊게-들여다보기&quot;&gt;&lt;a href=&quot;#2장-리팩터링-깊게-들여다보기&quot; class=&quot;headerlink&quot; title=&quot;2장: 리팩터링 깊게 들여다보기&quot;&gt;&lt;/a&gt;2장: 리팩터링 깊게 들여다보기&lt;/h1&gt;&lt;h2 id=&quot;가독성-및-유
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="2장-리팩터링-깊게-들여다보기"><a href="#2장-리팩터링-깊게-들여다보기" class="headerlink" title="2장: 리팩터링 깊게 들여다보기"></a>2장: 리팩터링 깊게 들여다보기</h1><h2 id="가독성-및-유지보수성-향상"><a href="#가독성-및-유지보수성-향상" class="headerlink" title="가독성 및 유지보수성 향상"></a>가독성 및 유지보수성 향상</h2><p>리팩터링</p><ul><li>더 나은 코드를 만드는것 </li><li>코드가 하는 일은 변경하지 않는것</li></ul><h3 id="코드-개선"><a href="#코드-개선" class="headerlink" title="코드 개선"></a>코드 개선</h3><ul><li>가독성 : 의도를 전달하기 위한 코드의 성질</li><li>유지보수성 : 코드를 변경하기 쉽게 만드는 성질<ul><li>함께 변하는건 함께 있어야 된다(localizing ivariants)</li><li>취약성의 근원은 전역 상태(global state)이다</li><li>불변속성(invariants) : 코드에서 상태(조선)를 명시적으로 확인하지 않는 속성(assertion 으로만 확인)</li></ul></li></ul><h3 id="코드가-하는-일을-바꾸지-않고-유지보수하기"><a href="#코드가-하는-일을-바꾸지-않고-유지보수하기" class="headerlink" title="코드가 하는 일을 바꾸지 않고 유지보수하기"></a>코드가 하는 일을 바꾸지 않고 유지보수하기</h3><p>코드는 블랙박스로 생각하고 외부에 영향을 주지 않는 내부의 모든 작업을 변경할수 있다고 생각</p><p>리팩터링을 할 때는 블랙박스의 경계를 고려해야 함</p><p>리팩터링의 세가지 핵심</p><ul><li>의도를 전달함으로써 가독성 향상</li><li>불변속성의 범위제한을 통한 유지보수성 향상</li><li>범위 밖의 코드에 영향을 주지 않고 1항과 2항을 수정</li></ul><h2 id="속도-유연성-및-안정성-확보"><a href="#속도-유연성-및-안정성-확보" class="headerlink" title="속도, 유연성 및 안정성 확보"></a>속도, 유연성 및 안정성 확보</h2><p>리팩터링 패턴에는 구체적이고 지역적인것(변수명 변경) 부터 추상적이고 전역적인 것에 이르기 까지 여러 수준이 있다.</p><h3 id="상속보다는-컴포지션-사용"><a href="#상속보다는-컴포지션-사용" class="headerlink" title="상속보다는 컴포지션 사용"></a>상속보다는 컴포지션 사용</h3><p>유연성 : 컴포지션을 중심으로 만들어진 시스템을 사용하면 다른 방식보다 더 깔끔하게 코드를 결합하고 재사용 할 수 있다</p><h3 id="수정이-아니라-추가로-코드를-변경"><a href="#수정이-아니라-추가로-코드를-변경" class="headerlink" title="수정이 아니라 추가로 코드를 변경"></a>수정이 아니라 추가로 코드를 변경</h3><p>컴포지션의 가장 큰 장점은 추가(addition)로 변경 가능 하다는 것</p><p>개방 폐쇠 원칙- 확장엔 열려있어야 하고 수정엔 닫혀 있어야 한다는 의미</p><ul><li>프로그래밍 속도<ul><li>어떤 코드가 사용되고 어떤 코드가 사용되지 않는지 주의를 기울이고 사용하지 않는 코드는 최대한 빨리 삭제</li></ul></li><li>안정성<ul><li>추가에 의한 변경 방식을 따르면 기존코드를 항상 보존할 수 있다</li></ul></li></ul><h2 id="리팩터링과-일상-업무"><a href="#리팩터링과-일상-업무" class="headerlink" title="리팩터링과 일상 업무"></a>리팩터링과 일상 업무</h2><p>기슬부채</p><ul><li>레거시 시스템을 변경하기 전에 먼저 리팩터링 하자</li><li>코드를 변경한 후에도 리팩터링 하자</li></ul><h3 id="학습-방법으로서의-리팩터링"><a href="#학습-방법으로서의-리팩터링" class="headerlink" title="학습 방법으로서의 리팩터링"></a>학습 방법으로서의 리팩터링</h3><p>리팩터링은 코드를 연구하는 완전히 다른 방법</p><h2 id="소프트웨어-분야에서-‘도메인’-정의하기"><a href="#소프트웨어-분야에서-‘도메인’-정의하기" class="headerlink" title="소프트웨어 분야에서 ‘도메인’ 정의하기"></a>소프트웨어 분야에서 ‘도메인’ 정의하기</h2><p>실제 세계의 구성요소를 소프트웨어의 도메인 이라고 한다</p><p>프로그래밍은 주로 학습과 의사소통에 관한것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion Samplers</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/</guid>
      <pubDate>Thu, 21 Dec 2023 08:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Stable-Diffusion-Samplers&quot;&gt;&lt;a href=&quot;#Stable-Diffusion-Samplers&quot; class=&quot;headerlink&quot; title=&quot;Stable Diffusion Samplers&quot;&gt;&lt;/a&gt;Stable Diff
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Stable-Diffusion-Samplers"><a href="#Stable-Diffusion-Samplers" class="headerlink" title="Stable Diffusion Samplers"></a>Stable Diffusion Samplers</h1><h2 id="Old-School-ODE-solvers"><a href="#Old-School-ODE-solvers" class="headerlink" title="Old-School ODE solvers"></a>Old-School ODE solvers</h2><p>상미분 방정식(ODE)</p><ul><li>Euler :  가장 간단한 해결 입니다.</li><li>Heun : 오일러의 더 정확하지만 느린 버전입니다.</li><li>LMS(Linear multi-step method) : 오일러와 속도는 동일하지만 (아마도) 더 정확합니다.</li></ul><h2 id="Ancestral-samplers"><a href="#Ancestral-samplers" class="headerlink" title="Ancestral samplers"></a>Ancestral samplers</h2><ul><li>Euler a</li><li>DPM2 a</li><li>DPM++ 2S a</li><li>DPM++ 2S a Karras</li></ul><p>Ancestral samplers는 각 샘플링 단계에서 이미지에 노이즈를 추가합니다. 샘플링 결과에 임의성이 있기 때문에 확률적 샘플러 입니다.</p><p>단점은 이미지가 수렴되지 않는다는 것입니다.</p><h2 id="Karras-noise-schedule"><a href="#Karras-noise-schedule" class="headerlink" title="Karras noise schedule"></a>Karras noise schedule</h2><p>Karras 라는 라벨이 붙은 샘플러는 Karras 기사 에서 권장하는 소음 일정을 사용합니다.<br>주의 깊게 살펴보면 노이즈 단계 크기가 끝 부분에서 더 작아지는 것을 볼 수 있습니다.<br>그들은 이것이 이미지의 품질을 향상시킨다는 것을 발견했습니다.</p><h2 id="DDIM-및-PLMS"><a href="#DDIM-및-PLMS" class="headerlink" title="DDIM 및 PLMS"></a>DDIM 및 PLMS</h2><p>DDIM(Denoising Diffusion Implicit Model) 및 PLMS(Pseudo Linear Multi-Step 방법)는 원래 Stable Diffusion v1 과 함께 제공되는 샘플러였습니다 .<br>DDIM은 확산 모델용으로 설계된 최초의 샘플러 중 하나입니다. PLMS는 DDIM의 더 새롭고 빠른 대안입니다.</p><p>일반적으로 오래된 것으로 간주되어 더 이상 널리 사용되지 않습니다.</p><h2 id="DPM-및-DPM"><a href="#DPM-및-DPM" class="headerlink" title="DPM 및 DPM++"></a>DPM 및 DPM++</h2><p>DPM (확산 확률 모델 솔버) 및 DPM++ 는 2022년에 출시된 확산 모델용으로 설계된 새로운 샘플러입니다. 이들은 유사한 아키텍처의 솔버 제품군을 나타냅니다.</p><p>DPM 과 DPM2는 DPM2가 2차라는 점을 제외하면 유사합니다(더 정확하지만 느림).</p><p>DPM++ 는 DPM보다 개선된 것입니다.</p><p>DPM 적응형은 단계 크기를 적응적으로 조정합니다. 샘플링 단계 수 내에서 완료를 보장하지 않으므로 속도가 느려질 수 있습니다.</p><h2 id="UniPC"><a href="#UniPC" class="headerlink" title="UniPC"></a>UniPC</h2><p>UniPC (Unified Predictor-Corrector)는 2023년에 출시된 새로운 샘플러입니다.<br>ODE 솔버의 예측-수정기 방법에서 영감을 받아 5~10단계로 고품질 이미지 생성을 달성할 수 있습니다.</p><h2 id="k-diffusion"><a href="#k-diffusion" class="headerlink" title="k-diffusion"></a>k-diffusion</h2><p>마지막으로, k-확산 이라는 용어를 듣고 그것이 무엇을 의미하는지 궁금했을 것입니다.<br>이는 단순히 Katherine Crowson의 k-diffusion GitHub 저장소 및 이와 관련된 샘플러를 나타냅니다.</p><p>저장소는 Karras 2022 기사 에서 연구된 샘플러를 구현합니다.</p><p>기본적으로 DDIM, PLMS, UniPC를 제외한 AUTOMATIC1111의 모든 샘플러는 k-diffusion에서 차용한 것입니다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://stable-diffusion-art.com/samplers/">Stable Diffusion Samplers: A Comprehensive Guide</a></li><li><a href="https://github.com/crowsonkb/k-diffusion">k-diffusion</a></li><li><a href="https://arxiv.org/abs/2206.00364">Elucidating the Design Space of Diffusion-Based Generative Models</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Classifier-Free Guidance : CFG</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/</guid>
      <pubDate>Thu, 21 Dec 2023 02:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Classifier-Free-Guidance-CFG&quot;&gt;&lt;a href=&quot;#Classifier-Free-Guidance-CFG&quot; class=&quot;headerlink&quot; title=&quot;Classifier-Free Guidance : CFG&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Classifier-Free-Guidance-CFG"><a href="#Classifier-Free-Guidance-CFG" class="headerlink" title="Classifier-Free Guidance : CFG"></a>Classifier-Free Guidance : CFG</h1><h2 id="Classifier-guidance-분류자-지침"><a href="#Classifier-guidance-분류자-지침" class="headerlink" title="Classifier guidance(분류자 지침)"></a>Classifier guidance(분류자 지침)</h2><p>Classifier guidance은 확산 모델에 이미지 와 라벨을 통합하는 방법입니다.<br>라벨을 사용하여 확산 과정을 안내할 수 있습니다. 예를 들어, “고양이”라는 라벨은 역확산 과정을 조종하여 고양이 사진을 생성합니다.</p><p>classifier guidance scale 은 확산 프로세스가 라벨을 얼마나 밀접하게 따라야 하는지를 제어하기 위한 매개변수입니다.</p><p>높은 classifier guidance를 사용하면 확산 모델에 의해 생성된 이미지가 극단적이거나 모호하지 않은 예시 쪽으로 편향됩니다.<br>모델에게 고양이를 요청하면 모델은 명백히 고양이이고 다른 것은 없는 이미지를 반환합니다.</p><p>classifier guidance scale 지침을 얼마나 밀접하게 준수하는지 제어합니다.<br>위 그림에서 오른쪽 샘플링은 중간 샘플링보다 분류자 안내 척도가 더 높습니다.<br>실제로 이 척도 값은 해당 레이블이 있는 데이터에 대한 드리프트 항의 승수일 뿐입니다.</p><h2 id="Classifier-free-guidance-분류자-없는-지침"><a href="#Classifier-free-guidance-분류자-없는-지침" class="headerlink" title="Classifier-free guidance(분류자 없는 지침)"></a>Classifier-free guidance(분류자 없는 지침)</h2><p>classifier guidance은 기록적인 성능을 달성했지만 해당 지침을 제공하려면 추가 모델이 필요합니다.<br>이로 인해 훈련에 약간의 어려움이 생겼습니다. Classifier-free guidance는 classifier guidance를  classifier 없이  달성하는 방법입니다.<br>지침을 위해 클래스 레이블과 별도의 모델을 사용하는 대신,<br>텍스트-이미지에서 논의한 것과 똑같은 이미지 캡션을 사용하고 조건부 확산 모델을 학습할 것을 제안했습니다.</p><p>classifier-free guidance scale (CFG scale)는 텍스트 프롬프트가 확산 과정을 얼마나 조정하는지 제어하는 값입니다.<br>CFG 스케일이 0으로 설정되면 AI 이미지 생성은 조건이 적용되지 않습니다 (즉, 프롬프트가 무시됩니다).<br>CFG 스케일이 높을수록 확산이 프롬프트 쪽으로 조정됩니다. 이 값은 일반적으로 7.0에서 13.0 사이의 값을 가집니다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a></li><li><a href="https://arxiv.org/abs/2207.12598">Classifier-Free Diffusion Guidance</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장: 리팩터링 리팩터링하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/</guid>
      <pubDate>Thu, 21 Dec 2023 01:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 책에서 소개된 규칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다섯중 제한&lt;/li&gt;
&lt;li&gt;호출 또는 전달 한가지만 할것&lt;/li&gt;
&lt;li&gt;if문은 함수의 시작에만 배치&lt;/li&gt;
&lt;li&gt;if문은 else를 사용하지 말것&lt;/li&gt;
&lt;li&gt;switch를 사용하지 말것
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이 책에서 소개된 규칙</p><ul><li>다섯중 제한</li><li>호출 또는 전달 한가지만 할것</li><li>if문은 함수의 시작에만 배치</li><li>if문은 else를 사용하지 말것</li><li>switch를 사용하지 말것</li><li>인터페이스에서만 상속 받을것</li><li>순수 조건 사용</li><li>구현체가 하나뿐인 인터페이스를 만들지 말것</li><li>getter&#x2F;setter를 사용하지 말것</li><li>공통 접사를 사용하지 말것</li></ul><h1 id="1장-리팩터링-리팩터링하기"><a href="#1장-리팩터링-리팩터링하기" class="headerlink" title="1장: 리팩터링 리팩터링하기"></a>1장: 리팩터링 리팩터링하기</h1><p>코드 스멜과 단위테스트를 가지고 리팩터링을 학습하는 방법은 진입 장벽이 너무 높다</p><h2 id="리팩터링이란-무엇인가"><a href="#리팩터링이란-무엇인가" class="headerlink" title="리팩터링이란 무엇인가?"></a>리팩터링이란 무엇인가?</h2><p>기능을 변경하지 않고 코드를 변경하는것</p><p>리팩터링을 해야 하는 이유</p><ul><li>코드를 더 빠르게 만들기 위해</li><li>더 작은 코드를 만들기 위해</li><li>코드를 더 일반적이거나 재사용 가능하게 하기 위해</li><li>코드의 가독성을 높이고 유지보수를 용이하게 하기 위해</li></ul><p>좋은코드 - 사람이 읽기 쉽고 유지보수가 용이하며 의도한 대로 잘 동작하는 코드</p><h2 id="스킬-무엇을-리팩터링할-것인가"><a href="#스킬-무엇을-리팩터링할-것인가" class="headerlink" title="스킬: 무엇을 리팩터링할 것인가?"></a>스킬: 무엇을 리팩터링할 것인가?</h2><p>리팩터링은 코드 스멜과 함꼐 가르친다 하지마 코드스멜은 보는 감각을 키우는데 시간이 걸린다</p><h2 id="문화-리팩터링은-언제-할까"><a href="#문화-리팩터링은-언제-할까" class="headerlink" title="문화: 리팩터링은 언제 할까?"></a>문화: 리팩터링은 언제 할까?</h2><p>리팩터링은 샤워와 같다 - 켄트 백</p><p>탐색 - 명세화 - 구현 - 테스트 - 리팩터링 - 전달</p><h3 id="레거시-시스템에서의-리팩터링"><a href="#레거시-시스템에서의-리팩터링" class="headerlink" title="레거시 시스템에서의 리팩터링"></a>레거시 시스템에서의 리팩터링</h3><p>우선 변경하기 쉽게 만든 후 변경 하라 - 켄트 백</p><h3 id="언제-리팩터링을-하지-말아야-할까"><a href="#언제-리팩터링을-하지-말아야-할까" class="headerlink" title="언제 리팩터링을 하지 말아야 할까?"></a>언제 리팩터링을 하지 말아야 할까?</h3><ul><li>한 번 실행하고 삭제할 코드 - xp 에서 스파이크로 알려진것</li><li>폐기되기 전 유지보수 모드에 있는 코드</li><li>임베디드 시스템이나 게임의 고급 물리엔진과 같인 엄격한 성능 요구사항이 있는 코드</li></ul><h2 id="도구-안전한-리팩터링-방법"><a href="#도구-안전한-리팩터링-방법" class="headerlink" title="도구: (안전한) 리팩터링 방법"></a>도구: (안전한) 리팩터링 방법</h2><ul><li>레시피처럼 상세하고 단계별로 구조화된 리팩터링 패턴</li><li>버전관리</li><li>컴파일러</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>12장: 데이터 시스템의 미래</title>
      <link>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/</guid>
      <pubDate>Mon, 18 Dec 2023 06:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;파생-데이터&quot;&gt;&lt;a href=&quot;#파생-데이터&quot; class=&quot;headerlink&quot; title=&quot;파생 데이터&quot;&gt;&lt;/a&gt;파생 데이터&lt;/h1&gt;&lt;h2 id=&quot;12장-데이터-시스템의-미래&quot;&gt;&lt;a href=&quot;#12장-데이터-시스템의-미래&quot; class
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="파생-데이터"><a href="#파생-데이터" class="headerlink" title="파생 데이터"></a>파생 데이터</h1><h2 id="12장-데이터-시스템의-미래"><a href="#12장-데이터-시스템의-미래" class="headerlink" title="12장: 데이터 시스템의 미래"></a>12장: 데이터 시스템의 미래</h2><h3 id="데이터-통합"><a href="#데이터-통합" class="headerlink" title="데이터 통합"></a>데이터 통합</h3><p>문제가 주어졌을때 모든 문제를 만족하는 하나의 해결책은 없지만 상황에 따라 적절한 서로 다른 접근법이 많이 있다</p><ul><li>파생 데이터에 특화된 도구의 결합<ul><li>포스트그레스큐엘 같은 디비는 간단한 애플리케이션 만들기에 충분한 전문 색인 기능이 포함되어 있지만 더 복잡한 검색 기능을 지원하기 위해서는 전문적인 정보 탐색 도구가 필요하다</li><li>데이터 통합은 나무가 아닌 숲을 보기 위해 줌아웃해서 조직 전체 데이터플로를 고려할때 명확해진다<ul><li>데이터플로에 대한 추론<ul><li>같은 데이터의 사본을 여러 저장소 시스템에 유지해야 할때 입력가 출력을 분명히 할 필요가 있다</li></ul></li><li>파생 데이터 대 분산 트랜잭션<ul><li>서로 다른 데이터 시스템 간 일관성을 유지하는 고전적인 방법은 원자적 커밋가 2단계 커밋에서 설명한 분산트랜잭션이다</li><li>추상적인 수준으로 보면 파생 데이터와 분산 트랜잭션은 다른 방식으로 유사한 목표를 달성한다</li></ul></li><li>전체 순서화의 제약<ul><li>충분히 작은 시스템에서 이벤트 로그의 순서 전체를 보장하는 것은 가능하다 하지만 규모가 커지고 더 복잡한 작업부하가 발생함에 따라 한계가 드러나기 시작한다</li><li>이벤트의 전체 순서를 결정하는것 - 전체 순서 브로드캐스트</li></ul></li><li>인과성 획득을 위한 이벤트 순서화<ul><li>이벤트 인과성이 미묘한 방식으로 발생하기도 한다</li></ul></li></ul></li></ul></li><li>일괄 처리와 스트림 처리<ul><li>데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것</li><li>입력을 소비 형태로 바꾸고 필터링하고 집계해 모델을 학습하고 평가한 뒤 마지막에는 적절한 출력으로 기록</li><li>일괄 처리자와 스트림은 이 목표를 달성하기 위한 도구</li><li>파생 상태 유지<ul><li>일괄 처리는 함수형 프로그래밍 언어로 코드를 작성하지 않아도 상당히 강력한 함수형 특징을 가진다</li><li>일괄 처리는 결정적이고 출력이 입력에만 의존하며 명시적 출력 외에는 다른 부수 효과가 없는 순수함수를 장려하며 입력을 불변으로 간주하고 출력은 추가 전용으로만 사용된다</li></ul></li><li>애플리케이션 발전을 위한 데이터 재처리<ul><li>파생데이터를 유지할 때 일괄 처리와 스트림 처리 모두 유용한다</li><li>스트림 처리를 사용하면 입력의 변화를 빠르게 파생 뷰에 반영할수 있다</li><li>일괄 처리 시스템을 이용하면 누적된 상당한 양의 과거 데이터를 재처리에 기존 데이터셋에 반영할수 있다</li></ul></li><li>람다 아키텍처<ul><li>입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터셋에 추가하는 방식으로 기록해야 한다는것으로 이벤트 소싱과 유사하다</li><li>일괄 처리는 간단해서 버그가 생길 가능성이 적은 반면 스트림 처리자는 신뢰성이 떨어지고 내결함성을 확보하기 어렵다는 것이다</li></ul></li><li>일괄 처리와 스트림 처리의 통합<ul><li>한 시스템에서 일괄 처리와 스트림 처리를 통합하는 작업이 진행 되고 있다</li></ul></li></ul></li></ul><h3 id="데이터베이스-언번들링"><a href="#데이터베이스-언번들링" class="headerlink" title="데이터베이스 언번들링"></a>데이터베이스 언번들링</h3><p>유닉스와 관계형 데이터베이스는 정보 관리 문제를 각기 매우 다른 유사점과 차이점은 탐구할 가치가 있다.</p><ul><li><p>데이터 저장소 기술 구성하기</p><ul><li>테이터 베이스가 제공하는 다양한 기능<ul><li>색인 생성 하기<ul><li>트랜젝션이 테이블에 쓸 때 마다 꾸준히 색인에 반영</li></ul></li><li>모든 것의 메타데이터베이스<ul><li>전체 조직의 데이터플로가 거대한 데이터베이스</li><li>연합 데이터베이스 : 읽기를 통합</li><li>언번들링 데이터베이스 : 쓰기를 통합</li></ul></li><li>언번들링이 동작하게 만들기<ul><li>신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 시스템을 만든다는 측면 에서 연합과 언번들링은 동전의 양면과 같다</li><li>쓰기 동기화는 읽기 동기화 보다 어렵다</li><li>로그기반통합은 느슨한 결합이다</li></ul></li><li>언번들링 대 통합 시스템<ul><li>언번들링은 단일 소프트웨어로 가능한것 보다 더 넓은 범위의 문제를 해결하기 위한 방법이다</li></ul></li><li>뭐가 빠졌지?<ul><li>미분 데이터플로(differential dataflow)</li></ul></li></ul></li></ul></li><li><p>데이터플로 주변 애플리케이션 설계</p><ul><li>파생 함수로서의 애플리케이션 코드<ul><li>트리거, 스토어드 프로시저, 사용자정의함수</li></ul></li><li>애플리케이션 코드와 상태의 분리<ul><li>웹 어플리케이션이 상태 비저장 서비스로 배포된다 하지만 상태는 데이터베이스에 저장한다</li><li>관찰자 패턴(observer pattern) : 상태를 관찰하는 코드와 상태를 변경하는 코드를 분리하는 방법</li></ul></li><li>데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용</li><li>스트림 처리자와 서비스<ul><li>스트림 연산자로 데이터플로 스스템을 구성하는 것은 마이크로서비스 접근법가 유사한 특징이 상당히 많다</li></ul></li></ul></li><li><p>파생 상태 관찰하기</p><ul><li>쓰기 경로(Write path) : 데이터베이스에 데이터를 쓰는 경로</li><li>읽기 경로(Read path) : 데이터베이스에서 데이터를 읽는 경로</li><li>구체화 뷰 와 캐싱<ul><li>공통 질의 캐시</li></ul></li><li>오프라인 대응 가능한 상태 저장 클라이언트<ul><li>오프라인 우선(offine-first) 애플리케이션</li></ul></li><li>상태 변경을 클라이언트에게 푸시 하기<ul><li>각 장치는 작은 이벤트 스트림을 구독하는 작은 구독자</li></ul></li><li>종단간 이벤트 스트림<ul><li>데이터 시스템을 설계한다면 현재 상태를 단지 질의하는 방식이 아니라 변경 사항을 구독하는 방식을 염두에 뒤야 한다</li></ul></li><li>읽기도 이벤트다<ul><li>지속성 있는 저장소에 읽기 이벤트를 기록하면 인과적 의존성을 추적하기가 더 용이하다</li></ul></li><li>다중 파티션 데이터 처리<ul><li>질의를 스트림으로 간주하면 기성 솔루션의 한계를 넘어서는 대규모 애플리케이션을 구현하는 방안<h3 id="정확성을-목표로"><a href="#정확성을-목표로" class="headerlink" title="정확성을 목표로"></a>정확성을 목표로</h3></li></ul></li></ul></li></ul><p>모두가 신뢰성있고 정확한 애플리케이션을 구축하기를 원한다</p><p>전통적인 트랜잭션 접근법이 사라지고 있지는 않지만 나는 이것이 최후에 방법이라 생각하지 않는다</p><ul><li>데이터베이스에 관한 종단 간 논증<ul><li>불변성이 유용하긴 해도 그 자체가 만능은 아니다</li><li>연산자의 정확히 한 번 실행<ul><li>정확히 한번(또는 결과적으로 한 번)</li><li>연산을 멱등으로 만드는 법</li></ul></li><li>중복 억제</li><li>연산 식별자</li><li>종단 간 논증<ul><li>종단 간 논증(end-to-end argument) : 시스템의 모든 부분이 신뢰성을 보장하는 것은 아니며 신뢰성을 보장하는 것은 시스템의 최종 목표이다</li></ul></li><li>종단 간 사고를 데이터 시스템에 적용하기<ul><li>트랜잭션은 오랜 기간 매우 휼륭한 추상화로 간주됐고 아직도 유용하다고 나는 믿는다</li></ul></li></ul></li><li>제약 조건 강제하기<ul><li>유일성 제약조건은 합의가 필요하다</li><li>로그 기반 메시징의 유일성<ul><li>전체 순서 브로드캐스트(total order broadcast) : 모든 메시지가 동일한 순서로 전달되는 것을 보장</li></ul></li><li>다중 파티션 요청 처리</li></ul></li><li>적시성과 무결성<ul><li>일관성<ul><li>적시성 : 시스템의 상태가 얼마나 최신인지를 나타내는 척도</li><li>무결성 : 시스템의 상태가 얼마나 정확한지를 나타내는 척도</li></ul></li><li>데이터플로 시스템의 정확성<ul><li>ACID 트랜잭션은 대개 적시성 과 무결성을 보장한다</li><li>정확히 한번이나 결과적으로 한 번 시맨틱은 무결성을 보존하는 매커니즘이다</li></ul></li><li>느슨하게 해석되는 제약 조건</li><li>코디네이션 회피 데이터 시스템</li></ul></li><li>믿어라. 하지만 확인하라.<ul><li>소프트웨어 버그가 발생해도 무결성 유지하기</li><li>약속을 맹목적으로 믿지 마라</li><li>검증하는 문화</li><li>감사 기능 설계</li><li>다시 종단 간 논증</li><li>감사 데이터 시스템용 도구</li></ul></li></ul><h3 id="옳은-일-하기"><a href="#옳은-일-하기" class="headerlink" title="옳은 일 하기"></a>옳은 일 하기</h3><p>ACM 소프트웨어 공학 윤리 강령</p><ul><li>예측 분석<ul><li>편견과 차별</li><li>책임과 의무</li><li>피드백 루프</li></ul></li><li>사생활과 추적<ul><li>감시<ul><li>감시 중심 애플리케이션 설계</li></ul></li><li>동의와 선택의 자유</li><li>사생활 데이터 사용</li><li>자산 권력으로서의 데이터</li><li>산업 혁명의 기억</li><li>법률과 자기 규제</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>엔지니어는 우리가 원하는 세상 즉 사람이 사람답게 존중 받는 세상을 위해 일할 책임이 있음을 기억해야 한다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Simple Python Version Management: pyenv</title>
      <link>https://sejoung.github.io/2023/12/2023-12-13-python_pyenv/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-13-python_pyenv/</guid>
      <pubDate>Wed, 13 Dec 2023 05:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Simple-Python-Version-Management-pyenv&quot;&gt;&lt;a href=&quot;#Simple-Python-Version-Management-pyenv&quot; class=&quot;headerlink&quot; title=&quot;Simple Python Ve
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Simple-Python-Version-Management-pyenv"><a href="#Simple-Python-Version-Management-pyenv" class="headerlink" title="Simple Python Version Management: pyenv"></a>Simple Python Version Management: pyenv</h1><p>jenv와 같은 역할을 하는 pyenv를 소개한다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line"></span><br><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.10</span><br><span class="line"></span><br><span class="line">pyenv global 3.10</span><br></pre></td></tr></table></figure><h2 id="업그레이드"><a href="#업그레이드" class="headerlink" title="업그레이드"></a>업그레이드</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade pyenv</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/pyenv/pyenv">pyenv</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-13-python_pyenv/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장: 스트림 처리</title>
      <link>https://sejoung.github.io/2023/12/2023-12-12-Designing_Data_Intensive_Applications_chapter11/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-12-Designing_Data_Intensive_Applications_chapter11/</guid>
      <pubDate>Tue, 12 Dec 2023 01:09:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;파생-데이터&quot;&gt;&lt;a href=&quot;#파생-데이터&quot; class=&quot;headerlink&quot; title=&quot;파생 데이터&quot;&gt;&lt;/a&gt;파생 데이터&lt;/h1&gt;&lt;h2 id=&quot;11장-스트림-처리&quot;&gt;&lt;a href=&quot;#11장-스트림-처리&quot; class=&quot;headerli
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="파생-데이터"><a href="#파생-데이터" class="headerlink" title="파생 데이터"></a>파생 데이터</h1><h2 id="11장-스트림-처리"><a href="#11장-스트림-처리" class="headerlink" title="11장: 스트림 처리"></a>11장: 스트림 처리</h2><p>“복잡하지만 잘 작동하는 시스템은 예외 없이 간단하지만 잘 작동하는 시스템으로부터 발전한다.<br>이 명제는 역도 참이다. 처음부터 복잡하게 설계된 시스템은 절대 작동할 리도 없고 작동하게 만들지도 못한다.” 존갈, 체계론</p><p>일괄처리는 입력으로 파일 집합을 읽어 출력으로 새로운 파일 집합을 생성하는 기술 출력은 파생데이터 형태</p><p>일괄처리의 문제는 입력의 변화가 하루가 지나야 반영된다는것</p><p>이벤트가 발생할때 마다 처리하는것 - 스트림처리</p><h3 id="이벤트-스트림-전송"><a href="#이벤트-스트림-전송" class="headerlink" title="이벤트 스트림 전송"></a>이벤트 스트림 전송</h3><p>스트림 처리에서 레코드 -&gt; 이벤트</p><p>이벤트는 특정 시점에 일어난 사건에 대한 세부 사항을 포함하는 작고 독립된 불변 객체</p><p>이벤트는 일반적으로 일기준 시계를 따르는 이벤트 발생 타임스템프를 포함한다</p><p>일괄처리에서 파일은 한번 기록하면 여러 작업에서 읽을 수 있다 스트리밍에서도 비슷하다</p><p>폴링은 비용이 크다. 폴링이 잦을수록 새로운 이벤트를 반환하는 요청비율이 낮아지기 때문에 폴링을 수행하는 오버헤드가 커진다</p><ul><li>메시징 시스템<ul><li>발행,구독 모델</li><li>메시지 유실을 허용할지 말지는 애플리케이션에 따라서 틀리다</li><li>생산자에서 소비자로 메시지 직접 전달하기<ul><li>생산자와 소비자가 항상 온라인이라고 가정한다</li></ul></li><li>메시지 브로커(메시지 큐)<ul><li>메시지 스트림을 처리하는 데 최적화된 데이터베이스의 일종</li><li>비동기식으로 작동</li></ul></li><li>메시지 브로커와 데이터베이스의 비교<ul><li>데이터 베이스는 명시적으로 데이터가 삭제될 때까지 데이터를 보관한다. 메시지 브로커는 소비자에게 메시지가 전달 되면 대부분 삭제한다</li><li>메시지 브로커는 대부분 메시지를 빨리 지우기 때문에 작업 집합이 상당히 작다고 가정한다</li><li>데이터 베이스는 보조색인을 지원하고 데이터 검색을 위한 다양한 방법을 지원하는 반면 메시지 브로커는 특정 패턴과 부합하는 토픽의 부분 집합을 구동하는 방식을 지원한다</li><li>데이터베이스에 질의 할때 그 결과는 질의 시점의 스냅숏을 기준으로 한다. 메시지 브로커는 데이터가 변하면 클라이언트에게 알려준다</li></ul></li><li>복수 소비자<ul><li>로드 밸런싱 : 메시지는 한 소비자에게 전달 된다</li><li>팬 아웃 : 메시지는 여러 소비자에게 전달 된다</li></ul></li><li>확인 응답과 재전동<ul><li>메시지 브로커는 확인 응답을 사용한다</li><li>메시지 순서는 메시지가 서로 독립적이라면 문제가 없지만 메시지간의 인과성이 있다면 매우 중요한 문제이다</li></ul></li></ul></li><li>파티셔닝된 로그<ul><li>로그 기반의 메시지 브로커</li><li>로그를 사용한 메시지 저장소<ul><li>로그는 단순히 디스크에 저장된 추가 전용 레코드의 연속이다</li><li>디스크 하나를 쓸때 처리량을 높이기 위해 확장하는 방법으로 로그를 파티셔닝 하는 방법이 있다</li></ul></li><li>로그 방식과 전통적인 메시지 방식의 비교<ul><li>메시지를 처리하는 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 구렇게 중요하지 않다면 JMS&#x2F;AMQP 같은 메시징 시스템을 사용하는 것이 좋다</li><li>메시지 순서가 중요하고 메시지 처리량이 많으면 로그기반 접근법이 효과적이다</li></ul></li><li>소비자 오프셋<ul><li>메시지 오프셋은 로그 순차 번호와 상당히 유사</li></ul></li><li>디스크 공간 사용<ul><li>로그는 크기가 제한된 버퍼로 구현하고 버퍼가 가득 차면 오래된 메시지 순서대로 삭제한다 </li><li>원형 버퍼 또는 링 버퍼라고 한다</li></ul></li><li>소비자가 생산자를 따라갈 수 없을 때<ul><li>메시지 버리기</li><li>버퍼링</li><li>배압 적용</li></ul></li><li>오래된 메시지 재상<ul><li>오프셋의 이동</li><li>일괄처리와 비슷</li></ul></li></ul></li></ul><h3 id="데이터베이스와-스트림"><a href="#데이터베이스와-스트림" class="headerlink" title="데이터베이스와 스트림"></a>데이터베이스와 스트림</h3><p>상태 기계 복제</p><ul><li>시스템 동기화 유지하기<ul><li>데이터 덤프는 너무 느려서 이중기록(dual write)의 방법도 있다<ul><li>이중쓰기는 하나만 성공할수도 있다</li></ul></li></ul></li><li>변경 데이터 캡처<ul><li>CDC(Change Data Capture)는 데이터베이스의 변경 사항을 캡처하는 방법이다</li><li>변경 데이터 캡처의 구현<ul><li>로그 기반의 CDC</li><li>트리거 기반의 CDC</li><li>스냅샷 기반의 CDC</li></ul></li><li>초기 스냅숏<ul><li>로그를 모두 플레이해서 재생하는것은 시간이 너무 오래 걸림</li><li>적당히 짤라서 처리해야함</li></ul></li><li>로그 컴팩션<ul><li>log compaction</li></ul></li><li>변경 스트림용 API 지원</li></ul></li><li>이벤트 소싱<ul><li>이벤트 소싱은 변경 데이터 캡처의 일종이다</li><li>데이터 모델링에 쓸수 있는 강력한 기법</li><li>이벤트 로그에서 현재 상태 파생하기</li><li>명령과 이벤트<ul><li>명령은 시스템의 상태를 변경하는 요청</li><li>이벤트는 시스템에서 일어난 사건의 사실을 기록</li></ul></li></ul></li><li>상태와 스트림과 불변성<ul><li>모든 변경로그(changelog)는 시간에 따라 변화하는 값</li><li>불변이벤트의 장점<ul><li>문제 상황의 진단과 복구가 훨씬 쉽다</li><li>불변이벤트는 현재 상태보다 훨씬 많은 정보를 포함한다</li></ul></li><li>동일한 이벤트 로그로 여러 가지 뷰 만들기<ul><li>CQRS(Command Query Responsibility Segregation)</li></ul></li><li>동시성 제어<ul><li>이벤트 소싱과 CDC의 단점은 비동기로 이루어진다는 것이다</li></ul></li><li>불변성의 한계<ul><li>데이터를 삭제하는것 - 이벤트를 추가해서 되는것이 아니다<ul><li>데이토믹 : 적출(exicision)</li><li>포씰 : 셔닝(shunning)</li></ul></li></ul></li></ul></li></ul><h3 id="스트림-처리"><a href="#스트림-처리" class="headerlink" title="스트림 처리"></a>스트림 처리</h3><p>일괄처리랑 다른 점은 스트림은 끝나지 않는다</p><ul><li>스트림 처리의 사용<ul><li>사기 감사 시스템</li><li>거래 시스템</li><li>제조 시스템 공장 기계 상태 모니터링</li><li>군사 첩보 시스템</li><li>복잡한 이벤트 처리<ul><li>CEP(Complex Event Processing)</li></ul></li><li>스트림 분석</li><li>구체화뷰 유지</li><li>스트림 상에서 검색하기</li><li>메시지 전달과 RPC</li></ul></li><li>시간에 관한 추론<ul><li>이벤트 시간 대 처리 시간</li><li>준비 여부 인식<ul><li>낙오자 이벤트 처리 -&gt; 무시, 수정 값 발행</li></ul></li><li>어쨋든 어떤 시계를 사용할 것인가<ul><li>시스템 시계</li><li>외부 시계</li><li>이벤트 시계</li></ul></li><li>원도우 유형<ul><li>덤블링 원도우(tumbling window) : 모든 이벤트는 정확히 한 원도우에 속한다</li><li>홉핑 원도우(hopping window) : 이벤트는 여러 원도우에 속할 수 있다</li><li>슬라이딩 원도우(sliding window) : 각 시간 간격 사이에서 발생한 모든 이벤트를 포함 한다</li><li>세션 윈도우(session window) : 고정된 기간이 없다</li></ul></li></ul></li><li>스트림 조인<ul><li>스트림 스트림 조인(stream-stream join) - 원도우 조인<ul><li>클릭 이벤트와 구매 이벤트를 조인 광고에서</li></ul></li><li>스트림 테이블 조인(stream-table join) - 스트림 강화<ul><li>데이터 베이스 정보로 이벤트 강화</li></ul></li><li>테이블 테이블 조인(table-table join) - 구체화 뷰 유지<ul><li>조인의 시간 의존성<ul><li>천천히 변하는 차원(slowlly changing dimension)</li></ul></li></ul></li></ul></li><li>내결함성<ul><li>정확히 한 번 시맨틱</li><li>결과적으로 한 번 시맨틱</li><li>마이크로 일괄 처리와 체크포인트</li><li>원자적 커밋 재검토</li><li>멱등성</li><li>실패 후에 상태 재구축하기</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul><li>amqp&#x2F;jms 스타일 메시지 브로커</li><li>로그 기반 메시지 브로커</li><li>스트림 스트림 조인</li><li>스트림 테이블 조인 </li><li>테이블 테이블 조인</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-12-Designing_Data_Intensive_Applications_chapter11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장: 일괄 처리</title>
      <link>https://sejoung.github.io/2023/12/2023-12-07-Designing_Data_Intensive_Applications_chapter10/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-07-Designing_Data_Intensive_Applications_chapter10/</guid>
      <pubDate>Thu, 07 Dec 2023 01:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;파생-데이터&quot;&gt;&lt;a href=&quot;#파생-데이터&quot; class=&quot;headerlink&quot; title=&quot;파생 데이터&quot;&gt;&lt;/a&gt;파생 데이터&lt;/h1&gt;&lt;p&gt;1부와 2부에서는 디스크에 저장된 데이터의 레이아웃부터 결함이 있는 상황에서의&lt;br&gt;분산된 일관성
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="파생-데이터"><a href="#파생-데이터" class="headerlink" title="파생 데이터"></a>파생 데이터</h1><p>1부와 2부에서는 디스크에 저장된 데이터의 레이아웃부터 결함이 있는 상황에서의<br>분산된 일관성의 한계까지 분산 데이터베이스로 가기위해 고려해야 할 모든 주요사항을 밑바닥부터 다뤘다</p><p>데이터를 저장하고 처리하는 시스템</p><ul><li>레코드 시스템 : 데이터를 레코드 단위로 저장하고 읽는다</li><li>파생 데이터 시스템 : 데이터를 레코드 단위로 저장하지 않고, 다른 데이터를 기반으로 계산된 결과를 저장한다</li></ul><p>파생 데이터는 기존 데이터를 복제한다는 의미에서 중복(redundant)이다.</p><h2 id="10장-일괄-처리"><a href="#10장-일괄-처리" class="headerlink" title="10장: 일괄 처리"></a>10장: 일괄 처리</h2><p>온라인 시스템은 응답시간 단축에 노력을 많이 기울인다</p><p>시스템 유형</p><ul><li>서비스(온라인 시스템) : 사용자와 상호작용하는 시스템</li><li>일괄 처리(오프라인 시스템) : 사용자와 상호작용하지 않고, 대량의 데이터를 처리하는 시스템</li><li>스트림 처리(준 실시간 시스템) : 온라인과 오프라인 처리의 어딘가에 있기 때문에 준 실시간 처리라 불린다</li></ul><p>일괄처리는 컴퓨터 연산에 있어서 매우 오래된 형태다<br>1890년 미국 인구조사에서 사용한 기계는 일괄 처리 시스템이다</p><h3 id="유닉스-도구로-일괄-처리하기"><a href="#유닉스-도구로-일괄-처리하기" class="headerlink" title="유닉스 도구로 일괄 처리하기"></a>유닉스 도구로 일괄 처리하기</h3><p>아래는 엔진엑스 웹 서버의 엑세스 로그 파일이다</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222.333.444.555 - - [11/Mar/2016:10:28:49 -0500] &quot;GET / HTTP/1.1&quot; 301 184 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">222.333.444.555 - - [11/Mar/2016:10:28:49 -0500] &quot;GET / HTTP/1.1&quot; 301 184 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">222.333.444.555 - - [11/Mar/2016:10:28:49 -0500] &quot;GET /test-endpoint HTTP/1.1&quot; 301 184 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">222.333.444.555 - - [11/Mar/2016:10:28:50 -0500] &quot;GET /test-endpoint HTTP/1.1&quot; 301 184 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                 &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                 &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">log_format notes &#x27;$remote_addr &quot;$request&quot; $status&#x27;;</span><br></pre></td></tr></table></figure><ul><li>단순 로그 분석</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk &#x27;&#123;print $7&#125;&#x27; | sort | uniq -c | sort -r -n | head -n 5</span><br></pre></td></tr></table></figure><ul><li>연쇄 명령 대 맞춤형 프로그램</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">counts = <span class="title class_">Hash</span>.new(<span class="number">0</span>)</span><br><span class="line">File.foreach(<span class="string">&#x27;access.log&#x27;</span>) <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">  url = line.split[<span class="number">6</span>]</span><br><span class="line">  counts[url] += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">top5 = counts.map &#123;|<span class="params">url, count</span>| [count, url]&#125;.sort.reverse[<span class="number">0</span>..<span class="number">5</span>]</span><br><span class="line">top5.each &#123;|<span class="params">count, url</span>| puts <span class="string">&quot;<span class="subst">#&#123;count&#125;</span> <span class="subst">#&#123;url&#125;</span>&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 루비 프로그램은 단순 로그 분석 명령보다 읽기 더 쉽다</p><ul><li>정렬 대 인메모리 집계</li></ul><p>데이터 양이 작으면 정렬이던 인메모리 집계던 문제가 없지만 데이터 양이 많아지면 문제가 발생한다</p><ul><li>유닉스 철학</li></ul><p>유닉스 파이프를 발명한 더그 맥일로이(Doug McIlroy)는 “다른 방법으로 데이터 처리가 필요할 때 정원 호스와 같이 여러 다른 프로그램을 연결하는 방법이 필요하다 이것은 I&#x2F;O 방식이기도 하다”</p><ol><li>각 프로그램은 한가지 일만 하도록 작성하라. 새 작업이 필요하면 기존 프로그램을 고치지 말고 새로운 프로그램을 작성하라</li><li>모든 프로그램의 출력은 아직 알려지지 않은 프로그램의 출력에 쓰일수 있다</li><li>소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라</li><li>프로그램 작업을 줄이려면 미숙한 도움보단 도구를 사용하라</li></ol><p>동일 인터페이스 : 각 프로그램은 표준 입력을 읽고 표준 출력을 쓴다</p><p>로직과 연결의 분리 : 느슨한 결합, 지연 바인딩, 제어의 반전</p><p>투명성과 실험 : 유닉스 도구가 성공적인 이유 중 하나는 진행 사항을 파악하기가 쉽다</p><ol><li>입력 파일은 일반적으로 불변으로 처리된다</li><li>어느 시점이든 파이프라인을 중단하고 출력을 파이프를 통해 less로 보내 원하는 형태의 출력이 나오는지 확인 할 수 있다</li><li>특정 파이프라인 단계의 출력을 파일에 쓰고 그 파일을 다음 단계의 입력으로 사용할 수 있다</li></ol><h3 id="맵리듀스와-분산-파일-시스템"><a href="#맵리듀스와-분산-파일-시스템" class="headerlink" title="맵리듀스와 분산 파일 시스템"></a>맵리듀스와 분산 파일 시스템</h3><p>맵리듀스는 유닉스 도구와 비슷한 면이 있지만 수천 대의 장비로 분산해서 실행이 가능하다는 점에서 차이가 있다</p><p>맵리듀스는 분산파일시스템(HDFS)에서 데이터를 읽고 쓴다</p><p>HDFS는 비공유 원칙 NAS, SAN과 다르다</p><p>네임노드 : 파일 시스템의 메타데이터를 관리하는 서버</p><ul><li>맵리듀스 작업 실행하기<ul><li>매퍼(mapper) : 입력 데이터를 읽어서 키-값 쌍을 생성한다</li><li>리듀서(reducer) : 매퍼의 출력을 입력으로 받아서 집계를 수행한다</li><li>맵리듀스의 분산실행 : 맵리듀스 적업은 여러 개의 맵 태스크와 리듀스 태스크로 나뉜다</li><li>맵리듀스의 워크플로 : 맵리듀스 작업을 연결해 워크플로를 구성하는 방식은 꽤 일반적이다</li></ul></li><li>리듀스 사이드 조인과 그룹화<ul><li>일괄처리 관점에서 조인은 데이터셋 내 모든 연관 관계를 다룬다는 뜻</li><li>사용자 활동 이벤트 분석 예제 : 사용자 활동 이벤트와 사용자 레코드를 조인해 사용자의 이름을 알아내는 것</li><li>정렬 병합 조인 : 키로 맴퍼의 출력을 파티셔닝해 키-값 쌍으로 정렬하면 같은 사용자의 활동이벤트와 사용자 레코드는 리듀서의 입력으로 서로 인접해서 간다</li><li>같은 곳으로 연관된 데이터 가져오기 : 데이터를 한곳에 모으면 조인이 쉽다</li><li>그룹화 : 매퍼의 키-값 쌍을 생성할때 그룹화할 대상을 키로 하는 것이다</li><li>쏠림 다루기 : 린치핀 객체, 핫 키, 핫스팟, 유명인사 문제</li></ul></li><li>맵 사이드 조인<ul><li>리듀스 사이드 조인(reduce-side join) : 조인을 리듀서에서 수행하는 것</li><li>맵 사이드 조인(map-side join) : 조인을 매퍼에서 수행하는 것</li><li>브로드캐스트 해시 조인(broadcast hash join) : 작은 데이터셋을 모든 맵 태스크에 복제해 놓는다</li><li>파티션 해시 조인(partitioned hash join) : 조인 키를 해시해서 파티션을 할당한다</li><li>맵 사이드 병합 조인(map-side merge join) : 조인 키를 정렬해서 파티셔닝한다</li><li>맵 사이드 조인을 사용하는 맵리듀스 워크플로 : Hcatalog, Hive 메타스토어를 사용하기도 한다</li></ul></li><li>일괄 처리 워크플로의 출력<ul><li>검색 색인 구축 </li><li>일괄 처리의 출력으로 키-값을 저장</li><li>일괄 처리 출력에 관한 철학<ul><li>인적 내결함성(human fault tolerance)</li><li>비가역성 최소화(minimizing irreversibility)</li><li>입력은 불변</li></ul></li></ul></li><li>하둡과 분산 데이터베이스의 비교<ul><li>대규모 병렬 처리(massively parallel processing, MPP) 에 모두 구현되어 있다</li><li>MPP는 분석 질의를 병렬로 수행하는데 중점, 맵리듀스은 아무 프로그램이나 실행 운영체제랑 비슷</li><li>저장소의 다양성<ul><li>데이터 레이크</li><li>데이터 덤핑</li></ul></li><li>처리 모델의 다양성<ul><li>MPP 데이터베이스는 일체식 구조</li></ul></li><li>빈번하게 발생하는 결함을 줄이는 설계<ul><li>맵리듀스는 태스크 종료가 자주 발생해도 견딜수 있는구조</li></ul></li></ul></li></ul><h3 id="맵리듀스를-넘어"><a href="#맵리듀스를-넘어" class="headerlink" title="맵리듀스를 넘어"></a>맵리듀스를 넘어</h3><p>맵리듀스는 단순함 사용하기 쉽지 않음</p><ul><li>중간 상태 구체화<ul><li>모든 맵리듀스 작업은 다른 작업과 모두 독립적</li><li>중간단계(Intermidiate state) : 맵리듀스 작업의 중간 단계의 출력</li><li>중간단계를 파일로 기록하는 과정을 구체화(materialization)라고 한다</li><li>데이터플로 엔진 : 스파크</li><li>내결함성 : 스파크는 아직 유효한 데이터로 부터 계산을 다시 해서 복구한다</li><li>구체화에 대한 논의<ul><li>데이터플로 엔진을 사용할 때 HDFS상에 구체화된 데이터 셋은 보통 작업의 입력과 최종 출력이다</li></ul></li></ul></li><li>그래프와 반복 처리<ul><li>그래프 분석 알고리즘 : 페이지랭크</li><li>이행적 패쇄(transitive closure) : 그래프의 각 노드가 다른 노드에 도달할 수 있는지 여부를 나타내는 그래프</li><li>맵리듀스는 알고리즘의 반복적 속성을 고려하지 않음</li><li>프리글 처리 모델 : 벌크 동기식 병렬(bulk synchronous parallel, BSP) 모델</li><li>내결함성<ul><li>정확히 한번 수행</li></ul></li><li>병렬 실행</li></ul></li><li>고수준 API와 언어<ul><li>하이브, 피그, 캐스캐이딩과 크런치 같은 고수준 언어나 API가 인기를 끌었다</li><li>선언형 질의 언어로 변환<ul><li>임팔라</li></ul></li><li>다양한 분야를 지원하기 위한 전문화<ul><li>통계학과 수치 알고리즘</li><li>K 최근접 이웃 알고리즘(K-nearest neighbors, KNN)</li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>분산 일괄 처리 프레임워크가 해결해야할 두가지 문제</p><ul><li>파티셔닝</li><li>내결함성</li></ul><p>맵리듀스 조인 알고리즘</p><ul><li>정렬 병합 조인</li><li>브로드캐스트 해시 조인</li><li>파티션 해시 조인</li></ul><p>입력 데이터는 고정된 크기로 한정된다</p><p>스트림 처리는 입력이 한정되지 않는다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-07-Designing_Data_Intensive_Applications_chapter10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github 여러 계정 관리(ssh)</title>
      <link>https://sejoung.github.io/2023/12/2023-12-05-git_multiple_accounts/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-05-git_multiple_accounts/</guid>
      <pubDate>Tue, 05 Dec 2023 01:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;github-여러-계정-관리-ssh&quot;&gt;&lt;a href=&quot;#github-여러-계정-관리-ssh&quot; class=&quot;headerlink&quot; title=&quot;github 여러 계정 관리(ssh)&quot;&gt;&lt;/a&gt;github 여러 계정 관리(ssh)&lt;/h1&gt;&lt;h2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="github-여러-계정-관리-ssh"><a href="#github-여러-계정-관리-ssh" class="headerlink" title="github 여러 계정 관리(ssh)"></a>github 여러 계정 관리(ssh)</h1><h2 id="ssh-키-생성"><a href="#ssh-키-생성" class="headerlink" title="ssh 키 생성"></a>ssh 키 생성</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;sejoung@gmail.com&quot; -f &quot;id_ed25519_sejoung&quot;</span><br><span class="line"></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;beni@realdraw.ai&quot; -f &quot;id_ed25519_beni&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ssh-키-등록"><a href="#ssh-키-등록" class="headerlink" title="ssh 키 등록"></a>ssh 키 등록</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519_sejoung</span><br><span class="line"></span><br><span class="line">ssh-add ~/.ssh/id_ed25519_beni</span><br></pre></td></tr></table></figure><p>등록된 ssh 키 등록 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><h2 id="키등록"><a href="#키등록" class="headerlink" title="키등록"></a>키등록</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_ed25519_sejoung.pub</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_ed25519_beni.pub</span><br></pre></td></tr></table></figure><h2 id="ssh-config-설정"><a href="#ssh-config-설정" class="headerlink" title="ssh config 설정"></a>ssh config 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User sejoung</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_sejoung</span><br><span class="line"></span><br><span class="line">Host github.com-beni</span><br><span class="line">  HostName github.com</span><br><span class="line">  User beni</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_beni  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="설정-후-테스트"><a href="#설정-후-테스트" class="headerlink" title="설정 후 테스트"></a>설정 후 테스트</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">ssh -T git@github.com-beni</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.github.com/ko/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">새 SSH 키 생성 및 ssh-agent에 추가</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-05-git_multiple_accounts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>09장: 일관성과 합의</title>
      <link>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/</guid>
      <pubDate>Tue, 28 Nov 2023 01:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;h2 id=&quot;09장-일관성과-합의&quot;&gt;&lt;a href=&quot;#09장-일관성과-합의&quot; class=&quot;header
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><h2 id="09장-일관성과-합의"><a href="#09장-일관성과-합의" class="headerlink" title="09장: 일관성과 합의"></a>09장: 일관성과 합의</h2><p>결함의 가장 간단한 해결방법은 서비스가 실패하도록 두고 사용자에게 오류메시지를 보내는것</p><p>내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는것</p><p>분산시스템에 가장 중용한 추상화 중 하나는 합의</p><p>스플릿 브래인(split brain) : 두 노드가 자신이 리더라고 생각하는 상황</p><h3 id="일관성-보장"><a href="#일관성-보장" class="headerlink" title="일관성 보장"></a>일관성 보장</h3><p>복제 데이터베이스는 대부분 최소한 최종적 일관성(Eventual Consistency)을 제공한다</p><p>이것은 매우 약한 보장 언제 복제본이 수렴될지에 대해선 모른다</p><p>트랜젝션 격리는 주로 동시에 실행되는 트랜젝션 때문에 발생하는 경쟁조건을 회피하는것에 관한것</p><p>분산 일관성은 대게 지연과 결함이 있더라도 복제본 상태를 코디네이션 하는것</p><h3 id="선형성"><a href="#선형성" class="headerlink" title="선형성"></a>선형성</h3><p>선형성을 뒷바침 하는 아이디어</p><ul><li>원자적 일관성(atomic consistency)</li><li>강한 일관성(strong consistency)</li><li>즉각 일관성(immediate consistency)</li><li>외부 일관성(external consistency)</li></ul><p>선형성은 최신성 보장(recency guarantee)이다</p><ul><li>시스템에 선형성을 부여하는 것은 무엇인가?<ul><li>읽기가 새로운 값을 반환한 적이 있은 후에는 모든 후속 읽기도 반드시 새로운 값을 반환 해야 된다</li><li>선형성 대 직렬성<ul><li>직렬성 : 트랜잭션들의 격리 속성(트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해 준다)</li><li>선형성 : 레지스터에 실행되는 읽기 쓰기에 대한 최신성 보장이다</li></ul></li></ul></li><li>선형성에 기대기<ul><li>어떤 환경에서 선형성이 유용할까?<ul><li>잠금과 리더 선출<ul><li>아파치 주키퍼</li><li>etcd</li></ul></li><li>제약 조건과 유일성 보장<ul><li>엄격한 유일성 제약조건은 선형성이 필요하다</li></ul></li><li>채널 간 타이밍 의존성<ul><li>웹서버와 이미지 크기 변경 모듈 사이에 다른 통신 채널, 파일저장소와 메시지 큐 때문에 발생하는 문제</li></ul></li></ul></li></ul></li><li>선형성 시스템 구현하기<ul><li>복제 방법<ul><li>단일 리더 복제(선형적이 될 가능성이 있음)</li><li>합의 알고리즘(선형적)</li><li>다중 리더 복제(비선형적)</li><li>리더 없는 복제(아마도 비선형적)</li></ul></li><li>선형성과 정족수<ul><li>엄격한 정족수를 사용한 읽기는 선형적인 것처럼 보인다 하지만 네트워크 지연의 변동이 심하면 경쟁조건이 생길수 있다</li></ul></li></ul></li><li>선형성의 비용<ul><li>복제 방법중 선형성을 제공하는 것도 있고 그렇지 않은 것도 있다</li><li>단일 리더를 사용하는 데이터 베이스는 선형성을 제공하지만 리더가 장애가 나면 선형성을 제공하지 못한다</li><li>CAP 정리<ul><li>일관성(Consistency) : 모든 클라이언트가 같은 순간의 데이터를 보는 것</li><li>가용성(Availability) : 모든 클라이언트의 요청에 항상 응답을 주는 것</li><li>분단 내성(Partition tolerance) : 네트워크 장애가 일어나도 시스템이 정상적으로 동작하는 것</li></ul></li><li>선형성과 네트워크 지연<ul><li>실제로 선형적인 시스템은 놀랄 만큼 드물다</li><li>cpu의 램조차 선형적이지 않다</li><li>선형성을 제거한 이유는 내결함성이 아니라 성능이다</li></ul></li></ul></li></ul><h3 id="순서화-보장"><a href="#순서화-보장" class="headerlink" title="순서화 보장"></a>순서화 보장</h3><p>선형성을 보장할때 순서하가 중요한 근본적 아이디어일 수도 있다는것</p><ul><li>순서화와 인과성<ul><li>순서화가 인과성을 보존하는데 도움을 준다</li><li>질문과 답변사이의 인과적 의존성이 있다</li><li>트랜젝션은 일관된 스냅숏에서 읽는다고 했다 여기서 일관성은 인과성에 일관적이란 의미</li><li>시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다</li><li>인과적 순서가 전체 순서는 아니다<ul><li>수학적 집합은 항성 전체 순서를 정할수 있는건 아니다</li><li>부분적으로 순서가 정해진다(partially ordered)</li><li>선형성 : 시스템에서 연산의 전체순서를 정할수 있다</li><li>인과성 : 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻</li></ul></li><li>선형성은 인과적 일관성보다 강하다<ul><li>선형성은 인과성을 내포한다</li></ul></li><li>인과적 의존성 담기<ul><li>인과성이 유지하기 위해서 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다</li></ul></li></ul></li><li>일련번호 순서화<ul><li>일련번호나 타임스탬프를 써서 이벤트의 순서를 정할수 있다</li><li>일련번호나 타임스템프느는 크기가 작고 전체 순서를 제공한다</li><li>인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다</li><li>비인과적 일련번호 생성기<ul><li>각 노드가 자신만에 독립적인 일련번호 집합을 생성할수 있다</li><li>각 연산에 일 기준 시계에서 얻은 타임스템프를 붙일수 있다</li><li>일련번호 블록을 미리 할당할수 있다</li><li>생성한 일련번호가 인과성에 일관적이지 않다</li></ul></li><li>램포트 타임스템프<ul><li>인과성에 일관적인 일련번호 생성</li><li>모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킨다</li><li>항상 전체순서화를 강제화</li></ul></li></ul></li><li>전체 순서 브로드캐스트<ul><li>cpu에서 실행된 순서가 바로 전체 순서다</li><li>전체 순서 브로드캐스트(total order broadcast)</li><li>원자적 브로드캐스트(atmoic broadcast)</li><li>만족해야할 안전성 속성<ul><li>신뢰성 있는 전달(reliable delivery)</li><li>전체 순서가 정해진 전달(totally ordered delivery)</li></ul></li><li>전체 순서 브로드캐스트 사용하기<ul><li>상태 기계 복제(state machine replication) : 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다</li><li>직렬성 트랜적션을 구현하는데도 쓸수 있다</li><li>메시지가 전달하는 시점에 그 순서가 고정됨</li><li>로그를 만드는 방법 중 하나</li></ul></li><li>전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기<ul><li>전체 순서 브로드캐스트는 비동기식이다</li><li>순차적 일관성(sequential consistency) : 모든 클라이언트가 같은 순서로 메시지를 보는 것</li><li>타임라인 일관성(timeline consistency) : 모든 클라이언트가 같은 순서로 메시지를 보는 것</li></ul></li><li>선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기<ul><li>선형성 레지스터와 전체순서 브로드캐스트는 둘 다 합의와 동등하다고 증명할수 있다</li></ul></li></ul></li></ul><h3 id="분산-트랜잭션과-합의"><a href="#분산-트랜잭션과-합의" class="headerlink" title="분산 트랜잭션과 합의"></a>분산 트랜잭션과 합의</h3><p>여러 노드들이 뭔가에 동의하게 만드는것</p><p>리더선출, 원자적커밋</p><ul><li>원자적 커밋과 2단계 커밋(2PC)<ul><li>원자성은 주데이터와 보조색인이 일관성을 유지하도록 보장한다</li><li>단일 노드에서 분산 원자적 커밋으로<ul><li>단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현됨</li><li>커밋된 트랜잭션 효과는 나중에 다른 보상 트랜잭션(compensation transaction)을 실행해 취소할수 있다</li></ul></li><li>2단계 커밋 소개<ul><li>XA 트랜잭션</li><li>트랜잭션의 참여자(participant)</li><li>트랜잭션 코디네이터(coordinator)</li></ul></li><li>약속에 관한 시스템<ul><li>2PC는 약속에 관한 시스템(promise system)이다</li></ul></li><li>코디네이터 장애<ul><li>코디네이터가 장애가 나면 참여자들은 영원히 대기 상태에 빠진다</li></ul></li><li>3단계 커밋<ul><li>2PC는 코디네이터가 복구하기를 기다리느라 멈출 수 있다는 사실때문에 블로킹 원자적 커밋 프로토콜</li><li>2PC 대안으로 3PC가 있다</li><li>3PC는 원자성을 보장하지못한다</li></ul></li></ul></li><li>현실의 분산 트랜잭션<ul><li>데이터베이스 내부 분산 트랜잭션</li><li>이종 분산 트랜잭션</li><li>정확히 한 번 메시지 처리<ul><li>결과적으로(effectively), 정확히 한번(exactly once) 처리 되도록 보장할수 있다</li></ul></li><li>XA 트랜잭션<ul><li>X&#x2F;Open XA(Extended Architecture) 이종 기술에 걸친 2단계 커밋을 구현하는 표준</li></ul></li><li>의심스러운 상태에 있는 동안 잠금을 유지하는 문제<ul><li>데이터베이스는 트랜잭션이 커밋하거나 어보트할 떄까지 이런 잠금을 해제할 수 없다</li></ul></li><li>코디네이트 장애에서 복구하기<ul><li>고아가된(orphand) 트랜잭션 해결방법은 수동 커밋 롤백 선택</li><li>경험적 결정(hueristic decision) : 코디네이터가 장애가 나면 참여자들이 트랜잭션을 커밋하거나 어보트할 수 있다</li><li>경험적은 2PC 약속 체계를 위반하기 때문에 아마도 원자성을 깰 수 있다</li></ul></li><li>분산트랜잭션 제약<ul><li>코디네이터가 복제되지 않고 단일 장비에서 실행되면 단일 장애점(single point of failure)이 된다</li><li>코디네이터 서버가 어플리케이션의 일부가 되면 상태 비저장 서버가 아니다</li><li>XA가 최소 공통 분모가 되어야 된다</li><li>분산 트랜잭션은 장애를 증폭시키는 경향이 있다</li></ul></li></ul></li><li>내결함성을 지닌 합의<ul><li>합의 알고리즘<ul><li>군일한 동의</li><li>무결성</li><li>유효성</li><li>종료</li></ul></li><li>합의 알고리즘과 전체 순서 브로드캐스트<ul><li>뷰스탬프 복제(viewstamped replication), 팍소스(paxos), 라프트(raft)</li><li>순차열(sequence)에 대해 결정해서 전체 순서 알고리즘을 만든다</li><li>전체 순서 브로드캐스트는 합의를 여러번 반복하는것과 동일</li></ul></li><li>단일 리더 복제와 합의<ul><li>리더를 선출 할려면 먼저 리더가 필요?</li></ul></li><li>에포크 번호 붙이기와 정족수<ul><li>에포크 번호(epoch number)</li><li>투표 번호(ballot number)</li><li>뷰 번호(view number)</li><li>팀 번호(team number)</li></ul></li><li>합의의 제약<ul><li>장애 노드 감지를 위해 일반적으로 타임아웃에 의존</li></ul></li></ul></li><li>멤버십과 코디네이션 서비스<ul><li>분산 키-값 저장소, 코디네이션과 설정 서비스</li><li>선형성 원자적 연산</li><li>연산의 전체 순서화</li><li>장애 감지</li><li>변경 알림</li><li>작업을 노드에 할당하기<ul><li>노드들을 코디네이션 하는 작업의 일부를 외부 서이스에 위탁</li></ul></li><li>서비스 찾기<ul><li>서비스 디스커버리</li></ul></li><li>맴버십 서비스<ul><li>주키퍼와 유사 프로젝트들은 맴버쉽 서비스(membership service)</li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>합의의 문제점</p><ul><li>선형성 레지스터</li><li>원자적 트랜잭션 커밋</li><li>전체 순서 브로드캐스트</li><li>잠금과 임차권</li><li>맴버십&#x2F;코디네이션 서비스</li><li>유일성 제약조건</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
