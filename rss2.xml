<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Sun, 26 Feb 2023 15:45:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CHAPTER 6 예측 가능한 코드를 작성하라</title>
      <link>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/</guid>
      <pubDate>Sun, 26 Feb 2023 15:21:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-6-예측-가능한-코드를-작성하라"><a href="#CHAPTER-6-예측-가능한-코드를-작성하라" class="headerlink" title="CHAPTER 6 예측 가능한 코드를 작성하라"></a>CHAPTER 6 예측 가능한 코드를 작성하라</h2><h3 id="6-1-매직값을-반환하지-말아야-한다"><a href="#6-1-매직값을-반환하지-말아야-한다" class="headerlink" title="6.1 매직값을 반환하지 말아야 한다"></a>6.1 매직값을 반환하지 말아야 한다</h3><p>매직값 magic value는 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다 매직값의 일반적인 예는 값이 ㅇ벗거나 오류가 발생 했음을 나타내기 위해<br>-1을 반환 하는것이다</p><ul><li>매직값은 버그를 유발할 수 있다<ul><li>널, 옵셔널 또는 오류를 반환 하라</li></ul></li><li>때때로 매직값이 우연히 발생할 수 있다<ul><li>매직값은 예측을 벗어나는 결과를 초래 할 수있기 때문에 발생 가능한 상황에 대해 조심해야 된다</li></ul></li></ul><h3 id="6-2-널-객체-패턴을-적절히-사용하라"><a href="#6-2-널-객체-패턴을-적절히-사용하라" class="headerlink" title="6.2 널 객체 패턴을 적절히 사용하라"></a>6.2 널 객체 패턴을 적절히 사용하라</h3><p>값을 얻을수 없을떄 널값이나 빈 옵셔널을 반환 하는 대신 널 객체 패턴을 사용할수 있다.</p><ul><li>빈 컬렉션을 반환하면 코드가 개선될 수 있다.</li><li>빈 문자열을 반환하는 것도 때로는 문제가 될수 있다<ul><li>문자들의 모음으로서의 문자열</li><li>ID로서의 문자열</li></ul></li><li>더 복잡한 널 객체는 예측을 벗어날 수 있다</li><li>널 객체 구현은 예상을 벗어 나는 동작을 유발할 수 있다.</li></ul><h3 id="6-3-예상치-못한-부수-효과를-피하라"><a href="#6-3-예상치-못한-부수-효과를-피하라" class="headerlink" title="6.3 예상치 못한 부수 효과를 피하라"></a>6.3 예상치 못한 부수 효과를 피하라</h3><h4 id="일반적인-부수효과"><a href="#일반적인-부수효과" class="headerlink" title="일반적인 부수효과"></a>일반적인 부수효과</h4><ul><li><p>사용자에게 출력 표시</p></li><li><p>파일이나 데이터베이스에 무언가를 저장</p></li><li><p>다른 시스템을 호출하여 네트워크 트래픽 발생</p></li><li><p>캐시 업데이트 혹은 무효화</p></li><li><p>분명하고 의도적인 부수효과는 괜찮다</p></li><li><p>예기치 않은 부수효과는 문제가 될수 있다</p><ul><li>부수효과는 비용이 많이 들수 있다</li><li>호출한 쪽의 가정을 깨뜨리기</li><li>다중 스레드 코드의 버그</li></ul></li><li><p>부수효과를 피하거나 그 사실을 분명히 해라</p></li></ul><h3 id="6-4-입력-매개변수를-수정하는-것에-주의하라"><a href="#6-4-입력-매개변수를-수정하는-것에-주의하라" class="headerlink" title="6.4 입력 매개변수를 수정하는 것에 주의하라"></a>6.4 입력 매개변수를 수정하는 것에 주의하라</h3><ul><li>입력 매개변수를 수정하면 버그를 초래할 수 있다.<ul><li>변경하기 전에 복사하라</li></ul></li></ul><h3 id="6-5-오해를-일으키는-함수는-작성하지-말라"><a href="#6-5-오해를-일으키는-함수는-작성하지-말라" class="headerlink" title="6.5 오해를 일으키는 함수는 작성하지 말라"></a>6.5 오해를 일으키는 함수는 작성하지 말라</h3><ul><li>중요한 입력이 누락되었을때 아무것도 하지 않으면 놀랄수 있다<ul><li>중요한 입력은 필수 항목으로 만들라</li></ul></li></ul><h3 id="6-6-미래를-대비한-열거형-처리"><a href="#6-6-미래를-대비한-열거형-처리" class="headerlink" title="6.6 미래를 대비한 열거형 처리"></a>6.6 미래를 대비한 열거형 처리</h3><ul><li>미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될수 있다.<ul><li>모든 경우를 처리하는 스위치 문을 사용하라<ul><li>기본 케이스를 주의하라<ul><li>기본 케이스에서 예외 발생</li></ul></li></ul></li><li>주의? 다른 프로젝트의 열거형의 의존</li></ul></li></ul><h3 id="6-7-이-모든-것을-테스트로-해결할-수는-없는가"><a href="#6-7-이-모든-것을-테스트로-해결할-수는-없는가" class="headerlink" title="6.7 이 모든 것을 테스트로 해결할 수는 없는가?"></a>6.7 이 모든 것을 테스트로 해결할 수는 없는가?</h3><ul><li>어떤 개발자는 테스트에 부지런 하지 않을수 있다.</li><li>테스트가 항상 실제 상황을 정확하게 시뮬레이션 하는것은 아니다</li><li>어떤 것들은 테스트하기가 매우 어렵다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>argocd 사용자 추가</title>
      <link>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/</guid>
      <pubDate>Fri, 24 Feb 2023 08:57:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;argocd-사용자-추가&quot;&gt;&lt;a href=&quot;#argocd-사용자-추가&quot; class=&quot;headerlink&quot; title=&quot;argocd 사용자 추가&quot;&gt;&lt;/a&gt;argocd 사용자 추가&lt;/h1&gt;&lt;p&gt;먼저 admin 패스워드 확인 방법은 아래의 방
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="argocd-사용자-추가"><a href="#argocd-사용자-추가" class="headerlink" title="argocd 사용자 추가"></a>argocd 사용자 추가</h1><p>먼저 admin 패스워드 확인 방법은 아래의 방법을 사용하면 조회가 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;&#123;.data.password&#125;&quot; | base64 -d</span><br></pre></td></tr></table></figure><p>argocd CLI 인스톨 방법</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install argocd</span><br></pre></td></tr></table></figure><p>CLI로 접속</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd login &lt;hostname&gt; --username admin --grpc-web-root-path /</span><br></pre></td></tr></table></figure><p>argocd-cm configmap 다운로드</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl get configmap argocd-cm -n argocd -o yaml &gt; argocd-cm.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">accounts.sanaes:</span> <span class="string">login</span></span><br><span class="line">  <span class="attr">accounts.sanaes.enabled:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 처럼 사용자 추가</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f argocd-cm.yml</span><br></pre></td></tr></table></figure><p>사용자 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd account list</span><br></pre></td></tr></table></figure><p>패스워드 업데이트</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd account update-password --account &lt;user-id&gt; --new-password &lt;new-password&gt; --current-password &lt;admin-password&gt;</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/">argocd user management</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 5 가독성 높은 코드를 작성하라</title>
      <link>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/</guid>
      <pubDate>Sat, 18 Feb 2023 14:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-5-가독성-높은-코드를-작성하라"><a href="#CHAPTER-5-가독성-높은-코드를-작성하라" class="headerlink" title="CHAPTER 5 가독성 높은 코드를 작성하라"></a>CHAPTER 5 가독성 높은 코드를 작성하라</h2><p>가독성은 주관적인것 </p><h3 id="서술형-명칭-사용"><a href="#서술형-명칭-사용" class="headerlink" title="서술형 명칭 사용"></a>서술형 명칭 사용</h3><ul><li>서술적이지 않은 이름은 코드를 읽기 어렵게 만든다</li><li>주석문으로 서술적인 이름을 대체할수 없다<ul><li>주석도 유지보수 해야된다</li></ul></li></ul><h3 id="주석문의-적절한-사용"><a href="#주석문의-적절한-사용" class="headerlink" title="주석문의 적절한 사용"></a>주석문의 적절한 사용</h3><p>주석문의 목적</p><ul><li>코드가 무엇을 하는지 설명</li><li>코드가 왜 그 일을 하는지 설명</li><li>사용 지침 등 기타 정보 제공</li></ul><p>코드 기능을 설명하기 위해 주석문을 많이 추가해야 되면 가독성이 떨어진다는 신호</p><ul><li>중복된 주석문은 유해할 수 있다<ul><li>주석도 유지보수 해야 된다</li><li>코드를 지저분하게 만든다</li></ul></li><li>주석문으로 가독성 높은 코드를 대체할 수 없다</li><li>주석문은 코드의 이유를 설명하는데 유용하다</li><li>주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다<ul><li>책 읽을때 줄거리</li></ul></li></ul><h3 id="코드-줄-수를-고정하지-말라"><a href="#코드-줄-수를-고정하지-말라" class="headerlink" title="코드 줄 수를 고정하지 말라"></a>코드 줄 수를 고정하지 말라</h3><ul><li>간결하지만 이해하기 어려운 코드는 피해라<ul><li>많은줄이 필요하더라고 가독성 높은 코드를 작성하라</li></ul></li></ul><h3 id="일관된-코딩-스타일을-고수하라"><a href="#일관된-코딩-스타일을-고수하라" class="headerlink" title="일관된 코딩 스타일을 고수하라"></a>일관된 코딩 스타일을 고수하라</h3><ul><li>일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있다<ul><li>스타일 가이드를 채택하고 따르라</li></ul></li></ul><h3 id="깊이-중첩된-코드를-피하라"><a href="#깊이-중첩된-코드를-피하라" class="headerlink" title="깊이 중첩된 코드를 피하라"></a>깊이 중첩된 코드를 피하라</h3><p>일반적인 코드가 갖는 중첩되는 블록</p><ul><li><p>함수가 호출되면 그 함수가 실행되는 코드가 하나의 블록이 된다</p></li><li><p>if문의 조건이 참일 때 실행되는 코드는 하나의 블록이 된다</p></li><li><p>for루프의 각 반복시 실행되는 코드는 하나의 블록이 된다</p></li><li><p>깊이 중첩된 코드는 읽기 어려울 수 있다</p><ul><li>중첩을 최소화하기 위한 구조 변경</li></ul></li><li><p>중첩은 너무 많은 일을 한 결과물이다</p><ul><li>더 작은 함수로 분리</li></ul></li></ul><h3 id="함수-호출도-가독성이-있어야-한다"><a href="#함수-호출도-가독성이-있어야-한다" class="headerlink" title="함수 호출도 가독성이 있어야 한다"></a>함수 호출도 가독성이 있어야 한다</h3><p>함수의 이름이 잘 명명되면 그함수가 무슨일을 하는지 분명하지만 인수가 무엇이고 무슨역활을 하지는 명롹하지 않다면 호출이 이해되지 않는다</p><ul><li>매개변수는 이해하기 어려울 수 있다<ul><li>명명된 매개변수 사용</li><li>서술적 유형 사용<ul><li>열거형</li><li>클래스</li></ul></li></ul></li><li>때로는 훌륭한 해결책이 없다<ul><li>주석?</li><li>세터 함수</li><li>빌더 패턴</li></ul></li><li>IDE는 어떤가?<ul><li>가독성에는 의존하지 않는것이 좋다<ul><li>모든 개발자가 사용하는게 아닐수 있다</li></ul></li></ul></li></ul><h3 id="설명되지-않은-값을-사용하지-말라"><a href="#설명되지-않은-값을-사용하지-말라" class="headerlink" title="설명되지 않은 값을 사용하지 말라"></a>설명되지 않은 값을 사용하지 말라</h3><p>하드코드로 작성된 값이 필요한 경우</p><ul><li>한 수량을 다른 수량으로 변환 할때 사용하는 계수</li><li>작업이 실패할 경우 재시도의 최대 횟수와 같이 조정 가능한 파라미터 값</li><li>어떤 값이 채워질 수 있는 템플릿을 나타내는 문자열</li></ul><p>하드 코드로 작성된 모든 값에 있는 두가지 중요한 정보</p><ul><li><p>값이 무엇인지</p></li><li><p>값이 무엇을 의미 하는지</p></li><li><p>설명되지 않은 값은 혼란스러울 수 있다</p><ul><li>잘 명명된 상수를 사용하라</li><li>잘 명명된 함수를 사용하라<ul><li>상수를 반환하는 공급자 함수</li><li>변환을 수행하는 헬퍼 함수</li></ul></li></ul></li></ul><h3 id="익명-함수를-적절하게-사용하라"><a href="#익명-함수를-적절하게-사용하라" class="headerlink" title="익명 함수를 적절하게 사용하라"></a>익명 함수를 적절하게 사용하라</h3><ul><li>익명 함수는 간단한 로직에 좋다<ul><li>재사용 관점에서 명명함수가 유용할때가 있다</li></ul></li><li>익명 함수는 가독성이 떨어질 수 있다<ul><li>대신 명명 함수를 사용하라</li></ul></li><li>익명 함수가 길면 문제가 될 수 있다<ul><li>긴 익명 함수를 여러 개의 명명 함수로 나누라</li></ul></li></ul><h3 id="프로그래밍-언어의-새로운-기능을-적절하게-사용하라"><a href="#프로그래밍-언어의-새로운-기능을-적절하게-사용하라" class="headerlink" title="프로그래밍 언어의 새로운 기능을 적절하게 사용하라"></a>프로그래밍 언어의 새로운 기능을 적절하게 사용하라</h3><ul><li>새 기능은 코드를 개선할 수 있다</li><li>불분명한 기능은 혼동을 일으킬 수 있다</li><li>작업에 가장 적합한 도구를 사용하라</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>15장 구글 드라이브 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_15/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_15/</guid>
      <pubDate>Fri, 17 Feb 2023 14:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="15장-구글-드라이브-설계"><a href="#15장-구글-드라이브-설계" class="headerlink" title="15장 구글 드라이브 설계"></a>15장 구글 드라이브 설계</h2><ul><li>블록 저장소 서버<ul><li>큰 파일 업데이트시 해결방법<ul><li>델타 동기화 : 수정이 일어난 블록만 동기화</li><li>압축 : 블록단위로 압축하면 크기를 많이 줄일수 있다</li></ul></li></ul></li><li>높은 일관성 요구사항<ul><li>ACID 를 지원하는 데이터베이스 선택</li></ul></li><li>알림 서비스<ul><li>롱폴링 : 드랍박스</li><li>웹소켓</li></ul></li><li>저장소 공간 절약<ul><li>중복 제거</li><li>지능적 백업 전략<ul><li>한도 설정</li><li>중요한 버전만 보관</li></ul></li><li>자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>14장 유튜브 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_14/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_14/</guid>
      <pubDate>Fri, 17 Feb 2023 13:52:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="14장-유튜브-설계"><a href="#14장-유튜브-설계" class="headerlink" title="14장 유튜브 설계"></a>14장 유튜브 설계</h2><ul><li>비디오 트렌스 코딩<ul><li>비디오 트랜스 코딩의 중요성 <ul><li>가공되지 않은 원본 비디오는 저장 공간을 많이 차지한다</li><li>상당수의 단말과 브라우저는 특정 종류의 비디오 포멧만 지원한다</li><li>사용자에게 끊김 없는 고화질 비디오 재생을 보장하려면 네트워크 대역폭에 따라 다른 화질을 보여주는것이 좋다</li><li>모바일 단말의 경우 네트워크 상황이 수시로 틀려질수 있다</li></ul></li><li>인코딩 포멧<ul><li>컨테이너</li><li>코덱</li></ul></li></ul></li><li>유향 비순환 그래프(DAG) 모델<ul><li>검사</li><li>비디오 인코딩</li><li>썸네일</li><li>워터마크</li></ul></li><li>비디오 트랜스코딩 아키텍처<ul><li>전처리기</li><li>DAG 스케줄러</li><li>자원 관리자</li><li>작업 실행 서버</li><li>임시 저장소</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>13장 검색어 자동완성 시스템</title>
      <link>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_13/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_13/</guid>
      <pubDate>Fri, 17 Feb 2023 13:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="13장-검색어-자동완성-시스템"><a href="#13장-검색어-자동완성-시스템" class="headerlink" title="13장 검색어 자동완성 시스템"></a>13장 검색어 자동완성 시스템</h2><ul><li>트라이 자료구조<ul><li>트리형태의 자료구조</li><li>트리의 루트노드는 빈문자열을 나타낸다</li><li>각 노드는 글자 하나를 저장하며 26개의 자식 노드를 가질수 있다</li><li>각 트리노드는 하나의 단어 또는 접두어 문자열을 나타낸다</li><li>성능 향샹<ul><li>접두어 길이 제한</li><li>노드의 인기 검색어 캐시</li></ul></li></ul></li><li>데이터 수집 서비스</li><li>질의 서비스</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-17-system_design_interview_13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>12장 채팅 시스템 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_12/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_12/</guid>
      <pubDate>Wed, 15 Feb 2023 08:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="12장-채팅-시스템-설계"><a href="#12장-채팅-시스템-설계" class="headerlink" title="12장 채팅 시스템 설계"></a>12장 채팅 시스템 설계</h2><p>메시지 수신 시나리오 </p><ul><li>폴링 : 주기적으로 서버에 물어 보는 방법<ul><li>단점<ul><li>서버에 응답이 없어도 물어봐야 되어서 자원이 낭비됨</li></ul></li></ul></li><li>롱폴링 : 새메시지를 반환 하거나 타임아웃이 될때 까지 대기<ul><li>단점<ul><li>메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수도 있다.</li><li>서버 입장에서 연결을 해재했는지 알 좋은 방법이 없다</li><li>여전히 비효율적이다</li></ul></li></ul></li><li>웹소켓 : 서버가 클라이언트에게 비동기 메시지를 보낼때 가장 널리 사용하는 기술<ul><li>연결은 클라이언트가 하지만 연결되면 양방향으로 메시지 전송이 가능하다</li></ul></li></ul><p>무상태 서비스</p><ul><li>로그인, 회원가입, 사용자 프로파일 표시</li></ul><p>상태 유지 서비스</p><ul><li>채팅서비스</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장 뉴스 피드 시스템 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_11/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_11/</guid>
      <pubDate>Wed, 15 Feb 2023 07:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="11장-뉴스-피드-시스템-설계"><a href="#11장-뉴스-피드-시스템-설계" class="headerlink" title="11장 뉴스 피드 시스템 설계"></a>11장 뉴스 피드 시스템 설계</h2><p>피드 발행 : 피드를 생성하면 데이터 베이스에 저장하고 새 포스팅은 친구들의 뉴스피드에도 전송 된다</p><p>뉴스 피드 생성 : 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다</p><p>팬아웃 : 어떤 사용자의 새 포스팅을 그 사용자와 친구관계에 있는 모든 사용자에게 전달하는 과정</p><ul><li><p>쓰기 시점 팬아웃(push 모델)</p><ul><li>장점<ul><li>실시간 갱신</li><li>뉴스피드가 실시간 갱신되서 읽는 데 드는 시간이 짧아 진다</li></ul></li><li>단점<ul><li>친구가 많으면 뉴스피드 갱신시간이 오래 걸린다(핫키 문제)</li><li>서비스를 자주 사용하지 않는 사용자까지 갱신시켜 자원이 낭비</li></ul></li></ul></li><li><p>읽기 시점 팬아웃(poll 모델)</p><ul><li>장점 <ul><li>비활성화 사용자, 서비스의 거의 로그인하지 않는 사용자에겐 이방법이 유리하다</li><li>핫키 문제가 발생하지 않는다</li></ul></li><li>단점<ul><li>뉴스 피드를 읽는 데 많은 시간이 소요된다</li></ul></li></ul></li></ul><p>캐시 구조</p><ul><li>뉴스피드</li><li>콘텐츠</li><li>소셜그래프</li><li>행동</li><li>횟수</li></ul><p>데이터베이스 규모 확장</p><ul><li><p>수직적 규모 확장 vs 수평적 규모 확장</p></li><li><p>SQL vs NOSQL</p></li><li><p>주-부(master-slave) 다중화</p></li><li><p>복제본(replica)에 대한 읽기 연산</p></li><li><p>일관성 모델</p></li><li><p>데이터베이스 샤딩</p></li><li><p>웹 계층 무상태로 운영하기</p></li><li><p>가능한 많은 데이터를 캐시 할 방법</p></li><li><p>여러 데이터 센터를 지원할 방법</p></li><li><p>메시지 큐를 사용해서 컴포넌트간의 결합도 낮추기</p></li><li><p>핵심 메트릭에 대한 모니터링</p><ul><li>QPS</li><li>지연시간</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-15-system_design_interview_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장 알림 시스템 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/</guid>
      <pubDate>Tue, 07 Feb 2023 15:04:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="10장-알림-시스템-설계"><a href="#10장-알림-시스템-설계" class="headerlink" title="10장 알림 시스템 설계"></a>10장 알림 시스템 설계</h2><p>알림 시스템</p><ul><li>모바일 푸시 알림</li><li>SMS 메시지</li><li>이메일</li></ul><h3 id="알림-유형별-지원-방안"><a href="#알림-유형별-지원-방안" class="headerlink" title="알림 유형별 지원 방안"></a>알림 유형별 지원 방안</h3><ul><li>IOS 푸시 알림<ul><li>알림 제공자 : 애플 푸시 알림 서비스(APNS)<ul><li>단말 토큰</li><li>페이로드</li></ul></li><li>APNS : 애플이 제공하는 원격 서비스</li><li>IOS 단말</li></ul></li><li>안드로이드 푸시 알림<ul><li>FCM : firebase cloud messaging</li></ul></li><li>SMS 메시지<ul><li>트월리오</li><li>넥스모</li></ul></li><li>이메일<ul><li>샌드그리드</li><li>메일침프</li></ul></li></ul><h3 id="연락처-정보-수집-절차"><a href="#연락처-정보-수집-절차" class="headerlink" title="연락처 정보 수집 절차"></a>연락처 정보 수집 절차</h3><p>알림을 보낼려면 모바일 단말 토큰, 전화번호, 이메일 주소등의 정보가 필요하다 수집 방법을 고민할 필요가 있다</p><h3 id="알림-전송-및-수신-절차"><a href="#알림-전송-및-수신-절차" class="headerlink" title="알림 전송 및 수신 절차"></a>알림 전송 및 수신 절차</h3><ul><li>알림 시스템</li><li>제3자 서비스</li><li>IOS, AOS, SMS, 이메일 단말</li><li>문제점<ul><li>SPOF</li><li>규모 확장성</li><li>성능 병목</li></ul></li><li>메시지 큐</li><li>캐시</li><li>알림 서버</li><li>데이터베이스</li><li>worker 서버</li></ul><h3 id="상세설계"><a href="#상세설계" class="headerlink" title="상세설계"></a>상세설계</h3><ul><li>안정성<ul><li>데이터 손실 방지<ul><li>재시도 메커니즘이 존재해야 됨</li></ul></li><li>알림 중복 전송 방지<ul><li>분산 시스템 특성상 가끔 같은 알림이 중복 전송됨</li></ul></li><li>알림 템플릿</li><li>알림 설정</li><li>전송률 제한</li><li>재시도 방법</li><li>푸시 알람과 보안</li><li>큐 모니터링</li><li>이벤트 추적</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-08-system_design_interview_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장 웹 크롤러 설계</title>
      <link>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/</guid>
      <pubDate>Tue, 07 Feb 2023 14:06:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="9장-웹-크롤러-설계"><a href="#9장-웹-크롤러-설계" class="headerlink" title="9장 웹 크롤러 설계"></a>9장 웹 크롤러 설계</h2><p>웹 크롤러는 로봇 또는 스파이더라고도 부른다 검색엔진에 널리 쓰이는 기술로 웹에 새로 올라오거나 갱신된 컨텐츠를 찾는것이 주된 일이다.</p><p>크롤러의 용도</p><ul><li>검색 엔진 인덱싱</li><li>웹 아카이빙</li><li>웹 마이닝</li><li>웹 모니터링</li></ul><p>크롤러의 속성</p><ul><li>규모 확장성</li><li>안정성</li><li>예절</li><li>확장성</li></ul><p>시작 URL 집합</p><ul><li>크롤러가 크롤링을 시작하는 출발점</li><li>시작 URL은 조금 창의적으로 접근 해야될수도 있다.</li><li>주제별로 다른 URL을 사용</li></ul><p>미수집 URL 저장소</p><ul><li>크롤러 상태<ul><li>다운로드할 URL<ul><li>이 내용을 저장하는 저장소</li></ul></li><li>다운로드된 URL</li></ul></li><li>예의<ul><li>너무 많은 요청은 무례한 일이다(DDOS)</li></ul></li></ul><p>HTML 다운로더</p><ul><li>웹페이지를 다운로드하는 컴포넌트</li></ul><p>도메인 이름 변환기</p><ul><li>URL을 IP 주소로 변환 하는 절차가 필요함</li></ul><p>콘텐츠 파서</p><ul><li>웹페이지를 다운로드 하면 파싱과 검증 절차를 거쳐야됨</li></ul><p>중복 콘텐츠인가</p><ul><li>웹페이지에 중복된 컨텐츠가 많다.</li></ul><p>콘텐츠 저장소</p><ul><li>데이터 양이 너무 많으므로 대부분의 콘텐츠는 디스크에 저장한다</li><li>인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄일 것이다</li></ul><p>URL 추출기</p><ul><li>링크를 골라내는 역활</li></ul><p>URL 필터</p><ul><li>특정 콘텐츠 타입이나 파일 확장자를 갖는 URL</li><li>접속 오류 URL</li><li>접근 제외 목록에 포함된 URL</li></ul><p>DFS : 깊이 우선 탐색법</p><ul><li>그래프의 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어렵다</li></ul><p>BFS : 너비 우선 탐색법</p><ul><li>문제점<ul><li>한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.</li><li>표준적 BFS 알고리즘은 URL 간에 우선순위를 두지 않는다</li></ul></li></ul><p>성능 최적화</p><ul><li>분산 크롤링</li><li>도메인 이름 변환 결과 캐시</li><li>지역성</li><li>짧은 타임아웃</li></ul><p>안정성</p><ul><li>안정 해시 : 다운로더 서버들에 부하를 분산할 때 적용 가능한 기술</li><li>크롤링 상태 및 수집 데이터 저장</li><li>예외 처리</li><li>데이터 검증</li></ul><p>문제 있는 콘텐츠 감지 및 회피</p><ul><li>중복 콘텐츠</li><li>거미 덫</li><li>데이터 노이즈</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-07-system_design_interview_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 4 오류</title>
      <link>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/</guid>
      <pubDate>Sun, 05 Feb 2023 14:22:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-4-오류"><a href="#CHAPTER-4-오류" class="headerlink" title="CHAPTER 4 오류"></a>CHAPTER 4 오류</h2><p>코드가 실행되는 환경은 불완전 하다. 사용자가 잘못된 입력을 제공하고, 외부 시스템이 다운되며, 자신이 작성한 코드와 다른 개발자가 작성한 코드가 종종 버그를 가질수 있다.</p><p>오류에 대해서 특히 어떻게 알리고 대처해야 하는지 논의해봐야 골치만 아픈 복잡한 문제다.</p><h3 id="복구-가능성"><a href="#복구-가능성" class="headerlink" title="복구 가능성"></a>복구 가능성</h3><p>복구 가능한 오류</p><ul><li>네트워크 오류</li><li>잘못된 사용자 입력</li><li>중요하지 않은 작업 오류</li></ul><p>복구할 수 없는 오류</p><ul><li>코드와 함께 추가되어야 하는 리소스가 없다</li><li>잘못된 입력 인수로 호출</li><li>일부 필요한 상태를 사전에 초기화 하지 않음</li></ul><p>신속한 실패와 요란한 실패</p><p>호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다</p><p>다른 코드가 자신이 작성한 코드를 호출하는 것과 관련해 다음과 같은 사항을 신중하게 고려해야 한다</p><ul><li>오류로부터 복구하기를 호출하는 쪽에서 원하는가</li><li>만약 그렇다면 오류를 처리할 필요가 있다는 것을 호출하는 쪽에서는 어떻게 알 수 있을까?</li></ul><p>호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라</p><h3 id="견고성-vs-실패"><a href="#견고성-vs-실패" class="headerlink" title="견고성 vs 실패"></a>견고성 vs 실패</h3><p>오류가 발생될때 다음 중 하나를 선택해야 한다</p><ul><li>실패 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다</li><li>오류를 처리하고 계속 진행한다</li></ul><p>신속하게 실패하라</p><ul><li>신속하게 실패하기는 가능한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것</li><li>호출하는 쪽에서 오류를 복구할수 있는 기회를 최대한 제공</li><li>복구 할수 없는 오류일 경우 개발자에게 문제를 신속하게 파악하고 해결할수 있는 기회를 제공</li></ul><p>요란하게 실패하라</p><ul><li>오류가 발생하는데도 아무도 모르는 상황을 막고자 하는 법</li></ul><p>복구 가능성의 범위</p><ul><li>오류가 발견되면 오류를 기록하고 모니터링 해야 된다</li><li>복구할수 있는 또는 복구할수 없는 범위가 틀려질수 있다</li></ul><p>오류를 숨기지 않음</p><ul><li>호출하는 쪽에서 복구하고자 할 수도 있는 오류를 숨기면 호출하는 쪽에서 오류로부터 복구할 수 있는 기회를 없에는 것이다</li><li>복구할수 없는 오류를 숨기면 프로그래밍 오류가 감취진다</li><li>오류를 숨기면 호출하는 쪽에서 실제코드가 잘 작동하고 있다고 가정하지만 실제코드는 작동하지 않을수 있다</li></ul><p>오류가 발생했다는 사실을 숨길수 있는 방법</p><ul><li>기본값 반환<ul><li>오류가 발생했을때 기본값을 반환하는것</li><li>요란한 실패의 원리를 위반 하는것</li></ul></li><li>널 객체 패턴<ul><li>개념적으로 기본값 반환가 유사</li></ul></li><li>아무것도 하지 않음<ul><li>코드가 하는 일에 대해 개발자가 가지고 있는 정신 모델과 코드가 실제로 수행하는 것 사이의 불일치를 일으킬 가능성이 높다</li></ul></li></ul><h3 id="오류-전달-방법"><a href="#오류-전달-방법" class="headerlink" title="오류 전달 방법"></a>오류 전달 방법</h3><p>오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.</p><p>오류를 알리는 방법</p><ul><li>명시적 방법<ul><li>검사 예외<ul><li>명시적으로 오류를 전달하는 방법</li><li>호출하는쪽에서 강제적으로 인식함</li></ul></li><li>널 반환 유형(널 안정성의 경우)<ul><li>널값이 의미하는 바를 설명하기 위해 주석문이나 문서를 추가해야 된다</li><li>널 안정성(?)을 지원하기 때문에 호출하는 쪽에서 널인지 반듯이 확인 해야된다</li></ul></li><li>옵셔널 반환 유형</li><li>리절트 반환 유형<ul><li>널값이나 옵셔널 타입을 반환할때 문제 중하나는 오류 정보를 전달할수 없다는것</li><li>값을 얻을수 없음을 알릴 뿐만 아니라 값을 얻을 수 없는 이유까지 알려주면 유용하다</li></ul></li><li>아웃컴 반환 유형(반환값 확인이 필수인 경우)<ul><li>호출하는쪽에서 반환값을 강제적으로 확인해야 된다면 이것은 오류를 알리는 명백한 방법이다.</li><li>컴파일러가 경고를 생성하도록 함수를 표시할수 있다</li></ul></li><li>스위프트 오류</li></ul></li><li>암시적 방법<ul><li>비검사 예외<ul><li>세부조항일 뿐 오류를 암시적으로 알리는 방법</li><li>호출하는 쪽에서 예외가 발생할수도 있다는걸 몰라도 된다</li></ul></li><li>매직값 반환(피해야 한다)<ul><li>매직값은 코드 계약의 명백한 부분을 통해 호출하는 쪽에 알릴 수 없어서 예상을 벗어나는 결과를 가져올수 있고 버그로 이어질수 있다.</li><li>오류를 알리는 좋은 방법이 아니다</li></ul></li><li>프로미스 또는 퓨처<ul><li>프로미스와 퓨처는 오류 상태도 전달할수 있다.</li><li>호출하는 쪽에서 잠재적인 오류 시나리오를 완전히 알지 못하기 때문에 암시적인 방법</li><li>리절트 유형의 프로미스를 반환하면 명시적이지만 코드가 복잡해지기 때문에 모든 사람이 다 이렇게 사용하지 않을것이다</li></ul></li><li>어서션</li><li>체크(구현에 따라 틀려짐)</li><li>패닉</li></ul></li></ul><h3 id="복구할-수-없는-오류의-전달"><a href="#복구할-수-없는-오류의-전달" class="headerlink" title="복구할 수 없는 오류의 전달"></a>복구할 수 없는 오류의 전달</h3><ul><li>비검사 예외를 발생</li><li>프로그램이 패닉이 되도록</li><li>체크나 어셔션의 사용</li></ul><h3 id="호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달"><a href="#호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달" class="headerlink" title="호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달"></a>호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달</h3><p>비검사 예외를 사용해야 한다는 주장</p><ul><li>코드 구조 개선<ul><li>대부분의 오류 처리가 상위 계층에서 이루어질 수 있기 때문에 비검사 예외를 발생시키면 구조 개선을 할수 있다.</li></ul></li><li>개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함<ul><li>너무 많은 명시적 오류 전달을 접하면 결국 잘못된 일을 한다고 주장</li></ul></li></ul><p>명시적 기법을 사용해야 한다는 주장</p><ul><li>매끄러운 오류 처리<ul><li>비검사 예외를 사용한다면 모든 오류를 매끄럽게 처리할 수있는 단일 계층을 갖기 어렵다</li></ul></li><li>실수로 오류를 무시할 수 없다<ul><li>잘못된일이 기본적으로 혹은 실수로 인해 일어나지 않는다</li></ul></li><li>개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함<ul><li>비검사 예외는 코드베이스 전반에 걸쳐 제대로 문서화가 된다는 보장이 없고 개인적인 경험을 비추어 보아 문서화되지 않는 경우가 많다.</li></ul></li></ul><p>필자는 명시적인 방식을 선호</p><h3 id="컴파일러-경고를-무시하지-말라"><a href="#컴파일러-경고를-무시하지-말라" class="headerlink" title="컴파일러 경고를 무시하지 말라"></a>컴파일러 경고를 무시하지 말라</h3><p>컴파일러 경고는 어떤식으로든 코드가 의심스러우면 표시하는데 이것은 버그에 대한 조기 경고</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li><li><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/CheckReturnValue.html">jsr305 CheckReturnValue</a></li><li><a href="https://jcp.org/en/jsr/detail?id=305">jsr305</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async_function</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 3 다른 개발자와 코드 계약</title>
      <link>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/</guid>
      <pubDate>Sun, 05 Feb 2023 13:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-3-다른-개발자와-코드-계약"><a href="#CHAPTER-3-다른-개발자와-코드-계약" class="headerlink" title="CHAPTER 3 다른 개발자와 코드 계약"></a>CHAPTER 3 다른 개발자와 코드 계약</h2><p><code>예측 가능한 코드를 작성하라, 코드를 오용하기 어렵게 만들라</code> 두가지 원칙은 다른 사람이 작성한 코드와 상호작용할 때 일어날수 있는 일과 관련 있다</p><h3 id="자신의-코드와-다른-개발자의-코드"><a href="#자신의-코드와-다른-개발자의-코드" class="headerlink" title="자신의 코드와 다른 개발자의 코드"></a>자신의 코드와 다른 개발자의 코드</h3><p>1인 개발자 회사에서 일하지 않는한 다른 개발자들을 고려하지 않고는 고품질 코드를 작성할 수 없다</p><p>코드를 작성할때 고려할것 </p><ul><li>자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다<ul><li>자신은 문제를 해결하기 위해 몇시간 또는 몇일을 보냈지만 수정하는 사람은 충분한 시간을 갖지 못했던 사람이 수정해야 된다.</li></ul></li><li>다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다<ul><li>문제가 생기면 컴파일이 중지 되거나 테스트가 실패하도록 만드는것이 병합을 중지시킬수 있는 일이다</li></ul></li><li>시간이 지남에 따라 자신의 코드를 기억하지 못한다<ul><li>코드는 이해하기 쉬어야 하고 잘작동 하던 코드에 버그가 발생하는것이 어려워야 된다 다른 사람에게 호의를 베푸는것이고 미래의 자신을 위한 길이기도 하다</li></ul></li></ul><h3 id="여러분이-작성한-코드의-사용법을-다른-사람들은-어떻게-아는가"><a href="#여러분이-작성한-코드의-사용법을-다른-사람들은-어떻게-아는가" class="headerlink" title="여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?"></a>여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?</h3><ul><li>여러 가지 상황에서 어떤 함수를 호출해야 하는지</li><li>클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지</li><li>어떤 값을 인수로 사용해야 하는지</li><li>코드가 수행하는 동작이 무엇인지</li><li>어떤 값을 반환하는지</li></ul><p>코드가 어떻게 사용해야 하는지 알아내는 방법</p><ul><li>함수, 클래스, 열거형 등의 이름을 살펴본다<ul><li>이름을 잘짓는것이 다른 개발자가 어떻게 사용해야 하는지 가장 잘 전달할수 있는 방법이다.</li></ul></li><li>함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다<ul><li>유형 시스템을 사용하는 언어로 코드를 작성하는것은 오용하거나 오작동하지 못하게 하기 위한 좋은 방법이다.</li></ul></li><li>함수&#x2F;클래스 수준의 문서나 주석문을 읽어본다.<ul><li>함수및 클래스 수준의 비공식 주석문</li><li>자바독과 같은 좀더 공식적인 코드 내 문서</li><li>외부문서</li><li>단점<ul><li>다른 개발자가 이 문서들을 읽을 것이라는 보장이 없으며 실제로 읽지 않을 떄가 많다</li><li>설령 읽더라도 잘못 해석할 수 있다</li><li>문서의 업데이트가 제대로 안 될수 있다</li></ul></li></ul></li><li>직접 와서 묻거나 채팅&#x2F;이메일을 통해 문의한다<ul><li>단점<ul><li>코드를 많이 작성할수록 질문에 답하는 데 더 많은 시간을 써야 할 것이다</li><li>코드작성자가 휴가를 가면 물어볼사람이 없다</li><li>1년이 지나면 자기 자신도 그 코드를 기억하지 못한다 그래서 제한된 기간 동안만 효과가 있다.</li><li>코드를 작성한 사람이 회사를 떠날수도 있는데 그러면 코드를 사용하는 방법에 대한 지식이 사라져 버린다.</li></ul></li></ul></li><li>여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.<ul><li>코드의 양이 많으면 효과를 얻기 힘들다</li><li>추상화 계층을 만드는 데 있어 요점은 개발자가 한 번에 몇 가지 개념만 처리해야 하고 그 문제가 어떻게 해결되었는지 정확히 알지 못하더라고 하위 문제에 대한 해결책을 사용할수 있어야 된다</li></ul></li></ul><h3 id="코드-계약"><a href="#코드-계약" class="headerlink" title="코드 계약"></a>코드 계약</h3><p>계약에 의한 프로그래밍 또는 계약에 의한 디자인</p><p>코드의 계약에 대한 용어의 범주</p><ul><li>선결 조건 : 코드를 호출하기 전에 사실이어야 하는것</li><li>사후 조건 : 코드가 호출된 후에 사실이어야 하는것</li><li>불변 사항 : 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항</li></ul><p>어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대해 생각하는 것이 중요하다</p><p>계약이 명확한 부분</p><ul><li>함수와 클래스 이름</li><li>인자 유형</li><li>반환 유형</li><li>검사 예외(checked exception)</li></ul><p>세부 조항</p><ul><li>주석문과 문서</li><li>비검사 예외(unchecked exception)</li></ul><p>세부조항에 너무 의존하지 말라</p><ul><li>세부조항은 일반적으로 코드 계약을 전달하기 위해 신뢰할 만한 방법이 아니다</li><li>세부조항을 제거하는 방법<ul><li>정적팩토리 함수</li><li>상태나 가변성이 클래스 외부로 노출되는 것을 없엔다</li></ul></li></ul><h3 id="체크-및-어서션"><a href="#체크-및-어서션" class="headerlink" title="체크 및 어서션"></a>체크 및 어서션</h3><p>컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.</p><p>컴파일러를 사용하여 계약을 강제할수 있는 실질적인 방법이 없는 상황이 더러 있다.<br>이러한 경우 런타임 검사를 통해 계약을 확인하는 것이 아예 계약을 확인하지 않는 것보다 낫다.</p><p>체크 </p><ul><li>코드 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다.</li><li>체크는 신속한 실패와 밀접한 관계가 있다.</li></ul><p>체크가 계약조건에 따라 구분 되는 범주</p><ul><li>전제 조건 검사 : 입력 인수 확인, 일부 코드가 실행전에 유효한 상태인지 확인하는 경우</li><li>사후 상태 검사 : 반환값이 올바르거나 일부 코드 실행후 유효한 상태인지 확인하는 경우</li></ul><p>체크의 효과는 보장 되지 않는다</p><ul><li>테스트하기가 불분명한 상황에서 확인 중인 조건이 위반된다면, 코드가 배포되고 사용자가 사용하기 전까지 버그가 미노출</li><li>체크가 잘 작동해서 실패가 명백함에도 불구하고 아무도 알아차리지 못할 위험이 있다. 예외가 일어나더라고 시스템 작동이 엄추지 않게 상위 수준에서 예외가 처리되어<br>로그가 잘 기록 되어도 개발자가 신경쓰지 못하면 아무도 알아차리지 못 한다.</li></ul><p>코드에 체크가 많이 있으면 세부 조항을 없에는 것에 대해 고려해봐야 되는 신호일지도 모른다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-05-good_code_bad_code_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장 URL 단축기 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/</guid>
      <pubDate>Mon, 30 Jan 2023 06:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="8장-URL-단축기-설계"><a href="#8장-URL-단축기-설계" class="headerlink" title="8장 URL 단축기 설계"></a>8장 URL 단축기 설계</h2><ul><li>API 엔드포인트<ul><li>URL 단축용 엔드포인트</li><li>URL 리다이렉션 엔드포인트</li></ul></li><li>URL 리다이렉션<ul><li>301 Moved Permanently : Location 헤더가 가르키는 주소로 영구 이동됨</li><li>302 Found : Location 헤더가 가르키는 주소로 일시적으로 이동</li></ul></li><li>URL 단축</li><li>해시함수<ul><li>해시길이 : 10 + 26 + 26 &#x3D; 62</li><li>해시 함수<ul><li>crc23</li><li>md5</li><li>sha-1</li><li>base62 : 흔히 사용하는 접근법 사용할수 있는 갯수가 62개라서 사용</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장 분산 시스템을 위한 유일 ID 생성기 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/</guid>
      <pubDate>Mon, 30 Jan 2023 01:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="7장-분산-시스템을-위한-유일-ID-생성기-설계"><a href="#7장-분산-시스템을-위한-유일-ID-생성기-설계" class="headerlink" title="7장 분산 시스템을 위한 유일 ID 생성기 설계"></a>7장 분산 시스템을 위한 유일 ID 생성기 설계</h2><p>분산 시스템에서 유일성이 보장되는 id를 만드는 방법</p><ul><li>다중 마스터 복제(multi-master replication)<ul><li>데이터 베이스의 auto_increment 기능을 활용함, 서버 마다 증가하는 값을 다르게 셋팅함</li><li>단점<ul><li>여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다</li><li>ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할수 없다</li><li>서버를 추가하거나 삭제할때 잘 동작하도록 만들기 어렵다</li></ul></li></ul></li><li>UUID(universally unique identifier)<ul><li>유일성이 보장되는 ID를 만드는 간단한 방법</li><li>장점<ul><li>만드는것이 단순하다 서버사이에 조율이 필요없고 동기화 이슈도 없다</li><li>각 서버가 자기가 쓸 ID를 알아서 만드는 구조이며 확장도 쉽다</li></ul></li><li>단점<ul><li>ID가 128바이트로 길다</li><li>ID를 시간순으로 정렬할 수 없다</li><li>ID에 숫자아닌 값이 포함될 수 있다</li></ul></li></ul></li><li>티켓 서버(ticket server)<ul><li>키를 만들어내는 중앙집중식 서버를 한대만 사용하는것</li><li>장점<ul><li>유일성이 보장 되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다</li><li>구현하기 쉽고 중소 규모 애플리케이션에게 적합</li></ul></li><li>단점<ul><li>티켓 서버가 SPOF 가 된다 해당 시스템이 장애면 해당 시스템을 사용하는 모든서버가 영향을 받음</li></ul></li></ul></li><li>트위터 스토우플레이크(Snowflake) 접근법<ul><li>사인 비트 + 타임스탬프 + 데이터센터 ID + 머신 ID + 일련 번호</li><li>사인 비트 : 1 비트 할당</li><li>타임 스템프 : 41 비트 할당</li><li>데이터 센터 ID : 5 비트 할당 32개 데이터 센터를 지원</li><li>서버 ID : 5 비트 할당, 데이터센터당 32개 서버를 지원</li><li>일련번호 : 12 비트 할당, 1밀리초가 경과될때 0으로 초기화</li></ul></li></ul><p>추가 논의 사항</p><ul><li>시계 동기화<ul><li>NTP</li></ul></li><li>각 섹션의 길이 최적화<ul><li>동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 섹션의 길이를 줄이고 타임스탬프 섹션의 길이를 늘리는 방법</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-30-system_design_interview_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장 키-값 저장소 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/</guid>
      <pubDate>Sun, 29 Jan 2023 07:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="6장-키-값-저장소-설계"><a href="#6장-키-값-저장소-설계" class="headerlink" title="6장 키-값 저장소 설계"></a>6장 키-값 저장소 설계</h2><p>키-값 저장소는 키-값 데이터베이스라고도 불리는 비관계형 데이터베이스다<br>키는 유일해야 되며 성능상의 이슈로 키는 짧을수록 좋다<br>값은 보통 무엇이 오던 상관하지 않는다</p><p>분산 키-값 저장소는 분산 해시 테이블이라고도 불린다.</p><h3 id="CAP-정리"><a href="#CAP-정리" class="headerlink" title="CAP 정리"></a>CAP 정리</h3><p>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계 하는것은 불가능하다</p><ul><li>데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 된다</li><li>가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받아야 된다</li><li>파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생겨도 시스템은 계속 동작해야 된다</li></ul><p>핵심 컴포넌트 </p><ul><li>데이터 파티션<ul><li>데이터를 여러서버에 고르게 분산할 수 있는가</li><li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가</li><li>안정해시가 적합한기술</li></ul></li><li>데이터 다중화(replication)<ul><li>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화 필요가 있다.</li><li>가상 노드를 사용할때도 물리서버의 중복 선택되지 않도록 해야 된다</li><li>DR도 고려</li></ul></li><li>일관성(consistency)<ul><li>여러 노드에 다중화된 데이터는 적절히 동기화 해야 된다.</li><li>정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기&#x2F;쓰기 연산 모두에 일관성을 보장할수 있다</li><li>N &#x3D; 사본 갯수</li><li>W &#x3D; 쓰기 연산에 정족수</li><li>R &#x3D; 읽기 연산에 대한 정족수</li><li>R &#x3D; 1, W&#x3D;N : 빠른 읽기 연산에 최적화된 시스템</li><li>W &#x3D; 1, R&#x3D;N : 빠른 쓰기 연산에 최적화된 시스템</li><li>W + R &gt; N : 강한 일관성이 보장됨 (보통 N&#x3D;3, W&#x3D;R&#x3D;2)</li><li>W + R &lt;&#x3D; N : 강한 일관성이 보장되지 않음</li></ul></li><li>일관성 불일치 해소(inconsistency resolution)<ul><li>강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.</li><li>약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못한다.</li><li>최종 일관성 : 약한 일관성의 한 형태로 갱신 결과가 결국에는 모든 사본에 반영되는 모델</li><li>방법<ul><li>데이터 버저닝 : 변경 될때 마다 데이터의 새로운 버전을 만드는것</li><li>벡터 시계 : 서버:버전의 순서쌍을 데이터에 매단것<ul><li>단점<ul><li>충돌 감지 및 해소 로직이 클라이언트에 들어간다.</li><li>서버:버전의 순서쌍이 굉장히 빨리 늘어난다.</li></ul></li></ul></li></ul></li></ul></li><li>장애 처리<ul><li>장애감지<ul><li>모든 노드에 멀티캐스팅 채널을 구축하는것이 가장 손쉬운 방법, 서버가 많으면 비효율적</li><li>가십 프로토콜 같은 분산형 장애 감지 솔루션을 채낵하는것이 효율적</li></ul></li><li>장애해소<ul><li>일시적 장애처리<ul><li>엄격한 정족수 접근법을 쓰면 읽기와 쓰기 연산을 금지</li><li>느슨한 정족수 접근법은 이 조건을 완화하여 가용성을 높인다<ul><li>임시위탁 : 장애가 났을때 다른서버가 잠시 맡아 처리한다</li></ul></li></ul></li><li>영구적 장애처리<ul><li>반 엔트로피 프로토콜 구현 사본 동기화</li></ul></li><li>데이터 센터 장애처리</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장 안정 해시 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/</guid>
      <pubDate>Sun, 29 Jan 2023 07:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="5장-안정-해시-설계"><a href="#5장-안정-해시-설계" class="headerlink" title="5장 안정 해시 설계"></a>5장 안정 해시 설계</h2><p>수평적 규모 확장성을 달성하기 위해서 요청 또는 데이터를 서버에 균등하게 나누는게 중요하다</p><h3 id="해시키-재배치-문제"><a href="#해시키-재배치-문제" class="headerlink" title="해시키 재배치 문제"></a>해시키 재배치 문제</h3><p>n개의 캐시서버의 부하를 균등하게 나누는 보편적인 방법은 </p><p>serverindex &#x3D; hash(key) % n(서버 갯수)</p><p>위에 방법은 서버 풀이 고정되어 있을때 그리고 데이터 분포가 균등할때 잘 동작한다<br>하지만 서버가 추가되거나 삭제 될때는 대부분의 키가 재분배 해야 되는 문제가 생긴다.</p><h3 id="안정해시"><a href="#안정해시" class="headerlink" title="안정해시"></a>안정해시</h3><p>안정해시는 해시테이블의 크기가 조절될때 평균적으로 오직 k&#x2F;n개의 키만 재배치하는 해시 기술이다.</p><ul><li><p>해시 공간과 해시 링</p><ul><li>해시 공간을 구부리면 해시 링이 만들어 진다.</li></ul></li><li><p>해시 서버</p><ul><li>서버는 해시 링에 특정 위치에 존재한다.</li></ul></li><li><p>해시 키</p><ul><li>해시 키는 특정 방향으로 가장 가까운 서버에 값을 저장한다.</li></ul></li><li><p>서버 조회</p><ul><li>특정 위치에 가장 가까운 서버에게 질의 한다</li></ul></li><li><p>서버 추가</p><ul><li>추가가 되도 특정 위치의 해시 키만 다른 서버에 저장된다.</li></ul></li><li><p>서버 제거</p><ul><li>제거시에도 첫번째 만나는 서버에만 저장하면 된다.</li></ul></li><li><p>기본 구현법의 두 가지 문제</p><ul><li>기본 구현법<ul><li>서버와 키를 균등 분포 해시 함수를 사용해서 링에 배치한다</li><li>키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.</li></ul></li><li>두 가지 문제<ul><li>서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는게 불가능하다</li><li>키의 균등 분포를 달성하기가 어렵다</li></ul></li><li>해결 방법 <ul><li>가상 노드 또는 복제 기법</li></ul></li></ul></li><li><p>가상 노드</p><ul><li>실제 노드 또는 서버를 가리키는 노드로써 하나의 서버는 링 위에 여러 개 가상 노드를 가질 수 있다. 가상노드의 갯수를 늘리면 키의 분포는 점점 균등해진다 표준 편차가 작아져 데이터가 고르 분배</li><li>시스템 요구 사항에 맞춰 가상 노드 개수를 적절히 조정해야 된다.</li></ul></li><li><p>재배치할 키 결정</p><ul><li>서버가 추가 되거나 저거되면 데이터 일부는 재배치 해야 된다</li><li>삭제된 노드 반시계 방향에 있는 최초 서버 와 시계 방향 첫번째 서버사이에 키들은 재배치 되어야 된다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-29-system_design_interview_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 2 추상화 계층</title>
      <link>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/</guid>
      <pubDate>Fri, 27 Jan 2023 19:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-2-추상화-계층"><a href="#CHAPTER-2-추상화-계층" class="headerlink" title="CHAPTER 2 추상화 계층"></a>CHAPTER 2 추상화 계층</h2><ul><li>문제와 하위 문제를 어떻게 해결하는가도 중요하지만 그것들을 해결하는 코드를 어떻게 구성하는가도 중요하다</li><li>코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다</li></ul><h3 id="널값-및-의사코드-규약"><a href="#널값-및-의사코드-규약" class="headerlink" title="널값 및 의사코드 규약"></a>널값 및 의사코드 규약</h3><p>많은 프로그래밍 언어에는 값(또는 참조&#x2F;포인터)이 없다는 개념을 가지고 있다 이 개념을 표현하기 위해 넣 null 값을 사용한다.</p><ul><li>값이 제공되지 않거나 함수가 원하는 결과를 반환할수 없는 경우가 자주 발생함 값이 없다 또는 부재한다는 이 개념은 유용하다</li><li>값이 널일수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다</li></ul><p>널 안전성, 보이드 안정성 대한 생각이 점점 추진력을 얻고 있다.</p><p>최근에 몇년간 새로 등장한 중요한 언어들 대부분은 널 안전성을 지원한다.</p><p>사용하는 언어가 널 안전성을 지원하지 않으면 널값을 사용하는 되신 옵셔널 타입을 사용하는것이 좋다</p><h3 id="왜-추상화-계층을-만드는가"><a href="#왜-추상화-계층을-만드는가" class="headerlink" title="왜 추상화 계층을 만드는가?"></a>왜 추상화 계층을 만드는가?</h3><p>하나의 문제가 있을 때 이 문제와 하위 문제에 대한 해결책이 일련의 층을 형성한다고 생각할수 있다. 이것을 추상화 계층이라고 한다</p><p>같은 층위 내에서는 쉽게 이해할 수있는 몇개의 개념만 다루기 때문에 개별 코드가 복잡해 보이지 않을것 이다<br>소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야한다<br>비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로 복잡한 문제를 쉽게 해결 가능하다.</p><p>추상화 계층 및 코드 품질의 핵심 요소</p><ul><li>가독성<ul><li>깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다</li></ul></li><li>모듈화<ul><li>추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기 매우 쉽다</li></ul></li><li>재사용성 및 일반화성<ul><li>하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기 쉬워진다.</li></ul></li><li>테스트 용이성<ul><li>신뢰할수 있는 코드를 작성하고자 한다면 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인 해야 된다.</li><li>코드가 추상호 계층으로 깨끗하게 분활 되면 하위 문제에 대한 해결책을 테스트하는것이 쉬워진다.</li></ul></li></ul><h3 id="코드의-계층"><a href="#코드의-계층" class="headerlink" title="코드의 계층"></a>코드의 계층</h3><p>대부분의 프로그래밍 언어는 코드를 다른 단위로 나누기 위해 몇 가지 언어 요소를 자유롭게 사용할 수 있다</p><ul><li>함수</li><li>클래스(및 구조체나 믹스인과 같이 클래스와 비슷한 요소도 가능)</li><li>인터페이스</li><li>패키지, 네임스페이스, 모듈</li></ul><p>API 및 구현 세부사항</p><ul><li>코드를 호출할 때 볼 수 있는 내용<ul><li>퍼블릭 클래스, 인터페이스 및 함수</li><li>이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념</li><li>코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 정보(예: 호출순서)</li></ul></li><li>우리가 작성한 코드도 미니 API를 노출하는 것으로 생각하면 유용할때가 있다.</li></ul><p>함수</p><ul><li>각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다</li><li>함수를 작성하기 위한 좋은 전략<ul><li>단일 업무 수행</li><li>잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성</li></ul></li><li>함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다</li></ul><p>클래스</p><ul><li>단일 클래스의 이상적인 크기<ul><li>줄수 : 한 클래스의 코드는 300줄이 넘지 않아야 된다.<ul><li>300줄 보다 긴 클래스는 너무 많은 개념을 다룬다고 생각해서 분리해야 된다</li><li>그렇다고 해서 300줄 이하의 모든 클래스가 적절한 크기임을 보장하지 않음</li></ul></li><li>응집력 : 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지 보여주는 척도 좋은 클래스는 응집력이 강하다<ul><li>순차적 응집력 : 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다</li><li>기능적 응집력: 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할때 발생</li></ul></li><li>관심사의 분리 : 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙</li></ul></li><li>코드 계층 및 클래스 생성과 관련한 네가지 핵심요소<ul><li>코드 가독성</li><li>코드 모듈화</li><li>코드 재사용성 및 일반화</li><li>테스트 용이성 및 적절한 테스트</li></ul></li><li>저품질 코드의 근거<ul><li>코드를 읽을 수 없다</li><li>코드가 특별히 모듈화되어 있지 않다</li><li>코드를 재사용할 수 없다</li><li>코드를 일반화할 수 없다</li><li>코드를 제대로 테스트하기 어렵다</li></ul></li><li>코드 개선 방법<ul><li>하위 문제의 해결책을 자체 클래스로 분할하여 개선</li><li>의존성 주입을 활용한다</li><li>이점<ul><li>코드가 좀 더 모듈화되고 재구성할 수 있게 됨</li><li>코드의 재사용성이 좀 더 높아짐</li><li>코드의 테스트 용이성이 좀 더 높아짐</li></ul></li></ul></li></ul><p>인터페이스</p><ul><li>계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출 되지 않도록 하기 위해 사용할 수 있는 한가지 접근법은 잍터페이스를 통해 노출 여부를 결정하는것</li><li>추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스는 매우 유용한 도구다</li><li>모든것을 위한 인터페이스?<ul><li>장점<ul><li>퍼블릭 API를 명확하게 보여준다</li><li>한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다</li><li>테스트를 쉽게 할수 있다</li><li>같은 클래스로 두가지 하위 문제를 해결할 수 있다</li></ul></li><li>단점<ul><li>더 많은 작업이 필요하다</li><li>코드가 복잡해질 수 있다</li></ul></li></ul></li></ul><p>층이 너무 얇아질 때</p><ul><li>코드를 별개의 계층으로 할때 단점<ul><li>클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는코드로 인해 코드양이 늘어난다</li><li>로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다</li><li>인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현을 사용되는지 파악하는데 노력이 필요</li></ul></li><li></li></ul><h3 id="마이크로서비스는-어떤가"><a href="#마이크로서비스는-어떤가" class="headerlink" title="마이크로서비스는 어떤가?"></a>마이크로서비스는 어떤가?</h3><p>마이크로 서비스도 여전히 그 내부에서 적절한 추상화 계층을 고려하는것이 유용하다</p><p>마이크로 서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만 서비스를 위해 여러하위 문제를 해결 하는것은 변하지 않는다</p><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다</li><li>특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌수 있다</li><li>코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li><li><a href="https://en.wikipedia.org/wiki/Void_safety">Void_safety</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-28-good_code_bad_code_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 코드 품질</title>
      <link>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/</guid>
      <pubDate>Fri, 27 Jan 2023 11:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 코드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-I-이론" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART I 이론)</h1><h2 id="CHAPTER-1-코드-품질"><a href="#CHAPTER-1-코드-품질" class="headerlink" title="CHAPTER 1 코드 품질"></a>CHAPTER 1 코드 품질</h2><p>고품질 코드는</p><ul><li>좀 더 신뢰할 수 있다</li><li>유지보수가 쉽다</li><li>버그가 적은 소프트웨어를 생산</li></ul><p>좋은 코드는 좋은 소프트웨어를 만들기 위한 유일한 조건은 아니지만 중요한 조건중에 하나다</p><h3 id="코드는-어떻게-소프트웨어가-되는가"><a href="#코드는-어떻게-소프트웨어가-되는가" class="headerlink" title="코드는 어떻게 소프트웨어가 되는가"></a>코드는 어떻게 소프트웨어가 되는가</h3><ul><li>코드베이스 : 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소</li><li>코드 제출 : 코드 커밋 or mr(pr)</li><li>코드 리뷰 : 코드 제출 전에 다른 프로그래머가 리뷰 해주는것</li><li>제출 전 검사 : 병합전 훅, 병합전 점검, 커밋전 점검 이라고 하며 테스트가 실패하거나 컴파일 되지 않으면 병합되지 않도록 차단한다</li><li>배포 : 소프트웨어는 코드베이스의 스냅샷을 기반으로 빌드된다.</li><li>프로덕션 : 실제 서비드되는 환경을 가르킨다.</li></ul><h3 id="코드-품질의-목표"><a href="#코드-품질의-목표" class="headerlink" title="코드 품질의 목표"></a>코드 품질의 목표</h3><ul><li>안전하고</li><li>실제로 작동하고</li><li>고장 나지 않고</li><li>예측 가능한 행동을하는</li></ul><p>필자가 생각하는 상위수준의 목표</p><ul><li>작동해야 한다<ul><li>문제를 해결하기위해 목적한 대로 동작해야 된다</li></ul></li><li>작동이 멈춰서는 안 된다<ul><li>코드는 다른 코드에 의존할 수 있는데, 그 코드가 수정되고 변경될 수 있다.</li><li>새로운 기능이 필요할 때 코드를 수정해야 할 수도 있다.</li><li>해결해야 될 문제는 시간이 지남에 따라 변경 된다.</li></ul></li><li>변화하는 요구 사항에 적응해야 한다<ul><li>시나리오 A : 모든 요구사항이 어떻게 변할지 정확히 예측하고 잠재적인 변화를 모두 수용하기 위한 코드를 설계하려고 노력한다</li><li>시나리오 B : 요구사항이 변할 수 있다는 사실을 완전히 무시한다. 현재의 요구 사항만 충족시키기 위한 코드만 작성하고 적응력 높은 코드를 작성하기 위한 노력은 하지 않는다.</li><li>두개의 시나리오는 서로 대립하는 극단을 보여준다 두가지 사이에 어떤 지점을 선택해서 개발해야 된다</li></ul></li><li>이미 존재하는 기능을 또다시 구현해서는 안 된다<ul><li>시간과 노력을 절약한다</li><li>버그 가능성을 줄여준다</li><li>기존 전문지식을 활용한다</li><li>코드가 이해하기 쉽다</li></ul></li></ul><h3 id="코드-품질의-핵심-요소"><a href="#코드-품질의-핵심-요소" class="headerlink" title="코드 품질의 핵심 요소"></a>코드 품질의 핵심 요소</h3><ul><li>코드는 읽기 쉬워야 한다<ul><li>코드가 하는일</li><li>어떻게 그 일을 수행하는지</li><li>어떤 것을 필요로 하는지</li><li>코드 실행 결과물</li></ul></li><li>코드는 예측 가능해야 한다<ul><li>코드가 예상을 벗어나면 명백하게 이상한 일이 발견되기 전까지 시스템은 계속 비정상적으로 작동한다.</li></ul></li><li>코드를 오용하기 어렵게 만들라<ul><li>tv 제조 업체는 전원 코드와 HDMI 케이블을 잘못 꽃게 하지 않게 모양을 틀리게 만들었다(요즘 노트북은 모두 USB-C….)</li><li>코드 계약은 근본적으로 코드 오용을 어럽게 만들어주는 기술 이다.</li></ul></li><li>코드를 모듈화하라<ul><li>모듈화는 개체나 시스템의 구성 요소가 독립적으로 교환되거나 교체될 수 있음을 의미한다.</li></ul></li><li>코드를 재사용 가능하고 일반화할 수 있게 작성하라<ul><li>재사용성 : 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있음</li><li>일반화성 : 개념적으로 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미</li><li>모듈화된 코드 역시 더 높은 재사용성과 일반화성을 갖는다</li></ul></li><li>테스트가 용이한 코드를 작성하고 제대로 테스트하라<ul><li>버그나 제대로 동작하지 않는 기능을 갖는 코드가 코드베이스에 병합되지 않도록 방지</li><li>버그나 제대로 동작하지 않는 기능을 갖는 코드가 베포되지 않도록 막고 서비스 환경에서 실행되지 않도록 보장</li><li>테스트 : 코드 혹은 소프트웨어 전체를 테스트하는 것과 관련이 있다<ul><li>단위 테스트 : 일반적으로 개별 함수나 클래스와 같은 작은 단위의 코드를 테스트한다.</li><li>통합 테스트 : 시스템은 일반적으로 여러 구성 요소, 모듈, 하위 시스템으로 구성된다 이러한 하위시스템을 연결하는 과정을 통합이라고 한다</li><li>종단간 테스트 : 이 테스트는 처음부터 끝까지 전체 소프트웨어 시스템에서 작동 흐름을 테스트 한다.</li></ul></li><li>테스트 용이성 : 실제 코드가 얼마나 테스트하기 적합한지를 나타낸다</li></ul></li></ul><h3 id="고품질-코드-작성은-일정을-지연시키는가"><a href="#고품질-코드-작성은-일정을-지연시키는가" class="headerlink" title="고품질 코드 작성은 일정을 지연시키는가?"></a>고품질 코드 작성은 일정을 지연시키는가?</h3><ul><li>단기적으로는 고품질 코드를 작성하는데 시간이 더 걸릴수 있다</li><li>중장기적으로는 개발 시간을 단축시켜준다.</li></ul><p><code>서두르지 않으면 더 빠르다</code></p><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>좋은 소프트웨어를 만들려면 고품질 코드를 작성해야 한다</li><li>실제 서비스 환경에서 실행되는 소프트웨어가 되기 전에 코드는 일반적으로 여러 단계의 검사와 테스트를 통과해야 한다</li><li>버그나 제대로 동작하지 않는 기능이 사용자에게 제공되거나 비즈니스에 중요한 시스템에서 실행 되는 것을 이러한 검사를 통해 막을수 있다</li><li>테스트는 코드를 작성하는 모든 단계에서 고려하는 것이 좋다. 코드를 다 작성하고 난 후에 고려 하는 것이 아니다</li><li>고품질 코드를 작성하면 처음에는 시간이 오래 걸리지만 중장기적으로 개발 시간이 단축되는 경우가 많다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-27-good_code_bad_code_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장 처리율 제한 장치 설계</title>
      <link>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/</guid>
      <pubDate>Thu, 26 Jan 2023 12:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="4장-처리율-제한-장치-설계"><a href="#4장-처리율-제한-장치-설계" class="headerlink" title="4장 처리율 제한 장치 설계"></a>4장 처리율 제한 장치 설계</h2><h3 id="토큰-버킷-알고리즘"><a href="#토큰-버킷-알고리즘" class="headerlink" title="토큰 버킷 알고리즘"></a>토큰 버킷 알고리즘</h3><p>인자</p><ul><li>버킷 크기</li><li>토큰 공급율</li></ul><p>장점</p><ul><li>구현이 쉽다</li><li>메모리 사용 측면에서도 효율적이다.</li><li>짧은 시간에 집중되는 트래픽도 처리가능하다</li></ul><p>단점</p><ul><li>버킷 크기와 토큰 공급률이라는 두개의 인자를 가지고 있는데 이값을 적절하게 튜닝하는게 어렵다.</li></ul><h3 id="누출-버킷-알고리즘"><a href="#누출-버킷-알고리즘" class="headerlink" title="누출 버킷 알고리즘"></a>누출 버킷 알고리즘</h3><p>토큰 버킷 알고리즘이랑 비슷하지만 요청 처리율이 고정되어 있다. 보통 큐로 많이 구현한다.</p><p>인자</p><ul><li>버킷 크기</li><li>처리율</li></ul><p>장점</p><ul><li>큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.</li><li>고정된 처리율을 갖고 있기 때문에 안정적 출력이 필요한 경우에 적합하다</li></ul><p>단점</p><ul><li>단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게 되고 그요청들을 제때 처리 못하면 최신요청은 버려지게 된다.</li><li>두개의 인자를 가지고 있는 데 이를 올바르게 튜닝하기 어렵다.</li></ul><h3 id="고정-원도-카운터-알고리즘"><a href="#고정-원도-카운터-알고리즘" class="headerlink" title="고정 원도 카운터 알고리즘"></a>고정 원도 카운터 알고리즘</h3><ul><li>타임라인을 고정된 간격의 원도로 나누고 각 원도우 마다 카운터를 붙힌다.</li><li>요청이 접수될 떄마다 카운터의 값은 1씩 증가한다.</li><li>카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 윈도우가 열릴때 까지 버려진다.</li></ul><p>장점</p><ul><li>메모리 효율이 좋다</li><li>이해하기 쉽다</li><li>원도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기 적합하다.</li></ul><p>단점</p><ul><li>원도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우 기대했던 시스템 처리 한도보다 많은 양의 요청을 처리한다.</li></ul><h3 id="이동-원도-로깅-알고리즘"><a href="#이동-원도-로깅-알고리즘" class="headerlink" title="이동 원도 로깅 알고리즘"></a>이동 원도 로깅 알고리즘</h3><p>고정 원도 카운터 알고리즘에 중대한 문제가 있는데 원도우 경계 부근에 트래픽이 집중 되는 경우 시스템에서 설정한 한도 보다 많은 요청을 처리하는것이다.</p><p>이동 원도 로깅 알고리즘은 이 문제를 해결한다.</p><ul><li>이 알고리즘은 요청의 타임스템프를 추적한다. 타임스템프 데이터는 보통 레디스의 정렬 집합(sorted set) 같은 캐시에 저장한다.</li><li>새 요청이 오면 만료된 타임스템프는 제거 한다. 만료된 타임스템프는 그값이 현재 원도우 시작시점보다 오래된 타임스템프를 말한다.</li><li>새 요청의 타임스템프를 로그에 추가 한다.</li><li>로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다 그렇지 않으면 요청은 버린다.</li></ul><p>장점</p><ul><li>이 알고리즘이 구현하는 처리율 제한 메커니즘은 아주 정교하다. 어느 순간의 원도를 보더라도 허용되는 요청의 개수는 시스템 처리한도를 넘지 않는다.</li></ul><p>단점</p><ul><li>이 알고리즘은 다량의 메모리를 사용하는데 거부된 요청의 타임 스템프도 보관하기 때문이다.</li></ul><h3 id="이동-원도-카운터-알고리즘"><a href="#이동-원도-카운터-알고리즘" class="headerlink" title="이동 원도 카운터 알고리즘"></a>이동 원도 카운터 알고리즘</h3><p>이동 원도 카운터 알고리즘은 고정 원도 카운터 알고리즘 과 이동 원도 로깅 알고리즘을 결합한 것이다.</p><p>고정 원도우 카운터 알고리즘 처럼 원도우의 카운터를 추적하고 제한 하는데 현재 타임스템프 기반으로 추적하면 이전 요청의 가중치를 부여하여 트레픽 폭주를 완화 한다.</p><p>장점</p><ul><li>이전 시간대의 평균 처리율에 따라 현재 원도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘대응한다.</li><li>메모리 효율이 좋다.</li></ul><p>단점</p><ul><li>직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.</li></ul><h3 id="분산-환경의-처리율-제한장치의-구현"><a href="#분산-환경의-처리율-제한장치의-구현" class="headerlink" title="분산 환경의 처리율 제한장치의 구현"></a>분산 환경의 처리율 제한장치의 구현</h3><ul><li><p>경쟁조건(race condition)</p><ul><li>병행성이 심한 환경에서 경쟁 조건 이슈가 발생할수 있다.</li><li>가장 널리 알려진 해결책은 락이다. 하지만 시스템 성능을 상당히 떨어뜨린다.</li><li>락 대신 해결 방법 루아 스크립트, sorted set 사용</li></ul></li><li><p>동기화(synchronization)</p><ul><li>처리율 제한장치를 여러대 쓸때 동기화 이슈가 발생<ul><li>sticky session 을 활용해 같은 처리율 장치로 전달하는 방법도 있다</li><li>다른 방법은 중앙집중식 데이터 저장소를 활용하는것이다.(ex. redis)</li></ul></li></ul></li><li><p>경성(hard) 또는 연성(soft) 처리율 제한</p><ul><li>경성 처리율 제한 : 절대 임계치를 넘을수 없다</li><li>연성 처리율 제한 : 잠시 동안은 임계치를 넘을수 있다.</li></ul></li><li><p>다양한 계층에서의 처리율 제한</p><ul><li>iptables를 사용하면 ip에 처리율 제한을 걸수도 있다.<ul><li>connlimit 모듈</li><li>limit 모듈</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li><li><a href="https://spring.io/blog/2021/04/05/api-rate-limiting-with-spring-cloud-gateway">API Rate Limiting with Spring Cloud Gateway</a></li><li><a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket</a></li><li><a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky bucket</a></li><li><a href="https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm">How to Design a Scalable Rate Limiting Algorithm with Kong API</a></li><li><a href="https://doublem.org/api-gateway-basic/">API Gateway Throttling 구현</a></li><li><a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-02.html">RateLimit Header Fields for HTTP</a></li><li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">RateLimit header fields for HTTP datatracker</a></li><li><a href="https://www.netfilter.org/projects/iptables/index.html">The netfilter.org “iptables” project</a></li><li><a href="https://thelowedown.wordpress.com/2008/07/03/iptables-how-to-use-the-limits-module/">iptables: How to use the limits module</a></li><li><a href="https://nginxstore.com/blog/kubernetes/microservices-march-protect-kubernetes-apis-with-rate-limiting/">자습서-NGINX Ingress Controller 속도 제한 설정</a></li><li><a href="https://istio.io/latest/docs/tasks/policy-enforcement/rate-limit/">Enabling Rate Limits using Envoy</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-26-system_design_interview_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장 시스템 설계 면접 공략법</title>
      <link>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/</guid>
      <pubDate>Fri, 20 Jan 2023 06:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;가상면접으로-배우는-대규모-시스템-설계-기초&quot;&gt;&lt;a href=&quot;#가상면접으로-배우는-대규모-시스템-설계-기초&quot; class=&quot;headerlink&quot; title=&quot;가상면접으로 배우는 대규모 시스템 설계 기초&quot;&gt;&lt;/a&gt;가상면접으로 배우는 대규모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="가상면접으로-배우는-대규모-시스템-설계-기초"><a href="#가상면접으로-배우는-대규모-시스템-설계-기초" class="headerlink" title="가상면접으로 배우는 대규모 시스템 설계 기초"></a>가상면접으로 배우는 대규모 시스템 설계 기초</h1><h2 id="3장-시스템-설계-면접-공략법"><a href="#3장-시스템-설계-면접-공략법" class="headerlink" title="3장 시스템 설계 면접 공략법"></a>3장 시스템 설계 면접 공략법</h2><h3 id="효과적-면접을-위한-4단계-접근법"><a href="#효과적-면접을-위한-4단계-접근법" class="headerlink" title="효과적 면접을 위한 4단계 접근법"></a>효과적 면접을 위한 4단계 접근법</h3><ul><li>문제 이해 및 설계 범위 확정<ul><li>깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하라<ul><li>구체적으로 어떤 기능들을 만들어야 하나?</li><li>제품 사용자 수는 얼마나 되나?</li><li>회사의 규모는 얼마나 빨리 커지리라 예상되나?</li><li>회사가 주로 사용하는 기술 스택은 무엇인가?</li><li>설계를 단순화 하기위해 활용할수 있는 기존 서비스로는 어떤것이 있나?</li></ul></li></ul></li><li>개략적인 설계안 제시 및 동의 구하기<ul><li>설계안에 대한 최초 청사진을 제시하고 의견을 구하라</li><li>화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라</li><li>시스템 규모에 관계된 제약사항을 만족하는지 개략적으로 계산해 보어라 계산과정을 소리내어 설명하라</li></ul></li><li>상세 설계<ul><li>시스템에서 전반적으로 달성해야할 목표와 기능확인</li><li>전체 설계의 개략적 청사진 마련</li><li>해당 청사진에 대한 면접관의 의견청휘</li><li>상세 설계에서 집중해야 할 영역들 확인</li></ul></li><li>마무리<ul><li>시스템 병목구간 혹은 좀더 개선가능한 지점을 찾아내라</li><li>만든 설계를 한번 다시 요약해주는 것도 도움이 될 수 있다.</li><li>오류가 발생하면 무슨 일이 생기는지 따져보면 흥미롭다</li><li>운영이슈도 논의할 가치가 충분하다.</li><li>미래에 닥칠 규모 확장 요구에 어떻게 대처할 것인지도 흥미로운 주제다</li><li>필요하지만 다루지 못했던 세부적 개선사항들을 제안 할수 있다.</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/102819435">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-20-system_design_interview_3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
