<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Wed, 04 Jan 2023 12:56:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>이펙티브 코틀린 아이템 40: equals 의 규약을 지켜라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/</guid>
      <pubDate>Wed, 04 Jan 2023 12:52:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-40-equals-의
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-40-equals-의-규약을-지켜라"><a href="#아이템-40-equals-의-규약을-지켜라" class="headerlink" title="아이템 40: equals 의 규약을 지켜라"></a>아이템 40: equals 의 규약을 지켜라</h2><h3 id="동등성"><a href="#동등성" class="headerlink" title="동등성"></a>동등성</h3><p>코틀린에는 두 가지 종류의 동등성(equality)이 있다.</p><ul><li>구조적 동등성(structural equality) : equals 메서드와 이를 기반으로 만들어진 &#x3D;&#x3D; 연산자(!&#x3D; 포함)로 확인하는 동등성이다.</li><li>레퍼런스적 동등성(referential equality**) : &#x3D;&#x3D;&#x3D; 연산자(!&#x3D;&#x3D; 포함)로 확인하는 동등성이다.</li></ul><p>equals 는 모든 클래스의 슈퍼클래스인 Any 에 구현되어 있으므로, 모든 객체에서 사용할 수 있다.<br>다만, 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않는다.</p><p>“”.equals(1) 은 가능하지만, “” &#x3D;&#x3D; 1 은 불가능하다.</p><p>같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있다.</p><h3 id="equals-가-필요한-이유"><a href="#equals-가-필요한-이유" class="headerlink" title="equals 가 필요한 이유"></a>equals 가 필요한 이유</h3><p>Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 &#x3D;&#x3D;&#x3D; 처럼 두 인스턴스가 완전히 같은 객체인지를 비교한다.</p><p>이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미한다.</p><p>data 한정자를 붙여서 데이터 클래스로 정의하면, 두 객체가 기본 생성자와 프로퍼티가 같다면 동등성으로 동작한다.</p><p>모든 프로퍼티가 아닌 일부 프로퍼티로만 동등성을 비교 할때는 데이터 클래스에서 동등성 비교 대상이 아닌 프로퍼티를 생성자 프로퍼티가 아닌 클래스 프로퍼티로 선언하면 된다.</p><p>기본 생성자에 선언되지 않은 프로퍼티는 copy() 메서드로 복사되지 않는다.</p><h3 id="equals-를-직접-구현해야-하는-경우"><a href="#equals-를-직접-구현해야-하는-경우" class="headerlink" title="equals 를 직접 구현해야 하는 경우"></a>equals 를 직접 구현해야 하는 경우</h3><ul><li>기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우</li><li>일부 프로퍼티만으로 비교해야 하는 경우</li><li>data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우</li></ul><p>equals 구현하기</p><ul><li>특별한 이유가 없는 이상, 직접 equals 를 구현하는 것은 좋지 않다.</li><li>만약 상속을 한다면, 서브클래스에서 equals 가 작동하는 방식을 변경하면 안 된다는 것을 기억하자.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-04-effective_kotlin_item_40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/</guid>
      <pubDate>Tue, 03 Jan 2023 13:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-39-태그-클래스보다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-39-태그-클래스보다는-클래스-계층을-사용하라"><a href="#아이템-39-태그-클래스보다는-클래스-계층을-사용하라" class="headerlink" title="아이템 39: 태그 클래스보다는 클래스 계층을 사용하라"></a>아이템 39: 태그 클래스보다는 클래스 계층을 사용하라</h2><p>상수(constant) 모드를 가진 클래스를 많이 볼수 있다. 이러한 상수 모드를 태그(tag)라고 부르며 태크를 포함한 클래스를 태그 클래스라고 부른다.</p><p>태그 클래스는 서로다른 책임을 한 클래스에 태그로 넣는 문제를 가진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value: T? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> matcher: Matcher</span><br><span class="line">)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>?)</span></span> = <span class="keyword">when</span>(matcher) &#123;</span><br><span class="line">        Matcher.EQUAL -&gt; value == <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.NOT_EQUAL -&gt; value != <span class="keyword">this</span>.value</span><br><span class="line">        Matcher.LIST_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">        Matcher.LIST_NOT_EMPTY -&gt; value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">        EQUAL,</span><br><span class="line">        NOT_EQUAL,</span><br><span class="line">        LIST_EMPTY,</span><br><span class="line">        LIST_NOT_EMPTY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">equal</span><span class="params">(value: <span class="type">T</span>)</span></span> = </span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEqual</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.NOT_EQUAL)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">emptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_EMPTY)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">notEmptyList</span><span class="params">(value: <span class="type">T</span>)</span></span> =</span><br><span class="line">            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_NOT_EMPTY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>태그 클래스의 단점</p><ul><li>한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가된다.</li><li>여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있다. (value는 LIST_EMPTY, LIST_NOT_EMPTY일때 사용 안됨)</li><li>요소가 여러 목적을 가지고 요소를 여러 방법으로 설정할 수 있는 경우 상태의 일관성과 정확성을 지키기 어렵다.</li><li>팩토리 메소드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 어렵다.</li></ul><p>코틀린에서는 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용한다. 한 클래스에 여러 모드를 만드는 방법 대신에 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueMatcher</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Equal</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value == <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEqual</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> value: T) : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value != <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotEmptyList</span>&lt;<span class="type">T</span>&gt;</span>() : ValueMatcher&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">match</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> List&lt;*&gt; &amp;&amp; value.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sealed-한정자"><a href="#sealed-한정자" class="headerlink" title="sealed 한정자"></a>sealed 한정자</h3><p>sealed 한정자를 반드시 사용해야 하는 것은 아니다. 대신 abstract 한정자를 사용할 수도 있지만 sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한한다.</p><p>sealed class 의 장점</p><ul><li>외부에서 추가적인 서브클래스를 만들 수 없으므로 타입이 추가되지 않는 것이 보장된다. 따라서 when을 사용할 때 else 브랜치를 만들 필요가 없다.</li><li>위 장점을 이용해 새로운 기능을 쉽게 추가할 수 있으며 when 구문에서 처리하는 것을 잊어버리지 않을 수 있다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> ValueMatcher<span class="type">&lt;T&gt;</span>.<span class="title">reversed</span><span class="params">()</span></span>: ValueMatcher&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.EmptyList -&gt; ValueMatcher.EmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEmptyList -&gt; ValueMatcher.NotEmptyList&lt;T&gt;()</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.Equal -&gt; ValueMatcher.Equal&lt;T&gt;(value)</span><br><span class="line">        <span class="keyword">is</span> ValueMatcher.NotEqual -&gt; ValueMatcher.NotEqual&lt;T&gt;(value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>클래스의 서브 클래스를 제어하려면 sealed 한정자를 사용하고 abstract는 상속과 관련된 설계를 할 때 사용한다.</p><h3 id="태그-클래스와-상태-패턴의-차이"><a href="#태그-클래스와-상태-패턴의-차이" class="headerlink" title="태그 클래스와 상태 패턴의 차이"></a>태그 클래스와 상태 패턴의 차이</h3><p>태그 클래스와 상태 패턴(state pattern)을 혼동하면 안된다. 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkoutState</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepareState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExerciseState</span></span>(<span class="keyword">val</span> exercise: Exercise) : WorkoutState()</span><br><span class="line"><span class="keyword">object</span> DoneState : WorkoutState()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Exercise&gt;</span>.<span class="title">toStates</span><span class="params">()</span></span>: List&lt;WorkoutState&gt; = </span><br><span class="line">    flatMap &#123; exercise -&gt; </span><br><span class="line">        listOf(PrepareState(exercise), ExerciseState(exercise))</span><br><span class="line">    &#125; + DoneState</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkoutPresenter</span></span>( <span class="comment">/*...*/</span> ) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: WorkoutState = states.first()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차이점</p><ul><li>상태는 더 많은 책임을 가진 클래스이다</li><li>상태는 변경할 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/</guid>
      <pubDate>Tue, 03 Jan 2023 12:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-38-연산-또는-액션
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라"><a href="#아이템-38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라" class="headerlink" title="아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라"></a>아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라</h2><p>대부분의 프로그래밍 언어에서는 함수 타입이 없다. 그래서 액션을 전달할때 메서드가 하나만 있는 인터페이스를 전달한다<br>이러한 인터페이스를 SAM(Single-Abstract Method)이라 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clicked</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClick</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setOnClickListener(<span class="keyword">object</span> : OnClick &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clicked</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>파라미터 전달 방법</p><ul><li><p>람다 표현식 또는 익명 함수로 전달</p></li><li><p>함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달</p></li><li><p>선언된 함수 타입을 구현한 객체로 전달</p></li></ul><p>SAM의 장점이 아규먼트에 이름이 붙어있다고 말하는 경우도 있지만, type alias를 이용해 함수 타입도 이름을 붙여 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Onclick = (View) -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="keyword">typealias</span> OnClick = (view: View) -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>람다 표현식을 사용할 때는 아규먼트 분해(destructure argument)도 사용할 수 있다.</p><h3 id="언제-SAM을-사용해야-할까"><a href="#언제-SAM을-사용해야-할까" class="headerlink" title="언제 SAM을 사용해야 할까?"></a>언제 SAM을 사용해야 할까?</h3><p>코틀린이 아닌 다른 언어에서 사용할 클래스를 설계하는 경우라면 SAM을 사용하는것이 좋다.</p><p>함수 타입으로 사용할떄 단점</p><ul><li>함수 타입으로 만들어진 클래스는 자바에서 type alias과 IDE의 지원을 제대로 받을 수 없다.</li><li>다른 언어(자바 등)에서 코틀린의 함수 타입을 사용하려면 Unit을 명시적으로 리턴하는 함수가 필요하다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-03-effective_kotlin_item_38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 37: 데이터 집합표현에 data 한정자를 사용하라</title>
      <link>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/</link>
      <guid>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/</guid>
      <pubDate>Mon, 02 Jan 2023 12:47:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-37-데이터-집합표현
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-37-데이터-집합표현에-data-한정자를-사용하라"><a href="#아이템-37-데이터-집합표현에-data-한정자를-사용하라" class="headerlink" title="아이템 37: 데이터 집합표현에 data 한정자를 사용하라"></a>아이템 37: 데이터 집합표현에 data 한정자를 사용하라</h2><p>떄로는 데이터를 한번에 전달해야 되는데 이럴때는 data 한정자를 사용해서 class를 만들면 좋다</p><ul><li>toString</li><li>equals와 hashcode</li><li>copy : immutable 클래스를 만들때 유용하다.</li><li>compoentN : 위치 기반 클래스 해체를 할수 있게 도와준다.</li></ul><h3 id="위치-기반-해체"><a href="#위치-기반-해체" class="headerlink" title="위치 기반 해체"></a>위치 기반 해체</h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ul><li>변수명을 원하는대로 지정할수 있다.</li></ul><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ul><li>위치를 잘못 지정하면 잘못 해체된다.</li><li>해체 할때 생성자의 프로퍼티 명과 동일하게 해주는게 좋다 IDE의 경고 메시지를 받을수 있다.</li><li>값을 하나만 갖는 데이터 클래스는 해체하지 말자 읽는사람에게 혼동을 줄수 있다</li></ul><h3 id="튜플-대신-데이터-클래스-사용하기"><a href="#튜플-대신-데이터-클래스-사용하기" class="headerlink" title="튜플 대신 데이터 클래스 사용하기"></a>튜플 대신 데이터 클래스 사용하기</h3><p>Pair 와 Triple은 코틀린에 마지막 남은 튜플</p><p>데이터 클래스가 튜플보다 항상 나아서 사라짐</p><p>튜플의 사용 용도</p><ul><li>값에 간단하게 이름을 붙일때</li><li>미리 알수 없는 집합을 표현할때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/01/2023-01-02-effective_kotlin_item_37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 36: 상속보다는 컴포지션을 사용하라</title>
      <link>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/</guid>
      <pubDate>Fri, 30 Dec 2022 02:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-36-상속보다는-컴포
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-36-상속보다는-컴포지션을-사용하라"><a href="#아이템-36-상속보다는-컴포지션을-사용하라" class="headerlink" title="아이템 36: 상속보다는 컴포지션을 사용하라"></a>아이템 36: 상속보다는 컴포지션을 사용하라</h2><p>단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 한다.</p><h3 id="간단한-행위-재사용"><a href="#간단한-행위-재사용" class="headerlink" title="간단한 행위 재사용"></a>간단한 행위 재사용</h3><p>상속의 단점</p><ul><li>상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면 거대한 Base 클래스를 만들게 되고 복잡한 계층 구조가 만들어 진다.</li><li>상속은 클래스의 모든것을 가지고 오게 된다. 불필요한 함수를 갖는 클래스가 만들어진다.</li><li>상속은 이해하기 어렵다.</li></ul><p>컴포지션을 사용하는것은 객체를 프로퍼티로 갖고 함수를 호출하는 형태로 재사용하는 것을 의미 한다.</p><h3 id="모든것을-가지고-올-수밖에-없는-상속"><a href="#모든것을-가지고-올-수밖에-없는-상속" class="headerlink" title="모든것을 가지고 올 수밖에 없는 상속"></a>모든것을 가지고 올 수밖에 없는 상속</h3><p>상속은 슈퍼클래스의 매서드, 제약, 행위 등 모든 것을 가지고 온다. 객체의 계층구조를 나타낼 때 굉장히 좋은 도구</p><p>하지만 그래서 단점도 존재 한다. 필요 없는 매소드는 오버라이딩 해서 처리해야 된다.(인터페이스 분리 원칙의 위배)</p><h3 id="캡슐화를-깨는-상속"><a href="#캡슐화를-깨는-상속" class="headerlink" title="캡슐화를 깨는 상속"></a>캡슐화를 깨는 상속</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt; : <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위임 패턴, 포워딩 매소드 </p><p>위임 패턴을 쉽게 구현할수 있는 문법을 제공해 준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableSet&lt;T&gt; = mutableSetOf()</span><br><span class="line">) : MutableSet&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="오버라이딩-제한하기"><a href="#오버라이딩-제한하기" class="headerlink" title="오버라이딩 제한하기"></a>오버라이딩 제한하기</h3><p>개발자가 상속용으로 설계 되지 않은 클래스의 상속을 막을려면 final 키워드를 붙히면 된다.<br>하지만 어떤 이유에서 상속은 허용하지만 메소드의 오버라이딩만 제한하고 싶을때는 open 키워드를 사용하면 된다.</p><p>open 클래스는 open된 메소드만 오버라이딩 가능하다.</p><p>정리 </p><ul><li><p>컴포지션은 더 안전하다.</p></li><li><p>컴포지션이 더 유연하다.</p></li><li><p>컴포지션이 더 명시적이다.</p></li><li><p>컴포지션은 생각보다 번거롭다.</p></li><li><p>다형성을 가지기 어렵다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-30-effective_kotlin_item_36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스용 유용한 툴</title>
      <link>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/</guid>
      <pubDate>Fri, 09 Dec 2022 05:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스용-유용한-툴&quot;&gt;&lt;a href=&quot;#쿠버네티스용-유용한-툴&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스용 유용한 툴&quot;&gt;&lt;/a&gt;쿠버네티스용 유용한 툴&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://minikub
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스용-유용한-툴"><a href="#쿠버네티스용-유용한-툴" class="headerlink" title="쿠버네티스용 유용한 툴"></a>쿠버네티스용 유용한 툴</h1><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a> : 로컬에서 쿠버네티스 테스트용</li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a> : 쿠버네티스 네임스페이스&#x2F;컨텍스트 변경</li><li><a href="https://k9scli.io/">k9s</a> : 쿠버네티스 커멘드라인 gui tool</li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a> : 쿠버네티스 IDE</li><li><a href="https://www.telepresence.io/">telepresence</a> : 원격 개발 환경을 설정할 수 있는 오픈 소스 도구</li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a> : 명령 줄 플러그인</li><li><a href="https://github.com/yannh/kubeconform">kubeconform</a> : 쿠버네티스 yml 검증</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/ahmetb/kubectx">kubectx</a></li><li><a href="https://k9scli.io/">k9s</a></li><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a></li><li><a href="https://www.telepresence.io/">telepresence</a></li><li><a href="https://github.com/jonmosco/kube-ps1">kube-ps1</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-09-k8s_tools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 속성 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/</guid>
      <pubDate>Tue, 06 Dec 2022 02:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-속성-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-속성-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 속성 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 속성 테스트&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-속성-테스트"><a href="#쿠버네티스-워크로드-크론잡-속성-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 속성 테스트"></a>쿠버네티스 워크로드 크론잡 속성 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cron-job-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">    <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">failedJobsHistoryLimit:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때 완료되거나 실패한 pod를 정리하는 속성</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">## 특정 시간이 지날때까지 잡이 끝나지 않을때 종료하는 옵션</span></span><br><span class="line">            <span class="comment">## type: Failed 와 reason: DeadlineExceeded 로 표시됨</span></span><br><span class="line">            <span class="attr">activeDeadlineSeconds:</span> <span class="number">200</span></span><br><span class="line">            <span class="comment">## backoffLimit 에 도달하면 작업은 실패한것으로 간주한다.</span></span><br><span class="line">            <span class="attr">backoffLimit:</span> <span class="number">10</span></span><br><span class="line">            <span class="comment">## 병렬실행 관련 옵션</span></span><br><span class="line">            <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">            <span class="comment">## 완료</span></span><br><span class="line">            <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">concurrency-policy-forbid-test</span></span><br><span class="line">                          <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">                          <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;job start&#x27;;sleep 140; echo &#x27;job end&#x27;&quot;</span>]</span><br><span class="line">                    <span class="comment">## 재시작 정책 Never, OnFailure</span></span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create -f cronjob.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-06-k8s_cronjob_test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 크론잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/</guid>
      <pubDate>Mon, 05 Dec 2022 03:23:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-크론잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-크론잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 크론잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 크론잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-크론잡-테스트"><a href="#쿠버네티스-워크로드-크론잡-테스트" class="headerlink" title="쿠버네티스 워크로드 크론잡 테스트"></a>쿠버네티스 워크로드 크론잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">    <span class="attr">jobTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">template:</span></span><br><span class="line">                <span class="attr">spec:</span></span><br><span class="line">                    <span class="attr">containers:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                      <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                      <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">                    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobTemplate 아래는 job 과 완전 똑같은 스팩이다. 바로 직전에 테스트 해본 잡을 가지고 테스트 해보면 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/tasks/job/automated-tasks-with-cron-jobs/">kubernetes cron job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-k8s_workloads_cronjob/#disqus_thread</comments>
    </item>
    
    <item>
      <title>argo workflows 설치</title>
      <link>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/</guid>
      <pubDate>Mon, 05 Dec 2022 02:53:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;argo-workflows-설치&quot;&gt;&lt;a href=&quot;#argo-workflows-설치&quot; class=&quot;headerlink&quot; title=&quot;argo workflows 설치&quot;&gt;&lt;/a&gt;argo workflows 설치&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="argo-workflows-설치"><a href="#argo-workflows-설치" class="headerlink" title="argo workflows 설치"></a>argo workflows 설치</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><p><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a><br>최신 릴리즈 버전을 인스톨 한다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl create namespace argo</span><br><span class="line">kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v3.3.10/install.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment \</span><br><span class="line">  argo-server \</span><br><span class="line">  --namespace argo \</span><br><span class="line">  --type=&#x27;json&#x27; \</span><br><span class="line">  -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/args&quot;, &quot;value&quot;: [</span><br><span class="line">  &quot;server&quot;,</span><br><span class="line">  &quot;--auth-mode=server&quot;</span><br><span class="line">]&#125;]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>아래처럼 포트 포워딩후에 <a href="https://localhost:2746/">https://localhost:2746/</a> 접속한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argo port-forward deployment/argo-server 2746:2746</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://github.com/argoproj/argo-workflows/releases">argo workflows release</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-05-argo_workflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>쿠버네티스 워크로드 잡 테스트</title>
      <link>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</link>
      <guid>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/</guid>
      <pubDate>Fri, 02 Dec 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;쿠버네티스-워크로드-잡-테스트&quot;&gt;&lt;a href=&quot;#쿠버네티스-워크로드-잡-테스트&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 워크로드 잡 테스트&quot;&gt;&lt;/a&gt;쿠버네티스 워크로드 잡 테스트&lt;/h1&gt;&lt;p&gt;로컬에서 테스트 하기 위해
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="쿠버네티스-워크로드-잡-테스트"><a href="#쿠버네티스-워크로드-잡-테스트" class="headerlink" title="쿠버네티스 워크로드 잡 테스트"></a>쿠버네티스 워크로드 잡 테스트</h1><p>로컬에서 테스트 하기 위해 <a href="https://minikube.sigs.k8s.io/docs/start/">마니쿠베</a>를 인스톨 한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml</span><br></pre></td></tr></table></figure><p>위 처럼 간단하게 테스트 해볼수 있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">                  <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">                  <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">            <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li><li><a href="https://kubernetes.io/ko/docs/concepts/workloads/controllers/job/">kubernetes job</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/12/2022-12-02-k8s_workloads_job/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 33: 생성자 대신 팩토리 함수를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-33-생성자-대신-팩토리-함
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-33-생성자-대신-팩토리-함수를-사용하라"><a href="#아이템-33-생성자-대신-팩토리-함수를-사용하라" class="headerlink" title="아이템 33: 생성자 대신 팩토리 함수를 사용하라"></a>아이템 33: 생성자 대신 팩토리 함수를 사용하라</h2><p>생성자 역활을 대신해주는 함수를 팩토리 함수</p><p>팩토리 함수의 장점</p><ul><li>함수의 이름을 붙일수 있다</li><li>함수가 원하는 타입을 리턴할 수 있다</li><li>호출될때 마다 새객체를 만들 필요가 없다</li><li>아직 존재하지 않는 객체를 리턴할 수 있다</li><li>객체 외부에 팩토리 함수를 만들면 가시성을 원하는 대로 조정할수 있다</li><li>팩토리 함수는 인라인으로 만들수 있으며 그 파라미터들을 reified로 만들수 있다</li><li>생성자로 만들기 복잡한 객체도 만들수 있다</li><li>원하는 때에 생성자를 호출할수 있다</li></ul><p>팩토리 함수의 제약</p><p>서브클레스 생성에는 슈퍼클래스 생성자가 필요하기 때문에 서브 클래스를 만들어 낼수 없다.</p><h3 id="Companion-객체-팩토리-함수"><a href="#Companion-객체-팩토리-함수" class="headerlink" title="Companion 객체 팩토리 함수"></a>Companion 객체 팩토리 함수</h3><p>자바의 정적 팩토리 함수</p><p>c++ 이름을 가진 생성자</p><p>많이 사용되는 함수 이름</p><ul><li>from : 파라미터를 하나 받고, 같은 타입의 인스턴스를 하나 리턴하는 타입의 변환 함수</li><li>of : 파라미터를 여러개 받고, 이를 통합하여 인스턴스를 만들어 주는 함수</li><li>valueOf : from 또는 of 와 비슷한 기능을 하면서 의미를 조금 더 쉽게 읽을수 있게 이름을 붙힘 함수</li><li>instance or getInstance : 싱글턴으로 인스턴스 하나를 리턴하는 함수</li><li>createInstance : instance or getInstance 처럼 동작하지만 싱글턴이 적용되지 않아 매번 인스턴스를 새롭게 만드는 함수</li><li>getType : getInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li><li>newType : createInstance 처럼 동작하지만 팩토리 함수가 다른 클래스에 있을때 사용하는 함수</li></ul><p>추상 Companion 객체 팩토리는 값을 가질수 있다 캐싱을 구현 하거나 테스트를 위한 가짜 객체 생성할수 있다.</p><h3 id="확장-팩토리-함수"><a href="#확장-팩토리-함수" class="headerlink" title="확장 팩토리 함수"></a>확장 팩토리 함수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Tool.Companion.<span class="title">createBigTool</span><span class="params">()</span></span> : BigTool&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>companion 객체가 존재할 때, 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때 사용</li></ul><h3 id="톱레벨-팩토리-함수"><a href="#톱레벨-팩토리-함수" class="headerlink" title="톱레벨 팩토리 함수"></a>톱레벨 팩토리 함수</h3><ul><li>대표적인 예 listOf, setOf, mapOf</li><li>public 톱 레벨 함수는 모든곳에서 사용할 수 있으므로 ide가 제공하는 팁을 복잡하게 만드는 단점</li></ul><h3 id="가짜-생성자"><a href="#가짜-생성자" class="headerlink" title="가짜 생성자"></a>가짜 생성자</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">4</span>) &#123;<span class="string">&quot;User<span class="variable">$it</span>&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">List</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">size:<span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">init</span>: (<span class="type">index</span>:<span class="type">Int</span>)-&gt;<span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; = MutableList(size,<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">invoke</span><span class="params">(size: <span class="type">Int</span>, generator: (<span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span>: Tree &lt;T&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>invoke 연산자를 갖는 companion 객체를 사용할 수도 있는데 추천 하지 않는 방식이다</p><ul><li>인터페이스를 위한 생성자를 만들고 싶을때</li><li>reified 타입 아규먼트를 갖게 하고 싶을때</li></ul><h3 id="팩토리-클래스의-메서드"><a href="#팩토리-클래스의-메서드" class="headerlink" title="팩토리 클래스의 메서드"></a>팩토리 클래스의 메서드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SutudentsFactory</span></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> nextId = <span class="number">0</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">(name:<span class="type">String</span>,surname:<span class="type">String</span> = Student(nextId++,name,surname)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>팩토리 클래스는 프로퍼티를 가질 수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-27-effective_kotlin_item_33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-34-기본-생성자에-이름-있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라"><a href="#아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라" class="headerlink" title="아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라"></a>아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라</h2><p>기본 생성자 : 객체를 정의하고 생성하는 방법을 지정할때 사용하는 가장 기본적인 방법</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> surname: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(<span class="string">&quot;Zola&quot;</span>, <span class="string">&quot;Gianfranco&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="점층적-생성자-패턴-telescoping-constructor-pattern"><a href="#점층적-생성자-패턴-telescoping-constructor-pattern" class="headerlink" title="점층적 생성자 패턴(telescoping constructor pattern)"></a>점층적 생성자 패턴(telescoping constructor pattern)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size: String</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheess: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>, bacon: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size</span><br><span class="line">        <span class="keyword">this</span>.cheess = cheess</span><br><span class="line">        <span class="keyword">this</span>.olives = olives</span><br><span class="line">        <span class="keyword">this</span>.bacon = bacon</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>, olives: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, olives, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String, cheese: <span class="built_in">Int</span>): <span class="keyword">this</span>(size, cheese, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(size: String): <span class="keyword">this</span>(size, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>코틀린은 디폴트 아규먼트(default argument)를 사용할 수 있기 때문에 아래처럼 사용할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="빌더-패턴-builder-pattern"><a href="#빌더-패턴-builder-pattern" class="headerlink" title="빌더 패턴(builder pattern)"></a>빌더 패턴(builder pattern)</h3><p>자바에서는 네임드 파라미터(named parameter)와 디폴트 아규먼트(default argument)를 사용할 수 없다. 그래서 빌더 패턴을 사용한다.</p><p>빌더 패턴의 장점</p><ul><li>파라미터에 이름을 가진다.</li><li>파라미터를 원하는 순서대로 지정</li><li>디폴트 값을 지정</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> size: String,</span><br><span class="line">    <span class="keyword">val</span> cheese: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> olives: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> bacon: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> size: String) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cheese: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> olives: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> bacon: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setCheese</span><span class="params">(value: <span class="type">Int</span>)</span></span>: Builder = apply &#123;</span><br><span class="line">            cheese = value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = Pizza(size, cheese, olives, bacon)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린은 빌더 패턴을 사용하는것 보다 네임드 파라미터를 사용하는게 좋다.</p><p>값의 의미를 묶어서 지정할때나 특정값을 누적하는 형태로 사용될때 빌더 패턴을 이용하는것이 나을수도 있는데<br>코틀린에서는 DSL 빌더를 이용해서 구현하는것을 더 좋게 본다(?)</p><p>빌더 패턴은 다음과 같은 경우에만 사용</p><ul><li>빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때</li><li>디폴트 아규먼트와 DSL을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API를 설계할 때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/</guid>
      <pubDate>Tue, 27 Sep 2022 03:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-객체생성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-객체생성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(객체생성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(객체생성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-35-복잡한-객체를-생성하기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-객체생성"><a href="#이펙티브-코틀린-객체생성" class="headerlink" title="이펙티브 코틀린(객체생성)"></a>이펙티브 코틀린(객체생성)</h1><h2 id="아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라"><a href="#아이템-35-복잡한-객체를-생성하기-위한-DSL을-정의하라" class="headerlink" title="아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라"></a>아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라</h2><p>함수 타입의 몇가지 예</p><ul><li>()-&gt;Unit : 아규먼트를 갖지 않고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Unit : Int를 아규먼트로 받고, Unit을 리턴하는 함수</li><li>(Int)-&gt;Int : Int를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int, Int)-&gt;Int : Int 2개를 아규먼트로 받고, Int를 리턴하는 함수</li><li>(Int)-&gt;()-&gt;Unit : Int를 아규먼트로 받고, 다른 함수를 리턴하는 함수 이때 다른함수는 아규먼트로 아무것도 받지 않고 Unit을 리턴</li><li>(()-&gt;Unit)-&gt;Unit : 다른 함수를 아규먼트로 받고, Unit을 리턴하는 함수</li></ul><p>함수 타입을 만드는 기본적인 방법</p><ul><li>람다 표현식</li><li>익명함수</li><li>함수 레퍼런스</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> plus1: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;a, b -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="title">fun</span><span class="params">(a, b)</span></span> = a + b</span><br><span class="line"><span class="keyword">val</span> plus3: (<span class="built_in">Int</span>, <span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = ::plus</span><br><span class="line"><span class="keyword">val</span> plus4 = &#123;a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt; a + b&#125;</span><br><span class="line"><span class="keyword">val</span> plus5 = <span class="function"><span class="title">fun</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>함수타입은 함수를 나타내는 객체를 표현하는 타입</p><p>확장함수(리시버를 가진 함수타입)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">myPlus</span><span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br><span class="line"><span class="keyword">val</span> myPlus: <span class="built_in">Int</span>.(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"><span class="keyword">val</span> myPlus = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = thie + other</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 호출 방법</p><ul><li>일반적인 객체처럼 invoke 메서드를 사용</li><li>확장 함수가 아닌 함수처럼 사용</li><li>일반적인 확장함수처럼 사용</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPlus.invoke(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">myPlus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1.</span>myPlus(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>리시버를 가진 함수타입의 가장 중요한 특징은 this의 참조 대상을 변경할수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> surname: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User().apply &#123; </span><br><span class="line">    name = <span class="string">&quot;sejoung&quot;</span></span><br><span class="line">    surname = <span class="string">&quot;kim&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DSL-의-사용"><a href="#DSL-의-사용" class="headerlink" title="DSL 의 사용"></a>DSL 의 사용</h3><ul><li>복잡한 자료구조</li><li>계층적인 구조</li><li>거대한 양의 데이터</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-28-effective_kotlin_item_35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 32: 추상화 규약을 지켜라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/</guid>
      <pubDate>Mon, 26 Sep 2022 12:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-32-추상화-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-32-추상화-규약을-지켜라"><a href="#아이템-32-추상화-규약을-지켜라" class="headerlink" title="아이템 32: 추상화 규약을 지켜라"></a>아이템 32: 추상화 규약을 지켜라</h2><p>규약은 개발자들의 단순한 합의 무언가를 할 수 있다는 것이 그것을 해도 괜찮다는 의미는 아니다.</p><h3 id="상속된-규약"><a href="#상속된-규약" class="headerlink" title="상속된 규약"></a>상속된 규약</h3><p>클래스를 상속하거나 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 된다.</p><p>프로그램을 안정적으로 유지하고 싶으면 규약을 지켜야 된다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-26-effective_kotlin_item_32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 31: 문서로 규약을 정의하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/</guid>
      <pubDate>Fri, 23 Sep 2022 04:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-31-문서로-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-31-문서로-규약을-정의하라"><a href="#아이템-31-문서로-규약을-정의하라" class="headerlink" title="아이템 31: 문서로 규약을 정의하라"></a>아이템 31: 문서로 규약을 정의하라</h2><p>함수가 무슨일을 하는지 명확하게 설명하고 싶다면 KDoc 주석을 붙혀주는것이 좋다.</p><p>일반적인 문제는 행위가 문서화 되지 않고 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 현재 구현에만 의존하게 된다.<br>이러한 문제는 예상되는 행위를 문서화만 잘해도 해소 된다.</p><h3 id="규약-정의하기"><a href="#규약-정의하기" class="headerlink" title="규약 정의하기"></a>규약 정의하기</h3><ul><li>이름: 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할수 있다.</li><li>주석과 문서: 필요한 모든규약을 적을수 있는 강력한 방법</li><li>타입: 타입은 객체에 대한 많은것을 알려준다. 자주 사용하는 타입의 경우는 타입만 보아도 어떻게 사용하는지 유추할수 있지만 일부타입은 문서를 추가해야된다.</li></ul><h3 id="주석을-써야-될까"><a href="#주석을-써야-될까" class="headerlink" title="주석을 써야 될까?"></a>주석을 써야 될까?</h3><p>자바 커뮤니티 초기에 문학적 프로그래밍(literate programming)이라는 개념이 인기였다.<br>10년이 지난 후에는 주석 없이도 읽을수 있는 코드를 작성해야 하는 프로그래밍 방식으로 바뀜</p><p>극단적인것은 언제나 좋지 않다.</p><h3 id="타입-시스템과-예측"><a href="#타입-시스템과-예측" class="headerlink" title="타입 시스템과 예측"></a>타입 시스템과 예측</h3><p>타입 계층은 객체와 관련된 아주 중요한 정보이다.</p><p>클래스가 어떤 동작을 할것이라 예측 되면 그서브 클래스에도 이를 보장해야된다. - 리스코프 치환의 원칙</p><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>요소, 특히 외부 API를 구현할 때는 규약을 잘정리 해야된다.</p><p>규약은 이름, 문서, 주석, 타입을 통해 구현될수 있다.</p><p>규약은 단순 합의이지만 그 합의를 존중한다면 큰 문제는 없을것이다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-23-effective_kotlin_item_31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 30: 요소의 가시성을 최소화하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/</guid>
      <pubDate>Thu, 22 Sep 2022 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-30-요소의-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-30-요소의-가시성을-최소화하라"><a href="#아이템-30-요소의-가시성을-최소화하라" class="headerlink" title="아이템 30: 요소의 가시성을 최소화하라"></a>아이템 30: 요소의 가시성을 최소화하라</h2><p>API를 설계할때 간결한 API를 선호하는 이유</p><ul><li>작은 인터페이스는 배우기 쉽고 유지하기 쉽다.</li><li>기능이 많은 클래스보다 작은 클래스이 이해하기 쉽다.</li><li>유지보수가 편하다.</li></ul><p>변경을 가할떄는 기존것을 숨기는것 보다 새로운것을 만드는것이 편하다 그래서 가시성을 최소화 시키는것이 좋다.<br>그리고 갑자기 가시성을 제한하면 다른곳에서 사용이 어렵다. 따라서 처음엔 작은 API로 개발을 강제하는것이 좋다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableSet&lt;T&gt; = mutableSetOf()</span><br><span class="line">) : MutableSet&lt;T&gt; <span class="keyword">by</span> innerSet&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elementsAdded: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        elementsAdded += elements.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="가시성-한정자-사용하기"><a href="#가시성-한정자-사용하기" class="headerlink" title="가시성 한정자 사용하기"></a>가시성 한정자 사용하기</h3><p>클래스의 맴버의 경우</p><ul><li>public(default): 어디에서나 볼 수 있다.</li><li>private: 클래스 내부에서만 볼 수 있다.</li><li>protected: 클래스와 서브클래스 내부에서만 볼 수 있다.</li><li>internal: 모듈 내부에서만 볼 수 있다.</li></ul><p>톱레벨 요소</p><ul><li>public(default): 어디에서나 볼 수 있다.</li><li>private: 같은 파일 내부에서만 볼 수 있다.</li><li>internal: 모듈 내부에서만 볼 수 있다.</li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><ul><li>인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.</li><li>최대한 제한이 되어 있어야 변경하기 쉽다.</li><li>클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.</li><li>가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-22-effective_kotlin_item_30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 29: 외부 API를 랩(wrap)해서 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/</guid>
      <pubDate>Wed, 21 Sep 2022 01:05:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-29-외부-A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-29-외부-API를-랩-wrap-해서-사용하라"><a href="#아이템-29-외부-API를-랩-wrap-해서-사용하라" class="headerlink" title="아이템 29: 외부 API를 랩(wrap)해서 사용하라"></a>아이템 29: 외부 API를 랩(wrap)해서 사용하라</h2><p>랩(wrap) 해서 API를 사용할떄 장점</p><ul><li>문제가 있다면 래버(wrapper)만 변경하면 되서 변화에 쉽게 대응 할수 있다.</li><li>프로젝트 스타일에 맞춰서 API의 형태를 조절할수 있다.</li><li>특정 라이브러리에서 문제가 발생하면 래퍼를 수정해서 다른 라이브러리를 사용하도록 쉽게 바꿀수 있다.</li><li>필요한 경우 쉽게 동작을 추가하거나 수정할수 있다.</li></ul><p>단점 </p><ul><li>래퍼를 따로 정의해야 된다.</li><li>다른 개발자가 프로젝트를 다룰 때 어떤 래퍼들이 있는지 따로 확인해야 한다.</li><li>래퍼들은 프로젝트 내부에서만 유효하므로 문제가 생겨도 질문 할수가 없다.</li></ul><p>라이브러리가 안정적인지 확인할수 있는 가장 기본적은 휴리스틱은 버전 번호화 사용자 수이다.<br>사용자가 많을수록 안정적이다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-21-effective_kotlin_item_29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 28: API 안정성을 확인하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/</guid>
      <pubDate>Tue, 20 Sep 2022 00:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-28-API-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-28-API-안정성을-확인하라"><a href="#아이템-28-API-안정성을-확인하라" class="headerlink" title="아이템 28: API 안정성을 확인하라"></a>아이템 28: API 안정성을 확인하라</h2><p>시멘틱 버저닝</p><ul><li>MAJOR 버전: 호환되지 않는 수준의 API 변경</li><li>MINOR 버전: 이전 변경과 호환되는 기능을 추가</li><li>PATCH 버전: 간단한 버그 수정</li></ul><p>어노테이션 </p><ul><li>@Experimental: 안정적이지 않음</li><li>@Deprecated: 더 이상 사용되지 않음 (단, 사용자가 적용할 시간을 주자)<ul><li>ReplaceWith: 다른 것으로 대체 되었으면 표시해주는것이 좋음</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-20-effective_kotlin_item_28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/</guid>
      <pubDate>Mon, 19 Sep 2022 05:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-27-변화로부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><h2 id="아이템-27-변화로부터-코드를-보호하려면-추상화를-사용하라"><a href="#아이템-27-변화로부터-코드를-보호하려면-추상화를-사용하라" class="headerlink" title="아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라"></a>아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라</h2><h3 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> MAX_THREADS = <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>이름을 붙일 수 있다.</li><li>나중에 값을 쉽게 변경 가능하다.</li></ul><h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>일반적인 알고리즘을 함수로 추출 하면 코드를 항상 기억해 두지 않아도 된다</p><p>함수의 단점</p><ul><li>함수는 상태를 유지 하지 않는다.</li><li>함수 시그니처를 변경하면 프로그램 전체에 큰영향을 줄수 있다.</li></ul><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>클래스가 함수보다 더 강력한 이유</p><ul><li>상태를 가질 수 있고, 많은 함수를 가질 수 있다</li><li>의존성 주입 프레임워크를 이용하면 클래스 생성을 위임할 수도 있다.</li><li>mock 객체를 활용해서 테스트할 수 있다.</li></ul><h3 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h3><ul><li>코틀린은 거의 모든 것을 인터페이스로 표현한다.</li><li>인터페이스 뒤에 객체를 숨겨 구현을 추상화하고 사용자가 추상화된 것에만 의존하도록 만들어서 결합을 줄인다.</li><li>테스트 시 모킹보다 간단하게 인터페이스 페이킹을 사용할 수 있다.</li></ul><h3 id="추상화-문제"><a href="#추상화-문제" class="headerlink" title="추상화 문제"></a>추상화 문제</h3><p>추상화는 자유를 주지만 코드를 이해하고 수정하기 어렵게 만든다.</p><p>너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려워진다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li><li><a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">fizzbuzz enterprise edition</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-19-effective_kotlin_item_27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이펙티브 코틀린 아이템 26: 함수 내부의 추상화 레벨을 통일하라</title>
      <link>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/</link>
      <guid>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/</guid>
      <pubDate>Fri, 16 Sep 2022 13:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-추상화-설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-추상화-설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(추상화 설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(추상화 설계)&lt;/h1&gt;&lt;p&gt;추상화란 : 복잡한 자료, 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-추상화-설계"><a href="#이펙티브-코틀린-추상화-설계" class="headerlink" title="이펙티브 코틀린(추상화 설계)"></a>이펙티브 코틀린(추상화 설계)</h1><p>추상화란 : 복잡한 자료, 모듈, 시스템 등으로 부터 핵심적인 개념 또는 기능을 간추려 내는것을 말한다.</p><p>추상화를 설계한다는 것은 단순하게 모듈 또는 라이브러리로 분리한다는 의미가 아니라 함수를 정의할 때는 그 구현을 함수 시그니처 뒤에 숨기게 되는데 이것이 바로 추상화다.</p><p>추상화의 목적</p><ul><li>복잡성을 숨기기 위해</li><li>코드를 체계화하기 위해</li><li>만드는 사람에게 변화의 자유를 주기 위해</li></ul><h2 id="아이템-26-함수-내부의-추상화-레벨을-통일하라"><a href="#아이템-26-함수-내부의-추상화-레벨을-통일하라" class="headerlink" title="아이템 26: 함수 내부의 추상화 레벨을 통일하라"></a>아이템 26: 함수 내부의 추상화 레벨을 통일하라</h2><p>계층이 잘 분리 되면 장점</p><ul><li>어떤 계층에서 작업할 때 그아래의 계층은 이미 완성되어 있으므로 해당 계층만 생각하면 된다.</li></ul><h3 id="추상화-레벨"><a href="#추상화-레벨" class="headerlink" title="추상화 레벨"></a>추상화 레벨</h3><p>프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현한다.</p><h3 id="추상화-레벨-통일"><a href="#추상화-레벨-통일" class="headerlink" title="추상화 레벨 통일"></a>추상화 레벨 통일</h3><p>코드도 추상화를 계층처럼 만들어 사용할수 있다.</p><p>함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있다. 이를 추상화 레벨 통일 SLA 원칙이라고 부른다.</p><p>함수는 간단해야 된다. 함수는 작아야 하며 최소한의 책임만을 가져야 된다 단일책임 원칙</p><h3 id="프로그램-아키텍처의-추상-레벨"><a href="#프로그램-아키텍처의-추상-레벨" class="headerlink" title="프로그램 아키텍처의 추상 레벨"></a>프로그램 아키텍처의 추상 레벨</h3><p>추상화를 구분하면 서브 시스템의 세부사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 가질수 있다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2022/09/2022-09-16-effective_kotlin_item_26/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
