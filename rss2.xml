<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Mon, 29 Jan 2024 05:28:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/</guid>
      <pubDate>Mon, 29 Jan 2024 05:01:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기&quot;&gt;&lt;a href=&quot;#CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 7 신뢰할 수 없는 코드를 쓰
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기"><a href="#CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기" class="headerlink" title="CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기"></a>CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기</h1><h2 id="레거시-코드와-불변성"><a href="#레거시-코드와-불변성" class="headerlink" title="레거시 코드와 불변성"></a>레거시 코드와 불변성</h2><p>방어적 복사 : 카피-온-라이트 원칙을 지키면서 안전하게 함수를 사용할수 있는 다른 원칙 </p><h2 id="우리가-만든-카피-온-라이트-코드는-신뢰할-수-없는-코드와-상호작용해야-합니다"><a href="#우리가-만든-카피-온-라이트-코드는-신뢰할-수-없는-코드와-상호작용해야-합니다" class="headerlink" title="우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다"></a>우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다</h2><p>모든 코드는 불변성이 지켜지는 안전지대에 있다</p><p>안전지대 밖으로 나가는 데이터는 바뀔수도 있다. 신뢰할 수 없는 코드가 데이터를 바꿀수 있기 때문이다<br>불변성을 지키면서 데이터를 주고 받는 법을 찾아야된다</p><p>레거시 코드를 바꿀수 없을때 방어적 복사를 사용할수도 있다</p><h2 id="방어적-복사는-원본이-바뀌는-것을-막아-줍니다"><a href="#방어적-복사는-원본이-바뀌는-것을-막아-줍니다" class="headerlink" title="방어적 복사는 원본이 바뀌는 것을 막아 줍니다"></a>방어적 복사는 원본이 바뀌는 것을 막아 줍니다</h2><p>들어오고 나가는 데이터의 복사본을 만드는 것이 방어적 복사가 동작하는 방식</p><h2 id="방어적-복사-구현하기"><a href="#방어적-복사-구현하기" class="headerlink" title="방어적 복사 구현하기"></a>방어적 복사 구현하기</h2><p>복사할때는 깊은 복사를 사용해야 된다</p><h2 id="방어적-복사-규칙"><a href="#방어적-복사-규칙" class="headerlink" title="방어적 복사 규칙"></a>방어적 복사 규칙</h2><ul><li>데이터가 안전한 코드에서 나갈 때 복사하기<ul><li>불변성 데이터를 위한 깊은 복사본을 만든다</li><li>신뢰할 수 없는 코드로 복사본을 전달한다</li></ul></li><li>안전한 코드로 데이터가 들어올 때 복사하기<ul><li>변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다</li><li>복사본을 안전한 코드에서 사용한다</li></ul></li></ul><h2 id="신뢰할-수-없는-코드-감싸기"><a href="#신뢰할-수-없는-코드-감싸기" class="headerlink" title="신뢰할 수 없는 코드 감싸기"></a>신뢰할 수 없는 코드 감싸기</h2><p>방어적 복사 코드를 분리해 새로운 함수로 만들어 두면 좋다</p><h2 id="방어적-복사가-익숙할-수도-있습니다"><a href="#방어적-복사가-익숙할-수도-있습니다" class="headerlink" title="방어적 복사가 익숙할 수도 있습니다"></a>방어적 복사가 익숙할 수도 있습니다</h2><ul><li>웹 API속에 방어적 복사<ul><li>JSON 으로 데이터를 주고 받을 때</li></ul></li><li>얼랭과 엘릭서에서 방어적 복사<ul><li>서로 메시지를 주고 받을때</li></ul></li></ul><h2 id="카피-온-라이트와-방어적-복사를-비교해-봅시다"><a href="#카피-온-라이트와-방어적-복사를-비교해-봅시다" class="headerlink" title="카피-온-라이트와 방어적 복사를 비교해 봅시다"></a>카피-온-라이트와 방어적 복사를 비교해 봅시다</h2><h3 id="카피-온-라이트"><a href="#카피-온-라이트" class="headerlink" title="카피-온-라이트"></a>카피-온-라이트</h3><p>언제 쓰나요?</p><ul><li>통제할수 있는 데이터를 바꿀때</li></ul><p>어디서 쓰나요?</p><ul><li>안전지대 어디에서나?</li></ul><p>복사방식</p><ul><li>얕은복사</li></ul><p>규칙</p><ul><li>바꿀 데이터의 얕은 복사를 만든다</li><li>복사본을 변경한다</li><li>복사본을 리턴한다</li></ul><h3 id="방어적-복사"><a href="#방어적-복사" class="headerlink" title="방어적 복사"></a>방어적 복사</h3><p>언제 쓰나요?</p><ul><li>신뢰할 수 없는 코드와 데이터를 주고받아야 할때<br>어디서 쓰나요?</li><li>안전지대의 경계에서 데이터가 오고 갈 때<br>복사방식</li><li>깊은 복사<br>규칙</li><li>안전지대로 들어오는 데이터에 깊은 복사를 만듬</li><li>안전지대에서 나가는 데이터에 깊은 복사를 만듬</li></ul><h2 id="깊은-복사는-얕은-복사보다-비쌉니다"><a href="#깊은-복사는-얕은-복사보다-비쌉니다" class="headerlink" title="깊은 복사는 얕은 복사보다 비쌉니다"></a>깊은 복사는 얕은 복사보다 비쌉니다</h2><p>깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는것이 얕은 복사와 차이점</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/</guid>
      <pubDate>Fri, 26 Jan 2024 00:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기&quot;&gt;&lt;a href=&quot;#CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 6 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기"><a href="#CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기" class="headerlink" title="CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기"></a>CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기</h1><h2 id="동작을-읽기-쓰기-또는-둘-다로-분류하기"><a href="#동작을-읽기-쓰기-또는-둘-다로-분류하기" class="headerlink" title="동작을 읽기, 쓰기 또는 둘 다로 분류하기"></a>동작을 읽기, 쓰기 또는 둘 다로 분류하기</h2><p>쓰기 동작은 불변성원칙에 따라 구현해야 한다<br>불변성 원칙은 카피-온-라이트(Copy-On-Write)라고 한다</p><h2 id="카피-온-라이트-원칙-세-단계"><a href="#카피-온-라이트-원칙-세-단계" class="headerlink" title="카피-온-라이트 원칙 세 단계"></a>카피-온-라이트 원칙 세 단계</h2><ul><li>복사본 만들기</li><li>복사본 변경하기</li><li>복사본 리턴하기</li></ul><h2 id="쓰기를-하면서-읽기도-하는-동작은-어떻게-해야-할까요"><a href="#쓰기를-하면서-읽기도-하는-동작은-어떻게-해야-할까요" class="headerlink" title="쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요?"></a>쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요?</h2><ul><li>읽기와 쓰기 함수로 각각 분리한다</li><li>함수에서 값을 두개 리턴한다</li></ul><h2 id="쓰면서-읽기도-하는-함수를-분리하기"><a href="#쓰면서-읽기도-하는-함수를-분리하기" class="headerlink" title="쓰면서 읽기도 하는 함수를 분리하기"></a>쓰면서 읽기도 하는 함수를 분리하기</h2><ul><li>읽기와 쓰기 동작으로 분리</li><li>쓰기 동작을 카피-온-라이트로 바꾸기</li></ul><h2 id="값을-두-개-리턴하는-함수로-만들기"><a href="#값을-두-개-리턴하는-함수로-만들기" class="headerlink" title="값을 두 개 리턴하는 함수로 만들기"></a>값을 두 개 리턴하는 함수로 만들기</h2><ul><li>동작 감싸기</li><li>읽으면서 쓰기도 하는 함수를 읽기 함수로 바꾸기</li><li>다른방법<ul><li>첫번째 접근방법(함수 분리)을 사용해 두값을 객체로 조합하는 방법</li></ul></li></ul><h2 id="불변-데이터-구조를-읽는-것은-계산입니다"><a href="#불변-데이터-구조를-읽는-것은-계산입니다" class="headerlink" title="불변 데이터 구조를 읽는 것은 계산입니다"></a>불변 데이터 구조를 읽는 것은 계산입니다</h2><ul><li>변경 가능한 데이터를 읽는 것은 액션</li><li>쓰기는 데이터를 변경 가능한 구조로 만듬</li><li>어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터</li><li>불변 데이터 구조를 읽는 것은 계산</li><li>쓰기를 읽기로 바꾸면 코드에 계산이 많아짐</li></ul><h2 id="애플리케이션에는-시간에-따라-변하는-상태가-있습니다"><a href="#애플리케이션에는-시간에-따라-변하는-상태가-있습니다" class="headerlink" title="애플리케이션에는 시간에 따라 변하는 상태가 있습니다"></a>애플리케이션에는 시간에 따라 변하는 상태가 있습니다</h2><h2 id="불변-데이터-구조는-충분히-빠릅니다"><a href="#불변-데이터-구조는-충분히-빠릅니다" class="headerlink" title="불변 데이터 구조는 충분히 빠릅니다"></a>불변 데이터 구조는 충분히 빠릅니다</h2><p>일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다<br>하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다<br>이런 사례는 불변 데이터도 충분히 빠르다는 증거 입니다</p><ul><li>언제든 최적화할 수 있다</li><li>가비지 콜렉터는 매우 빠르다</li><li>생각보다 많이 복사하지 않다<ul><li>얕은 복사(Shallow Copy) : 데이터의 최상위 단계만 복사</li><li>얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다 이것은 구조적 공유(Structural Sharing)라고 한다</li><li>앝은 복사는 공유된 복사본이 변경되지 않는한 안전하다</li></ul></li><li>함수형 프로그래밍 언어에는 빠른 구현체가 있다</li></ul><h3 id="앝은-복사를-구조적-복사라고-하는-이유"><a href="#앝은-복사를-구조적-복사라고-하는-이유" class="headerlink" title="앝은 복사를 구조적 복사라고 하는 이유"></a>앝은 복사를 구조적 복사라고 하는 이유</h3><p>아래처럼 최상위는 정상적으로 복사 된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = [<span class="string">&quot;beni&quot;</span>, <span class="string">&quot;hans&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> copy = original.<span class="title function_">slice</span>();</span><br><span class="line">original.<span class="title function_">push</span>(<span class="string">&quot;grace&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">// [ &#x27;beni&#x27;, &#x27;hans&#x27;, &#x27;grace&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">// [ &#x27;beni&#x27;, &#x27;hans&#x27; ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;<span class="attr">name</span>: <span class="string">&quot;beni&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">custom</span>: [&#123;<span class="attr">hair</span>: <span class="string">&quot;black&quot;</span>, <span class="attr">eyes</span>: <span class="string">&quot;brown&quot;</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br><span class="line">copy.<span class="property">name</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;brown&#x27; &#125; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">//&#123; name: &#x27;black&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;brown&#x27; &#125; ] &#125;</span></span><br></pre></td></tr></table></figure><p>아래처럼 하지만 하위 값은 복사가 안된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;<span class="attr">name</span>: <span class="string">&quot;beni&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">custom</span>: [&#123;<span class="attr">hair</span>: <span class="string">&quot;black&quot;</span>, <span class="attr">eyes</span>: <span class="string">&quot;brown&quot;</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br><span class="line">copy.<span class="property">custom</span>[<span class="number">0</span>].<span class="property">eyes</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;black&#x27; &#125; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;black&#x27; &#125; ] &#125;</span></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 5 더 좋은 액션 만들기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/</guid>
      <pubDate>Thu, 25 Jan 2024 00:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-5-더-좋은-액션-만들기&quot;&gt;&lt;a href=&quot;#CHAPTER-5-더-좋은-액션-만들기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 5 더 좋은 액션 만들기&quot;&gt;&lt;/a&gt;CHAPTER 5 더 좋은 액션 만들기&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-5-더-좋은-액션-만들기"><a href="#CHAPTER-5-더-좋은-액션-만들기" class="headerlink" title="CHAPTER 5 더 좋은 액션 만들기"></a>CHAPTER 5 더 좋은 액션 만들기</h1><h2 id="비즈니스-요구-사항과-설계를-맞추기"><a href="#비즈니스-요구-사항과-설계를-맞추기" class="headerlink" title="비즈니스 요구 사항과 설계를 맞추기"></a>비즈니스 요구 사항과 설계를 맞추기</h2><p>액션에서 계산으로 리팩터링하는 과정은 단순하고 기계적이였다</p><p>기계적인 리팩터링이 항상 최선의 구조를 만들어 주는 것은 아니다<br>좋은 구조를 만들기 위해서 사람의 손길이 필요하다</p><p>중복이 항상 나쁜것은 아니지만 코드에서 나는 냄새이다. 코드 냄새는 나중에 문제가 될수도 있다</p><h2 id="비즈니스-요구-사항과-함수를-맞추기"><a href="#비즈니스-요구-사항과-함수를-맞추기" class="headerlink" title="비즈니스 요구 사항과 함수를 맞추기"></a>비즈니스 요구 사항과 함수를 맞추기</h2><p>함수의 동작을 바꿨기 때문에 엄밀히 말하면 리팩터링이라고 할 수 없다</p><h2 id="원칙-암묵적-입력과-출력은-적을수록-좋습니다"><a href="#원칙-암묵적-입력과-출력은-적을수록-좋습니다" class="headerlink" title="원칙: 암묵적 입력과 출력은 적을수록 좋습니다"></a>원칙: 암묵적 입력과 출력은 적을수록 좋습니다</h2><ul><li>계산 : 암묵적 입력과 출력이 없는 함수</li></ul><p>어떤 함수에 암묵적 입력과 출력이 있다면 다른 컴포넌트와 강하게 연결된 컴포넌트라고 할 수 있다<br>다른 곳에서 사용할 수 없기 때문에 모듈이 아니다</p><h2 id="계산-분류하기"><a href="#계산-분류하기" class="headerlink" title="계산 분류하기"></a>계산 분류하기</h2><p>계층을 구분해보자 비지니스 규칙과 나머지 동작을 구분해보면 힌트가 될수도 있다</p><h2 id="원칙-설계는-엉켜있는-코드를-푸는-것이다"><a href="#원칙-설계는-엉켜있는-코드를-푸는-것이다" class="headerlink" title="원칙: 설계는 엉켜있는 코드를 푸는 것이다"></a>원칙: 설계는 엉켜있는 코드를 푸는 것이다</h2><ul><li>재사용하기 쉽다</li><li>유지보수하기 쉽다</li><li>테스트하기 쉽다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 4 액션에서 계산 빼내기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/</guid>
      <pubDate>Wed, 24 Jan 2024 00:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-4-액션에서-계산-빼내기&quot;&gt;&lt;a href=&quot;#CHAPTER-4-액션에서-계산-빼내기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 4 액션에서 계산 빼내기&quot;&gt;&lt;/a&gt;CHAPTER 4 액션에서 계산 빼내기&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-4-액션에서-계산-빼내기"><a href="#CHAPTER-4-액션에서-계산-빼내기" class="headerlink" title="CHAPTER 4 액션에서 계산 빼내기"></a>CHAPTER 4 액션에서 계산 빼내기</h1><h2 id="테스트하기-쉽게-만들기"><a href="#테스트하기-쉽게-만들기" class="headerlink" title="테스트하기 쉽게 만들기"></a>테스트하기 쉽게 만들기</h2><ul><li>DOM 업데이트와 비즈니스 규칙은 분리되어야 한다</li><li>전역변수가 없어야 한다</li></ul><h2 id="재사용하기-쉽게-만들기"><a href="#재사용하기-쉽게-만들기" class="headerlink" title="재사용하기 쉽게 만들기"></a>재사용하기 쉽게 만들기</h2><ul><li>전역변수에 의존하지 않아야 한다</li><li>DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안됩니다</li><li>함수가 결과값을 리턴해야 한다<h2 id="함수에는-입력과-출력이-있습니다"><a href="#함수에는-입력과-출력이-있습니다" class="headerlink" title="함수에는 입력과 출력이 있습니다"></a>함수에는 입력과 출력이 있습니다</h2></li><li>입력은 함수가 계산을 하기 위한 외부정보</li><li>출력은 함수 밖으로 나오는 정보나 어떤 동작</li></ul><p>입력과 출력은 명시적이거나 암묵적일 수 있다</p><p>함수의 암묵적 입력과 출력이 있으면 액션이 된다</p><h2 id="테스트와-재사용성은-입출력과-관련-있습니다"><a href="#테스트와-재사용성은-입출력과-관련-있습니다" class="headerlink" title="테스트와 재사용성은 입출력과 관련 있습니다"></a>테스트와 재사용성은 입출력과 관련 있습니다</h2><ul><li>DOM 업데이트와 비즈니스 규칙은 분리되어야 한다</li><li>전역변수가 없어야 한다</li><li>전역변수에 의존하지 않아야 한다</li><li>DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안됩니다</li><li>함수가 결과값을 리턴해야 한다<ul><li>암묵적 출력 대신 명시적 출력을 사용하자</li></ul></li></ul><h2 id="액션에서-계산-빼내기"><a href="#액션에서-계산-빼내기" class="headerlink" title="액션에서 계산 빼내기"></a>액션에서 계산 빼내기</h2><ul><li>서브루틴 추출하기</li><li>암묵적 입출력 제거<ul><li>명시적으로 표현</li></ul></li></ul><h2 id="계산-추출을-단계별로-알아보기"><a href="#계산-추출을-단계별로-알아보기" class="headerlink" title="계산 추출을 단계별로 알아보기"></a>계산 추출을 단계별로 알아보기</h2><ul><li>계산 코드를 찾아 빼낸다</li><li>새 함수에 암묵적 입력과 출력을 찾는다</li><li>암묵적 입력은 인자로 암묵적 출력은 리턴값으로 바꿉니다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 3 액션과 계산, 데이터의 차이를 알기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/</guid>
      <pubDate>Tue, 23 Jan 2024 00:47:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-3-액션과-계산-데이터의-차이를-알기&quot;&gt;&lt;a href=&quot;#CHAPTER-3-액션과-계산-데이터의-차이를-알기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 3 액션과 계산, 데이터의 차이를 알기&quot;&gt;&lt;/a&gt;C
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-3-액션과-계산-데이터의-차이를-알기"><a href="#CHAPTER-3-액션과-계산-데이터의-차이를-알기" class="headerlink" title="CHAPTER 3 액션과 계산, 데이터의 차이를 알기"></a>CHAPTER 3 액션과 계산, 데이터의 차이를 알기</h1><p>일반적으로 코드에 액션이 너무 많이 사용되고 있는 반면에 계산은 거의 찾아보기 힘든 이유를 알수 있다</p><h2 id="액션과-계산-데이터"><a href="#액션과-계산-데이터" class="headerlink" title="액션과 계산, 데이터"></a>액션과 계산, 데이터</h2><p>함수형 프로그래머는 액션 계산 데이터를 구분한다</p><h3 id="문제에-대해-생각할-때"><a href="#문제에-대해-생각할-때" class="headerlink" title="문제에 대해 생각할 때"></a>문제에 대해 생각할 때</h3><p>문제에 대해 고민하고 있을 때도 문제를 액션과 계산 데이터로 나눠 생각해 볼 수 있다</p><h3 id="코딩할떄"><a href="#코딩할떄" class="headerlink" title="코딩할떄"></a>코딩할떄</h3><p>함수형 프로그래머는 최대한 액션에서 계산을 빼내려고 한다<br>또 계산에서는 데이터를 분리할 수 있는지 생각한다<br>더 나아가 액션이 계산이 될수 있는지 계산이 데이터가 될수 있는지 생각한다</p><h3 id="코드를-읽을-때"><a href="#코드를-읽을-때" class="headerlink" title="코드를 읽을 때"></a>코드를 읽을 때</h3><p>함수형 프로그래머는 더 좋은 코드를 만들기 위해 이미 있는 코드를 액션과 계산, 데이터로 리팩터링하는 방법을 찾을것이다</p><h2 id="액션과-계산-데이터는-어디에나-적용할-수-있습니다"><a href="#액션과-계산-데이터는-어디에나-적용할-수-있습니다" class="headerlink" title="액션과 계산, 데이터는 어디에나 적용할 수 있습니다"></a>액션과 계산, 데이터는 어디에나 적용할 수 있습니다</h2><h3 id="냉장고-확인하기"><a href="#냉장고-확인하기" class="headerlink" title="냉장고 확인하기"></a>냉장고 확인하기</h3><p>냉장고를 확인하는 일은 시점이 중요하기 때문에 액션이다<br>냉장고가 가지고 있는 제품은 데이터이다</p><h3 id="운전해서-상점으로-가기"><a href="#운전해서-상점으로-가기" class="headerlink" title="운전해서 상점으로 가기"></a>운전해서 상점으로 가기</h3><p>운전해서 상점으로 가는 것은 복잡한 행동이고 시점이 중요하기 때문에 액션이다<br>사실 여기엔 데이터가 숨어 있다 상점 위치나 가는 경로</p><h3 id="필요한-것-구입하기"><a href="#필요한-것-구입하기" class="headerlink" title="필요한 것 구입하기"></a>필요한 것 구입하기</h3><p>구입하는 일도 확실히 액션이다 하지만 구입하기를 몇단계로 나눠 생각해보면 계산과 데이터로 나눠 생각할 수 있다</p><p>현재 재고(데이터) -&gt; 필요한 재고(데이터) -&gt; 재고 빼기(계산) -&gt; 장보기 목록(데이터) -&gt; 목록에 있는 것 구입하기(액션)</p><p>액션과 계산, 데이터를 더 명확하게 하기 위해 액션과 계산, 데이터에 해당하는 단계를 각각 다른 열에 그려서 선으로 연결해보면 어느정도 보인다</p><h2 id="장보기-과정에서-배운-것"><a href="#장보기-과정에서-배운-것" class="headerlink" title="장보기 과정에서 배운 것"></a>장보기 과정에서 배운 것</h2><ul><li>액션과 계산, 데이터는 어디에나 적용할수 있다</li><li>액션 안에는 계산과 데이터 또 다른 액션이 숨어 있을지도 모른다</li><li>계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다</li><li>데이터는 데이터만 조합할 수 있다</li><li>계산은 때로 우리 머리속에서 일어난다<ul><li>계산이 잘보이지 않는 이유는 계싼이 우리 사고 과정에 녹아 있어서</li></ul></li></ul><h2 id="쿠폰-보내는-과정을-그려보기"><a href="#쿠폰-보내는-과정을-그려보기" class="headerlink" title="쿠폰 보내는 과정을 그려보기"></a>쿠폰 보내는 과정을 그려보기</h2><h3 id="데이터베이스에서-구독자를-가져오는-것부터-시작"><a href="#데이터베이스에서-구독자를-가져오는-것부터-시작" class="headerlink" title="데이터베이스에서 구독자를 가져오는 것부터 시작"></a>데이터베이스에서 구독자를 가져오는 것부터 시작</h3><p>이단계는 액션이다</p><h3 id="데이터베이스에서-쿠폰-목록-가져오기"><a href="#데이터베이스에서-쿠폰-목록-가져오기" class="headerlink" title="데이터베이스에서 쿠폰 목록 가져오기"></a>데이터베이스에서 쿠폰 목록 가져오기</h3><p>이것도 액션이다 </p><p>한번 가져온 쿠폰목록은 데이터이다</p><h3 id="보내야-할-이메일-목록-만들기"><a href="#보내야-할-이메일-목록-만들기" class="headerlink" title="보내야 할 이메일 목록 만들기"></a>보내야 할 이메일 목록 만들기</h3><p>이메일 목록 계획하기에서 생성된 이메일 목록은 다음 단계에서 사용할 데이터이다</p><h3 id="이메일-전송하기"><a href="#이메일-전송하기" class="headerlink" title="이메일 전송하기"></a>이메일 전송하기</h3><p>이메일 전송은 간단하다 목록을 미리 만들어서 목록을 순회하면서 그냥 보내면 된다</p><h3 id="이메일-만들는-부분-자세히-살펴보기"><a href="#이메일-만들는-부분-자세히-살펴보기" class="headerlink" title="이메일 만들는 부분 자세히 살펴보기"></a>이메일 만들는 부분 자세히 살펴보기</h3><ul><li>왜 계산을 만드냐?<ul><li>가능한 계산을 사용하려고 하는 이유는 테스트하기 쉽기 때문</li></ul></li></ul><h2 id="쿠폰-보내는-과정-구현하기"><a href="#쿠폰-보내는-과정-구현하기" class="headerlink" title="쿠폰 보내는 과정 구현하기"></a>쿠폰 보내는 과정 구현하기</h2><h3 id="테이터베이스에서-가져온-구독자-데이터"><a href="#테이터베이스에서-가져온-구독자-데이터" class="headerlink" title="테이터베이스에서 가져온 구독자 데이터"></a>테이터베이스에서 가져온 구독자 데이터</h3><p>데이터는 언어에서 제공하는 단순한 데이터 타입으로 표현한다. 언어에서 제공하는 데이터 타입은 알아보기 쉽고 사용하려고 하는 목적에도 잘 맞는다</p><h3 id="쿠폰-등급은-문자열입니다"><a href="#쿠폰-등급은-문자열입니다" class="headerlink" title="쿠폰 등급은 문자열입니다"></a>쿠폰 등급은 문자열입니다</h3><p>쿠폰 등급은 문자열로 표현한다 다른 타입을 써도 좋지만 문자열이 편하다</p><h3 id="쿠폰-등급을-결정하는-것은-함수이다"><a href="#쿠폰-등급을-결정하는-것은-함수이다" class="headerlink" title="쿠폰 등급을 결정하는 것은 함수이다"></a>쿠폰 등급을 결정하는 것은 함수이다</h3><p>계산은 함수로 구현된다. 입력값은 함수 인자이고 출력값은 함수의 리턴값이다</p><h3 id="데이터베이스에서-가져온-쿠폰-데이터"><a href="#데이터베이스에서-가져온-쿠폰-데이터" class="headerlink" title="데이터베이스에서 가져온 쿠폰 데이터"></a>데이터베이스에서 가져온 쿠폰 데이터</h3><p>자바스크립트 객체로 표현할수 있다</p><h3 id="특정-등급의-쿠폰-목록을-선택하는-계산은-함수-입니다"><a href="#특정-등급의-쿠폰-목록을-선택하는-계산은-함수-입니다" class="headerlink" title="특정 등급의 쿠폰 목록을 선택하는 계산은 함수 입니다"></a>특정 등급의 쿠폰 목록을 선택하는 계산은 함수 입니다</h3><p>특정 등급의 쿠폰 목록을 선택하는 계산도 함수로 구현</p><h3 id="이메일은-그냥-데이터-입니다"><a href="#이메일은-그냥-데이터-입니다" class="headerlink" title="이메일은 그냥 데이터 입니다"></a>이메일은 그냥 데이터 입니다</h3><p>데이터</p><h3 id="구독자가-받을-이메일을-계획하는-계산"><a href="#구독자가-받을-이메일을-계획하는-계산" class="headerlink" title="구독자가 받을 이메일을 계획하는 계산"></a>구독자가 받을 이메일을 계획하는 계산</h3><p>계산 </p><h3 id="보낼-이메일-목록-준비하기"><a href="#보낼-이메일-목록-준비하기" class="headerlink" title="보낼 이메일 목록 준비하기"></a>보낼 이메일 목록 준비하기</h3><p>계산</p><h3 id="이메일-보내기는-액션"><a href="#이메일-보내기는-액션" class="headerlink" title="이메일 보내기는 액션"></a>이메일 보내기는 액션</h3><p>액션</p><h3 id="일반적인-구현-순서"><a href="#일반적인-구현-순서" class="headerlink" title="일반적인 구현 순서"></a>일반적인 구현 순서</h3><p>데이터 -&gt; 계산 -&gt; 액션</p><p>계산은 보통 순수 함수(pure function) 또는 수학 함수(mathematical function)로 부른다</p><h2 id="이미-있는-코드에-함수형-사고-적용하기"><a href="#이미-있는-코드에-함수형-사고-적용하기" class="headerlink" title="이미 있는 코드에 함수형 사고 적용하기"></a>이미 있는 코드에 함수형 사고 적용하기</h2><h2 id="액션은-코드-전체로-퍼집니다"><a href="#액션은-코드-전체로-퍼집니다" class="headerlink" title="액션은 코드 전체로 퍼집니다"></a>액션은 코드 전체로 퍼집니다</h2><p>액션은 사용하기 참 어렵다. 액션을 부는 함수가 있다면 그함수도 액션이된다. 이렇게 액션은 코드 전체로 퍼집니다</p><h2 id="액션은-다양한-형태로-나타납니다"><a href="#액션은-다양한-형태로-나타납니다" class="headerlink" title="액션은 다양한 형태로 나타납니다"></a>액션은 다양한 형태로 나타납니다</h2><ul><li>함수호출</li><li>메서드 호출</li><li>생성자</li><li>표현식</li><li>상태</li></ul><p>액션은 보통 순수하지 않은 삼후(impure function) 또는 부수효과 함수(side effect function) 또는 부수효과가 있는 함수(function with side effect)라고 부른다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 2 현실에서의 함수형 사고</title>
      <link>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</guid>
      <pubDate>Mon, 22 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-2-현실에서의-함수형-사고&quot;&gt;&lt;a href=&quot;#CHAPTER-2-현실에서의-함수형-사고&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 2 현실에서의 함수형 사고&quot;&gt;&lt;/a&gt;CHAPTER 2 현실에서의 함수형 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-2-현실에서의-함수형-사고"><a href="#CHAPTER-2-현실에서의-함수형-사고" class="headerlink" title="CHAPTER 2 현실에서의 함수형 사고"></a>CHAPTER 2 현실에서의 함수형 사고</h1><h2 id="토니-피자에-오신-것을-환영합니다"><a href="#토니-피자에-오신-것을-환영합니다" class="headerlink" title="토니 피자에 오신 것을 환영합니다"></a>토니 피자에 오신 것을 환영합니다</h2><p>계층형 설계(stratifed design)원칙이 어떤것인지 알아 본다</p><p>분산시스템을 이해 하려고 타임라인 다이어그램(timeline diagram)을 사용</p><h2 id="파트-I-액션과-계산-데이터"><a href="#파트-I-액션과-계산-데이터" class="headerlink" title="파트 I: 액션과 계산, 데이터"></a>파트 I: 액션과 계산, 데이터</h2><ul><li>액션: 호출 횟수와 시점에 의존하는 것</li><li>계산: 어떤 것을 결정하거나 계획하는 것은 계산 입니다</li><li>데이터: 유연하기 때문에 저장하거나 네트워크로 전송하는 등 다양하게 쓸 수 있다</li></ul><h2 id="변경-가능성에-따라-코드-나누기"><a href="#변경-가능성에-따라-코드-나누기" class="headerlink" title="변경 가능성에 따라 코드 나누기"></a>변경 가능성에 따라 코드 나누기</h2><p>계층형설계는 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눕니다</p><h2 id="파트-II-일급-추상"><a href="#파트-II-일급-추상" class="headerlink" title="파트 II: 일급 추상"></a>파트 II: 일급 추상</h2><p>타임라인 다이어 그램은 로봇 한대가 피가를 만들기 위한 액션들을 보여 줍니다</p><h2 id="분산-시스템을-타임라인으로-시각화하기"><a href="#분산-시스템을-타임라인으로-시각화하기" class="headerlink" title="분산 시스템을 타임라인으로 시각화하기"></a>분산 시스템을 타임라인으로 시각화하기</h2><p>분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모른다</p><h2 id="각각의-타임라인은-다른-순서로-실행됩니다"><a href="#각각의-타임라인은-다른-순서로-실행됩니다" class="headerlink" title="각각의 타임라인은 다른 순서로 실행됩니다"></a>각각의 타임라인은 다른 순서로 실행됩니다</h2><p>타입라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다</p><h2 id="어려운-경험을-통해-분산-시스템에-대해-배운-것"><a href="#어려운-경험을-통해-분산-시스템에-대해-배운-것" class="headerlink" title="어려운 경험을 통해 분산 시스템에 대해 배운 것"></a>어려운 경험을 통해 분산 시스템에 대해 배운 것</h2><ul><li>기본적으로 타임라인은 서로 순서를 맞추지 않습니다</li><li>액션이 실행되는 시간은 중요하지 않다</li><li>드물지만 타이밍이 어긋나는 경우는 실제 일어난다</li><li>타임라인 다이어그램으로 시스템의 문제를 알 수 있다</li></ul><h2 id="타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기"><a href="#타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기" class="headerlink" title="타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기"></a>타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기</h2><p>커팅(cutting) : 타임라인의 시간을 맞추는 작업</p><p>타임라인 커팅은 고차동작(higher-order operation)으로 구현 </p><h2 id="좋은-경험을-통해-타임라인에-대해-배운-것"><a href="#좋은-경험을-통해-타임라인에-대해-배운-것" class="headerlink" title="좋은 경험을 통해 타임라인에 대해 배운 것"></a>좋은 경험을 통해 타임라인에 대해 배운 것</h2><ul><li>타임라인 커팅으로 서로 다른 작업들을 쉽게 이해 할 수 있다</li><li>타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다</li><li>타임라인 다이어그램은 유연하다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</title>
      <link>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</guid>
      <pubDate>Fri, 19 Jan 2024 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot;&gt;&lt;a href=&quot;#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 1 쏙쏙 들어오는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다"><a href="#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다" class="headerlink" title="CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다"></a>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</h1><h2 id="함수형-프로그래밍은-무엇인가요"><a href="#함수형-프로그래밍은-무엇인가요" class="headerlink" title="함수형 프로그래밍은 무엇인가요?"></a>함수형 프로그래밍은 무엇인가요?</h2><p>함수형 프로그래밍(functional programming)</p><ul><li>수학 함수를 사용하고 부수 효과(side effect)를 피하는것이 특성인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수(pure function)만 사용하는 프로그래밍 패러다임</li></ul><p>부수 효과(side effect)</p><ul><li>함수가 리턴값 이외에 하는 모든 일을 말한다</li></ul><p>순수 함수(pure function)</p><ul><li>인자에만 의존하고 부수 효과가 없는 함수</li><li>수학 함수라 볼수 있다</li></ul><h2 id="실용적인-측면에서-함수형-프로그래밍-정의의-문제점"><a href="#실용적인-측면에서-함수형-프로그래밍-정의의-문제점" class="headerlink" title="실용적인 측면에서 함수형 프로그래밍 정의의 문제점"></a>실용적인 측면에서 함수형 프로그래밍 정의의 문제점</h2><p>함수형 프로그래밍</p><ul><li>수학 함수를 사용하고 부수 효과를 피하는것이 특징인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일</li></ul><h3 id="문제-1-부수-효과는-필요합니다"><a href="#문제-1-부수-효과는-필요합니다" class="headerlink" title="문제 1. 부수 효과는 필요합니다"></a>문제 1. 부수 효과는 필요합니다</h3><p>부수 효과는 소프트웨어를 실행하는 이유이다</p><h2 id="문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다"><a href="#문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다" class="headerlink" title="문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다"></a>문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다</h2><p>순수 함수만 쓰라는 것처럼 되어 있지만 순수하지 않은 함수도 사용합니다</p><h2 id="문제-3-함수형-프로그래밍은-실용적이다"><a href="#문제-3-함수형-프로그래밍은-실용적이다" class="headerlink" title="문제 3. 함수형 프로그래밍은 실용적이다"></a>문제 3. 함수형 프로그래밍은 실용적이다</h2><p>함수형 프로그래밍이 수학적이라 실제 소프트웨어 개발에서 사용하지 않는 것 처럼 느껴집니다</p><h2 id="함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기"><a href="#함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기" class="headerlink" title="함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기"></a>함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기</h2><p>중요한 기술 </p><ul><li>액션 action</li><li>계산 calculation</li><li>데이터 data</li></ul><h2 id="액션과-계산-데이터-구분하기"><a href="#액션과-계산-데이터-구분하기" class="headerlink" title="액션과 계산, 데이터 구분하기"></a>액션과 계산, 데이터 구분하기</h2><p>함수형 프로그래머는 직감적으로 코드를 세 분류로 나눈다</p><ul><li>액션</li><li>계산</li><li>데이터</li></ul><h2 id="함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다"><a href="#함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다"></a>함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다</h2><ul><li>액션: 호출하는 시점과 횟수에 의존한다</li><li>액션이 아닌 코드 : 호출하는 시점과 횟수에 의존하지 않는다</li></ul><h2 id="함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다"><a href="#함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다"></a>함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다</h2><p>계산 과 데이터는 둘다 부르는 시점이나 횟수가 중요하지 않다</p><ul><li>데이터 : 정적이고 보이는 그대로</li><li>계산 : 동적이고 보이지 않는다</li></ul><p>함수형 프로그래머는 코드를 액션과 계산 데이터로 구분</p><h2 id="함수형-프로그래머는-액션과-계산-데이터를-구분합니다"><a href="#함수형-프로그래머는-액션과-계산-데이터를-구분합니다" class="headerlink" title="함수형 프로그래머는 액션과 계산, 데이터를 구분합니다"></a>함수형 프로그래머는 액션과 계산, 데이터를 구분합니다</h2><h3 id="1단계-사용자가-작업-완료-표시를-함"><a href="#1단계-사용자가-작업-완료-표시를-함" class="headerlink" title="1단계: 사용자가 작업 완료 표시를 함"></a>1단계: 사용자가 작업 완료 표시를 함</h3><p>UI 이벤트인데 실행 횟수에 의존하기 때문에 액션입니다</p><h3 id="2단계-클라이언트가-서버로-메시지를-보냄"><a href="#2단계-클라이언트가-서버로-메시지를-보냄" class="headerlink" title="2단계: 클라이언트가 서버로 메시지를 보냄"></a>2단계: 클라이언트가 서버로 메시지를 보냄</h3><p>메시지를 보내는것도 액션이다<br>메시지 자체는 나중에 서버에서 해석해야 되는 값이기 때문에 데이터다</p><h3 id="3단계-서버가-메시지를-받음"><a href="#3단계-서버가-메시지를-받음" class="headerlink" title="3단계: 서버가 메시지를 받음"></a>3단계: 서버가 메시지를 받음</h3><p>메시지를 받는 횟수에 의존하므로 액션</p><h3 id="4단계-서버가-데이터-베이스를-변경"><a href="#4단계-서버가-데이터-베이스를-변경" class="headerlink" title="4단계: 서버가 데이터 베이스를 변경"></a>4단계: 서버가 데이터 베이스를 변경</h3><p>내부 상태를 바꾸는 것은 액션</p><h3 id="5단계-서버가-누구에서-알림을-보낼지-결정"><a href="#5단계-서버가-누구에서-알림을-보낼지-결정" class="headerlink" title="5단계: 서버가 누구에서 알림을 보낼지 결정"></a>5단계: 서버가 누구에서 알림을 보낼지 결정</h3><p>결정하는 것은 계산이다. 입력값이 같다면 서버는 항상 같은 결정을 내리기 때문</p><h3 id="6단계-서버가-이메일로-알림을-보냄"><a href="#6단계-서버가-이메일로-알림을-보냄" class="headerlink" title="6단계: 서버가 이메일로 알림을 보냄"></a>6단계: 서버가 이메일로 알림을 보냄</h3><p>이메일 보내기는 액션</p><h2 id="함수형-프로그래밍에서는-코드를-세-가지로-분류합니다"><a href="#함수형-프로그래밍에서는-코드를-세-가지로-분류합니다" class="headerlink" title="함수형 프로그래밍에서는 코드를 세 가지로 분류합니다"></a>함수형 프로그래밍에서는 코드를 세 가지로 분류합니다</h2><ul><li>액션<ul><li>호출하는 시점과 횟수에 둘다 의존한다</li></ul></li><li>계산<ul><li>입력값을 출력값으로 만드는 것</li></ul></li><li>데이터<ul><li>이벤트에 대해 기록한 사실<h2 id="액션-계산-데이터를-구분하면-어떤-장점이-있나요"><a href="#액션-계산-데이터를-구분하면-어떤-장점이-있나요" class="headerlink" title="액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?"></a>액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?</h2>요즘 유행하는 분산 시스템에 잘 어울린다</li></ul></li></ul><p>시간에 따라 바뀌는 값을 모델링 할때 동작 방법을 이해하는 것은 중요하지만 쉽지 않다<br>실행시점이나 횟수에 의존하는 코드를 없애면 코드를 더 쉽게 이해할수 있고 심각한 버그를 막을수 있다</p><p>데이터와 계산은 실행 시점이나 횟수에 의존하지 않는다</p><p>액션은 실행시점이나 횟수에 의존하지만 코드 전체에 영향을 주지 않도록 격리시키면 된다</p><h2 id="함수형-사고가-무엇인가요"><a href="#함수형-사고가-무엇인가요" class="headerlink" title="함수형 사고가 무엇인가요?"></a>함수형 사고가 무엇인가요?</h2><p>함수형 사고(functional thinking)</p><ul><li>액션, 계산, 데이터</li><li>일급 추상</li></ul><h2 id="이-책을-읽는-기본-규칙"><a href="#이-책을-읽는-기본-규칙" class="headerlink" title="이 책을 읽는 기본 규칙"></a>이 책을 읽는 기본 규칙</h2><ul><li>특정 언어 기능에 의존하지 않아야 한다</li><li>실용적이라 바로 쓸 수 있어야 한다</li><li>여러분의 현재 가지고 있는 코드와 관계 없이 쓸 수 있어야 된다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장. 단위 테스트 안티 패턴</title>
      <link>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</guid>
      <pubDate>Thu, 18 Jan 2024 01:39:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-단위-테스트-안티-패턴&quot;&gt;&lt;a href=&quot;#11장-단위-테스트-안티-패턴&quot; class=&quot;headerlink&quot; title=&quot;11장. 단위 테스트 안티 패턴&quot;&gt;&lt;/a&gt;11장. 단위 테스트 안티 패턴&lt;/h1&gt;&lt;h2 id=&quot;비공개-메서드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-단위-테스트-안티-패턴"><a href="#11장-단위-테스트-안티-패턴" class="headerlink" title="11장. 단위 테스트 안티 패턴"></a>11장. 단위 테스트 안티 패턴</h1><h2 id="비공개-메서드-단위-테스트"><a href="#비공개-메서드-단위-테스트" class="headerlink" title="비공개 메서드 단위 테스트"></a>비공개 메서드 단위 테스트</h2><p>전혀 하지 말아야 된다</p><h3 id="비공개-메서드와-테스트-취약성"><a href="#비공개-메서드와-테스트-취약성" class="headerlink" title="비공개 메서드와 테스트 취약성"></a>비공개 메서드와 테스트 취약성</h3><p>단위 테스트를 하려고 비공개 메서드를 노출하는 경우에는 식별할수 있는 동작만 테스트하는 것을 위반한다</p><h3 id="비공개-메서드와-불필요한-커버리지"><a href="#비공개-메서드와-불필요한-커버리지" class="headerlink" title="비공개 메서드와 불필요한 커버리지"></a>비공개 메서드와 불필요한 커버리지</h3><ul><li>죽은 코드다</li><li>추상화가 누락되어 있다</li></ul><h3 id="비공개-메서드-테스트가-타당한-경우"><a href="#비공개-메서드-테스트가-타당한-경우" class="headerlink" title="비공개 메서드 테스트가 타당한 경우"></a>비공개 메서드 테스트가 타당한 경우</h3><p>비공개 메서드를 테스트하는 것 자체는 나쁘지 않다<br>비공개 메서드가 구현 세부사항의 프록시에 해당하므로 나쁜것</p><h2 id="비공개-상태-노출"><a href="#비공개-상태-노출" class="headerlink" title="비공개 상태 노출"></a>비공개 상태 노출</h2><p>안티패턴으로 단위 테스트 목적만으로 비공개 상태를 노출하는것이 있다</p><p>테스트 유의성을 위해 공개 API의 노출 영역을 넓히는 것은 좋지 않은 습관이다</p><h2 id="테스트로-유출된-도메인-지식"><a href="#테스트로-유출된-도메인-지식" class="headerlink" title="테스트로 유출된 도메인 지식"></a>테스트로 유출된 도메인 지식</h2><p>도메인 지식을 테스트로 유출하는 것은 또하나의 흔한 안티 패턴</p><h2 id="코드-오염"><a href="#코드-오염" class="headerlink" title="코드 오염"></a>코드 오염</h2><p>테스트에만 필요한 제품 코드를 추가하는것</p><h2 id="구체-클래스를-목으로-처리하기"><a href="#구체-클래스를-목으로-처리하기" class="headerlink" title="구체 클래스를 목으로 처리하기"></a>구체 클래스를 목으로 처리하기</h2><p>일부 기능을 지키려고 구체 클래스를 목으로 처리해야 하면 이는 단일 책임 원칙을 위한하는 결과다</p><h2 id="시간-처리하기"><a href="#시간-처리하기" class="headerlink" title="시간 처리하기"></a>시간 처리하기</h2><p>시간에 따라 달라지는 기능을 테스트하면 거짓 양성이 발생할 수 있다</p><h3 id="앰비언트-컨텍스트로서의-시간"><a href="#앰비언트-컨텍스트로서의-시간" class="headerlink" title="앰비언트 컨텍스트로서의 시간"></a>앰비언트 컨텍스트로서의 시간</h3><p>로거 기능과 마찬가지로 시간을 엠비언트 컨텍스트로 사용하는것도 안티 패턴이다</p><h3 id="명시적-의존성으로서의-시간"><a href="#명시적-의존성으로서의-시간" class="headerlink" title="명시적 의존성으로서의 시간"></a>명시적 의존성으로서의 시간</h3><p>더나은 방법으로 시간의존성을 명시적으로 주입하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장. 데이터베이스 테스트</title>
      <link>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</guid>
      <pubDate>Wed, 17 Jan 2024 01:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-데이터베이스-테스트&quot;&gt;&lt;a href=&quot;#10장-데이터베이스-테스트&quot; class=&quot;headerlink&quot; title=&quot;10장. 데이터베이스 테스트&quot;&gt;&lt;/a&gt;10장. 데이터베이스 테스트&lt;/h1&gt;&lt;p&gt;통합 테스트라는 퍼즐의 마지막 조각은
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-데이터베이스-테스트"><a href="#10장-데이터베이스-테스트" class="headerlink" title="10장. 데이터베이스 테스트"></a>10장. 데이터베이스 테스트</h1><p>통합 테스트라는 퍼즐의 마지막 조각은 프로세스 외부 관리 의존성이다. 가장 일반적인 예는 애플리케이션 데이터베이스다</p><p>실제 데이터베이스를 테스트하면 회귀 방지가 아주 뛰어나지만 설정하기 쉽지 않다</p><h2 id="데이터베이스-테스트를-위한-전제-조건"><a href="#데이터베이스-테스트를-위한-전제-조건" class="headerlink" title="데이터베이스 테스트를 위한 전제 조건"></a>데이터베이스 테스트를 위한 전제 조건</h2><ul><li>형상 관리 시스템에 데이터베이스 유지</li><li>개발자마다 별도의 데이터베이스 인스턴스 사용</li><li>데이터베이스 배포에 마이그레이션 기반 방식 적용</li></ul><h3 id="데이터베이스를-형상-관리-시스템에-유지"><a href="#데이터베이스를-형상-관리-시스템에-유지" class="headerlink" title="데이터베이스를 형상 관리 시스템에 유지"></a>데이터베이스를 형상 관리 시스템에 유지</h3><p>데이터베이스 스키마를 일반 코드로 취급하는것 </p><p>모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다</p><ul><li>변경 내역 부재</li><li>복수의 원천 정보</li></ul><h3 id="참조-데이터도-데이터베이스-스키마다"><a href="#참조-데이터도-데이터베이스-스키마다" class="headerlink" title="참조 데이터도 데이터베이스 스키마다"></a>참조 데이터도 데이터베이스 스키마다</h3><p>참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터다.</p><p>참조 데이터와 일반데이터를 구별할 수 있는 간단한 방법이 있다 애플리케이션이 데이터를 수정할 수 있으면 일반데이터고 그렇지 않으면 참조 데이터다.</p><h3 id="모든-개발자를-위한-별도의-데이터베이스-인스턴스"><a href="#모든-개발자를-위한-별도의-데이터베이스-인스턴스" class="headerlink" title="모든 개발자를 위한 별도의 데이터베이스 인스턴스"></a>모든 개발자를 위한 별도의 데이터베이스 인스턴스</h3><p>공유 데이터베이스를 사용하면 개발 프로세스를 방해 하게 된다</p><ul><li>서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문이다</li><li>하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있다</li></ul><p>테스트 실행 속도를 극대화 하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하라</p><h3 id="상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포"><a href="#상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포" class="headerlink" title="상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포"></a>상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포</h3><p>데이터베이스 배포 방식</p><ul><li>상태기반<ul><li>상태를 형상 관리에 저장함으로써 상태를 명시하고 비교도구가 마이그레이션을 암묵적으로 제어할 수 있게 한다</li></ul></li><li>마이그레이션 기반<ul><li>마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다</li></ul></li></ul><p>결과적으로 상태 기반 방식은 대다수의 프로젝트에서 실용적이지 않다</p><h2 id="데이터베이스-트랜잭션-관리"><a href="#데이터베이스-트랜잭션-관리" class="headerlink" title="데이터베이스 트랜잭션 관리"></a>데이터베이스 트랜잭션 관리</h2><h3 id="제품-코드에서-데이터베이스-트랜잭션-관리하기"><a href="#제품-코드에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="제품 코드에서 데이터베이스 트랜잭션 관리하기"></a>제품 코드에서 데이터베이스 트랜잭션 관리하기</h3><h3 id="통합-테스트에서-데이터베이스-트랜잭션-관리하기"><a href="#통합-테스트에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="통합 테스트에서 데이터베이스 트랜잭션 관리하기"></a>통합 테스트에서 데이터베이스 트랜잭션 관리하기</h3><p>테스트에서 트랜젝션이나 작업 단위를 재사용하지 말라</p><h2 id="테스트-데이터-생명-주기"><a href="#테스트-데이터-생명-주기" class="headerlink" title="테스트 데이터 생명 주기"></a>테스트 데이터 생명 주기</h2><ul><li>통합 테스트를 순차적으로 실행하라</li><li>테스트 실행 간에 남은 데이터를 제거하라</li></ul><h3 id="병렬-테스트-실행과-순차적-테스트-실행"><a href="#병렬-테스트-실행과-순차적-테스트-실행" class="headerlink" title="병렬 테스트 실행과 순차적 테스트 실행"></a>병렬 테스트 실행과 순차적 테스트 실행</h3><p>컨테이너를 사용해 테스트를 병렬로 실행시킬수 있다</p><p>단점은</p><ul><li>도커 이미지를 유지 보수해야함</li><li>각 테스트마다 컨테이너 인스턴스가 있는지 확인해야 함</li><li>통합 테스트를 일괄 처리하고</li><li>다 사용한 컨테이너는 폐기해야 한다</li></ul><p>통합 테스트의 실행 시간을 최소화 해야 하는 경우가 아니라면 컨테이너를 사용하지 않는 것이 좋다</p><p>데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 더 실용적이다</p><h3 id="테스트-실행-간-데이터-정리"><a href="#테스트-실행-간-데이터-정리" class="headerlink" title="테스트 실행 간 데이터 정리"></a>테스트 실행 간 데이터 정리</h3><ul><li>각 테스트 전에 데이터베이스 백업 복원하기</li><li>테스트 종료 시점에 데이터 정리하기</li><li>데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기</li><li>테스트 시작 시점에 데이터 정리하기</li></ul><h3 id="인메모리-데이터베이스-피하기"><a href="#인메모리-데이터베이스-피하기" class="headerlink" title="인메모리 데이터베이스 피하기"></a>인메모리 데이터베이스 피하기</h3><p>인메모리 데이터베이스의 장점</p><ul><li>테스트 데이터를 제거할 필요가 없음</li><li>작업 속도 향상</li><li>테스트가 실행될 때마다 인스턴스화 가능</li></ul><p>하지만 기능적 일관성이 없기 때문에 사용하지 않는것이 좋다</p><h2 id="테스트-구절에서-코드-재사용하기"><a href="#테스트-구절에서-코드-재사용하기" class="headerlink" title="테스트 구절에서 코드 재사용하기"></a>테스트 구절에서 코드 재사용하기</h2><p>통합 테스트가 너무 빨리 커지면 유지 보수 지표가 나빠질 수 있다</p><h3 id="준비-구절에서-코드-재사용하기"><a href="#준비-구절에서-코드-재사용하기" class="headerlink" title="준비 구절에서 코드 재사용하기"></a>준비 구절에서 코드 재사용하기</h3><p>오브젝트 마더(Object Mother) 패턴</p><p>테스트 데이터 빌더(Test Data Builder) 패턴</p><h3 id="실행-구절에서-코드-재사용하기"><a href="#실행-구절에서-코드-재사용하기" class="headerlink" title="실행 구절에서 코드 재사용하기"></a>실행 구절에서 코드 재사용하기</h3><p>대리자(Delegate) 패턴을 활용해서 실행구절을 줄일수 있따</p><h3 id="검증-구절에서-코드-재사용하기"><a href="#검증-구절에서-코드-재사용하기" class="headerlink" title="검증 구절에서 코드 재사용하기"></a>검증 구절에서 코드 재사용하기</h3><p>플루언트 인터페이스를 사용하면 검증문이 읽기 쉬워진다</p><h3 id="테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가"><a href="#테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가" class="headerlink" title="테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?"></a>테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?</h3><p>빠른 피드백과 유지 보수성의 절충</p><h2 id="데이터베이스-테스트에-대한-일반적인-질문"><a href="#데이터베이스-테스트에-대한-일반적인-질문" class="headerlink" title="데이터베이스 테스트에 대한 일반적인 질문"></a>데이터베이스 테스트에 대한 일반적인 질문</h2><h3 id="읽기-테스트를-해야-하는가"><a href="#읽기-테스트를-해야-하는가" class="headerlink" title="읽기 테스트를 해야 하는가?"></a>읽기 테스트를 해야 하는가?</h3><p>읽기를 테스트하기로 결정한 경우에는 실제 데이터베이스에서 통합 테스트하라</p><h3 id="리포지터리-테스트를-해야-하는가"><a href="#리포지터리-테스트를-해야-하는가" class="headerlink" title="리포지터리 테스트를 해야 하는가?"></a>리포지터리 테스트를 해야 하는가?</h3><p>리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트의 일부로 취급</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장. 목 처리에 대한 모범 사례</title>
      <link>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</guid>
      <pubDate>Tue, 16 Jan 2024 00:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-목-처리에-대한-모범-사례&quot;&gt;&lt;a href=&quot;#9장-목-처리에-대한-모범-사례&quot; class=&quot;headerlink&quot; title=&quot;9장. 목 처리에 대한 모범 사례&quot;&gt;&lt;/a&gt;9장. 목 처리에 대한 모범 사례&lt;/h1&gt;&lt;p&gt;목은 테스트 대
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-목-처리에-대한-모범-사례"><a href="#9장-목-처리에-대한-모범-사례" class="headerlink" title="9장. 목 처리에 대한 모범 사례"></a>9장. 목 처리에 대한 모범 사례</h1><p>목은 테스트 대상 시스템과 의존성 간의 상호 작용을 모방하고 검사하는 데 도움이 되는 테스트 대역이다</p><p>목은 비관리 의존성에만 적용해야 된다</p><h2 id="목의-가치를-극대화하기"><a href="#목의-가치를-극대화하기" class="headerlink" title="목의 가치를 극대화하기"></a>목의 가치를 극대화하기</h2><p>비관리 의존성에만 목을 사용하게끔 제한하는 것이 중요하지만 이는 목의 가치를 극대화 하기 위한 첫 번째 단계일 뿐이다</p><h3 id="시스템-끝에서-상호-작용-검증하기"><a href="#시스템-끝에서-상호-작용-검증하기" class="headerlink" title="시스템 끝에서 상호 작용 검증하기"></a>시스템 끝에서 상호 작용 검증하기</h3><p>시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라.</p><h3 id="목을-스파이로-대체하기"><a href="#목을-스파이로-대체하기" class="headerlink" title="목을 스파이로 대체하기"></a>목을 스파이로 대체하기</h3><p>스파이는 목과 같은 목적을 수행하는 테스트 대역이다<br>스파이는 수동으로 작성하는 반면에 목은 목프레임워크의 도움을 받아 생성한다는 것이 유일한 차이점이다</p><p>시스템 끝에 있는 클래스의 경우 스파이가 목보다 낫다</p><h2 id="목-처리에-대한-모범-사례"><a href="#목-처리에-대한-모범-사례" class="headerlink" title="목 처리에 대한 모범 사례"></a>목 처리에 대한 모범 사례</h2><ul><li>비관리 의존성에만 목 적용하기</li><li>시스템 끝에 있는 의존성에 대해 상호 작용 검증하기</li><li>통합 테스트에서만 목을 사용하고 단위 테스트에서는 하지 않기</li><li>항상 목 호출 수 확인하기</li><li>보유 타입만 목으로 처리하기</li></ul><h3 id="목은-통합-테스트만을-위한-것"><a href="#목은-통합-테스트만을-위한-것" class="headerlink" title="목은 통합 테스트만을 위한 것"></a>목은 통합 테스트만을 위한 것</h3><p>비지니스 로직과 오케이스레이션의 분리에서 비롯된다</p><h3 id="테스트당-목이-하나일-필요는-없음"><a href="#테스트당-목이-하나일-필요는-없음" class="headerlink" title="테스트당 목이 하나일 필요는 없음"></a>테스트당 목이 하나일 필요는 없음</h3><p>단위 테스트의 단위는 코드의 단위가 아니라 동작의 단위이다</p><h3 id="호출-횟수-검증하기"><a href="#호출-횟수-검증하기" class="headerlink" title="호출 횟수 검증하기"></a>호출 횟수 검증하기</h3><p>비관리 의존성과의 통신에 관해서 다음 두가지 모두 확인하는 것이 중요하다</p><ul><li>예상하는 호출이 있는가?</li><li>예상치 못한 호출이 있는가?</li></ul><h3 id="보유-타입만-목으로-처리하기"><a href="#보유-타입만-목으로-처리하기" class="headerlink" title="보유 타입만 목으로 처리하기"></a>보유 타입만 목으로 처리하기</h3><p>보유 타입만 목으로 처리하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장. 통합 테스트를 하는 이유</title>
      <link>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</guid>
      <pubDate>Fri, 12 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-통합-테스트를-하는-이유&quot;&gt;&lt;a href=&quot;#8장-통합-테스트를-하는-이유&quot; class=&quot;headerlink&quot; title=&quot;8장. 통합 테스트를 하는 이유&quot;&gt;&lt;/a&gt;8장. 통합 테스트를 하는 이유&lt;/h1&gt;&lt;p&gt;단위 테스트에만 전적으
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-통합-테스트를-하는-이유"><a href="#8장-통합-테스트를-하는-이유" class="headerlink" title="8장. 통합 테스트를 하는 이유"></a>8장. 통합 테스트를 하는 이유</h1><p>단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다</p><p>단위 테스트가 비즈니스 로직을 확인하는데 좋지만 비즈니스 로직을 외부와 단절된 상태로 확인하는 것만으로는 충분하지 않다</p><h2 id="통합-테스트는-무엇인가"><a href="#통합-테스트는-무엇인가" class="headerlink" title="통합 테스트는 무엇인가?"></a>통합 테스트는 무엇인가?</h2><h3 id="통합-테스트의-역할"><a href="#통합-테스트의-역할" class="headerlink" title="통합 테스트의 역할"></a>통합 테스트의 역할</h3><p>단위 테스트는 세가지 요구사항을 충족하는 테스트다</p><ul><li>단일 동작 단위를 검증하고</li><li>빠르게 수행하고</li><li>다른 테스트와 별도로 처리한다</li></ul><p>단위테스트가 아닌 모든 테스트는 통합테스트다</p><h3 id="다시-보는-테스트-피라미드"><a href="#다시-보는-테스트-피라미드" class="headerlink" title="다시 보는 테스트 피라미드"></a>다시 보는 테스트 피라미드</h3><p>유지비 증가 이유</p><ul><li>프로세스 외부 의존성 운영이 필요함</li><li>관련된 협력자가 많아서 테스트가 비대해짐</li></ul><p>단위 테스트로 가능한 많이 비즈니스 시나리오의 예외 상황을 확인하고 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룬다</p><h3 id="통합-테스트와-빠른-실패"><a href="#통합-테스트와-빠른-실패" class="headerlink" title="통합 테스트와 빠른 실패"></a>통합 테스트와 빠른 실패</h3><p>통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라<br>상호작용을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가로 작성하라</p><h2 id="어떤-프로세스-외부-의존성을-직접-테스트해야-하는가"><a href="#어떤-프로세스-외부-의존성을-직접-테스트해야-하는가" class="headerlink" title="어떤 프로세스 외부 의존성을 직접 테스트해야 하는가"></a>어떤 프로세스 외부 의존성을 직접 테스트해야 하는가</h2><h3 id="프로세스-외부-의존성의-두-가지-유형"><a href="#프로세스-외부-의존성의-두-가지-유형" class="headerlink" title="프로세스 외부 의존성의 두 가지 유형"></a>프로세스 외부 의존성의 두 가지 유형</h3><ul><li>관리 의존성<ul><li>테스트에서 제어할 수 있는 의존성</li><li>데이터베이스</li></ul></li><li>비관리 의존성<ul><li>테스트에서 제어할 수 없는 의존성</li><li>SMTP 서버</li></ul></li></ul><p>관리 의존성은 실제 인스턴스를 사용하고 비관리 의존성은 목으로 대체하라</p><h3 id="관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기"><a href="#관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기" class="headerlink" title="관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기"></a>관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기</h3><p>프로세스 외부 의존성(데이터 베이스)</p><p>데이터 베이스와의 상호작용을 검증하지 말고 데이터베이스의 최종 상태를 확인하라</p><h3 id="통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까"><a href="#통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까" class="headerlink" title="통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?"></a>통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?</h3><p>통합 테스트에서 관리 의존성을 실제 버전으로 사용할 수 없는 경우도 있다</p><p>그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라</p><h2 id="의존성-추상화를-위한-인터페이스-사용"><a href="#의존성-추상화를-위한-인터페이스-사용" class="headerlink" title="의존성 추상화를 위한 인터페이스 사용"></a>의존성 추상화를 위한 인터페이스 사용</h2><h3 id="인터페이스와-느슨한-결합"><a href="#인터페이스와-느슨한-결합" class="headerlink" title="인터페이스와 느슨한 결합"></a>인터페이스와 느슨한 결합</h3><p>인터페이스를 사용하는 이유</p><ul><li>프로세스 외부 의존성을 추상화해 느슨한 결합을 달성</li><li>기존 코드를 변경하지 않고 새로운 기능을 추가해 개방 폐쇄 원칙을 달성</li></ul><p>위에 2가지 이유 모두 오해</p><p>단일 구현을 위한 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다<br>진정한 추상화는 발견하는것이지 발명하는것이 아니다</p><p>YAGNI 원칙을 위반하는 생각이다<br>YAGNI 원칙은 현재 필요하지 않는 기능에 시간을 드리지 말라는 원칙이다</p><ul><li>기회비용</li><li>프로젝트 코드는 적을수록 좋다</li></ul><h3 id="프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가"><a href="#프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가" class="headerlink" title="프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?"></a>프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?</h3><p>목을 사용하기 위함</p><p>인터페이스가 없으면 테스트 대역을 만들수 없음</p><h2 id="통합-테스트-모범-사례"><a href="#통합-테스트-모범-사례" class="headerlink" title="통합 테스트 모범 사례"></a>통합 테스트 모범 사례</h2><p>통합 테스트를 최대한 활용하는 데 도움이 되는 몇가지 지침</p><ul><li>도메인 모델 경계 명시하기</li><li>애플리케이션 내 계층 줄이기</li><li>순환 의존성 제거하기</li></ul><h3 id="도메인-모델-경계-명시하기"><a href="#도메인-모델-경계-명시하기" class="headerlink" title="도메인 모델 경계 명시하기"></a>도메인 모델 경계 명시하기</h3><p>항상 도메인 모델을 코드베이스에서 명시적이고 잘알려진 위치에 두도록 하라<br>도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘 보여주고 더 잘 설명할 수 있다</p><h3 id="계층-수-줄이기"><a href="#계층-수-줄이기" class="headerlink" title="계층 수 줄이기"></a>계층 수 줄이기</h3><p>대부분의 프로그래머는 간접 계층을 추가해서 코드를 추상화하고 일반화 하려고 한다</p><p>추상계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기 너무 어려워진다</p><h3 id="순환-의존성-제거하기"><a href="#순환-의존성-제거하기" class="headerlink" title="순환 의존성 제거하기"></a>순환 의존성 제거하기</h3><p>순환 의존성의 대표적인 예는 콜백이다</p><p>순한 의존성은 코드를 읽고 이해할때 알아야 할것들이 너무 많아서 큰 부담이 된다</p><p>순한 의존성은 테스트를 방해 한다</p><h3 id="테스트에서-다중-실행-구절-사용"><a href="#테스트에서-다중-실행-구절-사용" class="headerlink" title="테스트에서 다중 실행 구절 사용"></a>테스트에서 다중 실행 구절 사용</h3><p>통합 테스트에서 두 유스케이스를 모두 확인하려고 할때 아래의 구조가 된다</p><ul><li>준비</li><li>실행</li><li>검증</li><li>실행</li><li>검증</li></ul><p>이러한 방식은 사용자의 상태가 자연스럽게 흐르기 때문에 설득력이 있고 첫 번째 실행은 두 번째 실행의 준비 단계 역활을 할수 있다<br>문제는 이러한 테스트가 초점을 잃고 순식간에 너무 커질수 있다</p><h2 id="로깅-기능을-테스트하는-방법"><a href="#로깅-기능을-테스트하는-방법" class="headerlink" title="로깅 기능을 테스트하는 방법"></a>로깅 기능을 테스트하는 방법</h2><ul><li>로깅을 조금이라도 테스트 해야 하는가?</li><li>만약 그렇다면 어떻게 테스트 해야 하는가?</li><li>로깅이 얼마나 많으면 충분한가?</li><li>로거 인스턴스를 어떻게 전달할까?</li></ul><h3 id="로깅을-테스트해야-하는가"><a href="#로깅을-테스트해야-하는가" class="headerlink" title="로깅을 테스트해야 하는가?"></a>로깅을 테스트해야 하는가?</h3><p>로깅은 횡단 기능으로 코드베이스 어느 부분에서나 필요로 할 수 있다</p><p>로깅의 종류 </p><ul><li>지원 로깅</li><li>진단 로깅</li></ul><h3 id="로깅을-어떻게-테스트해야-하는가"><a href="#로깅을-어떻게-테스트해야-하는가" class="headerlink" title="로깅을 어떻게 테스트해야 하는가?"></a>로깅을 어떻게 테스트해야 하는가?</h3><p>목으로 테스트 하지 마라</p><h3 id="로깅이-얼마나-많으면-충분한가"><a href="#로깅이-얼마나-많으면-충분한가" class="headerlink" title="로깅이 얼마나 많으면 충분한가?"></a>로깅이 얼마나 많으면 충분한가?</h3><ul><li>과도한 로깅은 코드를 혼란스럽게 한다</li><li>핵심은 로그의 신호 대비 잡음 비율이다</li></ul><h3 id="로거-인스턴스를-어떻게-전달하는가"><a href="#로거-인스턴스를-어떻게-전달하는가" class="headerlink" title="로거 인스턴스를 어떻게 전달하는가?"></a>로거 인스턴스를 어떻게 전달하는가?</h3><ul><li>정적 메서드를 사용하는 것</li></ul><p>앰비언트 컨텍스트라고 부른다 이는 안티 패턴이며 다음과 같은 두가지 단점</p><ul><li>의존성이 숨어 있고 변경하기가 어렵다</li><li>테스트가 더 어려워진다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장. 가치 있는 단위 테스트를 위한 리팩터링</title>
      <link>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/</guid>
      <pubDate>Thu, 11 Jan 2024 02:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;7장-가치-있는-단위-테스트를-위한-리팩터링&quot;&gt;&lt;a href=&quot;#7장-가치-있는-단위-테스트를-위한-리팩터링&quot; class=&quot;headerlink&quot; title=&quot;7장. 가치 있는 단위 테스트를 위한 리팩터링&quot;&gt;&lt;/a&gt;7장. 가치 있는 단위 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="7장-가치-있는-단위-테스트를-위한-리팩터링"><a href="#7장-가치-있는-단위-테스트를-위한-리팩터링" class="headerlink" title="7장. 가치 있는 단위 테스트를 위한 리팩터링"></a>7장. 가치 있는 단위 테스트를 위한 리팩터링</h1><p>좋은 단위 테스트 스위트의 속성</p><ul><li>개발 주기에 통합돼 있다</li><li>코드베이스 중 가장 중요한 부분만을 대상으로 한다</li><li>최소한의 유지비로 최대의 가치를 끌어낸다<ul><li>가치 있는 테스트</li><li>가치 있는 테스트 작성하기</li></ul></li></ul><h2 id="리팩터링할-코드-식별하기"><a href="#리팩터링할-코드-식별하기" class="headerlink" title="리팩터링할 코드 식별하기"></a>리팩터링할 코드 식별하기</h2><h3 id="코드의-네-가지-유형"><a href="#코드의-네-가지-유형" class="headerlink" title="코드의 네 가지 유형"></a>코드의 네 가지 유형</h3><ul><li>복잡도 또는 도메인 유의성<ul><li>코드 복잡도는 코드 내 의사 결정 지점 수로 정의한다</li><li>도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는지를 나타낸다</li></ul></li><li>클래스 또는 매서드가 가진 협력자 수<ul><li>가변 의존성이거나 프로젝트 외부 의존성 이다</li><li>협력자가 많은 코드는 테스트 비용이 많이 든다</li></ul></li></ul><p>기초가 되는 4가지 유형</p><ul><li>도메인 모델과 알고리즘</li><li>간단한 코드</li><li>컨트롤러</li><li>지나치게 복잡한 코드</li></ul><p>코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 된다</p><p>좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다</p><h3 id="험블-객체-패턴을-사용해-지나치게-복잡한-코드-분할하기"><a href="#험블-객체-패턴을-사용해-지나치게-복잡한-코드-분할하기" class="headerlink" title="험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기"></a>험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기</h3><p>지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야 한다<br>헥사고날과 함수형 아키텍처는 험블 객체 패턴을 사용한다<br>험블객체 패턴을 보는 또 다른 방법은 단일 책임 원칙(SRP)을 지키는 것<br>또 다른 예로 도메인 주도 설계에 나오는 집계 패턴이 있다</p><h2 id="최적의-단위-테스트-커버리지-분석"><a href="#최적의-단위-테스트-커버리지-분석" class="headerlink" title="최적의 단위 테스트 커버리지 분석"></a>최적의 단위 테스트 커버리지 분석</h2><p>비지니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트할수 있다</p><h3 id="전제-조건을-테스트해야-하는가"><a href="#전제-조건을-테스트해야-하는가" class="headerlink" title="전제 조건을 테스트해야 하는가?"></a>전제 조건을 테스트해야 하는가?</h3><p>전제 조건에 도메인 의미가 없으면 테스트는 가치가 없다</p><h2 id="컨트롤러에서-조건부-로직-처리"><a href="#컨트롤러에서-조건부-로직-처리" class="headerlink" title="컨트롤러에서 조건부 로직 처리"></a>컨트롤러에서 조건부 로직 처리</h2><p>비지니스 로직과 오케스트레이션의 분리</p><ul><li>저장소에서 데이터 검색</li><li>비즈니스 로직 실행</li><li>데이터를 다시 저장소에 저장</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장. 단위 테스트 스타일</title>
      <link>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/</guid>
      <pubDate>Wed, 10 Jan 2024 00:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;6장-단위-테스트-스타일&quot;&gt;&lt;a href=&quot;#6장-단위-테스트-스타일&quot; class=&quot;headerlink&quot; title=&quot;6장. 단위 테스트 스타일&quot;&gt;&lt;/a&gt;6장. 단위 테스트 스타일&lt;/h1&gt;&lt;p&gt;단위테스트 스타일&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;출
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="6장-단위-테스트-스타일"><a href="#6장-단위-테스트-스타일" class="headerlink" title="6장. 단위 테스트 스타일"></a>6장. 단위 테스트 스타일</h1><p>단위테스트 스타일</p><ul><li>출력 기반 테스트 -&gt; 가장 품질이 좋음</li><li>상태 기반 테스트 -&gt; 두번째 </li><li>통신 기반 테스트 -&gt; 가장 품질이 낮음</li></ul><h2 id="단위-테스트의-세-가지-스타일"><a href="#단위-테스트의-세-가지-스타일" class="headerlink" title="단위 테스트의 세 가지 스타일"></a>단위 테스트의 세 가지 스타일</h2><ul><li>출력 기반 테스트(output-based testing)</li><li>상태 기반 테스트(state-based testing)</li><li>통신 기반 테스트(communication-based testing)</li></ul><h3 id="출력-기반-테스트-정의"><a href="#출력-기반-테스트-정의" class="headerlink" title="출력 기반 테스트 정의"></a>출력 기반 테스트 정의</h3><p>대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식</p><p>출력 기반 단위 테스트 스타일은 함수형 이라고도 한다</p><h3 id="상태-기반-스타일-정의"><a href="#상태-기반-스타일-정의" class="headerlink" title="상태 기반 스타일 정의"></a>상태 기반 스타일 정의</h3><p>작업이 완료된 후 시스템 상태를 확인하는 것이다<br>이 테스트 스타일에서 상태라는 용어는 SUT나 협력자 중 하나 또는 데이터베이스나 파일시스템등 외부의존성의 상태를 의미 할수 있다 </p><h3 id="통신-기반-스타일-정의"><a href="#통신-기반-스타일-정의" class="headerlink" title="통신 기반 스타일 정의"></a>통신 기반 스타일 정의</h3><p>목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다</p><h2 id="단위-테스트-스타일-비교"><a href="#단위-테스트-스타일-비교" class="headerlink" title="단위 테스트 스타일 비교"></a>단위 테스트 스타일 비교</h2><p>4대 요소랑 비교해보면 재미있을것이다</p><ul><li>회귀방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지보수성</li></ul><h3 id="회귀-방지와-피드백-속도-지표로-스타일-비교하기"><a href="#회귀-방지와-피드백-속도-지표로-스타일-비교하기" class="headerlink" title="회귀 방지와 피드백 속도 지표로 스타일 비교하기"></a>회귀 방지와 피드백 속도 지표로 스타일 비교하기</h3><p>회귀 방지 지표</p><ul><li>테스트 중에 실행되는 코드의 양</li><li>코드 복잡도</li><li>도메인 유의성</li></ul><p> 어떤 스타일도 이 부분 에선 도움이 안된다</p><p>테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다</p><h3 id="리팩터링-내성-지표로-스타일-비교하기"><a href="#리팩터링-내성-지표로-스타일-비교하기" class="headerlink" title="리팩터링 내성 지표로 스타일 비교하기"></a>리팩터링 내성 지표로 스타일 비교하기</h3><p>리팩터링 내성은 리팩터링 중 발생하는 거짓 양성 수에 대한 척도다</p><p>거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다</p><ul><li>출력 기반 테스트가 가장 우수하다</li><li>상태 기반 테스트는 일반적으로 거짓양성이 되기 쉽다</li><li>통신 기반 테스트가 허위 정보에 가장 취약하다</li></ul><h3 id="유지-보수성-지표로-스타일-비교하기"><a href="#유지-보수성-지표로-스타일-비교하기" class="headerlink" title="유지 보수성 지표로 스타일 비교하기"></a>유지 보수성 지표로 스타일 비교하기</h3><ul><li>테스트를 이해라기 얼마나 어려운가(테스트 크기에 대한 함수)?</li><li>테스트를 실행하기 얼마나 어려운가(프로세스 외부 의존성 개수에 대한 함수)?</li></ul><p>출력 기반 테스트가 가장 유지보수에 용의하다</p><p>상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다</p><p>클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적 그렇지 않으면 코드 오염으로 이어진다</p><p>통신 기반 테스트는 유지 보수성 지표에서 출력 기반 테스트와 상태 기반 테스트 보다 점수가 낮다</p><h3 id="스타일-비교하기-결론"><a href="#스타일-비교하기-결론" class="headerlink" title="스타일 비교하기: 결론"></a>스타일 비교하기: 결론</h3><p>출력 기반 테스트가 가장 품질이 좋다</p><h2 id="함수형-아키텍처-이해"><a href="#함수형-아키텍처-이해" class="headerlink" title="함수형 아키텍처 이해"></a>함수형 아키텍처 이해</h2><p>함수형 프로그래밍과 출력 기반 테스트의 연관성을 이해하는데 도움이 될 것이다</p><h3 id="함수형-프로그래밍이란"><a href="#함수형-프로그래밍이란" class="headerlink" title="함수형 프로그래밍이란?"></a>함수형 프로그래밍이란?</h3><p>출력 기반 단위 테스트 스타일은 함수형이라고도 한다<br>기반 제품 코드를 함수형 프로그래밍을 이용해 순수 함수 방식으로 작성해야 하기 때문이다</p><p>함수형 프로그래밍은 수학적 함수를 사용한 프로그래밍이다</p><p>수학적 함수는 호출 횟수에 상관 없이 주어진 입력에 대해 동일한 출력을 생성한다</p><p>숨은 입출력의 유형</p><ul><li>부작용</li><li>예외</li><li>내외부 상태에 대한 참조</li></ul><h3 id="함수형-아키텍처란"><a href="#함수형-아키텍처란" class="headerlink" title="함수형 아키텍처란?"></a>함수형 아키텍처란?</h3><p>함수형 프로그래밍 목표는 부작용을 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것</p><p>비즈니스 로직과 부작용을 분리하는 유형</p><ul><li>결정을 내리는 코드 : 부작용이 없는 코드<ul><li>함수형 코어(불변 코어)</li></ul></li><li>해당 결정에 따라 작동하는 코드 : 결정이 된 부분을 데이터베이스로 변경이나 메시지 버스로 전송된 메시지 같이 가시적인 부분으로 변환하는 부분<ul><li>가변 셀</li></ul></li></ul><p>함수형 코어와 가변 셀의 협력</p><ul><li>가변 셍은 모든 입력을 수집한다</li><li>함수형 코어는 결정을 생성한다</li><li>셀은 결정을 부작용으로 변환한다</li></ul><h3 id="함수형-아키텍처와-육각형-아키텍처-비교"><a href="#함수형-아키텍처와-육각형-아키텍처-비교" class="headerlink" title="함수형 아키텍처와 육각형 아키텍처 비교"></a>함수형 아키텍처와 육각형 아키텍처 비교</h3><p>함수형 아키텍처와 육각형 아키텍처는 비슷한 점이 많다</p><p>함수형 아키텍처는 육각형 아키텍처의 하위 집합이다. 극단적으로 함수형 아키텍처를 육각형 아키텍처로 볼 수도 있다</p><h2 id="함수형-아키텍처와-출력-기반-테스트로-전환"><a href="#함수형-아키텍처와-출력-기반-테스트로-전환" class="headerlink" title="함수형 아키텍처와 출력 기반 테스트로 전환"></a>함수형 아키텍처와 출력 기반 테스트로 전환</h2><ul><li>프로세스 외부 의존성에서 목으로 변경</li><li>목에서 함수형 아키텍처로 변경</li></ul><h2 id="함수형-아키텍처의-단점-이해하기"><a href="#함수형-아키텍처의-단점-이해하기" class="headerlink" title="함수형 아키텍처의 단점 이해하기"></a>함수형 아키텍처의 단점 이해하기</h2><p>항수형 아키텍처와 관련된 비용과 장단점</p><h3 id="함수형-아키텍처-적용-가능성"><a href="#함수형-아키텍처-적용-가능성" class="headerlink" title="함수형 아키텍처 적용 가능성"></a>함수형 아키텍처 적용 가능성</h3><p>함수형 코어의 클래스는 협력자로 작동하면 안되고 작업의 결과인 값으로 작동해야 한다</p><h3 id="성능-단점"><a href="#성능-단점" class="headerlink" title="성능 단점"></a>성능 단점</h3><p>함수형 아키텍처와 전동적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성간의 절충이다</p><h3 id="코드베이스-크기-증가"><a href="#코드베이스-크기-증가" class="headerlink" title="코드베이스 크기 증가"></a>코드베이스 크기 증가</h3><p>함수형 아키텍처는 함수형 코어와 가변 셀 사이를 명확하게 분리해야 한다 그래서 초기에 코딩이 더 필요하다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장. 목과 테스트 취약성</title>
      <link>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/</guid>
      <pubDate>Tue, 09 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;5장-목과-테스트-취약성&quot;&gt;&lt;a href=&quot;#5장-목과-테스트-취약성&quot; class=&quot;headerlink&quot; title=&quot;5장. 목과 테스트 취약성&quot;&gt;&lt;/a&gt;5장. 목과 테스트 취약성&lt;/h1&gt;&lt;p&gt;런던파는 테스트 대상 코드 조각을 서로 분리
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="5장-목과-테스트-취약성"><a href="#5장-목과-테스트-취약성" class="headerlink" title="5장. 목과 테스트 취약성"></a>5장. 목과 테스트 취약성</h1><p>런던파는 테스트 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하고자 한다</p><p>고전파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하자고 한다 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다</p><h2 id="목과-스텁-구분"><a href="#목과-스텁-구분" class="headerlink" title="목과 스텁 구분"></a>목과 스텁 구분</h2><p>테스트 대역의 종류</p><ul><li>목(mock)</li><li>스텁(stub)</li><li>가짜(fakes)</li><li>스파이(spy)</li><li>더미(dummy)</li></ul><h3 id="테스트-대역-유형"><a href="#테스트-대역-유형" class="headerlink" title="테스트 대역 유형"></a>테스트 대역 유형</h3><p>테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다</p><ul><li>목은 외부로 나가는 상호 작용을 모방하고 검사하는데 도움이 된다</li><li>스텁은 내부로 들어오는 상호 작용을 모방하는데 도움이 된다</li></ul><h3 id="도구로서의-목과-테스트-대역으로서의-목"><a href="#도구로서의-목과-테스트-대역으로서의-목" class="headerlink" title="도구로서의 목과 테스트 대역으로서의 목"></a>도구로서의 목과 테스트 대역으로서의 목</h3><p>도구로써 목은 목라이브러리의 클래스도 목으로 참고할 수 있다</p><h3 id="스텁으로-상호-작용을-검증하지-말라"><a href="#스텁으로-상호-작용을-검증하지-말라" class="headerlink" title="스텁으로 상호 작용을 검증하지 말라"></a>스텁으로 상호 작용을 검증하지 말라</h3><p>스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다</p><p>최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세라고 부른다</p><p>목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만 대다수 그렇다</p><h3 id="목과-스텁-함께-쓰기"><a href="#목과-스텁-함께-쓰기" class="headerlink" title="목과 스텁 함께 쓰기"></a>목과 스텁 함께 쓰기</h3><p>때로는 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다</p><h3 id="목과-스텁은-명령과-조회에-어떻게-관련돼-있는가"><a href="#목과-스텁은-명령과-조회에-어떻게-관련돼-있는가" class="headerlink" title="목과 스텁은 명령과 조회에 어떻게 관련돼 있는가"></a>목과 스텁은 명령과 조회에 어떻게 관련돼 있는가</h3><p>목과 스텁의 개념은 명령 조회 분리 원칙과 관련이 있다</p><p>CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하고 이 둘을 혼용해서는 안된다</p><p>명령은 부작용을 일으키고 어떤 값도 반환 하지 않는다</p><h2 id="식별할-수-있는-동작과-구현-세부-사항"><a href="#식별할-수-있는-동작과-구현-세부-사항" class="headerlink" title="식별할 수 있는 동작과 구현 세부 사항"></a>식별할 수 있는 동작과 구현 세부 사항</h2><p>단위 테스트에서 리패터링 내성 지표가 가장 중요하다</p><p>테스트는 어떻게가 아니라 무엇에 중점을 뒤야한다</p><h3 id="식별할-수-있는-동작은-공개-API와-다르다"><a href="#식별할-수-있는-동작은-공개-API와-다르다" class="headerlink" title="식별할 수 있는 동작은 공개 API와 다르다"></a>식별할 수 있는 동작은 공개 API와 다르다</h3><p>모든 제품 코드는 2차원으로 분류 가능</p><ul><li>공개 API 또는 비공개 API</li><li>식별할 수 있는 동작 또는 구현 세부 사항</li></ul><p>각 차원의 범주는 겹치지 않는다</p><p>코드가 시스템의 식별할 수 있는 동작이려면 다음중 하나를 해야 한다</p><ul><li>클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라</li><li>클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라</li></ul><h3 id="잘-설계된-API와-캡슐화"><a href="#잘-설계된-API와-캡슐화" class="headerlink" title="잘 설계된 API와 캡슐화"></a>잘 설계된 API와 캡슐화</h3><p>장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다. 복잡도 때문이다</p><ul><li>구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다</li><li>데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다</li></ul><h3 id="구현-세부-사항-유출-상태의-예"><a href="#구현-세부-사항-유출-상태의-예" class="headerlink" title="구현 세부 사항 유출: 상태의 예"></a>구현 세부 사항 유출: 상태의 예</h3><p>API를 잘 설계하면 단위 테스트도 자동으로 좋아진다</p><p>클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개해야 하며 다른 모든 것은 구현 세부 사항이므로 비공개 API뒤에 숨어 있어야 된다</p><h2 id="목과-테스트-취약성-간의-관계"><a href="#목과-테스트-취약성-간의-관계" class="headerlink" title="목과 테스트 취약성 간의 관계"></a>목과 테스트 취약성 간의 관계</h2><h3 id="육각형-아키텍처-정의"><a href="#육각형-아키텍처-정의" class="headerlink" title="육각형 아키텍처 정의"></a>육각형 아키텍처 정의</h3><p>도메인과 애플리케이션 서비스라는 두 계층으로 나눈다<br>애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형성하며 이 육각형은 애플리케이션을 나타낸다</p><ul><li>도메인 계층과 애플리케이션 서비스 계층 간의 관심사의 분리</li><li>애플리케이션 내부 통신</li><li>애플리케이션 간의 통신</li></ul><h3 id="시스템-내부-통신과-시스템-간-통신"><a href="#시스템-내부-통신과-시스템-간-통신" class="headerlink" title="시스템 내부 통신과 시스템 간 통신"></a>시스템 내부 통신과 시스템 간 통신</h3><p>시스템 내부 통신은 구현 세부 사항이고 시스템 간 통신은 그렇지 않다</p><p>시스템 간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯된다<br>성장의 주요 원칙중 하나라 하위 호환성을 지키는 것이다</p><h2 id="단위-테스트의-고전파와-런던파-재고"><a href="#단위-테스트의-고전파와-런던파-재고" class="headerlink" title="단위 테스트의 고전파와 런던파 재고"></a>단위 테스트의 고전파와 런던파 재고</h2><p>런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다</p><p>고전파는 테스트 간에 공유하는 의존성만 교체하자고 한다</p><h3 id="모든-프로세스-외부-의존성을-목으로-해야-하는-것은-아니다"><a href="#모든-프로세스-외부-의존성을-목으로-해야-하는-것은-아니다" class="headerlink" title="모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다"></a>모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다</h3><ul><li>공유 의존성</li><li>프로세스 외부 의존성</li><li>비공개 의존성</li></ul><p>고전파는 공유 의존성을 피할 것을 권고 한다</p><h3 id="목을-사용한-동작-검증"><a href="#목을-사용한-동작-검증" class="headerlink" title="목을 사용한 동작 검증"></a>목을 사용한 동작 검증</h3><p>종종 목이 동작을 검증한다고 한다 하지만 대부분의 경우는 그렇지 않다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion 이해를 위한 자료 모음</title>
      <link>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/</guid>
      <pubDate>Mon, 08 Jan 2024 06:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ComfyUI-샘플-모음&quot;&gt;&lt;a href=&quot;#ComfyUI-샘플-모음&quot; class=&quot;headerlink&quot; title=&quot;ComfyUI 샘플 모음&quot;&gt;&lt;/a&gt;ComfyUI 샘플 모음&lt;/h1&gt;&lt;p&gt;ComfyUI를 이해하는데 도움이 되는 샘플 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ComfyUI-샘플-모음"><a href="#ComfyUI-샘플-모음" class="headerlink" title="ComfyUI 샘플 모음"></a>ComfyUI 샘플 모음</h1><p>ComfyUI를 이해하는데 도움이 되는 샘플 모음</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://comfyanonymous.github.io/ComfyUI_examples/">ComfyUI Examples</a></li><li><a href="https://github.com/WASasquatch/was-node-suite-comfyui/wiki/Workflow-Examples">was-node-examples</a></li><li><a href="https://github.com/atlasunified/Templates-ComfyUI-">Templates-ComfyUI-</a></li><li><a href="https://github.com/comfyanonymous/ComfyUI/blob/master/script_examples/websockets_api_example.py">ComfyUI websockets_api_example</a></li><li><a href="https://github.com/comfyanonymous/ComfyUI/blob/master/script_examples/basic_api_example.py">ComfyUI basic_api_example</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장. 좋은 단위 테스트의 4대 요소</title>
      <link>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/</guid>
      <pubDate>Mon, 08 Jan 2024 00:51:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;4장-좋은-단위-테스트의-4대-요소&quot;&gt;&lt;a href=&quot;#4장-좋은-단위-테스트의-4대-요소&quot; class=&quot;headerlink&quot; title=&quot;4장. 좋은 단위 테스트의 4대 요소&quot;&gt;&lt;/a&gt;4장. 좋은 단위 테스트의 4대 요소&lt;/h1&gt;&lt;p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="4장-좋은-단위-테스트의-4대-요소"><a href="#4장-좋은-단위-테스트의-4대-요소" class="headerlink" title="4장. 좋은 단위 테스트의 4대 요소"></a>4장. 좋은 단위 테스트의 4대 요소</h1><p>좋은 단위 테스트 스위트의 특성</p><ul><li>개발 주기에 통합돼 있다</li><li>코드베이스의 가장 중요한 부분만을 대상으로 한다</li><li>최소한의 유지비로 최대 가치를 끌어낸다<ul><li>가치 있는 테스트 식별</li><li>가치 있는 테스트 작성</li></ul></li></ul><h2 id="좋은-단위-테스트의-4대-요소-자세히-살펴보기"><a href="#좋은-단위-테스트의-4대-요소-자세히-살펴보기" class="headerlink" title="좋은 단위 테스트의 4대 요소 자세히 살펴보기"></a>좋은 단위 테스트의 4대 요소 자세히 살펴보기</h2><ul><li>회귀 방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지 보수성</li></ul><h3 id="첫-번째-요소-회귀-방지"><a href="#첫-번째-요소-회귀-방지" class="headerlink" title="첫 번째 요소: 회귀 방지"></a>첫 번째 요소: 회귀 방지</h3><p>회귀는 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우<br>회귀는 귀찮다. 최악의 상황은 아니다</p><p>회귀 방지 지표에 대한 테스트 점수가 잘 나오는지 평가하려면 다음 사항을 고려해야 한다</p><ul><li>테스트 중에 실행되는 코드의 양</li><li>코드 복잡도</li><li>코드의 도메인 유의성</li></ul><p>일반적으로 코드가 많을수록 테스트에서 회귀가 나타낼 가능성이 높다</p><p>복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드 보다 훨씬 더 중요하다</p><h3 id="두-번째-요소-리팩터링-내성"><a href="#두-번째-요소-리팩터링-내성" class="headerlink" title="두 번째 요소: 리팩터링 내성"></a>두 번째 요소: 리팩터링 내성</h3><p>테스트를 빨간색(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다</p><p>거짓양성(테스트가 실패하는 것처럼 보이지만 실제로는 성공하는 경우)이 발생하면 리팩터링 내성이 떨어진다</p><ul><li>기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다</li><li>코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다</li></ul><h3 id="무엇이-거짓-양성의-원인인가"><a href="#무엇이-거짓-양성의-원인인가" class="headerlink" title="무엇이 거짓 양성의 원인인가?"></a>무엇이 거짓 양성의 원인인가?</h3><p>거짓양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리 하는것 뿐이다</p><p>테스트는 최종 사용자의 관점에서 sut를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다</p><p>테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다</p><h3 id="구현-세부-사항-대신-최종-결과를-목표로-하기"><a href="#구현-세부-사항-대신-최종-결과를-목표로-하기" class="headerlink" title="구현 세부 사항 대신 최종 결과를 목표로 하기"></a>구현 세부 사항 대신 최종 결과를 목표로 하기</h3><p>리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항 과 테스트 간의 결합도를 낮추는 것뿐 이다</p><h2 id="첫-번째-특성과-두-번째-특성-간의-본질적인-관계"><a href="#첫-번째-특성과-두-번째-특성-간의-본질적인-관계" class="headerlink" title="첫 번째 특성과 두 번째 특성 간의 본질적인 관계"></a>첫 번째 특성과 두 번째 특성 간의 본질적인 관계</h2><ul><li>테스트 정확도 극대화</li><li>거짓 양성과 거짓 음성의 중요성</li></ul><h3 id="테스트-정확도-극대화"><a href="#테스트-정확도-극대화" class="headerlink" title="테스트 정확도 극대화"></a>테스트 정확도 극대화</h3><p>정확도 지표</p><ul><li>테스트가 버그 있음을 얼마나 잘 나타내는가</li><li>테스트가 버그 없음을 얼마나 잘 나타내는가</li></ul><h3 id="거짓-양성과-거짓-음성의-중요성-역학-관계"><a href="#거짓-양성과-거짓-음성의-중요성-역학-관계" class="headerlink" title="거짓 양성과 거짓 음성의 중요성: 역학 관계"></a>거짓 양성과 거짓 음성의 중요성: 역학 관계</h3><p>단기적으로 거짓 양성도 거짓 음성만큼 나쁘지 않다 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 큰영향을 미치기 시작한다</p><p>중대형 프로젝트를 하면 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다</p><h2 id="세-번째-요소와-네-번째-요소-빠른-피드백과-유지-보수성"><a href="#세-번째-요소와-네-번째-요소-빠른-피드백과-유지-보수성" class="headerlink" title="세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성"></a>세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성</h2><p>좋은 단위 테스트의 특성 중 남은 두가지 요소</p><ul><li>빠른 피드백</li><li>유지 보수성</li></ul><p>유지 보수성 평가</p><ul><li>테스트가 얼마나 이해하기 어려운가</li><li>테스트가 얼마나 실행하기 어려운가</li></ul><h2 id="이상적인-테스트를-찾아서"><a href="#이상적인-테스트를-찾아서" class="headerlink" title="이상적인 테스트를 찾아서"></a>이상적인 테스트를 찾아서</h2><ul><li>회귀방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지 보수성</li></ul><p>테스트 코드를 포함한 모든 코드는 책임이다. 최소한으로 필요한 가치로 임계치를 상당히 높게 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라</p><h3 id="이상적인-테스트를-만들-수-있는가"><a href="#이상적인-테스트를-만들-수-있는가" class="headerlink" title="이상적인 테스트를 만들 수 있는가?"></a>이상적인 테스트를 만들 수 있는가?</h3><p>회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이라 이상적인 테스트를 만드는게 불가능하다</p><h3 id="극단적인-사례-1-엔드-투-엔드-테스트"><a href="#극단적인-사례-1-엔드-투-엔드-테스트" class="headerlink" title="극단적인 사례 1: 엔드 투 엔드 테스트"></a>극단적인 사례 1: 엔드 투 엔드 테스트</h3><p>단점 느린 속도</p><h3 id="극단적인-사례-2-간단한-테스트"><a href="#극단적인-사례-2-간단한-테스트" class="headerlink" title="극단적인 사례 2: 간단한 테스트"></a>극단적인 사례 2: 간단한 테스트</h3><p>간단한 테스트는 실수할 여지가 많지 않아 회귀를 나타내지 않을것이다</p><h3 id="극단적인-사례-3-깨지기-쉬운-테스트"><a href="#극단적인-사례-3-깨지기-쉬운-테스트" class="headerlink" title="극단적인 사례 3: 깨지기 쉬운 테스트"></a>극단적인 사례 3: 깨지기 쉬운 테스트</h3><p>거짓 양성이 많은 테스트를 작성하기 매우 쉽다</p><h3 id="이상적인-테스트를-찾아서-결론"><a href="#이상적인-테스트를-찾아서-결론" class="headerlink" title="이상적인 테스트를 찾아서: 결론"></a>이상적인 테스트를 찾아서: 결론</h3><p>한 특성에서 얻는 것이 많을수록 다른 특성에서 더 일게 된다</p><p>테스트 스위트를 탄탄하게 만들려면 테스트 불안정성을 제거하는 것이 최우선 과제다</p><h2 id="대중적인-테스트-자동화-개념-살펴보기"><a href="#대중적인-테스트-자동화-개념-살펴보기" class="headerlink" title="대중적인 테스트 자동화 개념 살펴보기"></a>대중적인 테스트 자동화 개념 살펴보기</h2><h3 id="테스트-피라미드-분해"><a href="#테스트-피라미드-분해" class="headerlink" title="테스트 피라미드 분해"></a>테스트 피라미드 분해</h3><p>테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다</p><h3 id="블랙박스-테스트와-화이트박스-테스트-간의-선택"><a href="#블랙박스-테스트와-화이트박스-테스트-간의-선택" class="headerlink" title="블랙박스 테스트와 화이트박스 테스트 간의 선택"></a>블랙박스 테스트와 화이트박스 테스트 간의 선택</h3><ul><li>블랙 박스 테스트 : 시스템 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다</li><li>화이트 박스 테스트 : 애플리케이션의 내부 작업을 검증하는 테스트 방식이다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장. 단위 테스트 구조</title>
      <link>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</guid>
      <pubDate>Fri, 05 Jan 2024 01:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;3장-단위-테스트-구조&quot;&gt;&lt;a href=&quot;#3장-단위-테스트-구조&quot; class=&quot;headerlink&quot; title=&quot;3장. 단위 테스트 구조&quot;&gt;&lt;/a&gt;3장. 단위 테스트 구조&lt;/h1&gt;&lt;h2 id=&quot;단위-테스트를-구성하는-방법&quot;&gt;&lt;a hre
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="3장-단위-테스트-구조"><a href="#3장-단위-테스트-구조" class="headerlink" title="3장. 단위 테스트 구조"></a>3장. 단위 테스트 구조</h1><h2 id="단위-테스트를-구성하는-방법"><a href="#단위-테스트를-구성하는-방법" class="headerlink" title="단위 테스트를 구성하는 방법"></a>단위 테스트를 구성하는 방법</h2><h3 id="AAA-arrange-act-assert-패턴-사용"><a href="#AAA-arrange-act-assert-패턴-사용" class="headerlink" title="AAA(arrange act assert) 패턴 사용"></a>AAA(arrange act assert) 패턴 사용</h3><p>3A 패턴은 테스트를 준비(arrange), 실행(act), 검증(assert) 세 단계로 나누는 것을 의미한다.</p><p>AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는데 도움이 된다</p><p>일관성이 이 패턴의 가장 큰 장점 중 하나다</p><p>Given-When-Then 패턴</p><ul><li>Given: 테스트를 위한 사전 조건을 설정한다</li><li>When: 테스트를 수행한다</li><li>Then: 테스트 결과를 검증한다</li></ul><h3 id="여러-개의-준비-실행-검증-구절-피하기"><a href="#여러-개의-준비-실행-검증-구절-피하기" class="headerlink" title="여러 개의 준비, 실행, 검증 구절 피하기"></a>여러 개의 준비, 실행, 검증 구절 피하기</h3><p>여러 개의 준비 실행 검증 구절은 테스트가 너무 많은 것을 한 번에 검증한다는 의미다</p><p>검증 구절로 구분된 여러 개의 실행 구절을 보면 려러 개의 동작 단위를 검증 하는 테스트를 뜻한다 이건 더 이상 단위 테스트가 아니라 통합 테스트다</p><h3 id="테스트-내-if-문-피하기"><a href="#테스트-내-if-문-피하기" class="headerlink" title="테스트 내 if 문 피하기"></a>테스트 내 if 문 피하기</h3><p>이것도 안티 패턴이다</p><p>이러한 테스트는 반드시 여러 개의 테스트로 분리해야 한다</p><p>테스트에 분기가 있어서 얻는 이점은 없다</p><h3 id="각-구절은-얼마나-커야-하는가"><a href="#각-구절은-얼마나-커야-하는가" class="headerlink" title="각 구절은 얼마나 커야 하는가?"></a>각 구절은 얼마나 커야 하는가?</h3><p>일반적으로 준비 구절이 세 구절 중 가장 크다.<br>실행과 검증을 합친 만큼 클 수도 있다</p><p>그러나 준비 구절이 너무 크면 코드 재사용에 도움이 되는 두가지 패턴으로<br>오브젝트 마더(object mother)와 테스트 데이터 빌더(test data builder)가 있다</p><p>실행 구절은 보통 한 줄이다. 실행 구절이 두줄 이상인 경우는 sut의 공개 API에 문제가 있을수도 있다</p><p>불변 위반(jnvariant violation) 잠재적인 모순으로 부터 코드를 보호 하는 행위를 캡슐화라고 한다</p><h3 id="검증-구절에는-검증문이-얼마나-있어야-하는가"><a href="#검증-구절에는-검증문이-얼마나-있어야-하는가" class="headerlink" title="검증 구절에는 검증문이 얼마나 있어야 하는가"></a>검증 구절에는 검증문이 얼마나 있어야 하는가</h3><p>단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다<br>단일 동작 단위는 여러 결과를 낼 수 있으며 하나의 테스트로 모든 결과를 평가하는것이 좋다</p><h3 id="종료-단계는-어떤가"><a href="#종료-단계는-어떤가" class="headerlink" title="종료 단계는 어떤가"></a>종료 단계는 어떤가</h3><p>준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다</p><p>AAA 패턴에는 이 단계를 포함하지 않는다</p><p>종료는 통합 테스트의 영역이다</p><h3 id="테스트-대상-시스템-구별하기"><a href="#테스트-대상-시스템-구별하기" class="headerlink" title="테스트 대상 시스템 구별하기"></a>테스트 대상 시스템 구별하기</h3><p>SUT(System Under Test) 테스트에서 중요한 역할을 하는데 애플리케이션을 호출하고자 하는 동작에 대한 진입점을 제공한다</p><p>SUT와 의존성과 구분하는 것이 중요하다</p><h3 id="준비-실행-검증-주석-제거하기"><a href="#준비-실행-검증-주석-제거하기" class="headerlink" title="준비, 실행, 검증 주석 제거하기"></a>준비, 실행, 검증 주석 제거하기</h3><p>의존성에서 SUT를 떼어내는 것이 중요하듯이 주석으로 하는것 보다 빈 줄로 구절을 구분한다</p><ul><li>AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라</li><li>그렇지 않으면 구절 주석을 유지하라</li></ul><h2 id="테스트-간-테스트-픽스처-재사용"><a href="#테스트-간-테스트-픽스처-재사용" class="headerlink" title="테스트 간 테스트 픽스처 재사용"></a>테스트 간 테스트 픽스처 재사용</h2><p>테스트 픽처스</p><ul><li>테스트 픽스처는 테스트 실행 대상 객체이다</li><li>NUnit에서 [TestFixture] 특성을 사용하여 테스트가 포함된 클래스를 표시한다</li></ul><p>준비 구절을 생성자로 추출 할때 단점</p><ul><li>테스트 간 결합도가 높아진다</li><li>테스트 가독성이 떨어진다</li></ul><h3 id="테스트-간의-높은-결합도는-안티-패턴이다"><a href="#테스트-간의-높은-결합도는-안티-패턴이다" class="headerlink" title="테스트 간의 높은 결합도는 안티 패턴이다"></a>테스트 간의 높은 결합도는 안티 패턴이다</h3><p>테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다.</p><h3 id="테스트-가독성을-떨어뜨리는-생성자-사용"><a href="#테스트-가독성을-떨어뜨리는-생성자-사용" class="headerlink" title="테스트 가독성을 떨어뜨리는 생성자 사용"></a>테스트 가독성을 떨어뜨리는 생성자 사용</h3><p>준비 코드를 생성자로 추출할 때 테스트 가독성을 떨어뜨린다</p><h3 id="더-나은-테스트-픽스처-재사용법"><a href="#더-나은-테스트-픽스처-재사용법" class="headerlink" title="더 나은 테스트 픽스처 재사용법"></a>더 나은 테스트 픽스처 재사용법</h3><p>테스트 픽스처를 재사용할때 생성자 사용이 최선의 방법은 아니다</p><ul><li>비공개 팩토리 매서드를 두는것도 하나의 방법이다</li><li>기초 클래스 내 공통 초기화 코드를 두는법</li></ul><h2 id="단위-테스트-명명법"><a href="#단위-테스트-명명법" class="headerlink" title="단위 테스트 명명법"></a>단위 테스트 명명법</h2><p>가장 도움 되지 않는 명명법</p><p>[테스트 대상]<em>[시나리오]</em>[예상 결과]</p><ul><li>테스트 대상 메서드 : 테스트 중인 메서드의 이름</li><li>시나리오 : 메서드를 테스트하는 조건</li><li>현재 시나리오에서 테스트 대상 메서드에 기대하는 것</li></ul><p>프로그래머가 아닌 사람들에게 이름을 어떻게 생각하는지 중요하지 않다고 말할 수 있다 테스트는 프로그래머를 위한것이라서 그렇게 생각한다</p><h3 id="단위-테스트-명명-지침"><a href="#단위-테스트-명명-지침" class="headerlink" title="단위 테스트 명명 지침"></a>단위 테스트 명명 지침</h3><ul><li>엄격한 명명 정책을 따르지 않는다</li><li>문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자</li><li>단어를 밑줄 표시(_)로 구분한다</li></ul><h3 id="예제-지침에-따른-테스트-이름-변경"><a href="#예제-지침에-따른-테스트-이름-변경" class="headerlink" title="예제: 지침에 따른 테스트 이름 변경"></a>예제: 지침에 따른 테스트 이름 변경</h3><p>테스트 이름에 SYUT(System Under Test)에 메서드 이름을 포함하지 말라</p><h2 id="매개변수화된-테스트-리팩터링하기"><a href="#매개변수화된-테스트-리팩터링하기" class="headerlink" title="매개변수화된 테스트 리팩터링하기"></a>매개변수화된 테스트 리팩터링하기</h2><p>동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말라</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장. 단위 테스트란 무엇인가</title>
      <link>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</guid>
      <pubDate>Thu, 04 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;2장-단위-테스트란-무엇인가&quot;&gt;&lt;a href=&quot;#2장-단위-테스트란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;2장. 단위 테스트란 무엇인가&quot;&gt;&lt;/a&gt;2장. 단위 테스트란 무엇인가&lt;/h1&gt;&lt;p&gt;고전파(classical sc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="2장-단위-테스트란-무엇인가"><a href="#2장-단위-테스트란-무엇인가" class="headerlink" title="2장. 단위 테스트란 무엇인가"></a>2장. 단위 테스트란 무엇인가</h1><p>고전파(classical school)는 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식</p><p>런던파(London school)는 단위 테스트와 테스트 주도 개발에 실용적으로 접근하는 방식</p><h2 id="‘단위-테스트’의-정의"><a href="#‘단위-테스트’의-정의" class="headerlink" title="‘단위 테스트’의 정의"></a>‘단위 테스트’의 정의</h2><p>단위 테스트의 속성</p><ul><li>작은 코드 조각을 검증하고</li><li>빠르게 수행하고</li><li>격리된 방식으로 처리하는 자동화된 테스트다</li></ul><p>세번째에서 논란의 여지가 있는데 격리된 방식에 차이가 런던파와 고전파의 차이다.</p><h3 id="격리-문제에-대한-런던파의-접근"><a href="#격리-문제에-대한-런던파의-접근" class="headerlink" title="격리 문제에 대한 런던파의 접근"></a>격리 문제에 대한 런던파의 접근</h3><p>테스트 대상 시스템을 협력자에게서 격리하는 것을 말한다. 즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 된다</p><p>장점</p><ul><li>단위 테스트를 의존성과 별개로 수행할수 있다</li><li>테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알수 있다</li><li>객체 그래프를 분할할 수 있다</li></ul><h3 id="격리-문제에-대한-고전파의-접근"><a href="#격리-문제에-대한-고전파의-접근" class="headerlink" title="격리 문제에 대한 고전파의 접근"></a>격리 문제에 대한 고전파의 접근</h3><p>테스트는 서로 격리해서 실행해야 한다</p><ul><li>공유 의존성(shared dependency) : 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성</li><li>비공개 의존성(private dependency) : 공유하지 않은 의존성</li><li>프로세스 외부 의존성(out of process dependency) : 애플리케이션 실행 프로세스 외부에서 실행되는 의존성</li></ul><p>결리 문제에 대한 이러한 해석에는 목과 기타 테스트 대역을 적당히 쓰려는 견해가 있다</p><p>공유의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다<br>테스트 실행 속도를 높이기 의해 공유의존성을 대체한다</p><h2 id="단위-테스트의-런던파와-고전파"><a href="#단위-테스트의-런던파와-고전파" class="headerlink" title="단위 테스트의 런던파와 고전파"></a>단위 테스트의 런던파와 고전파</h2><table><thead><tr><th></th><th>격리주체</th><th>단위의 크기</th><th>테스트 대역 사용 대상</th></tr></thead><tbody><tr><td>런던파</td><td>단위</td><td>단일 클래스</td><td>불변의존성 외 모든 의존성</td></tr><tr><td>고전파</td><td>단위테스트</td><td>단일 클래스 또는 클래스 세트</td><td>공유 의존성</td></tr></tbody></table><h3 id="고전파와-런던파가-의존성을-다루는-방법"><a href="#고전파와-런던파가-의존성을-다루는-방법" class="headerlink" title="고전파와 런던파가 의존성을 다루는 방법"></a>고전파와 런던파가 의존성을 다루는 방법</h3><p>테스트 대역을 어디에서나 흔히 사용할수 있지만 런던파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 하고 있다</p><ul><li>협력자(collaborator) : 공유하거나 변경 가능한 의존성</li><li>의존성 : 일반적인 클래스는 두가지 유형의 의존성으로 동작한다 협력자, 값</li></ul><h2 id="고전파와-런던파-비교"><a href="#고전파와-런던파-비교" class="headerlink" title="고전파와 런던파 비교"></a>고전파와 런던파 비교</h2><p>코전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다</p><p>런던파의 장점</p><ul><li>입자성이 좋다. 테스트가 세밀해서 한번에 한 클래스만 확인한다</li><li>서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다</li><li>테스트가 실패하면 어떤 기능이 실패했는지 확실히 알수 있다</li></ul><h3 id="한-번에-한-클래스만-테스트하기"><a href="#한-번에-한-클래스만-테스트하기" class="headerlink" title="한 번에 한 클래스만 테스트하기"></a>한 번에 한 클래스만 테스트하기</h3><p>좋은 입자성이란 단위 테스트에서 단위를 구성하는 것에 대한 논쟁</p><p>런던파는 클래스를 단위로 간주한다 </p><h3 id="상호-연결된-클래스의-큰-그래프를-단위-테스트하기"><a href="#상호-연결된-클래스의-큰-그래프를-단위-테스트하기" class="headerlink" title="상호 연결된 클래스의 큰 그래프를 단위 테스트하기"></a>상호 연결된 클래스의 큰 그래프를 단위 테스트하기</h3><p>실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.<br>상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다.<br>대개 클래스 그래프가 커진 것은 코드 설계 문제이다</p><h3 id="버그-위치-정확히-찾아내기"><a href="#버그-위치-정확히-찾아내기" class="headerlink" title="버그 위치 정확히 찾아내기"></a>버그 위치 정확히 찾아내기</h3><p>테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다<br>마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 어렵지 않다</p><p>계단식 실패를 통해 방금 고장 낸 코드 조각이 큰가치가 있다는것을 알게 된다 -&gt; 전체 시스템이 그것에 의존한다</p><h3 id="고전파와-런던파-사이의-다른-차이점"><a href="#고전파와-런던파-사이의-다른-차이점" class="headerlink" title="고전파와 런던파 사이의 다른 차이점"></a>고전파와 런던파 사이의 다른 차이점</h3><p>고전파와 런던파 사이에 남아 있는 두가지 차이점</p><ul><li>테스트 주도 개발을 통한 시스템 설계 방식</li><li>과도한 명세 문제</li></ul><p>런던 스타일의 단위 테스트는 하양식 TDD로 이어지며 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트 부터 시작한다</p><p>고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다</p><h2 id="두-분파의-통합-테스트"><a href="#두-분파의-통합-테스트" class="headerlink" title="두 분파의 통합 테스트"></a>두 분파의 통합 테스트</h2><p>런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다</p><p>고전 스타일로 작성된 대부분의 테스트는 런던파에게 통합테스트로 느껴질 것이다</p><h3 id="통합-테스트의-일부인-엔드-투-엔드-테스트"><a href="#통합-테스트의-일부인-엔드-투-엔드-테스트" class="headerlink" title="통합 테스트의 일부인 엔드 투 엔드 테스트"></a>통합 테스트의 일부인 엔드 투 엔드 테스트</h3><p>엔드투 앤드 테스트는 통합 테스트의 일부이다</p><p>엔드투 앤드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과후 빌드 프로세스 후반에 실행하는 것이 좋다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장. 단위 테스트 목표</title>
      <link>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</guid>
      <pubDate>Wed, 03 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1장-단위-테스트-목표&quot;&gt;&lt;a href=&quot;#1장-단위-테스트-목표&quot; class=&quot;headerlink&quot; title=&quot;1장. 단위 테스트 목표&quot;&gt;&lt;/a&gt;1장. 단위 테스트 목표&lt;/h1&gt;&lt;p&gt;단위 테스트를 배우는 것은 테스트 프레임워크나 목 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1장-단위-테스트-목표"><a href="#1장-단위-테스트-목표" class="headerlink" title="1장. 단위 테스트 목표"></a>1장. 단위 테스트 목표</h1><p>단위 테스트를 배우는 것은 테스트 프레임워크나 목 라이브러리등과 같은 기술적인 부분을 익히는 것에 그치지 않는다</p><p>단위 테스트를 매우 많이 작성하더라도 많은 버그와 유지비로 프로젝트 진행이 느려지게 된다</p><h2 id="단위-테스트-현황"><a href="#단위-테스트-현황" class="headerlink" title="단위 테스트 현황"></a>단위 테스트 현황</h2><p>대부분의 프로그래머는 단위 테스트를 실천하고 중요성을 알고 있다</p><p>보통 제품코드와 테스트 코드의 비율은 1:1에서 1:3 정도 된다</p><p>좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제이다</p><h2 id="단위-테스트-목표"><a href="#단위-테스트-목표" class="headerlink" title="단위 테스트 목표"></a>단위 테스트 목표</h2><p>단위 테스트와 코드 설계의 관계</p><ul><li>코드 조각을 단위 테스트하는 것은 훌륭한 리스머스 시험이지만 한 방향으로 작동한다</li></ul><p>단위 테스트의 목표는? -&gt; 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것 이다</p><p>개발속도가 빠르게 감소하는 현상을 소프트웨어 엔트로피라고 한다</p><h3 id="좋은-테스트와-좋지-않은-테스트를-가르는-요인"><a href="#좋은-테스트와-좋지-않은-테스트를-가르는-요인" class="headerlink" title="좋은 테스트와 좋지 않은 테스트를 가르는 요인"></a>좋은 테스트와 좋지 않은 테스트를 가르는 요인</h3><p>테스트의 가치와 유지비용을 모두 고려해야함 비용요소는 다음과 같은 다양한 활동에 필요한 시간에 따라 결정된다</p><ul><li>기반 코드를 리팩터링할 때 테스트도 리팩터링하라</li><li>각 코드 변경 시 테스트를 실행하라</li><li>테스트가 잘못된 경고를 발생시킬 경우 처리하라</li><li>기반 코드가 어떻게 동작하는지 이해라려고 할때 테스트를 읽는 시간에 투자하라</li></ul><p>제품 코드 대 테스트 코드</p><ul><li>코드는 자산이 아니라 책임이다</li><li>테스트도 역시 코드다 다른 코드와 마찬가지로 유지보수가 필요하다</li></ul><h2 id="테스트-스위트-품질-측정을-위한-커버리지-지표"><a href="#테스트-스위트-품질-측정을-위한-커버리지-지표" class="headerlink" title="테스트 스위트 품질 측정을 위한 커버리지 지표"></a>테스트 스위트 품질 측정을 위한 커버리지 지표</h2><ul><li>코드 커버리지</li><li>분기 커버리지</li></ul><p>커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다</p><h3 id="코드-커버리지-지표에-대한-이해"><a href="#코드-커버리지-지표에-대한-이해" class="headerlink" title="코드 커버리지 지표에 대한 이해"></a>코드 커버리지 지표에 대한 이해</h3><p>가장 많이 사용되는 커버리지 지표로 코드 커버리지가 있으며 테스트 커버리지로도 알려져 있다</p><p>코드가 작을수록 커버리지 지표는 더 좋아지는데 이는 원래 라인 수만 처리해서이다</p><p>코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지보수성이 변경되지 않는다</p><h3 id="분기-커버리지-지표에-대한-이해"><a href="#분기-커버리지-지표에-대한-이해" class="headerlink" title="분기 커버리지 지표에 대한 이해"></a>분기 커버리지 지표에 대한 이해</h3><p>분기 커버리지는 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조의 수를 나타낸다</p><h3 id="커버리지-지표에-관한-문제점"><a href="#커버리지-지표에-관한-문제점" class="headerlink" title="커버리지 지표에 관한 문제점"></a>커버리지 지표에 관한 문제점</h3><p>테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유</p><ul><li>테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다</li><li>외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다</li></ul><p>단위 테스트에는 반드시 적잘한 검증이 있어야 된다</p><p>정수 타입으로 변환할수 없는 몇가지 가능한 인수</p><ul><li>널 값</li><li>빈 문자열</li><li>정수가 아님</li><li>너무 긴 문자열</li></ul><h3 id="특정-커버리지-숫자를-목표로-하기"><a href="#특정-커버리지-숫자를-목표로-하기" class="headerlink" title="특정 커버리지 숫자를 목표로 하기"></a>특정 커버리지 숫자를 목표로 하기</h3><p>커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안된다</p><p>커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다</p><h2 id="무엇이-성공적인-테스트-스위트를-만드는가"><a href="#무엇이-성공적인-테스트-스위트를-만드는가" class="headerlink" title="무엇이 성공적인 테스트 스위트를 만드는가?"></a>무엇이 성공적인 테스트 스위트를 만드는가?</h2><p>테스트 스위트의 품질은 어떻게 측정해야 하는가? 믿을만한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는것 뿐이다</p><p>성공적인 테스트 스위트의 특성</p><ul><li>개발 주기에 통합돼 있다<ul><li>자동화된 테스트를 할수 있는 방법은 끊임없이 하는것 뿐</li></ul></li><li>코드베이스에서 가장 중요한 부분만을 대상으로 한다<ul><li>비지니스 로직이 아닌 부분<ul><li>인프라 코드</li><li>데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성</li><li>모든 것을 하나로 묶는 코드</li></ul></li></ul></li><li>최소한의 유지비로 최대의 가치를 끌어낸다<ul><li>가치 있는 테스트 식별하기</li><li>가치 있는 테스트 작성하기</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>13장: 나쁜 코드를 식별 가능하게 만들기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</guid>
      <pubDate>Tue, 02 Jan 2024 05:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;13장-나쁜-코드를-식별-가능하게-만들기&quot;&gt;&lt;a href=&quot;#13장-나쁜-코드를-식별-가능하게-만들기&quot; class=&quot;headerlink&quot; title=&quot;13장: 나쁜 코드를 식별 가능하게 만들기&quot;&gt;&lt;/a&gt;13장: 나쁜 코드를 식별 가능하게
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="13장-나쁜-코드를-식별-가능하게-만들기"><a href="#13장-나쁜-코드를-식별-가능하게-만들기" class="headerlink" title="13장: 나쁜 코드를 식별 가능하게 만들기"></a>13장: 나쁜 코드를 식별 가능하게 만들기</h1><p>나쁜 코드를 딱 봐도 않좋아 보이게 만들어 품질의 수준을 명확히 표시하는 방법 -&gt; 안티 리팩터링</p><h2 id="나쁜-코드에-대처하는-자세"><a href="#나쁜-코드에-대처하는-자세" class="headerlink" title="나쁜 코드에 대처하는 자세"></a>나쁜 코드에 대처하는 자세</h2><p>코드를 원하는 수준으로 리팩터링하지 못할 때가 많다 이런 상황에서 끔찍하지만 않게 약깐의 리팩터링을 수행하기도 한다 하지만 이렇게 하는것은 실수다</p><p>나쁜 코드를 남겨둘때 장점</p><ul><li>다시 찾기가 쉽다</li><li>통제가 지속 가능하지 않다는 신호를 준다</li></ul><h2 id="깨끗한-코드와-레거시-코드로-분리"><a href="#깨끗한-코드와-레거시-코드로-분리" class="headerlink" title="깨끗한 코드와 레거시 코드로 분리"></a>깨끗한 코드와 레거시 코드로 분리</h2><p>잘 만들수 없으면 눈에 띄게 만들어야 된다</p><h3 id="깨진-유리창-이론"><a href="#깨진-유리창-이론" class="headerlink" title="깨진 유리창 이론"></a>깨진 유리창 이론</h3><p>유리창이 하나가 깨지고 나면 곧 더 많은 유리창이 깨진다. 논란의 여지는 있지만 최소한 은유적인 가치는 있다</p><h2 id="나쁜-코드를-찾는-방법"><a href="#나쁜-코드를-찾는-방법" class="headerlink" title="나쁜 코드를 찾는 방법"></a>나쁜 코드를 찾는 방법</h2><h3 id="이-책의-규칙-단순하고-구체적인-코드"><a href="#이-책의-규칙-단순하고-구체적인-코드" class="headerlink" title="이 책의 규칙: 단순하고 구체적인 코드"></a>이 책의 규칙: 단순하고 구체적인 코드</h3><h3 id="코드-스멜-완전하고-추상적인-코드"><a href="#코드-스멜-완전하고-추상적인-코드" class="headerlink" title="코드 스멜: 완전하고 추상적인 코드"></a>코드 스멜: 완전하고 추상적인 코드</h3><h3 id="순환-복잡도-알고리즘-객관적"><a href="#순환-복잡도-알고리즘-객관적" class="headerlink" title="순환 복잡도: 알고리즘(객관적)"></a>순환 복잡도: 알고리즘(객관적)</h3><h3 id="인지-복잡도-알고리즘-주관적"><a href="#인지-복잡도-알고리즘-주관적" class="headerlink" title="인지 복잡도: 알고리즘(주관적)"></a>인지 복잡도: 알고리즘(주관적)</h3><h2 id="코드를-안전하게-나쁜-코드로-보이기-위한-규칙"><a href="#코드를-안전하게-나쁜-코드로-보이기-위한-규칙" class="headerlink" title="코드를 안전하게 나쁜 코드로 보이기 위한 규칙"></a>코드를 안전하게 나쁜 코드로 보이기 위한 규칙</h2><ul><li>올바른 정보를 절대 훼손하지 말 것</li><li>향후 리팩터링을 어렵게 만들지 말 것 </li><li>결과를 한눈에 알 수 있을 것</li></ul><h2 id="나쁜-코드를-나쁘게-보이기-위한-방법"><a href="#나쁜-코드를-나쁘게-보이기-위한-방법" class="headerlink" title="나쁜 코드를 나쁘게 보이기 위한 방법"></a>나쁜 코드를 나쁘게 보이기 위한 방법</h2><p>안전과 가역성은 필수요소</p><h3 id="열거형-사용"><a href="#열거형-사용" class="headerlink" title="열거형 사용"></a>열거형 사용</h3><h3 id="정수형-및-문자열을-타입-코드로-사용"><a href="#정수형-및-문자열을-타입-코드로-사용" class="headerlink" title="정수형 및 문자열을 타입 코드로 사용"></a>정수형 및 문자열을 타입 코드로 사용</h3><h3 id="코드에-매직-넘버-넣기"><a href="#코드에-매직-넘버-넣기" class="headerlink" title="코드에 매직 넘버 넣기"></a>코드에 매직 넘버 넣기</h3><h3 id="코드에-주석-넣기"><a href="#코드에-주석-넣기" class="headerlink" title="코드에 주석 넣기"></a>코드에 주석 넣기</h3><h3 id="코드에-공백-넣기"><a href="#코드에-공백-넣기" class="headerlink" title="코드에 공백 넣기"></a>코드에 공백 넣기</h3><h3 id="이름을-기준으로-항목을-그룹화하기"><a href="#이름을-기준으로-항목을-그룹화하기" class="headerlink" title="이름을 기준으로 항목을 그룹화하기"></a>이름을 기준으로 항목을 그룹화하기</h3><h3 id="이름에-컨텍스트-추가하기"><a href="#이름에-컨텍스트-추가하기" class="headerlink" title="이름에 컨텍스트 추가하기"></a>이름에 컨텍스트 추가하기</h3><h3 id="긴-메서드-만들기"><a href="#긴-메서드-만들기" class="headerlink" title="긴 메서드 만들기"></a>긴 메서드 만들기</h3><h3 id="메서드에-많은-매개변수-넘기기"><a href="#메서드에-많은-매개변수-넘기기" class="headerlink" title="메서드에 많은 매개변수 넘기기"></a>메서드에 많은 매개변수 넘기기</h3><h3 id="getter와-setter-사용하기"><a href="#getter와-setter-사용하기" class="headerlink" title="getter와 setter 사용하기"></a>getter와 setter 사용하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
