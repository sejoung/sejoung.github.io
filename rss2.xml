<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Sun, 09 Apr 2023 12:50:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>실용주의 프로그래머 20주년 기념판 1장 ~ 2장</title>
      <link>https://sejoung.github.io/2023/04/2023-04-09-The_Pragmatic_Programmer_01/</link>
      <guid>https://sejoung.github.io/2023/04/2023-04-09-The_Pragmatic_Programmer_01/</guid>
      <pubDate>Sun, 09 Apr 2023 12:28:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;실용주의-프로그래머&quot;&gt;&lt;a href=&quot;#실용주의-프로그래머&quot; class=&quot;headerlink&quot; title=&quot;실용주의 프로그래머&quot;&gt;&lt;/a&gt;실용주의 프로그래머&lt;/h1&gt;&lt;h2 id=&quot;1장-실용주의-철학&quot;&gt;&lt;a href=&quot;#1장-실용주의-철학&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="실용주의-프로그래머"><a href="#실용주의-프로그래머" class="headerlink" title="실용주의 프로그래머"></a>실용주의 프로그래머</h1><h2 id="1장-실용주의-철학"><a href="#1장-실용주의-철학" class="headerlink" title="1장. 실용주의 철학"></a>1장. 실용주의 철학</h2><h3 id="항목-1-당신의-인생이다"><a href="#항목-1-당신의-인생이다" class="headerlink" title="항목 1. 당신의 인생이다"></a>항목 1. 당신의 인생이다</h3><p>주도적으로 행동해서 기회를 잡아라</p><h3 id="항목-2-고양이가-내-소스-코드를-삼켰어요"><a href="#항목-2-고양이가-내-소스-코드를-삼켰어요" class="headerlink" title="항목 2. 고양이가 내 소스 코드를 삼켰어요"></a>항목 2. 고양이가 내 소스 코드를 삼켰어요</h3><p>팀 내 신뢰를 얻어야 된다 </p><p>책임지기</p><ul><li>어설픈 변명 보다는 대안을 제시</li></ul><h3 id="항목-3-소프트웨어-엔트로피"><a href="#항목-3-소프트웨어-엔트로피" class="headerlink" title="항목 3. 소프트웨어 엔트로피"></a>항목 3. 소프트웨어 엔트로피</h3><p>깨진 창문을 내버려 두지 말자</p><p>우선 망가 뜨리지 말자</p><h3 id="항목-4-돌멩이-수프와-삶은-개구리"><a href="#항목-4-돌멩이-수프와-삶은-개구리" class="headerlink" title="항목 4. 돌멩이 수프와 삶은 개구리"></a>항목 4. 돌멩이 수프와 삶은 개구리</h3><p>시작의 피로</p><p>변화의 촉매가 되라</p><p>큰 그림을 기억하라</p><h3 id="항목-5-적당히-괜찮은-소프트웨어"><a href="#항목-5-적당히-괜찮은-소프트웨어" class="headerlink" title="항목 5. 적당히 괜찮은 소프트웨어"></a>항목 5. 적당히 괜찮은 소프트웨어</h3><p>품질을 요구사항으로 만들어라</p><p>멈춰야 할때을 알아야 된다</p><h3 id="항목-6-지식-포트폴리오"><a href="#항목-6-지식-포트폴리오" class="headerlink" title="항목 6. 지식 포트폴리오"></a>항목 6. 지식 포트폴리오</h3><p>지식의 포트 폴리오에 주기적으로 투자하라</p><p>읽고 듣는것을 비판적으로 분석하라</p><h3 id="항목-7-소통하라"><a href="#항목-7-소통하라" class="headerlink" title="항목 7. 소통하라!"></a>항목 7. 소통하라!</h3><p>한국어든 영어든 하나의 프로그램언어일 뿐이다</p><ul><li>청중을 알라</li><li>말하고 싶은 게 무언지 알라</li><li>때를 골라라</li><li>스타일을 골라라</li><li>멋져 보이게 하라</li><li>청중을 참여시켜라</li><li>경청 하라</li><li>응답 하라</li><li>문서화</li></ul><h2 id="2장-실용주의-접근법"><a href="#2장-실용주의-접근법" class="headerlink" title="2장. 실용주의 접근법"></a>2장. 실용주의 접근법</h2><h3 id="항목-8-좋은-설계의-핵심"><a href="#항목-8-좋은-설계의-핵심" class="headerlink" title="항목 8. 좋은 설계의 핵심"></a>항목 8. 좋은 설계의 핵심</h3><p>좋은 설계는 나쁜설계 보다 바꾸기 쉽다</p><h3 id="항목-9-DRY-중복의-해악"><a href="#항목-9-DRY-중복의-해악" class="headerlink" title="항목 9. DRY: 중복의 해악"></a>항목 9. DRY: 중복의 해악</h3><p>반복하지 말라</p><p>모든 코드의 중복의 지식의 중복은 아니다</p><p>재사용하기 쉽게 만들어라</p><h3 id="항목-10-직교성"><a href="#항목-10-직교성" class="headerlink" title="항목 10. 직교성"></a>항목 10. 직교성</h3><p>관련 없는것들 간에 서로 영향이 없도록 하라</p><h3 id="항목-11-가역성"><a href="#항목-11-가역성" class="headerlink" title="항목 11. 가역성"></a>항목 11. 가역성</h3><p>최종 결정이란 없다</p><p>유행을 쫒지말라</p><h3 id="항목-12-예광탄"><a href="#항목-12-예광탄" class="headerlink" title="항목 12. 예광탄"></a>항목 12. 예광탄</h3><p>목표물을 찾기 위해 예광탄을 쏴라</p><h3 id="항목-13-프로토타입과-포스트잇"><a href="#항목-13-프로토타입과-포스트잇" class="headerlink" title="항목 13. 프로토타입과 포스트잇"></a>항목 13. 프로토타입과 포스트잇</h3><p>프로토타입을 코드로 만들 때는 시작하기 전에 항상 모든 사람에게 여러분이 폐기 처분할 코드를 작성하고 있다는 사실을 이해 시켜야 한다</p><h3 id="항목-14-도메인-언어"><a href="#항목-14-도메인-언어" class="headerlink" title="항목 14. 도메인 언어"></a>항목 14. 도메인 언어</h3><p>언어의 한계가 곧 자기 세계의 한계이다</p><p>문제 도메인에 가깝게 프로그래밍 하라</p><h3 id="항목-15-추정"><a href="#항목-15-추정" class="headerlink" title="항목 15. 추정"></a>항목 15. 추정</h3><p>추정으로 놀람을 피하라</p><p>코드와 함께 일정도 반복해서 조정하라</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/04/2023-04-09-The_Pragmatic_Programmer_01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 52: mutable 컬렉션 사용을 고려하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_52/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_52/</guid>
      <pubDate>Mon, 27 Mar 2023 12:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-52-mutable-컬렉션-사용을-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-52-mutable-컬렉션-사용을-고려하라"><a href="#아이템-52-mutable-컬렉션-사용을-고려하라" class="headerlink" title="아이템 52: mutable 컬렉션 사용을 고려하라"></a>아이템 52: mutable 컬렉션 사용을 고려하라</h2><p>immutable 컬렉션 보다 mutable 컬렉션이 좋은 점은 성능적인 측면에서 더 빠르다<br>컬렉션 복제는 처리 비용이 많이 든다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_52/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_51/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_51/</guid>
      <pubDate>Mon, 27 Mar 2023 12:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-51-성능이-중요한-부분에는-기본-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-51-성능이-중요한-부분에는-기본-자료형-배열을-사용하라"><a href="#아이템-51-성능이-중요한-부분에는-기본-자료형-배열을-사용하라" class="headerlink" title="아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라"></a>아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라</h2><p>기본 자료형의 특징</p><ul><li>가볍다 -&gt; 일반적인 객체와 다르게 추가적으로 포함되는것이 없기 때문</li><li>빠르다 -&gt; 값에 접근할 때 추가비용이 들지 않는다</li></ul><p>일반적으로 array보다 list나 set을 사용하는 것이 좋다 하지만 기본 자료형 컬렉션을 굉장히 많이 보유해야 하는 경우에는<br>성능을 높이고 메모리 사용량을 줄일 수 있도록 array를 사용하는 것이 좋다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_51/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 50: 컬렉션 처리 단계 수를 제한하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_50/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_50/</guid>
      <pubDate>Mon, 27 Mar 2023 12:39:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-50-컬렉션-처리-단계-수를-제한하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-50-컬렉션-처리-단계-수를-제한하라"><a href="#아이템-50-컬렉션-처리-단계-수를-제한하라" class="headerlink" title="아이템 50: 컬렉션 처리 단계 수를 제한하라"></a>아이템 50: 컬렉션 처리 단계 수를 제한하라</h2><p>전체 컬렉션에 대한 반복과 중간 컬렉션 생성이라는 비용이 발생함<br>이 비용은 적절한 컬렉션 처리 함수들을 활용해서 줄일 수 있다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_50/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_49/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_49/</guid>
      <pubDate>Mon, 27 Mar 2023 12:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-49-하나-이상의-처리-단계를-가진
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-49-하나-이상의-처리-단계를-가진-경우에는-시퀀스를-사용하라"><a href="#아이템-49-하나-이상의-처리-단계를-가진-경우에는-시퀀스를-사용하라" class="headerlink" title="아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라"></a>아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라</h2><p>Iterable 과 Sequence 는 완전히 다른 목적으로 설계되어서 완전히 다른 형태로 동작한다<br>Sequence 는 지연 처리 된다</p><p>시퀀스 지연처리의 장점</p><ul><li>자연스러운 처리 순서를 유지함</li><li>최소한만 연산함</li><li>무한 시컨스 형태로 사용할 수 있음</li><li>각각의 단계에서 컬렉션을 만들어 내지 않음</li></ul><p>시퀀스가 빠르지 않는경우</p><ul><li>stdlib의 sorted</li><li>무한 시퀀스에서 sorted를 사용할수 없다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_49/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_48/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_48/</guid>
      <pubDate>Mon, 27 Mar 2023 12:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-48-더-이상-사용하지-않는-객체의
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-48-더-이상-사용하지-않는-객체의-레퍼런스를-제거하라"><a href="#아이템-48-더-이상-사용하지-않는-객체의-레퍼런스를-제거하라" class="headerlink" title="아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라"></a>아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라</h2><p>상태를 유지할 때는 메모리 관리를 염두에 두어야 한다는 것</p><p>코드를 작성할때는 메모리와 성능 뿐 아니라 가독성과 확장성을 항상 고려해야 한다<br>일반적으로는 가독성과 확장성이 더욱 중요하지만 라이브러리를 구현할 때는 메모리와 성능이 중요하다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-27-effective_kotlin_item_48/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 47: 인라인 클래스의 사용을 고려하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-21-effective_kotlin_item_47/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-21-effective_kotlin_item_47/</guid>
      <pubDate>Tue, 21 Mar 2023 11:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-47-인라인-클래스의-사용을-고려하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-47-인라인-클래스의-사용을-고려하라"><a href="#아이템-47-인라인-클래스의-사용을-고려하라" class="headerlink" title="아이템 47: 인라인 클래스의 사용을 고려하라"></a>아이템 47: 인라인 클래스의 사용을 고려하라</h2><p>inline 으로 만들수 있는것은 함수뿐만 아니다 하나의 값을 보유하는 객체도 inline 으로 만들수 있다</p><p>inline 클래스는 아래 상황에 많이 쓰인다</p><ul><li>측정 단위를 표현할때</li><li>타입 오용으로 발생하는 문제를 막을때</li></ul><p>인터페이스를 구현하는 인라인 클래스는 inline 으로 동작하지 않는다<br>그래서 장점이 아무것도 없다</p><p>typealias 를 사용하면 타입에 새로운 이름을 붙혀줄수 있다<br>하지만 안전하지 않다 </p><p>인라인 클래스를 사용하면 오버헤드없이 타입을 래핑 할 수 있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-21-effective_kotlin_item_47/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_46/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_46/</guid>
      <pubDate>Sun, 12 Mar 2023 08:52:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;h2 id=&quot;아이템-46-함수-타입-파라미터를-갖는-함
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><h2 id="아이템-46-함수-타입-파라미터를-갖는-함수에-inline-한정자를-붙여라"><a href="#아이템-46-함수-타입-파라미터를-갖는-함수에-inline-한정자를-붙여라" class="headerlink" title="아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라"></a>아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라</h2><p>inline 한정자의 역활은 컴파일 시점에 함수를 호출하는 부분을 함수의 본문으로 대체하는것</p><p>inline 한정자의 장점</p><ul><li>타입 아규먼트에 reified 한정자를 붙여서 사용할수 있다<ul><li>reified 한정자를 지정하면 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체된다</li></ul></li><li>함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다<ul><li>함수호출과 리턴을 위해 점프하는 과정과 백스텍을 추적하는 과정이 없기 때문</li><li>함수 타입이 없을때는 사용하지 않는것을 권장</li></ul></li><li>비지역 리턴을 사용할수 있다<ul><li>일반적인 함수는 return을 사용할수 없다<ul><li>함수 리터널이 컴파일 될때 함수가 객체로 래핑되어 발생하는 문제</li></ul></li></ul></li></ul><p>inline 한정자의 비용</p><ul><li>인라인 함수는 재귀적으로 동작할수 없다</li></ul><p>crossinline : 아규먼트로 인라인 함수를 받지만 비지역적 리턴을 하는 함수는 받을수 없게 만듬</p><p>noinline : 아규먼트로 인라인 함수를 받을수 없게 만듬</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_46/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 45: 불필요한 객체 생성을 피하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_45/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_45/</guid>
      <pubDate>Sun, 12 Mar 2023 06:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-효율성&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-효율성&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(효율성)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(효율성)&lt;/h1&gt;&lt;p&gt;오늘날에는 코드 효율성을 관대 하게 바라본다 개발자
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-효율성"><a href="#이펙티브-코틀린-효율성" class="headerlink" title="이펙티브 코틀린(효율성)"></a>이펙티브 코틀린(효율성)</h1><p>오늘날에는 코드 효율성을 관대 하게 바라본다 개발자가 비싸지고 메모리는 싸졌기 때문이다<br>장기적으로 효율성은 중요하다</p><h2 id="아이템-45-불필요한-객체-생성을-피하라"><a href="#아이템-45-불필요한-객체-생성을-피하라" class="headerlink" title="아이템 45: 불필요한 객체 생성을 피하라"></a>아이템 45: 불필요한 객체 생성을 피하라</h2><p>객체 생성에는 언제나 비용이 든다</p><p>객체를 wrap 하면 크게 3가지 비용이든다</p><ul><li>객체는 더 많은 용량을 차지한다</li><li>요소가 캡슐화 되어 있다면 접근에 추가적인 함수 호출이 필요하다</li><li>객체는 생성되어야 한다</li></ul><h3 id="객체선언-싱글톤"><a href="#객체선언-싱글톤" class="headerlink" title="객체선언(싱글톤)"></a>객체선언(싱글톤)</h3><p>매순간 객체를 생성하지 않고 객체를 재사용하는 간단한 방법<br>mutable 객체는 캐시하지 않는 규칙을 지키는게 좋다</p><h3 id="캐시를-활용하는-팩토리-함수"><a href="#캐시를-활용하는-팩토리-함수" class="headerlink" title="캐시를 활용하는 팩토리 함수"></a>캐시를 활용하는 팩토리 함수</h3><p>일반적은 객체는 생성자를 사용해서 만든다 하지만 팩토리 메서드를 사용해서 만드는 경우도 있다 팩토리 함수는 캐시를 가질수도 있다</p><ul><li>WeakReference : 가비지 컬렉터가 값을 정리하는 것을 막지 않는다</li><li>SoftReference : 가비지 컬렉터가 값을 정리할 수도 있고, 정리하지 않을 수도 있다</li></ul><h3 id="무거운-객체를-외부-스코프로-보내기"><a href="#무거운-객체를-외부-스코프로-보내기" class="headerlink" title="무거운 객체를 외부 스코프로 보내기"></a>무거운 객체를 외부 스코프로 보내기</h3><p>성능을 위한 굉장히 유용한 트릭 무거운 객체를 외부 스코프로 보내는 방식</p><h3 id="지연초기화"><a href="#지연초기화" class="headerlink" title="지연초기화"></a>지연초기화</h3><p>무서운 클래스 생성은 지연되게 만드는게 좋을때도 있다</p><h3 id="기본-자료형-사용하기"><a href="#기본-자료형-사용하기" class="headerlink" title="기본 자료형 사용하기"></a>기본 자료형 사용하기</h3><p>두가지 상황에서 기본 자료형을 랩한 자료형이 사용된다</p><ul><li>nullable 타입을 연산할떄</li><li>타입을 제네릭으로 사용할때</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_45/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 44: 멤버 확장 함수의 사용을 피하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_44/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_44/</guid>
      <pubDate>Sun, 12 Mar 2023 05:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-44-멤버-확장-함수
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-44-멤버-확장-함수의-사용을-피하라"><a href="#아이템-44-멤버-확장-함수의-사용을-피하라" class="headerlink" title="아이템 44: 멤버 확장 함수의 사용을 피하라"></a>아이템 44: 멤버 확장 함수의 사용을 피하라</h2><p>확장함수는 첫 번째 아규먼트로 리시버를 받는 단순한 일반 함수로 컴파일된다</p><p>맴버 확장을 피해야 하는 이유</p><ul><li>레퍼런스를 지원하지 않는다</li><li>암묵적으로 접근할때 두 리시버중에 어떤 리시버를 선택할지 혼동된다</li><li>확장 함수가 외부에 있는 다른 클래스를 리시버로 받을때 해당 함수가 어떤 동작을 하지는 명확하지 않다</li><li>경험이 적은 개발자의 경우 화장 함수를 보면 직관적이지 않거나 심지어 보기만 해도 겁먹을수 있다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-12-effective_kotlin_item_44/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-10-effective_kotlin_item_43/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-10-effective_kotlin_item_43/</guid>
      <pubDate>Fri, 10 Mar 2023 13:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이펙티브-코틀린-클래스설계&quot;&gt;&lt;a href=&quot;#이펙티브-코틀린-클래스설계&quot; class=&quot;headerlink&quot; title=&quot;이펙티브 코틀린(클래스설계)&quot;&gt;&lt;/a&gt;이펙티브 코틀린(클래스설계)&lt;/h1&gt;&lt;h2 id=&quot;아이템-43-API의-필수적
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이펙티브-코틀린-클래스설계"><a href="#이펙티브-코틀린-클래스설계" class="headerlink" title="이펙티브 코틀린(클래스설계)"></a>이펙티브 코틀린(클래스설계)</h1><h2 id="아이템-43-API의-필수적이지-않는-부분을-확장-함수로-추출하라"><a href="#아이템-43-API의-필수적이지-않는-부분을-확장-함수로-추출하라" class="headerlink" title="아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라"></a>아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라</h2><p>클래스 메서드를 정의할때 멤버로 정의할 것인지 확장 함수로 정의할 것인지 결정해야 된다</p><p>맴버와 확장 방식의 차이점</p><ul><li>따로 가져와서 사용해야 된다 일반적으로 확장은 다른 패키지에 위치한다</li><li>확장은 우리가 직접 멤버를 추가할 수 없는 경우 데이터와 행위를 분리하도록 설계된 프로젝트에서 사용된다.</li><li>임포트 해서 사용한다는 특징 덕분에 확장은 같은 타입에 같은 이름으로 여러개를 만들수 있다</li><li>확장은 가상(virtual)이 아니다 파생 클래스에서 오버라이드 할수 없다</li><li>확장은 클래스가 아니라 타입에 만들어진다</li><li>확장은 클래스 레퍼런스에 나오지 않는다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-10-effective_kotlin_item_43/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EKS에서 HTTP를 HTTPS로 Redirect</title>
      <link>https://sejoung.github.io/2023/03/2023-03-07-k8s_alb_redirect_http_to_https/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-07-k8s_alb_redirect_http_to_https/</guid>
      <pubDate>Tue, 07 Mar 2023 14:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;EKS에서-HTTP를-HTTPS로-Redirect&quot;&gt;&lt;a href=&quot;#EKS에서-HTTP를-HTTPS로-Redirect&quot; class=&quot;headerlink&quot; title=&quot;EKS에서 HTTP를 HTTPS로 Redirect&quot;&gt;&lt;/a&gt;EKS에서
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="EKS에서-HTTP를-HTTPS로-Redirect"><a href="#EKS에서-HTTP를-HTTPS로-Redirect" class="headerlink" title="EKS에서 HTTP를 HTTPS로 Redirect"></a>EKS에서 HTTP를 HTTPS로 Redirect</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ingress</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">alb</span></span><br><span class="line">        <span class="attr">alb.ingress.kubernetes.io/scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">        <span class="attr">alb.ingress.kubernetes.io/listen-ports:</span> <span class="string">&#x27;[&#123;&quot;HTTP&quot;: 80&#125;, &#123;&quot;HTTPS&quot;: 443&#125;]&#x27;</span></span><br><span class="line">        <span class="attr">alb.ingress.kubernetes.io/healthcheck-path:</span> <span class="string">&#x27;/health&#x27;</span></span><br><span class="line">        <span class="attr">alb.ingress.kubernetes.io/certificate-arn:</span> <span class="string">arn:aws:acm:us-west-2:xxxx:certificate/xxxxxx</span></span><br><span class="line">        <span class="attr">alb.ingress.kubernetes.io/actions.ssl-redirect:</span> <span class="string">&#x27;&#123;&quot;Type&quot;: &quot;redirect&quot;, &quot;RedirectConfig&quot;: &#123; &quot;Protocol&quot;: &quot;HTTPS&quot;, &quot;Port&quot;: &quot;443&quot;, &quot;StatusCode&quot;: &quot;HTTP_301&quot;&#125;&#125;&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;www.sejoung.com&quot;</span></span><br><span class="line">          <span class="attr">http:</span></span><br><span class="line">              <span class="attr">paths:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">                    <span class="attr">path:</span> <span class="string">/*</span></span><br><span class="line">                    <span class="attr">backend:</span></span><br><span class="line">                        <span class="attr">service:</span></span><br><span class="line">                            <span class="attr">name:</span> <span class="string">ssl-redirect</span></span><br><span class="line">                            <span class="attr">port:</span></span><br><span class="line">                                <span class="attr">name:</span> <span class="string">use-annotation</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">                    <span class="attr">path:</span> <span class="string">/*</span></span><br><span class="line">                    <span class="attr">backend:</span></span><br><span class="line">                        <span class="attr">service:</span></span><br><span class="line">                            <span class="attr">name:</span> <span class="string">&quot;sejoung-develop&quot;</span></span><br><span class="line">                            <span class="attr">port:</span></span><br><span class="line">                                <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p><code>alb.ingress.kubernetes.io/listen-ports</code> 설정에 <code>[&#123;&quot;HTTP&quot;: 80&#125;, &#123;&quot;HTTPS&quot;: 443&#125;]</code> 2개 포트를 열어야 됨</p><p><code>alb.ingress.kubernetes.io/certificate-arn</code> 설정이 되어 있어야 됨</p><p><code>alb.ingress.kubernetes.io/actions.ssl-redirect: &#39;&#123;&quot;Type&quot;: &quot;redirect&quot;, &quot;RedirectConfig&quot;: &#123; &quot;Protocol&quot;: &quot;HTTPS&quot;, &quot;Port&quot;: &quot;443&quot;, &quot;StatusCode&quot;: &quot;HTTP_301&quot;&#125;&#125;&#39;</code> 설정이 되어 있어야 됨</p><p>최종적으로 제일 처음위치에 아래의 설정이 필요하다</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/*</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">ssl-redirect</span></span><br><span class="line">          <span class="attr">port:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">use-annotation</span></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.2/guide/tasks/ssl_redirect/">alb Redirect Traffic from HTTP to HTTPS</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-07-k8s_alb_redirect_http_to_https/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 11 단위 테스트의 실제</title>
      <link>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_11/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_11/</guid>
      <pubDate>Mon, 06 Mar 2023 12:53:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART III 단위 테스트)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART III 단위 테스트)</h1><h2 id="CHAPTER-11-단위-테스트의-실제"><a href="#CHAPTER-11-단위-테스트의-실제" class="headerlink" title="CHAPTER 11 단위 테스트의 실제"></a>CHAPTER 11 단위 테스트의 실제</h2><p>좋은 단위 테스트의 특징</p><ul><li>코드의 문제를 정확하게 감지한다</li><li>구현 세부 정보에 구애받지 않는다</li><li>실패는 잘 설명된다</li><li>테스트 코드가 이해하기 쉽다</li><li>테스트를 쉽고 빠르게 실행할 수 있다</li></ul><h3 id="11-1-기능뿐만-아니라-동작을-시험하라"><a href="#11-1-기능뿐만-아니라-동작을-시험하라" class="headerlink" title="11.1 기능뿐만 아니라 동작을 시험하라"></a>11.1 기능뿐만 아니라 동작을 시험하라</h3><ul><li>함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 많다</li><li>해결책<ul><li>각 동작을 테스트하는 데 집중하라<ul><li>모든 동작이 테스트되었는지 거듭 확인하라</li><li>오류 시나리오를 잊지 말라</li></ul></li></ul></li></ul><h3 id="11-2-테스트만을-위해-퍼블릭으로-만들지-말라"><a href="#11-2-테스트만을-위해-퍼블릭으로-만들지-말라" class="headerlink" title="11.2 테스트만을 위해 퍼블릭으로 만들지 말라"></a>11.2 테스트만을 위해 퍼블릭으로 만들지 말라</h3><ul><li>프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다<ul><li>해결책<ul><li>퍼블릭 API를 통해 테스트하라</li><li>코드를 더 작은 단위로 분할하라</li></ul></li></ul></li></ul><h3 id="11-3-한-번에-하나의-동작만-테스트하라"><a href="#11-3-한-번에-하나의-동작만-테스트하라" class="headerlink" title="11.3 한 번에 하나의 동작만 테스트하라"></a>11.3 한 번에 하나의 동작만 테스트하라</h3><ul><li>여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다<ul><li>해결책<ul><li>각 동작은 자체 테스트 케이스에서 테스트 하라</li><li>매개변수를 사용한 테스트</li></ul></li></ul></li></ul><h3 id="11-4-공유-설정을-적절하게-사용하라"><a href="#11-4-공유-설정을-적절하게-사용하라" class="headerlink" title="11.4 공유 설정을 적절하게 사용하라"></a>11.4 공유 설정을 적절하게 사용하라</h3><p>상태 공유 : 설정 코드가 beforeAll 블록에 추가 되면 모든 테스트 케이스 전에 한번 실행된다<br>설정 공유 : 설정 코드가 beforeEach 블록에 추가 되면 각 테스트 케이스가 실행전에 실행된다</p><ul><li>상태 공유는 문제가 될 수 있다</li><li>해결책<ul><li>상태를 공유하지 않거나 초기화하라</li></ul></li><li>설정 공유는 문제가 될 수 있다</li><li>해결책<ul><li>중요한 설정은 테스트 케이스 내에서 정의하라</li></ul></li><li>설정 공유가 적절한 경우</li></ul><h3 id="11-5-적절한-어서션-확인자를-사용하라"><a href="#11-5-적절한-어서션-확인자를-사용하라" class="headerlink" title="11.5 적절한 어서션 확인자를 사용하라"></a>11.5 적절한 어서션 확인자를 사용하라</h3><ul><li>부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다</li><li>해결책<ul><li>적절한 확인자를 사용하라</li></ul></li></ul><h3 id="11-6-테스트-용이성을-위해-의존성-주입을-사용하라"><a href="#11-6-테스트-용이성을-위해-의존성-주입을-사용하라" class="headerlink" title="11.6 테스트 용이성을 위해 의존성 주입을 사용하라"></a>11.6 테스트 용이성을 위해 의존성 주입을 사용하라</h3><ul><li>하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다</li><li>해결책<ul><li>의존성 주입을 사용하라</li></ul></li></ul><h3 id="11-7-테스트에-대한-몇-가지-결론"><a href="#11-7-테스트에-대한-몇-가지-결론" class="headerlink" title="11.7 테스트에 대한 몇 가지 결론"></a>11.7 테스트에 대한 몇 가지 결론</h3><ul><li>통합테스트</li><li>종단 간 테스트</li><li>회귀 테스트</li><li>골든 테스트(특성화 테스트)</li><li>퍼즈 테스트</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 10 단위 테스트의 원칙</title>
      <link>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_10/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_10/</guid>
      <pubDate>Mon, 06 Mar 2023 12:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-III-단위-테스트" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART III 단위 테스트)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART III 단위 테스트)</h1><h2 id="CHAPTER-10-단위-테스트의-원칙"><a href="#CHAPTER-10-단위-테스트의-원칙" class="headerlink" title="CHAPTER 10 단위 테스트의 원칙"></a>CHAPTER 10 단위 테스트의 원칙</h2><h3 id="10-1-단위-테스트-기초"><a href="#10-1-단위-테스트-기초" class="headerlink" title="10.1 단위 테스트 기초"></a>10.1 단위 테스트 기초</h3><ul><li>테스트 중인 코드</li><li>테스트 코드</li><li>테스트 케이스<ul><li>준비</li><li>실행</li><li>단언</li></ul></li><li>테스트 러너</li></ul><h3 id="10-2-좋은-단위-테스트는-어떻게-작성할-수-있는가"><a href="#10-2-좋은-단위-테스트는-어떻게-작성할-수-있는가" class="headerlink" title="10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?"></a>10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?</h3><p>좋은 단위 테스트가 가져야 할 주요 기능</p><ul><li>훼손의 정확한 감지<ul><li>코드에 대한 초기 신뢰를 준다</li><li>미래의 훼손을 막아준다</li></ul></li><li>세부 구현 사항에 독립적<ul><li>기능적 변화</li><li>리팩터링</li></ul></li><li>잘 설명되는 실패</li><li>이해 할수 있는 테스트 코드</li><li>쉽고 빠르게 실행</li></ul><h3 id="10-3-퍼블릭-API에-집중하되-중요한-동작은-무시하지-말라"><a href="#10-3-퍼블릭-API에-집중하되-중요한-동작은-무시하지-말라" class="headerlink" title="10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라"></a>10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라</h3><p>퍼블릭 API만을 사용한 테스트</p><p>퍼블릭 API만으로 테스트 할수 없는 테스트</p><ul><li>서버와 상호작용하는 코드</li><li>데이터베이스에 값을 저장하거나 읽는 코드</li></ul><h3 id="10-4-테스트-더블"><a href="#10-4-테스트-더블" class="headerlink" title="10.4 테스트 더블"></a>10.4 테스트 더블</h3><p>의존성을 실제로 사용하는 것데 대한 대안으로 테스트 더블이 있다</p><ul><li>테스트 더블을 사용하는 이유<ul><li>테스트 단순화<ul><li>테스트를 더 빠르게 실행하는 것</li></ul></li><li>테스트로부터 외부 세계 보호<ul><li>사용자는 이상하고 혼란스러운 값을 볼 수 있다</li><li>모니터링 및 로깅에 영향을 미칠 수 있다</li></ul></li><li>외부로부터 테스트 보호</li><li>가장 일반적인 테스트 더블<ul><li>목 mock : 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않는다</li><li>스텁 stub : 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다</li><li>페이크 fake : 클래스의 대체 구현체로 테스트에서 안전하게 사용할 수 있다</li></ul></li><li>목과 스텁은 문제가 될 수 있다<ul><li>목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다</li><li>구현 세부 사항과 테스트가 밀접 하게 결합하여 리팩터링이 어려워질수 있다</li></ul></li><li>페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다</li><li>페이크를 사용하면 구현 세부 정보로부터 테스트를 분리 할수 있다</li><li>목에 대한 의견<ul><li>mockist : 런던학파<ul><li>단위 테스트가 더욱 격리된다</li><li>테스트 코드 작성이 쉬워진다</li></ul></li><li>classicist : 디트로이트 학파<ul><li>목은 실제 호출이 유용한지 검증이 되지 않는다</li><li>구현 세부 사항에 대해 더 독립적인 테스트를 할 수 있다</li></ul></li></ul></li></ul></li></ul><h3 id="10-5-테스트-철학으로부터-신중하게-선택하라"><a href="#10-5-테스트-철학으로부터-신중하게-선택하라" class="headerlink" title="10.5 테스트 철학으로부터 신중하게 선택하라"></a>10.5 테스트 철학으로부터 신중하게 선택하라</h3><p>테스트 철학과 방법론</p><ul><li>테스트 주도 개발</li><li>행동 주도 개발</li><li>수용 테스트 주도 개발</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-06-good_code_bad_code_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 9 코드를 재사용하고 일반화할 수 있도록 하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_9/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_9/</guid>
      <pubDate>Sun, 05 Mar 2023 14:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-9-코드를-재사용하고-일반화할-수-있도록-하라"><a href="#CHAPTER-9-코드를-재사용하고-일반화할-수-있도록-하라" class="headerlink" title="CHAPTER 9 코드를 재사용하고 일반화할 수 있도록 하라"></a>CHAPTER 9 코드를 재사용하고 일반화할 수 있도록 하라</h2><h3 id="9-1-가정을-주의하라"><a href="#9-1-가정을-주의하라" class="headerlink" title="9.1 가정을 주의하라"></a>9.1 가정을 주의하라</h3><ul><li>가정은 코드 재사용 시 버그를 초래할 수 있다<ul><li>해결책<ul><li>불필요한 가정을 피하라</li><li>가정이 필요하면 강제적으로 하라<ul><li>가정이 깨지지 않게 만들라</li><li>오류 전달 기술을 사용하라</li><li>문제의 소지가 있는 강제되지 않은 가정</li><li>가정의 강제적 확인</li></ul></li></ul></li></ul></li></ul><h3 id="9-2-전역-상태를-주의하라"><a href="#9-2-전역-상태를-주의하라" class="headerlink" title="9.2 전역 상태를 주의하라"></a>9.2 전역 상태를 주의하라</h3><p>전역변수를 정의 하는 일반적인 방법</p><ul><li><p>자바나 C# 같은 언어에서 변수를 static 으로 표시</p></li><li><p>c++ 같은 언어에서 클래스나 함수의 외부 즉 파일 수준의 변수 정의</p></li><li><p>자바스크립트 기반 언어에서 전역 원도 객체의 속성으로 정의</p></li><li><p>전역 상태를 갖는 코드는 재사용하기 안전하지 않을 수 있다</p><ul><li>해결책<ul><li>공유 상태에 의존성 주입하라</li></ul></li></ul></li></ul><h3 id="9-3-기본-반환값을-적절하게-사용하라"><a href="#9-3-기본-반환값을-적절하게-사용하라" class="headerlink" title="9.3 기본 반환값을 적절하게 사용하라"></a>9.3 기본 반환값을 적절하게 사용하라</h3><ul><li>낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다<ul><li>상위 수준의 코드에서 기본 값을 제공하라</li></ul></li></ul><h3 id="9-4-함수의-매개변수를-주목하라"><a href="#9-4-함수의-매개변수를-주목하라" class="headerlink" title="9.4 함수의 매개변수를 주목하라"></a>9.4 함수의 매개변수를 주목하라</h3><ul><li>필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다<ul><li>해결책<ul><li>함수는 필요한것만 매개변수로 받도록 하라</li></ul></li></ul></li></ul><h3 id="9-5-제네릭의-사용을-고려하라"><a href="#9-5-제네릭의-사용을-고려하라" class="headerlink" title="9.5 제네릭의 사용을 고려하라"></a>9.5 제네릭의 사용을 고려하라</h3><ul><li>특정 유형에 의존하면 일반화를 제한한다<ul><li>제네릭을 사용하라</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 8 코드를 모듈화하라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_8/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_8/</guid>
      <pubDate>Sun, 05 Mar 2023 12:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-8-코드를-모듈화하라"><a href="#CHAPTER-8-코드를-모듈화하라" class="headerlink" title="CHAPTER 8 코드를 모듈화하라"></a>CHAPTER 8 코드를 모듈화하라</h2><p>모듈화의 목적</p><ul><li>코드가 어떻게 변경되거나 재구성 될지 모르는 상태에서 변경가 재구성이 용이한 코드를 작성</li></ul><h3 id="8-1-의존성-주입의-사용을-고려하라"><a href="#8-1-의존성-주입의-사용을-고려하라" class="headerlink" title="8.1 의존성 주입의 사용을 고려하라"></a>8.1 의존성 주입의 사용을 고려하라</h3><p>일반적으로 클래스는 다른 클래스에 의존한다</p><ul><li>하드 코드화된 의존성은 문제가 될 수 있다<ul><li>의존성 주입을 사용하라<ul><li>의존성 주입 프레임 워크</li></ul></li><li>의존성 주입을 염두에두고 코드를 설계하라</li></ul></li></ul><h3 id="8-2-인터페이스에-의존하라"><a href="#8-2-인터페이스에-의존하라" class="headerlink" title="8.2 인터페이스에 의존하라"></a>8.2 인터페이스에 의존하라</h3><ul><li>구체적인 구현에 의존하면 적응성이 제한된다<ul><li>가능한 경우 인터페이스에 의존하라</li></ul></li></ul><h3 id="8-3-클래스-상속을-주의하라"><a href="#8-3-클래스-상속을-주의하라" class="headerlink" title="8.3 클래스 상속을 주의하라"></a>8.3 클래스 상속을 주의하라</h3><ul><li>클래스 상속은 문제가 될수 있다<ul><li>상속은 추상화 계층에 방해가 될수 있다</li><li>상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다</li></ul></li><li>해결책<ul><li>구성을 사용하라<ul><li>더 간결한 추상화 계층</li><li>적응성이 높은 코드</li></ul></li></ul></li><li>진정한 is-a 관계는 어떤가<ul><li>취약한 베이스 클래스 문제</li><li>다이아몬드 문제(다중상속)</li><li>문제가 있는 계층 구조<ul><li>인터페이스를 사용하여 계층 구조를 정의</li><li>구성을 사용하여 코드를 재사용</li></ul></li></ul></li></ul><h3 id="8-4-클래스는-자신의-기능에만-집중해야-한다"><a href="#8-4-클래스는-자신의-기능에만-집중해야-한다" class="headerlink" title="8.4 클래스는 자신의 기능에만 집중해야 한다"></a>8.4 클래스는 자신의 기능에만 집중해야 한다</h3><ul><li>다른 클래스와 지나치게 연관되어 있으면 문제가 될수 있다</li><li>해결책<ul><li>자신의 기능에만 충실한 클래스를 만들라</li><li>디미터의 법칙</li></ul></li></ul><h3 id="8-5-관련-있는-데이터는-함께-캡슐화하라"><a href="#8-5-관련-있는-데이터는-함께-캡슐화하라" class="headerlink" title="8.5 관련 있는 데이터는 함께 캡슐화하라"></a>8.5 관련 있는 데이터는 함께 캡슐화하라</h3><ul><li>캡슐화되지 않은 데이터는 취급하기 어려울 수 있다<ul><li>관련된 데이터는 객체 또는 클래스로 그룹화하라</li></ul></li></ul><h3 id="8-6-반환-유형에-구현-세부-정보가-유출되지-않도록-주의하라"><a href="#8-6-반환-유형에-구현-세부-정보가-유출되지-않도록-주의하라" class="headerlink" title="8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라"></a>8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라</h3><ul><li>반환 형식에 구현 세부 사항이 유출될 경우 문제가 될수 있다<ul><li>해결책<ul><li>추상화 계층에 적합한 유형을 반환하라</li></ul></li></ul></li></ul><h3 id="8-7-예외-처리-시-구현-세부-사항이-유출되지-않도록-주의하라"><a href="#8-7-예외-처리-시-구현-세부-사항이-유출되지-않도록-주의하라" class="headerlink" title="8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라"></a>8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라</h3><ul><li>예외 처리시 구현 세부 사항이 유출되면 문제가 될 수 있다</li><li>해결책<ul><li>추상화 계층에 적절한 예외를 만들라</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-05-good_code_bad_code_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 7 코드를 오용하기 어렵게 만들라</title>
      <link>https://sejoung.github.io/2023/03/2023-03-03-good_code_bad_code_7/</link>
      <guid>https://sejoung.github.io/2023/03/2023-03-03-good_code_bad_code_7/</guid>
      <pubDate>Fri, 03 Mar 2023 12:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-7-코드를-오용하기-어렵게-만들라"><a href="#CHAPTER-7-코드를-오용하기-어렵게-만들라" class="headerlink" title="CHAPTER 7 코드를 오용하기 어렵게 만들라"></a>CHAPTER 7 코드를 오용하기 어렵게 만들라</h2><p>코드를 잘못 사용할수 있는 몇가지 일반적인 경우</p><ul><li>호출하는 쪽에서 잘못된 입력을 제공</li><li>다른 코드의 부수효과</li><li>정확한 시간이나 순서에 따라 함수를 호출하지 않음</li><li>관련 코드에서 가정과 맞지 않게 수정이 이루어짐</li></ul><h3 id="7-1-불변-객체로-만드는-것을-고려하라"><a href="#7-1-불변-객체로-만드는-것을-고려하라" class="headerlink" title="7.1 불변 객체로 만드는 것을 고려하라"></a>7.1 불변 객체로 만드는 것을 고려하라</h3><p>객체가 생성된 후에 상태를 바꿀 수 없는 객체는 불변(불가변)이다</p><p>가변객체의 문제점</p><ul><li><p>가변 객체는 추론하기 어렵다</p></li><li><p>가변 객체는 다중 스레드에서 문제가 발생할 수 있다</p></li><li><p>가변 클래스는 오용하기 쉽다</p><ul><li>객체를 생성할 때만 값을 할당하라</li><li>불변성에 대한 디자인 패턴을 사용하라<ul><li>빌더 패턴<ul><li>값을 하나씩 설정할 수 있는 빌더 클래스</li><li>발더에 의해 작성된 불변적인 읽기 전용 클래스</li></ul></li><li>쓰기시 복사 패턴</li></ul></li></ul></li></ul><h3 id="7-2-객체를-깊은-수준까지-불변적으로-만드는-것을-고려하라"><a href="#7-2-객체를-깊은-수준까지-불변적으로-만드는-것을-고려하라" class="headerlink" title="7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라"></a>7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라</h3><p>클래스가 실수로 가변적으로 될수 있는 일반적인 경우는 깊은 가변성 때문이다</p><ul><li>깊은 가변성은 오용을 초래할 수 있다<ul><li>방어적으로 복사하라</li><li>불변적 자료구조를 사용하라</li></ul></li></ul><h3 id="7-3-지나치게-일반적인-데이터-유형을-피하라"><a href="#7-3-지나치게-일반적인-데이터-유형을-피하라" class="headerlink" title="7.3 지나치게 일반적인 데이터 유형을 피하라"></a>7.3 지나치게 일반적인 데이터 유형을 피하라</h3><ul><li>지나치게 일반적인 유형은 오용될 수 있다<ul><li>유형 자체로 아무것도 설명해주지 않는다</li><li>리스트에서 어떤 항목인지 혼동하기 쉽다</li><li>패러다임은 퍼지기 쉽다</li><li>페어 유형은 오용하기 쉽다<ul><li>전용 유형 사용</li></ul></li></ul></li></ul><h3 id="7-4-시간-처리"><a href="#7-4-시간-처리" class="headerlink" title="7.4 시간 처리"></a>7.4 시간 처리</h3><p>시간을 다룰 때 코드를 잘못 사용하고 혼동을 일으킬 여지가 굉장히 많다.</p><ul><li>정수로 시간을 나타내는 것은 문제가 될수 있다<ul><li>한순간의 시간인가 아니면 시간의 양인가?</li><li>일치하지 않은 단위</li><li>시간대 처리오류</li></ul></li><li>해결책<ul><li>적절한 자료구조를 사용하라<ul><li>양으로서의 시간과 순간의 시간을 구분</li><li>더이상 단위에 대한 혼동이 없다</li></ul></li></ul></li></ul><h3 id="7-5-데이터에-대해-진실의-원천을-하나만-가져야-한다"><a href="#7-5-데이터에-대해-진실의-원천을-하나만-가져야-한다" class="headerlink" title="7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다"></a>7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다</h3><ul><li><p>기본데이터 : 코드에 제공해야 할 데이터</p></li><li><p>파생데이터 : 주어진 기본 데이터에 기반해서 코그가 계산할 수 있는 데이터</p></li><li><p>또 다른 진싱의 원천으 유효하지 않은 상태를 초래할 수 있다</p><ul><li>기본데이터를 유일한 진실의 원천으로 사용하라<ul><li>데이터 계산에 비용이 많은 드는 경우<ul><li>지연계산 및 캐싱</li></ul></li></ul></li></ul></li></ul><h3 id="7-6-논리에-대한-진실의-원천을-하나만-가져야-한다"><a href="#7-6-논리에-대한-진실의-원천을-하나만-가져야-한다" class="headerlink" title="7.6 논리에 대한 진실의 원천을 하나만 가져야 한다"></a>7.6 논리에 대한 진실의 원천을 하나만 가져야 한다</h3><p>진실의 원천은 코드에 제공된 데이터에만 적용되는 것이 아니라 코드에 포함된 논리에도 적용된다</p><ul><li>논리에 대한 진싱의 원천이 여러 개 있으면 버그를 유발할 수 있다<ul><li>진실의 원천은 단 하나만 있어야 한다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/03/2023-03-03-good_code_bad_code_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 6 예측 가능한 코드를 작성하라</title>
      <link>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/</guid>
      <pubDate>Sun, 26 Feb 2023 15:21:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-6-예측-가능한-코드를-작성하라"><a href="#CHAPTER-6-예측-가능한-코드를-작성하라" class="headerlink" title="CHAPTER 6 예측 가능한 코드를 작성하라"></a>CHAPTER 6 예측 가능한 코드를 작성하라</h2><h3 id="6-1-매직값을-반환하지-말아야-한다"><a href="#6-1-매직값을-반환하지-말아야-한다" class="headerlink" title="6.1 매직값을 반환하지 말아야 한다"></a>6.1 매직값을 반환하지 말아야 한다</h3><p>매직값 magic value는 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다 매직값의 일반적인 예는 값이 ㅇ벗거나 오류가 발생 했음을 나타내기 위해<br>-1을 반환 하는것이다</p><ul><li>매직값은 버그를 유발할 수 있다<ul><li>널, 옵셔널 또는 오류를 반환 하라</li></ul></li><li>때때로 매직값이 우연히 발생할 수 있다<ul><li>매직값은 예측을 벗어나는 결과를 초래 할 수있기 때문에 발생 가능한 상황에 대해 조심해야 된다</li></ul></li></ul><h3 id="6-2-널-객체-패턴을-적절히-사용하라"><a href="#6-2-널-객체-패턴을-적절히-사용하라" class="headerlink" title="6.2 널 객체 패턴을 적절히 사용하라"></a>6.2 널 객체 패턴을 적절히 사용하라</h3><p>값을 얻을수 없을떄 널값이나 빈 옵셔널을 반환 하는 대신 널 객체 패턴을 사용할수 있다.</p><ul><li>빈 컬렉션을 반환하면 코드가 개선될 수 있다.</li><li>빈 문자열을 반환하는 것도 때로는 문제가 될수 있다<ul><li>문자들의 모음으로서의 문자열</li><li>ID로서의 문자열</li></ul></li><li>더 복잡한 널 객체는 예측을 벗어날 수 있다</li><li>널 객체 구현은 예상을 벗어 나는 동작을 유발할 수 있다.</li></ul><h3 id="6-3-예상치-못한-부수-효과를-피하라"><a href="#6-3-예상치-못한-부수-효과를-피하라" class="headerlink" title="6.3 예상치 못한 부수 효과를 피하라"></a>6.3 예상치 못한 부수 효과를 피하라</h3><h4 id="일반적인-부수효과"><a href="#일반적인-부수효과" class="headerlink" title="일반적인 부수효과"></a>일반적인 부수효과</h4><ul><li><p>사용자에게 출력 표시</p></li><li><p>파일이나 데이터베이스에 무언가를 저장</p></li><li><p>다른 시스템을 호출하여 네트워크 트래픽 발생</p></li><li><p>캐시 업데이트 혹은 무효화</p></li><li><p>분명하고 의도적인 부수효과는 괜찮다</p></li><li><p>예기치 않은 부수효과는 문제가 될수 있다</p><ul><li>부수효과는 비용이 많이 들수 있다</li><li>호출한 쪽의 가정을 깨뜨리기</li><li>다중 스레드 코드의 버그</li></ul></li><li><p>부수효과를 피하거나 그 사실을 분명히 해라</p></li></ul><h3 id="6-4-입력-매개변수를-수정하는-것에-주의하라"><a href="#6-4-입력-매개변수를-수정하는-것에-주의하라" class="headerlink" title="6.4 입력 매개변수를 수정하는 것에 주의하라"></a>6.4 입력 매개변수를 수정하는 것에 주의하라</h3><ul><li>입력 매개변수를 수정하면 버그를 초래할 수 있다.<ul><li>변경하기 전에 복사하라</li></ul></li></ul><h3 id="6-5-오해를-일으키는-함수는-작성하지-말라"><a href="#6-5-오해를-일으키는-함수는-작성하지-말라" class="headerlink" title="6.5 오해를 일으키는 함수는 작성하지 말라"></a>6.5 오해를 일으키는 함수는 작성하지 말라</h3><ul><li>중요한 입력이 누락되었을때 아무것도 하지 않으면 놀랄수 있다<ul><li>중요한 입력은 필수 항목으로 만들라</li></ul></li></ul><h3 id="6-6-미래를-대비한-열거형-처리"><a href="#6-6-미래를-대비한-열거형-처리" class="headerlink" title="6.6 미래를 대비한 열거형 처리"></a>6.6 미래를 대비한 열거형 처리</h3><ul><li>미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될수 있다.<ul><li>모든 경우를 처리하는 스위치 문을 사용하라<ul><li>기본 케이스를 주의하라<ul><li>기본 케이스에서 예외 발생</li></ul></li></ul></li><li>주의? 다른 프로젝트의 열거형의 의존</li></ul></li></ul><h3 id="6-7-이-모든-것을-테스트로-해결할-수는-없는가"><a href="#6-7-이-모든-것을-테스트로-해결할-수는-없는가" class="headerlink" title="6.7 이 모든 것을 테스트로 해결할 수는 없는가?"></a>6.7 이 모든 것을 테스트로 해결할 수는 없는가?</h3><ul><li>어떤 개발자는 테스트에 부지런 하지 않을수 있다.</li><li>테스트가 항상 실제 상황을 정확하게 시뮬레이션 하는것은 아니다</li><li>어떤 것들은 테스트하기가 매우 어렵다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-27-good_code_bad_code_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>argocd 사용자 추가</title>
      <link>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/</guid>
      <pubDate>Fri, 24 Feb 2023 08:57:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;argocd-사용자-추가&quot;&gt;&lt;a href=&quot;#argocd-사용자-추가&quot; class=&quot;headerlink&quot; title=&quot;argocd 사용자 추가&quot;&gt;&lt;/a&gt;argocd 사용자 추가&lt;/h1&gt;&lt;p&gt;먼저 admin 패스워드 확인 방법은 아래의 방
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="argocd-사용자-추가"><a href="#argocd-사용자-추가" class="headerlink" title="argocd 사용자 추가"></a>argocd 사용자 추가</h1><p>먼저 admin 패스워드 확인 방법은 아래의 방법을 사용하면 조회가 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;&#123;.data.password&#125;&quot; | base64 -d</span><br></pre></td></tr></table></figure><p>argocd CLI 인스톨 방법</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install argocd</span><br></pre></td></tr></table></figure><p>CLI로 접속</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd login &lt;hostname&gt; --username admin --grpc-web-root-path /</span><br></pre></td></tr></table></figure><p>argocd-cm configmap 다운로드</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl get configmap argocd-cm -n argocd -o yaml &gt; argocd-cm.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">accounts.sanaes:</span> <span class="string">login</span></span><br><span class="line">  <span class="attr">accounts.sanaes.enabled:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 처럼 사용자 추가</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f argocd-cm.yml</span><br></pre></td></tr></table></figure><p>사용자 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd account list</span><br></pre></td></tr></table></figure><p>패스워드 업데이트</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argocd account update-password --account &lt;user-id&gt; --new-password &lt;new-password&gt; --current-password &lt;admin-password&gt;</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/">argocd user management</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-24-argocd_user_add/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 5 가독성 높은 코드를 작성하라</title>
      <link>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/</link>
      <guid>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/</guid>
      <pubDate>Sat, 18 Feb 2023 14:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot;&gt;&lt;a href=&quot;#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전&quot; class=&quot;headerlink&quot; title=&quot;좋은코드 나쁜코드: 프로그래머의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전"><a href="#좋은코드-나쁜코드-프로그래머의-코드-품질-개선법-PART-II-실전" class="headerlink" title="좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)"></a>좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법(PART II 실전)</h1><h2 id="CHAPTER-5-가독성-높은-코드를-작성하라"><a href="#CHAPTER-5-가독성-높은-코드를-작성하라" class="headerlink" title="CHAPTER 5 가독성 높은 코드를 작성하라"></a>CHAPTER 5 가독성 높은 코드를 작성하라</h2><p>가독성은 주관적인것 </p><h3 id="서술형-명칭-사용"><a href="#서술형-명칭-사용" class="headerlink" title="서술형 명칭 사용"></a>서술형 명칭 사용</h3><ul><li>서술적이지 않은 이름은 코드를 읽기 어렵게 만든다</li><li>주석문으로 서술적인 이름을 대체할수 없다<ul><li>주석도 유지보수 해야된다</li></ul></li></ul><h3 id="주석문의-적절한-사용"><a href="#주석문의-적절한-사용" class="headerlink" title="주석문의 적절한 사용"></a>주석문의 적절한 사용</h3><p>주석문의 목적</p><ul><li>코드가 무엇을 하는지 설명</li><li>코드가 왜 그 일을 하는지 설명</li><li>사용 지침 등 기타 정보 제공</li></ul><p>코드 기능을 설명하기 위해 주석문을 많이 추가해야 되면 가독성이 떨어진다는 신호</p><ul><li>중복된 주석문은 유해할 수 있다<ul><li>주석도 유지보수 해야 된다</li><li>코드를 지저분하게 만든다</li></ul></li><li>주석문으로 가독성 높은 코드를 대체할 수 없다</li><li>주석문은 코드의 이유를 설명하는데 유용하다</li><li>주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다<ul><li>책 읽을때 줄거리</li></ul></li></ul><h3 id="코드-줄-수를-고정하지-말라"><a href="#코드-줄-수를-고정하지-말라" class="headerlink" title="코드 줄 수를 고정하지 말라"></a>코드 줄 수를 고정하지 말라</h3><ul><li>간결하지만 이해하기 어려운 코드는 피해라<ul><li>많은줄이 필요하더라고 가독성 높은 코드를 작성하라</li></ul></li></ul><h3 id="일관된-코딩-스타일을-고수하라"><a href="#일관된-코딩-스타일을-고수하라" class="headerlink" title="일관된 코딩 스타일을 고수하라"></a>일관된 코딩 스타일을 고수하라</h3><ul><li>일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있다<ul><li>스타일 가이드를 채택하고 따르라</li></ul></li></ul><h3 id="깊이-중첩된-코드를-피하라"><a href="#깊이-중첩된-코드를-피하라" class="headerlink" title="깊이 중첩된 코드를 피하라"></a>깊이 중첩된 코드를 피하라</h3><p>일반적인 코드가 갖는 중첩되는 블록</p><ul><li><p>함수가 호출되면 그 함수가 실행되는 코드가 하나의 블록이 된다</p></li><li><p>if문의 조건이 참일 때 실행되는 코드는 하나의 블록이 된다</p></li><li><p>for루프의 각 반복시 실행되는 코드는 하나의 블록이 된다</p></li><li><p>깊이 중첩된 코드는 읽기 어려울 수 있다</p><ul><li>중첩을 최소화하기 위한 구조 변경</li></ul></li><li><p>중첩은 너무 많은 일을 한 결과물이다</p><ul><li>더 작은 함수로 분리</li></ul></li></ul><h3 id="함수-호출도-가독성이-있어야-한다"><a href="#함수-호출도-가독성이-있어야-한다" class="headerlink" title="함수 호출도 가독성이 있어야 한다"></a>함수 호출도 가독성이 있어야 한다</h3><p>함수의 이름이 잘 명명되면 그함수가 무슨일을 하는지 분명하지만 인수가 무엇이고 무슨역활을 하지는 명롹하지 않다면 호출이 이해되지 않는다</p><ul><li>매개변수는 이해하기 어려울 수 있다<ul><li>명명된 매개변수 사용</li><li>서술적 유형 사용<ul><li>열거형</li><li>클래스</li></ul></li></ul></li><li>때로는 훌륭한 해결책이 없다<ul><li>주석?</li><li>세터 함수</li><li>빌더 패턴</li></ul></li><li>IDE는 어떤가?<ul><li>가독성에는 의존하지 않는것이 좋다<ul><li>모든 개발자가 사용하는게 아닐수 있다</li></ul></li></ul></li></ul><h3 id="설명되지-않은-값을-사용하지-말라"><a href="#설명되지-않은-값을-사용하지-말라" class="headerlink" title="설명되지 않은 값을 사용하지 말라"></a>설명되지 않은 값을 사용하지 말라</h3><p>하드코드로 작성된 값이 필요한 경우</p><ul><li>한 수량을 다른 수량으로 변환 할때 사용하는 계수</li><li>작업이 실패할 경우 재시도의 최대 횟수와 같이 조정 가능한 파라미터 값</li><li>어떤 값이 채워질 수 있는 템플릿을 나타내는 문자열</li></ul><p>하드 코드로 작성된 모든 값에 있는 두가지 중요한 정보</p><ul><li><p>값이 무엇인지</p></li><li><p>값이 무엇을 의미 하는지</p></li><li><p>설명되지 않은 값은 혼란스러울 수 있다</p><ul><li>잘 명명된 상수를 사용하라</li><li>잘 명명된 함수를 사용하라<ul><li>상수를 반환하는 공급자 함수</li><li>변환을 수행하는 헬퍼 함수</li></ul></li></ul></li></ul><h3 id="익명-함수를-적절하게-사용하라"><a href="#익명-함수를-적절하게-사용하라" class="headerlink" title="익명 함수를 적절하게 사용하라"></a>익명 함수를 적절하게 사용하라</h3><ul><li>익명 함수는 간단한 로직에 좋다<ul><li>재사용 관점에서 명명함수가 유용할때가 있다</li></ul></li><li>익명 함수는 가독성이 떨어질 수 있다<ul><li>대신 명명 함수를 사용하라</li></ul></li><li>익명 함수가 길면 문제가 될 수 있다<ul><li>긴 익명 함수를 여러 개의 명명 함수로 나누라</li></ul></li></ul><h3 id="프로그래밍-언어의-새로운-기능을-적절하게-사용하라"><a href="#프로그래밍-언어의-새로운-기능을-적절하게-사용하라" class="headerlink" title="프로그래밍 언어의 새로운 기능을 적절하게 사용하라"></a>프로그래밍 언어의 새로운 기능을 적절하게 사용하라</h3><ul><li>새 기능은 코드를 개선할 수 있다</li><li>불분명한 기능은 혼동을 일으킬 수 있다</li><li>작업에 가장 적합한 도구를 사용하라</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/109366833">좋은코드 나쁜코드: 프로그래머의 코드 품질 개선법</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/02/2023-02-18-good_code_bad_code_5/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
