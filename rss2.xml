<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Wed, 28 Feb 2024 02:32:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CHAPTER 5 리팩터링 기법</title>
      <link>https://sejoung.github.io/2024/02/2024-02-28-design_patterns_beauty_5/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-28-design_patterns_beauty_5/</guid>
      <pubDate>Wed, 28 Feb 2024 01:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-5-리팩터링-기법&quot;&gt;&lt;a href=&quot;#CHAPTER-5-리팩터링-기법&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 5 리팩터링 기법&quot;&gt;&lt;/a&gt;CHAPTER 5 리팩터링 기법&lt;/h1&gt;&lt;h2 id=&quot;5-1-리
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-5-리팩터링-기법"><a href="#CHAPTER-5-리팩터링-기법" class="headerlink" title="CHAPTER 5 리팩터링 기법"></a>CHAPTER 5 리팩터링 기법</h1><h2 id="5-1-리팩터링의-네-가지-요소-목적-대상-시기-방법"><a href="#5-1-리팩터링의-네-가지-요소-목적-대상-시기-방법" class="headerlink" title="5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법"></a>5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법</h2><h3 id="5-1-1-리팩터링의-목적"><a href="#5-1-1-리팩터링의-목적" class="headerlink" title="5.1.1 리팩터링의 목적"></a>5.1.1 리팩터링의 목적</h3><p>코드에 대한 이해를 쉽게 하기 위해 소프트웨어의 내부 구조를 개선하는 것으로<br>소프트웨어의 외부 동작을 변경하지 않고 수정 비용을 줄이는 것을 목적으로 한다</p><p>고품질 코드는 훌륭한 설계 한 번에 나오는 것이 아니라 반복적인 작업의 결과로 나오는 것이다</p><h3 id="5-1-2-리팩터링의-대상"><a href="#5-1-2-리팩터링의-대상" class="headerlink" title="5.1.2 리팩터링의 대상"></a>5.1.2 리팩터링의 대상</h3><p>리팩터링의 종류</p><ul><li>대규모 리팩터링 : 시스템, 모듈, 코드 구조, 클래스 간 관계의 리팩터링을 포함하여 최상위 설계를 리팩터링하는 것</li><li>소규모 리팩터링 : 표준 명명, 표준 주석, 초대형 클래스와 함수 제거, 중복코드 추출, 같이 주로 클래스, 함수, 변수 수준에서 코드 세부 정보를 리팩터링하는 것을 말한다</li></ul><h3 id="5-1-3-리팩터링의-시기"><a href="#5-1-3-리팩터링의-시기" class="headerlink" title="5.1.3 리팩터링의 시기"></a>5.1.3 리팩터링의 시기</h3><p>코드가 망가지고 한꺼번에 해결하려는 수단으로 리팩터링은 옳지 않다</p><p>지속가능하고 진화적인 리팩터링 계획을 탐구 해야 된다 - 지속적인 리팩터링</p><h3 id="5-1-4-리팩터링의-방법"><a href="#5-1-4-리팩터링의-방법" class="headerlink" title="5.1.4 리팩터링의 방법"></a>5.1.4 리팩터링의 방법</h3><p>대규모 리팩터링 일때</p><ul><li>사전에 종합적인 리팩터링 계획을 수립해, 질서 있고 단계적으로 진행해야 한다</li></ul><p>소규모 리팩터링 일때</p><ul><li>시간 있을 때마다 소규모 리팩터링을 할수 있다</li></ul><h2 id="5-2-단위-테스트"><a href="#5-2-단위-테스트" class="headerlink" title="5.2 단위 테스트"></a>5.2 단위 테스트</h2><p>잘못된 리팩터링을 방지하는 방법?</p><ul><li>단위테스트로 할수 있지 않을까?</li></ul><h3 id="5-2-1-단위-테스트에-대해"><a href="#5-2-1-단위-테스트에-대해" class="headerlink" title="5.2.1 단위 테스트에 대해"></a>5.2.1 단위 테스트에 대해</h3><p>단위 테스트는 코드의 정확성을 테스트하기 위한 것이지만, 테스트 엔지니어가 아닌 개발 엔지니어가 작성하는 것이며 통합 테스트 보단 작다</p><ul><li>테스트 포괄성을 보장하기 위해 테스트 케이스 설계</li><li>코드로 변환</li></ul><h3 id="5-2-2-단위-테스트-코드를-작성하는-이유"><a href="#5-2-2-단위-테스트-코드를-작성하는-이유" class="headerlink" title="5.2.2 단위 테스트 코드를 작성하는 이유"></a>5.2.2 단위 테스트 코드를 작성하는 이유</h3><ul><li>프로그래머가 코드에서 버그를 찾는 데 도움이 될 수 있다</li><li>프로그래머가 코드 설계에서 문제를 찾는데 도움이 될 수 있다</li><li>통합 테스트를 보완하는 강력한도구다</li><li>단위 테스트 코드를 작성하는 과정은 코드 리팩터링 과정에 해당한다</li><li>단위 테스트는 프로그래머가 코드에 빠르게 익숙해지도록 도와준다</li><li>단위 테스트는 테스트 주도 개발을 개선하고 대체할 수 있다<h3 id="5-2-3-단위-테스트를-설계하는-방법"><a href="#5-2-3-단위-테스트를-설계하는-방법" class="headerlink" title="5.2.3 단위 테스트를 설계하는 방법"></a>5.2.3 단위 테스트를 설계하는 방법</h3></li><li>단위 테스트를 설계하는 것은 시간이 많이 걸리는 일인가?</li><li>단위 테스트 코드의 품질에 대한 요구 사항이 있는가?</li><li>단위 테스트의 커버리지가 높으면 그것만으로 충분한가?</li><li>단위 테스트 코드를 작성할 떄 코드의 구현 논리를 이해하는 것이 필요한가?</li><li>단위 테스트 프레임워크를 선택하는 방법은 무엇인가?<h3 id="5-2-4-단위-테스트를-작성하기-어려운-이유"><a href="#5-2-4-단위-테스트를-작성하기-어려운-이유" class="headerlink" title="5.2.4 단위 테스트를 작성하기 어려운 이유"></a>5.2.4 단위 테스트를 작성하기 어려운 이유</h3></li><li>단위 테스트 코드의 작성은 사실 인내심을 테스트하는 일이기도 하다</li><li>리더의 의지와 감독만으로는 불가능한 일이며 팀원들에게 코드에 대한 강한 주인의식이 있어야 가능하다</li><li>테스트 팀이 별도로 있기 때문에</li></ul><h2 id="5-3-코드-테스트-용이성"><a href="#5-3-코드-테스트-용이성" class="headerlink" title="5.3 코드 테스트 용이성"></a>5.3 코드 테스트 용이성</h2><h3 id="5-3-1-테스트-가능한-코드를-작성하는-방법"><a href="#5-3-1-테스트-가능한-코드를-작성하는-방법" class="headerlink" title="5.3.1 테스트 가능한 코드를 작성하는 방법"></a>5.3.1 테스트 가능한 코드를 작성하는 방법</h3><ul><li>클래스의 독립성 - 해당 클래스가 높은 응집도와 낮은 결합도를 만족하는지에 달려 있다</li></ul><h3 id="5-3-2-테스트가-불가능한-코드"><a href="#5-3-2-테스트가-불가능한-코드" class="headerlink" title="5.3.2 테스트가 불가능한 코드"></a>5.3.2 테스트가 불가능한 코드</h3><ul><li>보류 중인 동작</li><li>전역 변수</li><li>정적 메서드</li><li>복잡한 상속 관계</li></ul><h2 id="5-4-디커플링"><a href="#5-4-디커플링" class="headerlink" title="5.4 디커플링"></a>5.4 디커플링</h2><p>대규모 리팩터링의 주 목적은 디커플링이다</p><h3 id="5-4-1-디커플링이-중요한-이유"><a href="#5-4-1-디커플링이-중요한-이유" class="headerlink" title="5.4.1 디커플링이 중요한 이유"></a>5.4.1 디커플링이 중요한 이유</h3><p>코드의 복잡성을 제어하는 방법은 매우 많지만 그중에서 가장 효과적인 방법이 디커플링이다</p><p>높은 응집도와 낮은 결합도를 가진 코드의 특징</p><ul><li>코드 구조가 명확</li><li>계층화와 모듈화가 합리적 </li><li>의존성이 간단</li><li>모듈이나 클래스 사이의 결합도가 낮다</li></ul><h3 id="5-4-2-코드를-디커플링해야-하는지-판단하기"><a href="#5-4-2-코드를-디커플링해야-하는지-판단하기" class="headerlink" title="5.4.2 코드를 디커플링해야 하는지 판단하기"></a>5.4.2 코드를 디커플링해야 하는지 판단하기</h3><ul><li>기능 코드이 일부가 수정되면 전체 코드를 모두 건드려야 하는 상황을 발생한다는것</li><li>의존성 그래프의 복잡성에 따라 프로젝트의 코드를 분리해야 하는지 판단</li></ul><h3 id="5-4-3-코드-디커플링-방법"><a href="#5-4-3-코드-디커플링-방법" class="headerlink" title="5.4.3 코드 디커플링 방법"></a>5.4.3 코드 디커플링 방법</h3><ul><li>캡슐화와 추상화로 디커플링하기</li><li>중간 계층으로 디커플링하기</li><li>모듈화 계층화로 디커플링하기</li><li>고전적인 코드 설계 원칙과 사상을 이용한 디커플링<ul><li>단일 책임 원칙</li><li>구현이 아닌 인터페이스 기반의 프로그래밍</li><li>의존성 주입</li><li>상속보다는 합성을 더 많이 사용</li><li>디미터의 법칙을 따르는것</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/118859035">디자인 패턴의 아름다움</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-28-design_patterns_beauty_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Video</title>
      <link>https://sejoung.github.io/2024/02/2024-02-27-Video/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-27-Video/</guid>
      <pubDate>Tue, 27 Feb 2024 05:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Video&quot;&gt;&lt;a href=&quot;#Video&quot; class=&quot;headerlink&quot; title=&quot;Video&quot;&gt;&lt;/a&gt;Video&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Optical Flow&lt;ul&gt;
&lt;li&gt;pixel correspondences problem&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><ul><li>Optical Flow<ul><li>pixel correspondences problem</li><li>using local window</li><li>Lucas-Kanade flow</li><li>FlowNet<ul><li>CNN은 classification 분야에서 성공적이였으나, optical flow estimation에서는 적용된 사례가 없었음</li><li>End-to-end optical flow estimation CNN 구조와 학습방법 제안</li><li>Two Architectures (FlowNet-C, FlowNet-S)</li></ul></li><li>FlowNet2<ul><li>FlowNet을 faster and more accurate하게 하자</li></ul></li><li>PWC-Net<ul><li>Feature pyramid 와 warping, Correlation volme 을 활용한 optical flow estimation</li><li>Compare but effective CNN for optical flow</li><li>Pyramidal features의 사용</li></ul></li><li>RAFT<ul><li>All-pairs correlation volume 계산과, recurrent optical flow update</li><li>Multi-scale 3D correla)on volumes 을 만든다</li><li>Correlation volum을 전체 pixel에 대해 다 만듬</li></ul></li></ul></li></ul><h2 id="Video-Recognition-with-Sparse-Points"><a href="#Video-Recognition-with-Sparse-Points" class="headerlink" title="Video Recognition with Sparse Points"></a>Video Recognition with Sparse Points</h2><ul><li>Video Recognition with Space-Time Interest Points<ul><li>Space-time interest point (STIP)<ul><li>STIP detector</li><li>Corner point in a spatio-temporal domain</li><li>Bag of visual words</li></ul></li></ul></li></ul><h2 id="Video-Recognition-with-Dense-Trajectory-Descriptors"><a href="#Video-Recognition-with-Dense-Trajectory-Descriptors" class="headerlink" title="Video Recognition with Dense Trajectory Descriptors"></a>Video Recognition with Dense Trajectory Descriptors</h2><ul><li>Dense Trajectory<ul><li>Sparse -&gt; Dense</li><li>Point -&gt; Trajectory</li><li>Trajectory extraction</li></ul></li></ul><h2 id="Video-Recognition-with-3D-CNN"><a href="#Video-Recognition-with-3D-CNN" class="headerlink" title="Video Recognition with 3D CNN"></a>Video Recognition with 3D CNN</h2><ul><li>3D Convolutional Neural Network</li><li>C3D<ul><li>A modern 3D CNN architecture </li><li>VGGNet style network</li></ul></li><li>Visual Information Fusion Across Time<ul><li>A video &#x3D; A bag of short fixed-sized clips</li></ul></li><li>Time Information Fusion<ul><li>early fusion</li><li>late fusion</li><li>slow fusion</li></ul></li><li>Explicit Motion Estimation and Utilization<ul><li>Two-Stream Convolutional Network<ul><li>spatial stream<ul><li>ImageNet pretrained network, whose architecture is similar to ZFNet</li></ul></li><li>temporal stream<ul><li>Multi-task learning</li></ul></li></ul></li></ul></li></ul><h2 id="Video-Understanding-Modern-Approaches"><a href="#Video-Understanding-Modern-Approaches" class="headerlink" title="Video Understanding: Modern Approaches"></a>Video Understanding: Modern Approaches</h2><ul><li><p>Video Representation Learning</p></li><li><p>SlowFast Networks</p><ul><li>Low frame rate branch와 high frame rate branch를 나누어서 action recognition</li><li>Time axis 에 대한 탐구</li><li>Slow pathway</li><li>Fast pathway</li></ul></li><li><p>MoViNet</p><ul><li>Video를 좀 더 efficient하게 처리하기 위한 구조 탐구.</li><li>Video recognition에서의 efficientNet (ICML 2019) 와 같은 논문</li></ul></li><li><p>MaskFeat</p><ul><li>ransformer 와 self-supervised representation learning 을 통한 video recognition 의 최신 기법</li><li>Action recognition 을 위한 representation learning을 할 때 꼭 temporal sequence 가 필요할까?</li><li>Pretext task로 masked input으로 HOG를 prediction 해보자</li><li>HOG 는 이미지의 pixel intensity 등의 정보를 없애서 motion 그 자체의 학습에 좀 더 집중하게 도움을 줌</li></ul></li><li><p>Self-supervised learning 기반의 representation learning 방식이 video recognition 쪽에서 현재 가장 잘 동작한다. (MaskFeat)</p></li><li><p>Transformer architecture를 활용한 구조.</p></li><li><p>Video 를 이해하는 데에 꼭 sequential 한 information 이 필요하지 않을 수 있다</p></li><li><p>Single key frame 으로도 일부의 action 정보 학습&#x2F;파악 가능</p></li></ul><h2 id="Visual-Object-Tracking"><a href="#Visual-Object-Tracking" class="headerlink" title="Visual Object Tracking"></a>Visual Object Tracking</h2><ul><li>MDNet<ul><li>당시 CNN이 높은 성능을 내고 있으나, classification 과 tracking은 다른 문제여서 다르게 적용되어야 한다</li><li>Occlusion, deforma)on, mo)on blur 와 같은 문제를 처리해야함</li><li>같은 targe이여도 동영상&#x2F;배경에 따라 다르게 인식될 수 있음.</li><li>여러 동영상으로부터 target의 domain-independent shared representation 학습</li><li>Domain-specific branch를 두어 서로 다른 도메인 학습</li><li>VOT를 위한 CNN 구조 제안; Domain-independent shared layers &#x2F; Domain- specific branches.</li><li>Offline에서 pre-training되고, online으로 fine-tuning된다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-27-Video/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Object Detection &amp; Segmentation 2</title>
      <link>https://sejoung.github.io/2024/02/2024-02-27-Object_Detection_Segmentation_2/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-27-Object_Detection_Segmentation_2/</guid>
      <pubDate>Tue, 27 Feb 2024 04:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Object-Detection-amp-Segmentation-2&quot;&gt;&lt;a href=&quot;#Object-Detection-amp-Segmentation-2&quot; class=&quot;headerlink&quot; title=&quot;Object Detection &amp;amp;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Object-Detection-amp-Segmentation-2"><a href="#Object-Detection-amp-Segmentation-2" class="headerlink" title="Object Detection &amp; Segmentation 2"></a>Object Detection &amp; Segmentation 2</h1><h2 id="Additional-Object-Detection-Techniques"><a href="#Additional-Object-Detection-Techniques" class="headerlink" title="Additional Object Detection Techniques"></a>Additional Object Detection Techniques</h2><ul><li>Feature Pyramid Netowrk (FPN)<ul><li>충분히 빠르다</li><li>다양한 크기의 물체를 잘 찾아낸다</li><li>scale robustness 는 object detection에 중요하다.</li><li>Image pyramid 를 만드는 것보다 feature pyramid 를 만드는 것이 효과적이다</li><li>post-work: PANet (Path-aggregation network) – top-down-top을 활용한다</li></ul></li><li>Path Aggregation Network (PANet)<ul><li>top-down path의 FPN에서 bottom-up path를 추가하여 object detectio 에서의 scale robustness를 키운다</li><li>bottom-up connection 이 이미지의 더 좋은 features 생성에 도움이 된다.</li></ul></li><li>EfficientDet: Effcient Model Search<ul><li>EfficientNet 과 비슷한 모델 서치</li><li>BiFPN 구조를 채택하여, top-down, bottom-up 정보의 propagation을 한다</li><li>더 낮은 리소스로 더 좋은 결과를 낸다.</li></ul></li><li>DeTR: Detection Transformer<ul><li>Vision Transformer for Object Detection</li><li>CNN이 아닌 Transformer 구조를 사용해서 object detection 을 해보자</li></ul></li><li>Deformable DETR<ul><li>Deformable Convolution에서 아이디어를 얻 어 transformer 구조에 적용</li><li>마찬가지로 conv filter의 offset을 deformable DETER에서는 encoder 내의 attention 입력인 Key의 offset으로 대체하여 사용한다.</li></ul></li></ul><h2 id="Semantic-Segmentation"><a href="#Semantic-Segmentation" class="headerlink" title="Semantic Segmentation"></a>Semantic Segmentation</h2><ul><li><p>같은 클래스내에 있으면 동일한 영역이라고 본다</p></li><li><p>Fully Convolutional Network (FCN)</p><ul><li>이미지의 모든 픽셀에 대해 클래스를 예측</li><li>1x1 convolution을 사용하여, fully connected layer를 대체</li><li>add skip connection</li></ul></li><li><p>DeepLab</p><ul><li>atrous convolution을 사용하여, receptive field를 키움</li><li>fully connected conditional random field (CRF)를 사용하여, segmentation 결과를 더 정확하게 만듬</li><li>atrous spatial pyramid pooling (ASPP)를 사용하여, 다양한 크기의 receptive field를 사용</li></ul></li><li><p>Deconvolution Nework (DeconvNet)</p><ul><li>cpmvolutional layer를 거꾸로 쌓아서, segmentation을 수행</li><li>pooling layer에서의 위치 정보를 복원하기 위해, unpooling layer를 사용</li><li>deconvolution layer를 사용하여, segmentation 결과를 얻음</li></ul></li><li><p>U-Net</p></li><li><p>Instance-Aware Semantic Segmentation</p><ul><li>objectness를 캡쳐 할수 없다</li><li>Multi-scale features를 사용하여, objectness를 캡쳐</li><li>Multi-task Network Cascades<ul><li>cascade를 사용하여, segmentation과 classification을 동시에 수행</li><li>single network 사용</li></ul></li><li>Mask R-CNN<ul><li>instance segmentation을 수행</li><li>Faster R-CNN을 사용하여, object detection을 수행</li><li>RoIAlign을 사용하여, RoI pooling을 대체</li></ul></li></ul></li><li><p>Improving Semantic Segmentation</p><ul><li>Pyramid Scene Parsing Network</li><li>Context Encoding Network<ul><li>se loss를 사용하여, context 정보를 사용</li></ul></li><li>Dual Super-Resolution Learning<ul><li>image super-resolution과 semantic segmentation을 동시에 수행</li><li>sub-pixel convnet을 사용하여, segmentation 결과를 얻음</li></ul></li><li>Segmenter<ul><li>A fully Transformer-based encoder-decoder architecture</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-27-Object_Detection_Segmentation_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 4 코딩 규칙</title>
      <link>https://sejoung.github.io/2024/02/2024-02-27-design_patterns_beauty_4/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-27-design_patterns_beauty_4/</guid>
      <pubDate>Tue, 27 Feb 2024 00:36:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-4-코딩-규칙&quot;&gt;&lt;a href=&quot;#CHAPTER-4-코딩-규칙&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 4 코딩 규칙&quot;&gt;&lt;/a&gt;CHAPTER 4 코딩 규칙&lt;/h1&gt;&lt;h2 id=&quot;4-1-명명과-주석&quot;&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-4-코딩-규칙"><a href="#CHAPTER-4-코딩-규칙" class="headerlink" title="CHAPTER 4 코딩 규칙"></a>CHAPTER 4 코딩 규칙</h1><h2 id="4-1-명명과-주석"><a href="#4-1-명명과-주석" class="headerlink" title="4.1 명명과 주석"></a>4.1 명명과 주석</h2><p>명명은 코드 가독성에 큰 영향을 미치며 프로그래머의 기본 능력과 소양을 반영 하기도 한다</p><h3 id="4-1-1-긴-이름과-짧은-이름"><a href="#4-1-1-긴-이름과-짧은-이름" class="headerlink" title="4.1.1 긴 이름과 짧은 이름"></a>4.1.1 긴 이름과 짧은 이름</h3><ul><li>긴 이름 : 가급적 이름이 그 의미를 자세하기 표현하기 원함 그래야 한눈에 설계 의도를 파악할수 있기 때문</li><li>짧은 이름 : 코드가 간결하다</li></ul><p>명명시 일반적인 약어는 사용할수 있지만 약어 사용을 주의 해야 된다.<br>함수의 임시 변수와 같이 사용 범위가 비교적 작은 변수의 경우 짧은 이름을 사용할수 있다.</p><h3 id="4-1-2-문맥-정보를-사용한-명명-단순화"><a href="#4-1-2-문맥-정보를-사용한-명명-단순화" class="headerlink" title="4.1.2 문맥 정보를 사용한 명명 단순화"></a>4.1.2 문맥 정보를 사용한 명명 단순화</h3><p>객체의 콘텍스트 정보를 통해 명확하게 표현할수 있다<br>함수의 콘텍스트 정보를 통해 매개 변수의 이름도 단순화 할수 있다</p><h3 id="4-1-3-비즈니스-용어집을-사용한-명명-통일"><a href="#4-1-3-비즈니스-용어집을-사용한-명명-통일" class="headerlink" title="4.1.3 비즈니스 용어집을 사용한 명명 통일"></a>4.1.3 비즈니스 용어집을 사용한 명명 통일</h3><p>영어의 이해수준이 틀려서 동일한 비즈니스 용어의 번역이 다를수 있고 그 결과 코드의 가독성이 떨어진다<br>통일된 용어집을 준비해두면 이문제를 해결할수 있다 특히 긴 단어에 대해서 통일된 약어를 지정할수 있다</p><h3 id="4-1-4-명명은-정확하지만-추상적이어야-한다"><a href="#4-1-4-명명은-정확하지만-추상적이어야-한다" class="headerlink" title="4.1.4 명명은 정확하지만 추상적이어야 한다"></a>4.1.4 명명은 정확하지만 추상적이어야 한다</h3><p>명명은 정확하지만 추상적인 특성도 고려해야 클래스, 함수 등을 수정하더라도 이름을 매번 변경할 필요가 없다</p><h3 id="4-1-5-주석에-반드시-포함되어야-하는-것들"><a href="#4-1-5-주석에-반드시-포함되어야-하는-것들" class="headerlink" title="4.1.5 주석에 반드시 포함되어야 하는 것들"></a>4.1.5 주석에 반드시 포함되어야 하는 것들</h3><p>일부 프로그래머는 좋은 명명이 주석을 완전히 대체할 수 있으며, 만약 코드에 주석이 필요하면 명명이 충분히 적합하지 않다는 뜻 이러한 견해는 매우 편향적일수 있다</p><p>명명을 아무리 잘해도 결국 길이 제한이 있을 뿐만 아니라 모든 것을 담을 수 없다<br>주석은 매우 좋은 보충 설명이 될수 있다<br>주석은 주로 무엇 what을 하는지, 왜 why를 하는지, 어떻게 how를 하는지에 대한 정보를 담고 있다</p><ul><li>주석에는 이름 보다 훨씬 더 많은 정보를 담을수 있다</li><li>주석은 설명과 시연의 역활을 한다</li><li>요약 주석은 코드의 논리를 더 명확하게 할 수 있다</li></ul><h3 id="4-1-6-주석이-많다고-좋은-것은-아니다"><a href="#4-1-6-주석이-많다고-좋은-것은-아니다" class="headerlink" title="4.1.6 주석이 많다고 좋은 것은 아니다"></a>4.1.6 주석이 많다고 좋은 것은 아니다</h3><p>클래스, 함수, 멤버 변수에 대해서는 자세한 주석을 작성하는 것이 필요하지만<br>지역 변수와 같은 함수 내부의 코드나 함수 내부의 각 명령문에 대해서는 가능한 주석을 줄이고 좋은 명명, 기능 분활, 설명 변수로 대체할수 있다</p><h2 id="4-2-코드-스타일"><a href="#4-2-코드-스타일" class="headerlink" title="4.2 코드 스타일"></a>4.2 코드 스타일</h2><p>중요한건 팀이나 프로젝트 전체에서 코드 스타일을 일관되게 유지하는 것이다.<br>이렇게 하면 코드를 읽을 때 다른 스타일로 인해 발생하는 간섭을 줄일 수 있다</p><h3 id="4-2-1-클래스-함수의-적절한-크기"><a href="#4-2-1-클래스-함수의-적절한-크기" class="headerlink" title="4.2.1 클래스, 함수의 적절한 크기"></a>4.2.1 클래스, 함수의 적절한 크기</h3><p>클래스나 함수의 코드 줄 수는 너무 많아도 안 되며, 너무 적어도 안된다.<br>하지만 클래스나 함수의 크기가 몇 줄이어야 하는 지 명확한 수치는 없다</p><p>일부 프로그래머는 함수의 크기가 디스플레이가 한 번에 표시할수 있는 줄 수를 넘어서는 안된다고 생각한다<br>그렇지 않으면 함수의 내용을 파악하기 위해 계속 화면을 스크롤해야 하며, 이는 좋은 코드 리드 경험이라고 할 수 없다</p><h3 id="4-2-2-한-줄의-적절한-길이"><a href="#4-2-2-한-줄의-적절한-길이" class="headerlink" title="4.2.2 한 줄의 적절한 길이"></a>4.2.2 한 줄의 적절한 길이</h3><p>코드의 줄의 길이와 관련하여 가급적 IDE의 표시 너비를 초과해서는 안된다는 규칙을 따를 수 있다<br>이렇게 하면 코드를 읽을 때 화면을 스크롤할 필요가 없어진다<br>하지만 너무 짧아도 하나의 문장이 두 개 이상의 라인으로 분활되기 때문에 오히려 가독성이 떨어지는 경우가 생긴다</p><h3 id="4-2-3-빈-줄을-활용한-코드-블록-구분"><a href="#4-2-3-빈-줄을-활용한-코드-블록-구분" class="headerlink" title="4.2.3 빈 줄을 활용한 코드 블록 구분"></a>4.2.3 빈 줄을 활용한 코드 블록 구분</h3><p>코드 블록을 별도의 함수로 분리하기 불편한 경우 코드의 논리를 명확하게 하기위해서 빈 줄을 사용하여 코드 블록을 구분할 수도 있다</p><h3 id="4-2-4-4칸-들여쓰기-혹은-2칸-들여쓰기"><a href="#4-2-4-4칸-들여쓰기-혹은-2칸-들여쓰기" class="headerlink" title="4.2.4 4칸 들여쓰기 혹은 2칸 들여쓰기"></a>4.2.4 4칸 들여쓰기 혹은 2칸 들여쓰기</h3><p>공간을 절약하기 위해 2칸<br>4칸은 코드의 중첩이 늘어나면 누적된 들여쓰기로 인해 문장이 두줄 이상 분리될 확일이 높아져서 가독성에 영향을 미친다</p><p>들여쓰기에 tab을 사용하면 안된다 표시되는 너비가 틀려 가독성에 좋지 않다</p><h3 id="4-2-5-여는-중괄호는-어디에-놓여야-할까"><a href="#4-2-5-여는-중괄호는-어디에-놓여야-할까" class="headerlink" title="4.2.5 여는 중괄호는 어디에 놓여야 할까"></a>4.2.5 여는 중괄호는 어디에 놓여야 할까</h3><p>새로운 줄에서 여는 중괄호와 닫는 중괄호가 정렬되 코드 구조가 훨씬 명확해진다</p><p>앞줄에서 이어지는 중괄호는 공간이 줄어드는 장점 하지만 코드가 너무 붙어서 가독성이 떨어질수도 있다 </p><h3 id="4-2-6-클래스의-멤버-순서"><a href="#4-2-6-클래스의-멤버-순서" class="headerlink" title="4.2.6 클래스의 멤버 순서"></a>4.2.6 클래스의 멤버 순서</h3><p>클래스에서 멤버 변수는 일반적으로 함수 앞에 놓는다<br>멤버 변수사이, 함수 사이의 관계는 먼저 정적 멤버 변수 도는 정적함수가 놓이고 뒤에 비정적 멤버 변수와 비정정함수가 놓인다</p><p>멤버 변수와 함수 범위는 내림차순으로 정렬되므로, 먼저 public, protected, private 순으로 정렬된다</p><h2 id="4-3-코딩-팁"><a href="#4-3-코딩-팁" class="headerlink" title="4.3 코딩 팁"></a>4.3 코딩 팁</h2><h3 id="4-3-1-복잡한-코드의-모듈화"><a href="#4-3-1-복잡한-코드의-모듈화" class="headerlink" title="4.3.1 복잡한 코드의 모듈화"></a>4.3.1 복잡한 코드의 모듈화</h3><p>커다른 블록을 클래스나 함수로 캡슐화 하는데 능숙해져야 된다</p><h3 id="4-3-2-함수의-매개변수-관리"><a href="#4-3-2-함수의-매개변수-관리" class="headerlink" title="4.3.2 함수의 매개변수 관리"></a>4.3.2 함수의 매개변수 관리</h3><p>함수의 매개변수가 너무 많으면 함수를 읽거나 사용하는 것이 불편해진다<br>매개변수가 5개를 넘어가면 너무 많다고 할수 있다</p><ul><li>함수를 호출할때 함수 호출문이 길어저 가독성이 떨어진다</li><li>매개변수가 너무 많으면 단일 책임원칙을 지키지 않았었을 가능성이 높다</li></ul><h3 id="4-3-3-함수의-플래그-매개변수-제거"><a href="#4-3-3-함수의-플래그-매개변수-제거" class="headerlink" title="4.3.3 함수의 플래그 매개변수 제거"></a>4.3.3 함수의 플래그 매개변수 제거</h3><p>플래그 매개변수는 함수의 기능을 분기하는데 사용되는 매개변수이다</p><ul><li>단일 책임원칙과 인터페이스 분리원칙을 위반한다</li></ul><h3 id="4-3-4-깊은-중첩-코드-제거"><a href="#4-3-4-깊은-중첩-코드-제거" class="headerlink" title="4.3.4 깊은 중첩 코드 제거"></a>4.3.4 깊은 중첩 코드 제거</h3><ul><li>중복되는 if, else문을 제거</li><li>continue, break문, return문을 사용하여 중첩을 바로 종료한다</li><li>실행 순서를 조정하여 중첩 단계를 줄인다</li><li>중첩 단계를 줄이기 위해 코드의 일부를 함수로 캡슐화한다</li></ul><h3 id="4-3-5-설명-변수"><a href="#4-3-5-설명-변수" class="headerlink" title="4.3.5 설명 변수"></a>4.3.5 설명 변수</h3><ul><li>매직 넘버 대신 상수를 사용한다</li><li>설명 변수를 사용하여 복잡한 표현을 설명한다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/118859035">디자인 패턴의 아름다움</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-27-design_patterns_beauty_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Object Detection &amp; Segmentation 1</title>
      <link>https://sejoung.github.io/2024/02/2024-02-26-Object_Detection_Segmentation/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-26-Object_Detection_Segmentation/</guid>
      <pubDate>Mon, 26 Feb 2024 04:33:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Object-Detection-amp-Segmentation-1&quot;&gt;&lt;a href=&quot;#Object-Detection-amp-Segmentation-1&quot; class=&quot;headerlink&quot; title=&quot;Object Detection &amp;amp;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Object-Detection-amp-Segmentation-1"><a href="#Object-Detection-amp-Segmentation-1" class="headerlink" title="Object Detection &amp; Segmentation 1"></a>Object Detection &amp; Segmentation 1</h1><ul><li>Object Detection : 이미지 내에서 특정 객체의 위치를 찾아내는 것</li><li>Segmentation : 이미지 내에서 특정 객체의 픽셀을 찾아내는 것</li></ul><p>Object Detection &#x3D; Box localization + Box classification</p><h2 id="Region-based-CNN-RCNN"><a href="#Region-based-CNN-RCNN" class="headerlink" title="Region-based CNN* (RCNN)"></a>Region-based CNN* (RCNN)</h2><ul><li>bounding box의 transformation를 학습</li></ul><h2 id="Faster-R-CNN-with-ResNet"><a href="#Faster-R-CNN-with-ResNet" class="headerlink" title="Faster R-CNN with ResNet"></a>Faster R-CNN with ResNet</h2><ul><li>R-CNN의 속도를 개선</li></ul><h2 id="Object-Detection-‒-Basic-Concepts"><a href="#Object-Detection-‒-Basic-Concepts" class="headerlink" title="Object Detection ‒ Basic Concepts"></a>Object Detection ‒ Basic Concepts</h2><ul><li>Object Detection : 이미지 내에서 특정 객체의 위치를 찾아내는 것</li></ul><h2 id="Object-Detection-‒-Classical-Object-Detection"><a href="#Object-Detection-‒-Classical-Object-Detection" class="headerlink" title="Object Detection ‒ Classical Object Detection"></a>Object Detection ‒ Classical Object Detection</h2><ul><li>Support Vector Machine (SVM) : 이미지 내에서 특정 객체의 위치를 찾아내는 것<ul><li>Linear SVM : 선형 분류기</li><li>Non-Linear SVM : 비선형 분류기</li><li>Hyper-Parameters Tuning : cross-validation을 통해 최적의 파라미터를 찾는 것</li><li>Multi-Class SVM : 다중 클래스 분류기<ul><li>one-versus-all</li><li>one-versus-one</li></ul></li></ul></li><li>Histogram of Oriented Gradients (HOG)<ul><li>가우시안 스무딩을 하지 않는다</li><li>이미지를 8x8 크기의 cell로 나눈다</li><li>HOG+SVM for Pedestrian Detection</li></ul></li><li>Selective Search for Object Detection<ul><li>Capture all scales: 물체 크기 랜덤, 경계 불명확 할수 있음</li><li>Diversification: 색상, 재질, 크기 등의 조건을 고려해서 다중 전략을 취함</li><li>Fast to compute: 계산 시 너무 오래 걸리면 안됨</li><li>segment가 있으면 그 영역에 대해 candidate objects로 사용하여 좀 더 쉽게 object detection 을 할 수 있지 않을까?</li><li>Object recogntion이나 detection을 위한 후보 영역 을 알아 낼수 있는 알고리즘</li><li>Mean Average Best Overlap (MABO)</li><li>Recall</li></ul></li><li>EdgeBox for Object Detection<ul><li>Gradient orientation 을 기반으로 edge group을 표현하고, 이를 이용해서 bounding box score를 계산함</li><li>Evaluation metric 제안: Intersection on Union (IoU)</li></ul></li><li>Region-based CNN* (RCNN)<ul><li>2 stage detection</li></ul></li><li>Fast R-CNN<ul><li>ROI pooling</li><li>9 anchor per location</li></ul></li><li>Mask R-CNN<ul><li>instance segmentation</li></ul></li><li>One-Stage Detector<ul><li>regional proposal 와 classification을 동시에 수행 </li><li>YOLO(You Only Look Once)</li><li>YOLO v2<ul><li>better, faster, stronger</li><li>Batch normalization: 모든 conv layer에 BN추가</li><li>High-resolution classifier: ImageNet으로 pre-training하고, 448x448의 해상도로 10 epoch 동안 fine tuning</li><li>Convolutional with anchor boxes: V1에서 FC부분을 conv로 대체. Anchor box 적용</li></ul></li><li>YOLO v3<ul><li>하나의 object에 하나의 anchor box할당</li><li>3가지 다른 scale 사용한 feature pyramid 사용. 3개 scale에 대해 각각 3개 박스를 생성하여 9개의 anchor box가 있음.</li></ul></li><li>YOLO v4<ul><li>Practically, one-stage detector의 개선</li><li>다양한 테크닉을 통해 성능, 속도 향상한다</li><li>저자가 달라졌다</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">LIBSVM</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-26-Object_Detection_Segmentation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 3 설계 원칙</title>
      <link>https://sejoung.github.io/2024/02/2024-02-26-design_patterns_beauty_3/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-26-design_patterns_beauty_3/</guid>
      <pubDate>Mon, 26 Feb 2024 00:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-3-설계-원칙&quot;&gt;&lt;a href=&quot;#CHAPTER-3-설계-원칙&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 3 설계 원칙&quot;&gt;&lt;/a&gt;CHAPTER 3 설계 원칙&lt;/h1&gt;&lt;h2 id=&quot;3-1-단일-책임-원칙&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-3-설계-원칙"><a href="#CHAPTER-3-설계-원칙" class="headerlink" title="CHAPTER 3 설계 원칙"></a>CHAPTER 3 설계 원칙</h1><h2 id="3-1-단일-책임-원칙"><a href="#3-1-단일-책임-원칙" class="headerlink" title="3.1 단일 책임 원칙"></a>3.1 단일 책임 원칙</h2><h3 id="3-1-1-단일-책임-원칙의-정의-및-해석"><a href="#3-1-1-단일-책임-원칙의-정의-및-해석" class="headerlink" title="3.1.1 단일 책임 원칙의 정의 및 해석"></a>3.1.1 단일 책임 원칙의 정의 및 해석</h3><p>단일 책임 원칙(single responsibility principle, SRP)은 클래스와 모듈은 하나의 책임 또는 기능만을 가지고 있어야 된다</p><p>주의할 점은 단일 책임 원칙이 설명하는 대상에는 클래스와 모듈이라는 두가지 종류가 있다는 점</p><ul><li>모듈을 클래스보다 더 추상적인 개념으로 간주하고 클래스를 일종의 모듈로 간주하는것</li><li>모듈을 좀 더 포괄적인 범위의 대상으로 놓고 여러 클래스가 하나의 모듈을 구성한다고 간주하는 것</li></ul><h3 id="3-1-2-클래스에-단일-책임이-있는지-판단하는-방법"><a href="#3-1-2-클래스에-단일-책임이-있는지-판단하는-방법" class="headerlink" title="3.1.2 클래스에 단일 책임이 있는지 판단하는 방법"></a>3.1.2 클래스에 단일 책임이 있는지 판단하는 방법</h3><p>동일한 클래스라 할지라도 다른 응용 시나리오나 다른 단계의 요구 사항에 따라 클래스의 책임이 달라질 수 있다.<br>요구 사항이 달라지면 해당 클래스의 설계가 단일 책임 원칙을 충족하지 못할 수 있으므로 계속해서 더 작은 클래스로 분활해야 된다</p><p>단일 책임 여부를 결정하기 위해 사용되는 몇 가지 결정 원칙</p><ul><li>클래스에 코드, 함수 또는 속성이 너무 많아 코드의 가독성과 유지보수성에 영향을 미치는 경우 클래스 분활을 고려해야 된다</li><li>클래스가 너무 과하게 다른 클래스에 의존한다면, 높은 응집도와 낮은 결합도의 코드 설계 사상에 부합하지 않으므로 클래스 분활을 고려해야한다</li><li>클래스에 private 메서드가 너무 많다면 이 private 메서드를 새로운 클래스로 분리하고 더 많은 클래스에서 사용할 수 있도록 public 메서드로 설정하여 코드 재사용성을 높혀야 한다</li><li>클래스의 이름을 비즈니스적으로 정확하게 지정하기 어렵거나 manager, context처럼 일반적인 단어가 아니면 클래스 이름을 정의하기 어려운 경우 클래스 책임 정의가 충분히 명확하지 않음을 의미할수 있다</li><li>클래스의 많은 메서드가 여러속성 중 일부에서만 작동하는 경우 이런 속성과 해당 메서드를 분활하는것을 고려할수 있다</li></ul><h2 id="3-2-개방-폐쇄-원칙"><a href="#3-2-개방-폐쇄-원칙" class="headerlink" title="3.2 개방 폐쇄 원칙"></a>3.2 개방 폐쇄 원칙</h2><p>개방 폐쇄 원칙 (open-closed principle, OCP)</p><ul><li>확장할때는 개방</li><li>수정할때는 폐쇄</li></ul><p>개방 폐쇄 원칙은 확장성이 코드 품질의 중요한 척도이기 때문에 가장 유용하다</p><h3 id="3-2-1-확장할-때는-개방-수정할-때는-폐쇄"><a href="#3-2-1-확장할-때는-개방-수정할-때는-폐쇄" class="headerlink" title="3.2.1 확장할 때는 개방, 수정할 때는 폐쇄"></a>3.2.1 확장할 때는 개방, 수정할 때는 폐쇄</h3><p>모듈, 클래스, 함수와 같은 소프트웨어의 단위들은 확장을 위해 개방되어야 하지만 수정을 위해서는 폐쇄되어야 한다.<br>다시 말해 새로운 기능을 추가할때는 기존의 모듈, 클래스, 함수를 수정하지 보다는<br>기존 코드를 기반으로 모듈, 클래스, 함수등을 추가하는 방식으로 코드를 확장해야 한다</p><h3 id="3-2-2-코드를-수정하는-것은-개방-폐쇄-원칙을-위반하는-것일까"><a href="#3-2-2-코드를-수정하는-것은-개방-폐쇄-원칙을-위반하는-것일까" class="headerlink" title="3.2.2 코드를 수정하는 것은 개방 폐쇄 원칙을 위반하는 것일까?"></a>3.2.2 코드를 수정하는 것은 개방 폐쇄 원칙을 위반하는 것일까?</h3><p>클래스에 새 속성과 메서드를 추가하는 것은 수정에 해당하는가 아니면 확장에 해당하는가?</p><p>코드의 수정이 기존에 작성되었던 코드와 단위 테스트를 깨뜨리지 않는 한 이는 개방 폐쇄 원칙을 위반하지 않는다고 판단해도 무방</p><h3 id="3-2-3-확장할-때는-개방-수정할-때는-폐쇄를-달성하는-방법"><a href="#3-2-3-확장할-때는-개방-수정할-때는-폐쇄를-달성하는-방법" class="headerlink" title="3.2.3 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법"></a>3.2.3 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법</h3><p>확장 가능한 코드를 작성하려면 확장, 추상화, 캡슐화에 대해 인식하고 있는 것이 매우 중요하며<br>이는 개발 기술 자체보다 훨씬 더 중요할 수 있다</p><h3 id="3-2-4-프로젝트에-개방-폐쇄-원칙을-유연하게-적용하는-방법"><a href="#3-2-4-프로젝트에-개방-폐쇄-원칙을-유연하게-적용하는-방법" class="headerlink" title="3.2.4 프로젝트에 개방 폐쇄 원칙을 유연하게 적용하는 방법"></a>3.2.4 프로젝트에 개방 폐쇄 원칙을 유연하게 적용하는 방법</h3><p>단기간 내에 진행할 수 있는 확장, 코드 구조 변경에 미치는 영향이 비교적 큰확장,<br>구현 비용이 많이 들지 않는 확장에 대해 확장 포인트를 미리 준비하는것</p><p>코드의 확장성이 더 중요한 시나리오에는 코드의 가독성을 일부 희생할 필요가 있다</p><h2 id="3-3-리스코프-치환-원칙"><a href="#3-3-리스코프-치환-원칙" class="headerlink" title="3.3 리스코프 치환 원칙"></a>3.3 리스코프 치환 원칙</h2><h3 id="3-3-1-리스코프-치환-원칙의-정의"><a href="#3-3-1-리스코프-치환-원칙의-정의" class="headerlink" title="3.3.1 리스코프 치환 원칙의 정의"></a>3.3.1 리스코프 치환 원칙의 정의</h3><p>1986년에 MIT의 바바라 리스코프 교수에 의해 제안된 원칙<br>만약 S가 T의 하위 타입이라면 프로그램을 중단하지 않고 T 타입의 객체를 S 타입의 객체로 대체할 수 있어야 한다</p><h3 id="3-3-2-리스코프-치환-원칙과-다형성의-차이점"><a href="#3-3-2-리스코프-치환-원칙과-다형성의-차이점" class="headerlink" title="3.3.2 리스코프 치환 원칙과 다형성의 차이점"></a>3.3.2 리스코프 치환 원칙과 다형성의 차이점</h3><p>다형성은 코드를 구현하는 방식에 해당하지만, 리스코프 치환 원칙은 상속 관계에서 하위 클래스의 설계 방식을 설명하는 설계 원칙에 해당한다</p><h3 id="3-3-3-리스코프-치환-원칙을-위반하는-안티-패턴"><a href="#3-3-3-리스코프-치환-원칙을-위반하는-안티-패턴" class="headerlink" title="3.3.3 리스코프 치환 원칙을 위반하는 안티 패턴"></a>3.3.3 리스코프 치환 원칙을 위반하는 안티 패턴</h3><p>리스코프 원칙에는 좀더 이해하기 쉬운 설명 방식이 있는데 바로 계약에 따른 설계라는 표현이다</p><ul><li>하위 클래스가 구현하려는 상위 클래스에서 선언한 기능을 위반하는 경우</li><li>하위 클래스가 입력, 출력 및 예외에 대한 상위 클래스의 계약을 위반하는 경우</li><li>하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우</li></ul><h2 id="3-4-인터페이스-분리-원칙"><a href="#3-4-인터페이스-분리-원칙" class="headerlink" title="3.4 인터페이스 분리 원칙"></a>3.4 인터페이스 분리 원칙</h2><p>클라이언트는 필요하지 않은 인터페이스를 사용하도록 강요되어서는 않된다</p><p>인터페이스</p><ul><li>API나 기능의 집합</li><li>단일 API나 기능</li><li>객체지향 프로그래밍에서의 인터페이스</li></ul><h3 id="3-4-1-API나-기능의-집합으로서의-인터페이스"><a href="#3-4-1-API나-기능의-집합으로서의-인터페이스" class="headerlink" title="3.4.1 API나 기능의 집합으로서의 인터페이스"></a>3.4.1 API나 기능의 집합으로서의 인터페이스</h3><p>인터페이스 또는 기능의 일부가 호출자 중 일부에만 사용되거나 전혀 사용되지 않는다면 불필요한 항복을 강요하는 대신<br>인터페이스나 기능에서 해당 부분을 분리하여 해당 호출자에게 별도로 제공해야하며 사용하지 않는 인터페이스나 기능에는 접근하지 못하게 해야 한다</p><h3 id="3-4-2-단일-API나-기능으로서의-인터페이스"><a href="#3-4-2-단일-API나-기능으로서의-인터페이스" class="headerlink" title="3.4.2 단일 API나 기능으로서의 인터페이스"></a>3.4.2 단일 API나 기능으로서의 인터페이스</h3><p>API나 기능은 가능한 단순해야 하며 하나의 기능은 가능한 단순해야 하며 하나의 기능에 여러 다른 기능 논리를 구현하지 않아야 한다</p><p>호출자가 인터페이스의 일부 또는 그 기능의 일부만 사용하는 경우 해당 인터페이스 설계는 단일 책임 원칙을 충족하지 않는다고 말할 수 있다</p><h2 id="3-5-의존-역전-원칙"><a href="#3-5-의존-역전-원칙" class="headerlink" title="3.5 의존 역전 원칙"></a>3.5 의존 역전 원칙</h2><ul><li>의존성 역전이 뜻하는 것은 어떤 대상 사이의 역전인가? 그리고 어떤 의존이 역전되는 것인가? 그리고 여기서 말하는 역전은 무엇을 의미하는가?</li><li>종종 제어 반전과 의존성 주입이라는 두가지 다른 개념을 접할수 있는데 이 개념은 의존 역전과 같은 개념에 속하는가? 만약 그렇지 않다면 그차이는 무엇인가?</li><li>spring 프레임워크의 IoC는 앞에 언급한 세 가지 개념과 어떤 관련이 있는가?<h3 id="3-5-1-제어-반전"><a href="#3-5-1-제어-반전" class="headerlink" title="3.5.1 제어 반전"></a>3.5.1 제어 반전</h3></li></ul><p>실행 흐름은 프레임워크에 의해 제어되고 흐름의 제어는 프로그래머에서 프레임워크로 역전되는것</p><h3 id="3-5-2-의존성-주입"><a href="#3-5-2-의존성-주입" class="headerlink" title="3.5.2 의존성 주입"></a>3.5.2 의존성 주입</h3><p>클래스 내부에 종속되는 클래스의 객체를 생성하는 대신, 외부에서 종속 클래스의 객체를 생성한 후 생성자, 함수의 매개변수 등을 통해 클래스에 주입하는 것을 의미</p><h3 id="3-5-3-의존성-주입-프레임워크"><a href="#3-5-3-의존성-주입-프레임워크" class="headerlink" title="3.5.3 의존성 주입 프레임워크"></a>3.5.3 의존성 주입 프레임워크</h3><p>의존성 주입은 비즈니스 논리에 속하지 않기 때문에 프레임워크에 의해 자동으로 완성되는 코드 형태로 완전히 추상화 될수 있다<br>그리고 이러한 프레임워크를 의존성 주입 프레임워크라고 한다</p><p>spring 프레임워크를 제어 반전 컨테이너라고 부르고 또 어떤사람은 의존성 주입 프레임워크라고 부른다<br>사실 두개의 표현은 모두 틀리지 않으며 단지 제어 반전 컨테이너라는 표현이 더 광범위 하고, 의존성 주입 프레임워크라는 표현이 좀 더 구체적일 뿐이다</p><h3 id="3-5-4-의존-역전-원칙"><a href="#3-5-4-의존-역전-원칙" class="headerlink" title="3.5.4 의존 역전 원칙"></a>3.5.4 의존 역전 원칙</h3><ul><li>상위 모듈은 하위 모듈에 의존하지 않아야 하며, 추상화에 의존해야만 한다</li><li>추상화가 세부 사항에 의존하는 것이 아니라, 세부사항이 추상화에 의존해야 한다</li></ul><h2 id="3-6-KISS-원칙과-YAGNI-원칙"><a href="#3-6-KISS-원칙과-YAGNI-원칙" class="headerlink" title="3.6 KISS 원칙과 YAGNI 원칙"></a>3.6 KISS 원칙과 YAGNI 원칙</h2><ul><li>KISS 원칙에서 단순한이라는 단어가 가지는 의미는 무엇일까?</li><li>어떤 종류의 코드를 단순한 코드라고 할 수 있을까?</li><li>복잡한 코드는 어떤 코드인가?</li><li>간단한 코드를 작성하려면 어떻게 하면 좋을까?</li><li>YAGNI 원칙은 KISS 원칙과 어떤 차이가 있는가?</li></ul><h3 id="3-6-1-KISS-원칙의-정의와-해석"><a href="#3-6-1-KISS-원칙의-정의와-해석" class="headerlink" title="3.6.1 KISS 원칙의 정의와 해석"></a>3.6.1 KISS 원칙의 정의와 해석</h3><p>가능한 단순하게 유지하라 많은 상황에 적용될 수 있는 포괄적인 설계 원칙</p><p>KISS 원칙은 코드를 일고 유지 관리할 수 있도록 해주는 중요한 수단</p><h3 id="3-6-2-적은-줄-수의-코드가-더-간단하지-않다"><a href="#3-6-2-적은-줄-수의-코드가-더-간단하지-않다" class="headerlink" title="3.6.2 적은 줄 수의 코드가 더 간단하지 않다"></a>3.6.2 적은 줄 수의 코드가 더 간단하지 않다</h3><p>코드의 길이가 짧다고 해서 코드가 간단하다고 말할 수 없다</p><h3 id="3-6-3-복잡한-코드가-반드시-KISS-원칙을-위반하는-것은-아니다"><a href="#3-6-3-복잡한-코드가-반드시-KISS-원칙을-위반하는-것은-아니다" class="headerlink" title="3.6.3 복잡한 코드가 반드시 KISS 원칙을 위반하는 것은 아니다"></a>3.6.3 복잡한 코드가 반드시 KISS 원칙을 위반하는 것은 아니다</h3><p>알고리즘 자체의 논리가 복잡하고 구현이 어렵고 가독성이 떨어지는 특성을 가지고 있지만 복잡한 알고리즘을 사용하여 복잡한 문제를 해결하는 것은 KISS 원칙을 위반하는 것이 아니다</p><h3 id="3-6-4-KISS-원칙을-만족하는-코드-작성-방법"><a href="#3-6-4-KISS-원칙을-만족하는-코드-작성-방법" class="headerlink" title="3.6.4 KISS 원칙을 만족하는 코드 작성 방법"></a>3.6.4 KISS 원칙을 만족하는 코드 작성 방법</h3><ul><li>복잡한 정규표현식, 프로그래밍 언어에서 제공하는 지나치게 높은 레벨의 코드 등 지나치게 복잡한 기술을 사용하여 코드를 구현하지 않는다</li><li>바퀴를 다시 발명하는 대신 기존 라이브러리를 사용하는 것을 고려한다</li><li>과도하게 최적화하지 않는다<h3 id="3-6-5-YAGNI-원칙과-KISS-원칙의-차이"><a href="#3-6-5-YAGNI-원칙과-KISS-원칙의-차이" class="headerlink" title="3.6.5 YAGNI 원칙과 KISS 원칙의 차이"></a>3.6.5 YAGNI 원칙과 KISS 원칙의 차이</h3></li></ul><p>YAGNI (You Aren’t Gonna Need It) 원칙은 불필요한 기능을 추가하지 않는 것을 의미하며, 과도하게 설계하지 말라는것</p><p>KISS 원칙은 방법에 관한 것인데 YAGNI 원칙은 금지에 관한 것이다</p><h2 id="3-7-DRY-원칙"><a href="#3-7-DRY-원칙" class="headerlink" title="3.7 DRY 원칙"></a>3.7 DRY 원칙</h2><p>중복 코드를 작성하지 말라는 뜻으로 번역된다</p><h3 id="3-7-1-코드-논리의-중복"><a href="#3-7-1-코드-논리의-중복" class="headerlink" title="3.7.1 코드 논리의 중복"></a>3.7.1 코드 논리의 중복</h3><p>코드의 논리가 중복되지만 의미가 틀리면 중복되는 함수라고 할수 없다</p><h3 id="3-7-2-기능적-의미론적-중복"><a href="#3-7-2-기능적-의미론적-중복" class="headerlink" title="3.7.2 기능적(의미론적) 중복"></a>3.7.2 기능적(의미론적) 중복</h3><p>코드의 논리가 중복되지 않아도 의미적인 중복은 DRY 원칙을 위반하는 것이다</p><h3 id="3-7-3-코드-실행의-중복"><a href="#3-7-3-코드-실행의-중복" class="headerlink" title="3.7.3 코드 실행의 중복"></a>3.7.3 코드 실행의 중복</h3><p>코드 실행의 중복이 되도 DRY 원칙을 위반하는 것이다</p><h3 id="3-7-4-코드-재사용성"><a href="#3-7-4-코드-재사용성" class="headerlink" title="3.7.4 코드 재사용성"></a>3.7.4 코드 재사용성</h3><ul><li>코드의 결합도를 줄인다</li><li>단일 책임 원칙을 충족시켜야 한다</li><li>코드 모듈화는 필수다</li><li>비즈니스 논리와 비즈니스 논리가 아닌 부분을 분리할 필요가 있다</li><li>일반적인 코드는 하위 계층으로 내려보낸다</li><li>상속, 다형성, 추상화, 캡슐화를 활용한다</li><li>애플리케이션 템플릿과 같은 디자인 패턴을 활용하면 코드 재사용성을 향상 시킬수 있다</li></ul><p>3의 법칙(rule of three)은 처음 코드를 작성할 때는 재사용성을 고려하지 않고, 나중에 재사용 시나리로를 만나면 다시 사용할 수 있도록 리팩터링하면 되다</p><h2 id="3-8-LoD"><a href="#3-8-LoD" class="headerlink" title="3.8 LoD"></a>3.8 LoD</h2><p>데메테르의 법칙 (Law of Demeter, LoD)은 높은 응집도와 낮은 결합도를 달성하는 데 도움이 될수 있다</p><h3 id="3-8-1-높은-응집도와-낮은-결합도에-대한-생각"><a href="#3-8-1-높은-응집도와-낮은-결합도에-대한-생각" class="headerlink" title="3.8.1 높은 응집도와 낮은 결합도에 대한 생각"></a>3.8.1 높은 응집도와 낮은 결합도에 대한 생각</h3><p>코드의 가독성과 유지 보수성을 효과적으로 향상시키고 기능 변경으로 인한 코드 변경 범위를 줄일 수 있는 매우 중요한 설계 사상<br>많은 설계 원칙이 코드의 높은 응집도와 낮은 결합도를 달성하는 것을 목표로 하고 있다</p><ul><li>높은 응집도 : 클래스 자체의 설계에 사용된다. 유사한 기능은 동일한 클래스에 배치되어야 하고, 유사하지 않은 기능은 다른 클래스로 분리해야한다</li><li>낮은 결합도 : 클래스 간의 의존성 설계에 사용되는데, 코드에서 클래스 간의 의존성이 단순하고 명확해야 함</li></ul><h3 id="3-8-2-LoD의-정의"><a href="#3-8-2-LoD의-정의" class="headerlink" title="3.8.2 LoD의 정의"></a>3.8.2 LoD의 정의</h3><p>최소 지식의 원칙</p><ul><li>모든 유닛이 자신과 매우 밀접하게 관련된 유닛에 대해서 제한된 지식만 알아야 한다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/118859035">디자인 패턴의 아름다움</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-26-design_patterns_beauty_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Representation Learning (Self-Supervised Learning)</title>
      <link>https://sejoung.github.io/2024/02/2024-02-23-representation_learning_3/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-23-representation_learning_3/</guid>
      <pubDate>Fri, 23 Feb 2024 05:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Representation-Learning-Self-Supervised-Learning&quot;&gt;&lt;a href=&quot;#Representation-Learning-Self-Supervised-Learning&quot; class=&quot;headerlink&quot; tit
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Representation-Learning-Self-Supervised-Learning"><a href="#Representation-Learning-Self-Supervised-Learning" class="headerlink" title="Representation Learning (Self-Supervised Learning)"></a>Representation Learning (Self-Supervised Learning)</h1><ul><li><p>학습 기법의 label에 따른 분류</p><ul><li>딥러닝 모델 학습을 위해서는 많은 레이블이 필요하다.</li><li>하지만, 비싼 레이블링 없이도 모델을 잘 학습시키는 것은 중요하다.</li></ul></li><li><p>Supervised learning의 단점</p><ul><li>“레이블” 데이터가 많아야 함</li><li>학습되지 않은 데이터가 튀어나오면 예측하기 어려움. (transfer가 잘 안됨)</li></ul></li><li><p>Reinforcement learning의 단점</p><ul><li>실패해도 다시 시도하면 되는 게임에선 가능</li><li>현실 세계에서는 실패 자체가 치명적일 수 있어서 적용하기 힘듬</li><li>Policy gradients로 학습하는 과정은 불안정함</li></ul></li><li><p>Self-supervised learning의 필요성</p><ul><li>주변 상황과 조건을 고려해 예측해야 함 (context prediction)</li><li>실패하기 전에 사고가 난다는 것을 예측해야 함</li><li>레이블 없는 많은 데이터를 안정적으로 학습해야함</li><li>모델이 semantics 를 파악하는 데, 굳이 classification 이라는 task를 줄 필요가 없음</li></ul></li></ul><h2 id="Pretext-tasks-기반-self-supervised-learning"><a href="#Pretext-tasks-기반-self-supervised-learning" class="headerlink" title="Pretext tasks 기반 self-supervised learning"></a>Pretext tasks 기반 self-supervised learning</h2><ul><li>Exemplar<ul><li>STL-10 데이터셋 사용</li><li>96x96 이미지 내에서 considerable 한 gradient 영역 근처를 32x32 로 crop</li><li>32x32 seed patch를 기준으로 data augmentation을 적용하여 추가 영상 생성</li><li>Seed image를 data augmentation 하여 이 데이터를 seed image로 prediction하도록 학습.</li><li>surrogate training classes &#x2F; training samples가 많아질 수록 성능이 향상한다</li><li>Surrogate labels 을 data augmentation을 통해 얻어서 네트워크를 학습하면 transfer했을 때 성능이 좋다.</li><li>Discrimina&#x2F;ve 한 features로서 image matching에 적용했을 때 SIFT보다 좋은 descriptors로서의 결과도 낸다. (marginal 하지만)</li><li>ImageNet과 같은 large-scale datasets에는 적용하기 어려움.</li></ul></li><li>Context Prediction<ul><li>Context predicXon 이라는 pretext task를 통해 exemplar의 단점을 해결하려 함.</li><li>3x3 개의 patches를 뜯어서 가운데를 기준으로 1~8 번 할당</li><li>가운데를 기준으로 선택한 patch가 몇 번째 패치인지 예측하도록 모델이 학습됨.</li><li>사람도 다소 예측하기 어려움. 하지만, 이를 machine에게 학습시키면, 이미지 전반의 representation을 배울 수 있다는 게 모티베이션.</li><li>이미지 패치나 위치는 일정하지 않고 약간의 위치 변화를 주어 샘플링 된다.</li><li>그럼에도, context prediction tasks로 pre-training 한 feature extractor를 사용하면 성능이 좋다.</li></ul></li><li>Jigsaw Puzzles<ul><li>직쏘 퍼즐을 풀게하는 pretext task</li><li>앞선 context prediction과 3x3 패치를 추출하지만, 임의의 permutation으로 셔플함.</li><li>하지만, 직쏘 퍼즐은 9!&#x3D;362,880 개(36만개)의 클래스를 배워야해서 이는 어렵다.</li><li>Permutation 수에 따른 결과: permutation의 수가 많아질수록 permutation간의 차이가 클수록(구분하기 쉬워질 수록) transfer 성능이 좋아진다.</li><li>직쏘 퍼즐은 좋은 pretext task이다.</li><li>이와 같은 context-free network (CFN)은 인간이 해내기 어려운 task를 학습함으 로써 더 좋은 deep learning 모델을 학습 하는 데에 성공하였다.</li><li>또한 label없이 학습하는 self-supervised learning task를 정의하여 human annotation의 비용을 줄였다.</li></ul></li><li>Count<ul><li>한 patch에 대한 object의 특징을 가장의 vector로 표현함.</li><li>ex.각 패치안에 코2개,눈4개, 머리 1개 등등..</li><li>각 패치의 특징 벡터의 합을 prediction하는 것은 원래 이미지의 특징 벡터의 합과 같다는 이론에서 intuition을 얻음.</li><li>AlexNet을 사용하여 패치별 특 징벡터를 출력하게 함.</li><li>원본 이미지를 downsampling 했을때 얻는 특징 벡터와,각패치 별로 넣었을때 나오는 특징 벡터의 합이 같도록 학습함</li><li>하지만,같은 이미지로만 학습하면,모든 feature vector를 0으로만 예측하는 trivial solution이 생김</li><li>Counting task는 representation learning 으로 좋은 task이다.</li><li>Feature vector를 잘 학습해서 오른쪽 사진과 같이 retrieval 에서도 효과적으로 embedding space를 만든다.</li><li>Visual primitives의 조합을 잘 만드는 것은 중요하다.</li></ul></li><li>Multi-Task<ul><li>2017년 당시에 주요 쓰였던 self-supervised learning 방법들을 동시에 multi-task learning으로 학습시키는 방법 제안</li><li>하나의 네트워크로, relative patch location (Context prediction) + colorization + exemplar + motion segmentation 의 pretext tasks를 동시에 수행함.</li><li>각 결과를 서로 다른 GPU머신을 학습해서 gradient를 축적한 다음에 한번에 네트워크 업데이트를 한다.</li><li>Self-supv pre-training이 fully-supervised pre-training을 넘을 수 있는 가능성 제시.</li></ul></li><li>Rotation Prediction (RotNet)<ul><li>이미지의 upright 4방향 rotation을 prediction 하는 pretext task</li><li>회전 이미지가 원본에서 몇도 회전했는 지를 예측하게 함.</li></ul></li><li>Rotation Prediction (Decouple-RotNet)<ul><li>Pretext task는 RotNet과 같음.</li><li>Rotation 은 ambiguous 할 수 있지 않나?</li><li>그러면 그 example에 대해서는 학습이 매우 어렵고 무의미함.</li><li>Rotation-agnostic example을 제거하자.</li></ul></li></ul><h2 id="Contrastive-Learning"><a href="#Contrastive-Learning" class="headerlink" title="Contrastive Learning"></a>Contrastive Learning</h2><ul><li>Non-Parametric Instance Discrimination<ul><li>Non-parametric Softmax classifier<ul><li>고정된 w가 아닌 feature vector v로 대체하였다. (instance 특성학습 위해)</li><li>L2 norm을 통해 v를 unit sphere에 고정</li><li>모든 instance가 class에 상관없이 unit sphere에 골고루 퍼져서 분포하도록 학습</li></ul></li><li>Noise-contrastive estimation (NCE)<ul><li>NCE form의 contrative loss 추가.</li></ul></li><li>Proximal regularization<ul><li>각 instance를 개별 클래스로 두고 학습하면 학습이 불안정해서, proximal regularization 추가함.</li></ul></li><li>Weighted k-NN classifier<ul><li>Test time 때 들어오는 sample은 k-NN features를 찾아서 classifying 한다.</li></ul></li><li>결론<ul><li>instance-level discrimination 을 통해 unsupervised feature learning을 하는 것은 피처 학습에 효과적이다.</li><li>이때 non-parametric soamax formulation이 오히려 학습에 도움이 된다.</li><li>Image classification (ImageNet, Places) 결과</li><li>Semi-supervised learning, object detection으로의 일반화</li></ul></li></ul></li><li>MoCo: Momentum Contrast<ul><li>Contrastive learning을 unsupervised representa&#x2F;on learning 에 좀 더 효과적으로 적용시켜 보자.</li><li>Pretext task: Positive &#x2F; negative pairing을 augmentation 을 통해 더 많이 만들기.</li><li>Encoder가 key representation의 consistency를 해쳐서 학습이 불안정해지는 것을 막기위해 momentum contrast 도입.</li><li>결론<ul><li>Self-supervised contrastive learning 으로 model pre-training 하면 성능이 좋다.</li><li>Pretext task로 instance discrimination task 는 다른 task로 바뀔 수 있다. (e.g., masked auto-encoding 등)</li><li>Backbone network도 CNN에서 바뀔 수 있다.</li></ul></li></ul></li><li>SimCLR <ul><li>MoCo와 비슷한 시기에 나온 Contrastive learning 기법.</li><li>성능이 좀 더 향상되었다.</li><li>Simple framework로도 contrastive visual representation learning 의 좋은 결과를 낸다.</li></ul></li><li>MoCo Version 2<ul><li>SimCLR의 design improvements를 MoCo에도 적용하여 성능을 향상시키겠다.</li></ul></li><li>SimCLR Version 2<ul><li>Semi-supervised learning 쪽 알고리즘의 장점까지 도입하여 3단계로 학습해 보자.<ul><li>Unsupervised&#x2F;Self-supervised pretraining : task-agnostic CNN model 학습</li><li>Supervised Fine-tuning : pretraining 이후에 fine-tuning을 한다</li><li>Dis5lla5on using unlabeled data : teacher model에서 얻은 pseudo-label로 student model tuning.</li></ul></li></ul></li><li>MaskFeat<ul><li>모티베이션: Pretext task로 masked input으로 HOG를 prediction해보자.</li><li>결과<ul><li>Masked feature predictio은 visual pre-training task로서 좋은 결과를 준다.</li><li>특히 비디오와 같은 프레임간의 방향성을 가진 task에서 transfer가 잘 된다.</li></ul></li></ul></li><li>BYOL<ul><li>Contrastive learning방법들은 negative를 잘 선택 해야한다.</li><li>결과: batch size나 image augmentaXon에 대해 simclr보다 덜 민감함</li></ul></li><li>Barlow Twins<ul><li>BYOL과 비슷하게 Siamese network 활용</li><li>하지만, 최종 predicthon에서 mini-batch features 의 cross-correlation matrix를 계산하고, diagonal 을 maximize함</li></ul></li><li>DINO: Vision Transformer + SSL<ul><li>DINO:self-distillation with no labels.</li><li>모티베이션:Self-supvViT로 학습한 모델은 이미 object의 segmentation을 어느정도 잡고 있다.</li></ul></li></ul><h2 id="Semi-Supervised-Learning-이란"><a href="#Semi-Supervised-Learning-이란" class="headerlink" title="Semi-Supervised Learning 이란"></a>Semi-Supervised Learning 이란</h2><ul><li><p>준지도학습</p></li><li><p>Label이 일부 샘플에만 주어진것. (Supervised + Unsupervised)</p></li><li><p>Labeling은 비용이 많이 든다.</p></li><li><p>Smoothness:x1,x2의 거리가 가까우면, y1,y2도 가까워야 한다</p></li><li><p>Low-density:decisionboundary가 data의density가 높은 곳을 지나지 않는다. (잘 분리 된다.)</p></li><li><p>Manifold:고차원의 입력이 저 차원에서 특정 manifold를 따라 놓이게 된다.</p></li><li><p>Clustering:데이터가 같은 클러스터에 속하면, 같은 클래스이다. (유사도에 따라 분류된다.)</p></li><li><p>Entropy Minimization</p><ul><li>가정: Decision boundary는 데이터의 밀도가 낮은곳에 형성 될 것이다.</li><li>Prediction을 좀 더 sharp하게 만들어서 entropy를 minimize함.</li><li>pseudo-label사용.(one-hot vector로 argmax하기 때문에)</li></ul></li><li><p>Proxy-Label Methods</p><ul><li>Unlabeled data point에 label을 달아주는기법.</li><li>Labeled data에 벗어나는 샘플은 제대로된 pseudo-label을 주기 어렵다.</li><li>그래도,labeled data에서의 interpolation 효과를 줌</li><li>Pseudo-label의 confidence가높은샘플만을 사용했을 때 성능이 더 높았다는 보고가 있음.</li></ul></li><li><p>Proxy-Label Methods: Label Propagation by Graph</p><ul><li>Graph-based semi-supervised learning의 목표: unlabeled data로 예측 성능을 높이는 게 목표가 아닌, unlabeled data의 label 을 추정하는 그 자체가 목표.</li></ul></li><li><p>Consistency Regularization</p><ul><li>Consistency regularization: unlabeleddata에 small perturbation을 주어도 예측에는 일관성이 있을 것이다.</li><li>즉, unlabeled data에 data augmentation 을 주어 class가 바뀌지 않을 정도의 변화를 주고, 원래 데이터와 같아지도록 unsupervised loss를 준다.</li></ul></li><li><p>Consistency Regularization: Temporal Ensemble</p><ul><li>Temporal Ensemble: 과거의 network evaluation을 ensemble prediction 처럼 합친다. (이유: pi model이 noisy 한 input에 의해 모델도 noisy해진다)</li></ul></li><li><p>Consistency Regularization: Mean Teacher</p><ul><li>Meanteacher: output prediction뿐아니라,model weight에 대해서도 temporal ensembling을 하자.</li></ul></li><li><p>Consistency Regularization: Virtual Adversarial Training</p><ul><li>Virtual Adversarial Training: unlabeled 입력 데이터에 augmentation을 줄때에 fixed augmentation이 아닌 adversarial 한 이미지 변형을 주자</li></ul></li><li><p>Consistency Regularization: UDA</p><ul><li>세가지 dataaugmentation 방식을 통해 unlabeled data를 augment함.<ul><li>AutoAugmentation(이미지분류): rule-basedRL augmentation찾는 기법.</li><li>Backtranslation(텍스트분류): 두개의 기계 번역 모델로 원본 텍스트와 유사한 다양한 텍스트를 augmentation 하여 얻는 기법.</li><li>TD-IDF word replacement(텍스트분류): 설명력이 낮은(TD-IDF 벡터에서 값이 낮은) 단어를 대체하고, 키워드 단어는 보존하는 기법.</li></ul></li></ul></li><li><p>MixMatch</p><ul><li>MixMatch:여러 semi-supervised learning기법을 합쳐높은 성능을 냄</li></ul></li><li><p>ReMixMatch</p><ul><li>ReMixMatch: MixMatch에서 strong augmentation의 장점을 살리기위해 augmentation anchoring 도입</li></ul></li><li><p>FixMatch</p><ul><li>ReMixMatch+UDA</li><li>결론:semi-supervised learning의 a few lines of code변경으로 높은 성능 향상을 달성했다.</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://twitter.com/mldcmu/status/1046869963347283973">Yann Lecun (On True AI) twitter </a></li><li><a href="https://medium.com/syncedreview/yann-lecun-cake-analogy-2-0-a361da560dae">Yann LeCun Cake Analogy 2.0</a></li><li><a href="https://iclr.cc/media/iclr-2021/Slides/3720.pdf"></a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-23-representation_learning_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Representation Learning 2</title>
      <link>https://sejoung.github.io/2024/02/2024-02-22-representation_learning_2/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-22-representation_learning_2/</guid>
      <pubDate>Thu, 22 Feb 2024 06:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Representation-Learning-2&quot;&gt;&lt;a href=&quot;#Representation-Learning-2&quot; class=&quot;headerlink&quot; title=&quot;Representation Learning 2&quot;&gt;&lt;/a&gt;Representat
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Representation-Learning-2"><a href="#Representation-Learning-2" class="headerlink" title="Representation Learning 2"></a>Representation Learning 2</h1><h2 id="place-recognition-NetVLAD"><a href="#place-recognition-NetVLAD" class="headerlink" title="place recognition(NetVLAD)"></a>place recognition(NetVLAD)</h2><ul><li>Vector of Locally Aggregated Descriptors (VLAD)<ul><li>VLAD는 이미지의 특징점을 클러스터링하여 각 클러스터에 대한 특징점의 차이를 계산한 후 이를 이용하여 이미지를 표현하는 방법이다.</li></ul></li><li>NetVLAD<ul><li>VLAD를 딥러닝을 이용하여 학습하는 방법이다.</li><li>weakly supervised ranking loss를 이용하여 학습한다.</li></ul></li></ul><h2 id="Landmark-recognition"><a href="#Landmark-recognition" class="headerlink" title="Landmark recognition"></a>Landmark recognition</h2><ul><li>Deep Local Features (DELF)<ul><li>DELF는 이미지의 특징점을 추출하여 이를 이용하여 이미지를 표현하는 방법이다.</li><li>구글 랜드마크 데이터셋을 이용한다.</li><li>cross-entropy loss를 이용하여 학습한다.</li></ul></li><li>Google Landmark V2<ul><li>20만개의 랜드마크를 포함하고 있다.</li></ul></li></ul><h2 id="Mean-Average-Precision-mAP"><a href="#Mean-Average-Precision-mAP" class="headerlink" title="Mean Average Precision(mAP)"></a>Mean Average Precision(mAP)</h2><ul><li>쿼리에 대한 응답 모움에 대한 평균으로 정확도를 측정하는 방법이다.</li><li>listwise AP Loss <ul><li>50 개의 랭킹을 본다음 맞는것은 앞으로 땡기고 틀린것은 뒤로 밀어서 학습한다.</li></ul></li></ul><h2 id="Image-Clustering"><a href="#Image-Clustering" class="headerlink" title="Image Clustering"></a>Image Clustering</h2><ul><li>이미지들을 군집 시키는 방법</li><li>k-means<ul><li>이미지의 특징점을 이용하여 이미지를 군집화한다.</li></ul></li><li>mahalanobis distance<ul><li>이미지의 특징점을 이용하여 이미지를 군집화한다.</li></ul></li></ul><h2 id="Image-Clustering-Unsupervised-Metric-Learning"><a href="#Image-Clustering-Unsupervised-Metric-Learning" class="headerlink" title="Image Clustering: Unsupervised Metric Learning"></a>Image Clustering: Unsupervised Metric Learning</h2><ul><li>Pra-trained embedding에서 label없는 이미지 collection으로 fine-tuning한다.</li><li>Manifold 간의 hard positives와 hard negatives 를 구해서 contrastive learning을 한다.</li><li>STML (Self-Taught Metric Learning)</li></ul><h2 id="Image-Clustering-t-SNE"><a href="#Image-Clustering-t-SNE" class="headerlink" title="Image Clustering: t-SNE"></a>Image Clustering: t-SNE</h2><ul><li>t-Distributed Stochastic Neighbor Embedding<ul><li>Feature elimination: feature 를 단순히 제거함. 정보 손실이 있음. Feature selection: 통계적 방법을 통해 feature의 중요도에 rank를 매김.<br>정보 손실이 있음. </li><li>데이터셋마다 rank가 달라져야함. Feature extraction: 새로운 features를 추출해냄.</li><li>Linear vs. non-linear</li></ul></li></ul><h2 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h2><ul><li>학습 데이터의 갯수를 늘리기위해 샘플에 각종 변환을 적용하는것.</li><li>Color Transformation<ul><li>Gaussian Blur, Motion Blur, Brightness Jitter, Contrast Jitter, Saturation Jitter, ISO Noise, JPEG Compression 등</li></ul></li><li>Spatial Transformation<ul><li>Filp, Rotation, Crop, Affine 등.</li><li>Detection&#x2F;Segmentation 의 경우 GT도 transform 주의.</li></ul></li><li>Rule-based data augmentation<ul><li>PatchShuffle Regularization<ul><li>Window 내의 픽셀을 섞어서 augmentation 하는 기법.</li></ul></li><li>SamplePairing<ul><li>두 장의 이미지를 pixel-wise로 섞어서 네트워크에 통과시키는 형태의 augmentation</li></ul></li><li>Mixup<ul><li>두 장의 이미지를 섞을 때, linear interpolated 된 위치로 섞는 것.</li></ul></li><li>Mosaic Augmentation (Cropping and Patching)<ul><li>여러장의 이미지를 패치를 떼고 붙여서 N-label classification 문제로 푸는 방식</li></ul></li><li>Multiple Way of Mixing<ul><li>두 장의 이미지를 pixel-wise로 섞어서 네트워크에 통과 시키는 형태의 augmentation</li><li>Pair image를 좀 더 다양하게 mixing하는 8가지 방식을 제안한다.</li></ul></li><li>Manifold Mixup<ul><li>Hidden representation 에서 mixup 하는 것.</li><li>Input mixup에 비해 보다 디시전 바운더리를 더 자연스럽게 만든다.</li></ul></li><li>Random Erasing<ul><li>랜덤으로 지워서 augmentation 하는 방법. (블랙&#x2F;화이트&#x2F;랜덤)</li><li>Random erasing + random cropping 뿐 아니라, image&#x2F;object-aware erasing도 한다.</li><li>Object detection과 person re-identification 에도 적용한다.</li></ul></li><li>Cutout<ul><li>이미지의 일부를 잘라내서 수행하는 방식과 그 분석.</li></ul></li><li>Hide-And-Seek for Weakly-Supervised Localization<ul><li>이미지의 여러부분의 패치를 잘라내어서 augmentation 하는 방법</li></ul></li><li>CutMix<ul><li>Cropping and Patching 과 같이 이미지 여러장을 잘라 붙이는 방식.</li></ul></li><li>AugMix<ul><li>여러 augmentation 을 직렬과 병렬로 연결하여 적용하는 것.</li></ul></li><li>SmoothMix<ul><li>CutMix 처럼 붙일 때 바운더리 근처를 스무딩 하자.</li></ul></li></ul></li><li>GAN 기반의 Data Augmentation<ul><li>Generative Advarsarial Networks (GAN) 을 사 용한 data augmentation 을 수행한다.</li><li>Medical Image Augmentation<ul><li>간의 병변 추측 모델 학습을 위해 GAN으로 데이터를 생성하여 학습. </li><li>평가는 병변의 여부에 대한 classification 으로 함.</li></ul></li><li>SinGAN: Single Image GAN<ul><li>단일 이미지로 unconditional GAN을 학습하는 것.</li><li>Fully-convolutional GANs으로, multi-scale pyramid로 부터 패치 정보들과 이미지 전체 구조를 학습한다.</li><li>Loss: Advarsarial loss + Reconstruction loss</li></ul></li><li>GANGealing: GAN-Supervised alignment<ul><li>GAN으로 생성된 이미지를 supervision으로 주어 dense visual alignment 모델을 학습하기 위한 방식</li><li>별다른 supervision없이 다양한 image data augmentation을 gan을 통해 학습한다.</li></ul></li></ul></li><li>AutoML 기반의 방법<ul><li>Data Augmentation Policy 를 AutoML 을 통해 찾는 방법을 제안한다</li><li>AutoAugment<ul><li>Neural Architecture Search 와 비슷하게 RNN controller 를 통해 Augmentation policy를 뽑고 </li><li>이후 네트워크를 학습시켜서 validation accuracy 를 reward로 Policy gradient를 사용한 강화학습을 한다</li></ul></li><li>Population Based AutoAugment<ul><li>Density matching 기반의 efficient search strategy를 제안한다.</li><li>Bayesian Optimization기법(Tree-structuredParzenEstimator(TPE)) 를 사용하여 Augmentation policy 추출</li></ul></li><li>Fast AutoAugment<ul><li>Differentiable AutoAugment</li><li>미분 불가능한 policy gradients를 미분 가능하게 하면, gradient descent optimization 으로 augmentation policy를 학습할 수 있지 않을까?</li><li>Gradient-based Neural Architecture Search(NAS)의 대표적 방법인 “DARTS: Differentiable Architecture Search (ICLR 2019)”를 따라한다.</li></ul></li><li>RandAugment<ul><li>왜 AutoML 로 augmentation policy 를 찾아야 할까?</li><li>아예 찾지 말고, mini-batch 샘플링 때마다 여러 augmentation 옵션 중 랜덤으로 선택해서 적용해 보자.</li></ul></li><li>UniformAugment<ul><li>두 장의 이미지를 pixel-wise로 섞어서 네트워크에 통과시키는 형태의 augmentation</li><li>엑세스가 되지 않은 논문이다</li></ul></li><li>TrivialAugment<ul><li>Effectiveness와 Efficiency 사이에서 trade-off 를 고려</li><li>아예 parameter-free로 가기 보다는 몇가지 중요한 factor는 서치하자</li></ul></li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/Nanne/pytorch-NetVlad/blob/master/netvlad.py">pytorch-NetVlad</a></li><li><a href="https://arxiv.org/abs/2004.01804">Google Landmarks Dataset v2 – A Large-Scale Benchmark for Instance-Level Recognition and Retrieval</a></li><li><a href="https://towardsdatascience.com/breaking-down-mean-average-precision-map-ae462f623a52">Breaking Down Mean Average Precision (mAP)</a></li><li><a href="https://github.com/naver/deep-image-retrieval">Deep Image Retrieval</a></li><li><a href="https://ratsgo.github.io/machine%20learning/2017/04/19/KC/">K-평균 군집화(K-means Clustering)</a></li><li><a href="https://scikit-learn.org/stable/modules/clustering.html">scikit-learn</a></li><li><a href="https://lvdmaaten.github.io/tsne/">t-SNE</a></li><li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html">sklearn.manifold.TSNE</a></li><li><a href="https://hav4ik.github.io/articles/deep-metric-learning-survey">Deep Metric Learning: a (Long) Survey</a></li><li><a href="https://github.com/zhunzhong07/Random-Erasing">Random Erasing Data Augmentation</a></li><li><a href="https://www.wpeebles.com/gangealing">GANgealing</a></li><li><a href="https://github.com/barisozmen/deepaugment">deepaugment</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-22-representation_learning_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 2 객체지향 프로그래밍 패러다임</title>
      <link>https://sejoung.github.io/2024/02/2024-02-22-design_patterns_beauty_2/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-22-design_patterns_beauty_2/</guid>
      <pubDate>Thu, 22 Feb 2024 03:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-2-객체지향-프로그래밍-패러다임&quot;&gt;&lt;a href=&quot;#CHAPTER-2-객체지향-프로그래밍-패러다임&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 2 객체지향 프로그래밍 패러다임&quot;&gt;&lt;/a&gt;CHAPTER 2 객
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-2-객체지향-프로그래밍-패러다임"><a href="#CHAPTER-2-객체지향-프로그래밍-패러다임" class="headerlink" title="CHAPTER 2 객체지향 프로그래밍 패러다임"></a>CHAPTER 2 객체지향 프로그래밍 패러다임</h1><p>객체지향 프로그래밍은 현 시점에 가장 대중적인 프로그래밍 패턴이다</p><h2 id="2-1-객체지향이란-무엇인가"><a href="#2-1-객체지향이란-무엇인가" class="headerlink" title="2.1 객체지향이란 무엇인가?"></a>2.1 객체지향이란 무엇인가?</h2><h3 id="2-1-1-객체지향-프로그래밍과-객체지향-프로그래밍-언어"><a href="#2-1-1-객체지향-프로그래밍과-객체지향-프로그래밍-언어" class="headerlink" title="2.1.1 객체지향 프로그래밍과 객체지향 프로그래밍 언어"></a>2.1.1 객체지향 프로그래밍과 객체지향 프로그래밍 언어</h3><p>객체지향 프로그래밍이란?</p><ul><li>프로그래밍 패러다임 또는 프로그래밍 스타일을 의미한다</li><li>코드를 구성하는 기본 단위로 클래스 와 객체를 사용한다</li><li>코드 설계 와 구현의 초석으로 캡슐화,추상화,상속,다형성을 사용한다</li></ul><h3 id="2-1-2-엄격하게-정의되지-않은-객체지향-프로그래밍-언어"><a href="#2-1-2-엄격하게-정의되지-않은-객체지향-프로그래밍-언어" class="headerlink" title="2.1.2 엄격하게 정의되지 않은 객체지향 프로그래밍 언어"></a>2.1.2 엄격하게 정의되지 않은 객체지향 프로그래밍 언어</h3><p>프로그래밍 언어가 클래스 또는 객체의 문법적 개념을 지원하고 이를 코드 구성의 기본 단위로 사용하는 한 단순히 객체지향 언어로 간주될 수 있다고 생각한다</p><h3 id="2-1-3-객체지향-분석과-객체지향-설계"><a href="#2-1-3-객체지향-분석과-객체지향-설계" class="headerlink" title="2.1.3 객체지향 분석과 객체지향 설계"></a>2.1.3 객체지향 분석과 객체지향 설계</h3><p>분석과 설계 앞에 객체지향이라는 단어가 붙는 이유는 객체나 클래스에 대한 요구 사항을 분석하고 설계하기 때문이다</p><h2 id="2-2-캡슐화-추상화-상속-다형성이-등장한-이유"><a href="#2-2-캡슐화-추상화-상속-다형성이-등장한-이유" class="headerlink" title="2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유"></a>2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유</h2><h3 id="2-2-1-캡슐화"><a href="#2-2-1-캡슐화" class="headerlink" title="2.2.1 캡슐화"></a>2.2.1 캡슐화</h3><p>정보 은닉 또는 데이터 액세스 보호라고도 하는데 접근 가능한 인터페이스를 제한하여 클래스가 제공하는 메서드를 통해서만 내부 정보나 데이터에 대한 외부 접근을 허가 하는것을 뜻한다</p><h3 id="2-2-2-추상화"><a href="#2-2-2-추상화" class="headerlink" title="2.2.2 추상화"></a>2.2.2 추상화</h3><p>매서드 내부 구현을 숨기는 것을 의미한다. 클래스를 사용할 때 기능의 구현 방식에 대해 고민하지 않고 메서드가 제공하는 기능에만 집중할수 있다</p><p>추상화는 특이성이 그리 높지 않으며 이로 인해 객체지향 프로그래밍의 특성으로 간주 되지 않는 경우가 있다</p><h3 id="2-2-3-상속"><a href="#2-2-3-상속" class="headerlink" title="2.2.3 상속"></a>2.2.3 상속</h3><p>상속은 고양이는 포유류의 일종이다 처럼 클래스 사이의 is-a 관계를 나타내는데 사용된다</p><p>단점</p><ul><li>상속계층 구조가 너무 깊고 복잡하면 코드의 가독성과 유지 관리 성이 떨어진다</li><li>특정 클래스의 기능을 이해하기 위해서는 해당 클래스 코드만 보는게 아니라 상위 클래스도 봐야 된다</li><li>상위 클래스의 코드 수정이 하위 클래스에 직접적인 영향을 미친다</li></ul><h3 id="2-2-4-다형성"><a href="#2-2-4-다형성" class="headerlink" title="2.2.4 다형성"></a>2.2.4 다형성</h3><p>하위 클래스를 상위 클래스 대신 사용하고 하위 클래스의 메서드를 호출할 수 있는 특성을 의미한다</p><p>다형성을 충족시키기 위한 문법</p><ul><li>상위 클래스 객체가 하위 클래스 객체를 참조 할수 있어야 된다</li><li>상속을 지원해야 한다</li><li>상위 클래스의 메서드를 재정의하는 하위 클래스를 지원해야 된다</li></ul><p>다형성 특성을 구현을 위해 인터페이스 문법을 사용하거나 덕타이필 문법을 사용하는 두가지 구현 방법이 일반적이다</p><h2 id="2-3-객체지향-분석-객체지향-설계-객체지향-프로그래밍을-수행하는-방법"><a href="#2-3-객체지향-분석-객체지향-설계-객체지향-프로그래밍을-수행하는-방법" class="headerlink" title="2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법"></a>2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법</h2><h3 id="2-3-3-객체지향-설계-방법"><a href="#2-3-3-객체지향-설계-방법" class="headerlink" title="2.3.3 객체지향 설계 방법"></a>2.3.3 객체지향 설계 방법</h3><ul><li>책임과 기능을 나누고 어떤 클래스가 있는지 확인한다</li><li>클래스를 정의하고 클래스의 속성과 메서드를 정의한다</li><li>클래스 간의 상호 작용을 정의한다</li><li>클래스를 연결하고 실행 엔트리 포인트를 제공한다<h2 id="2-4-객체지향-프로그래밍-절차적-프로그래밍-함수형-프로그래밍의-차이"><a href="#2-4-객체지향-프로그래밍-절차적-프로그래밍-함수형-프로그래밍의-차이" class="headerlink" title="2.4 객체지향 프로그래밍, 절차적 프로그래밍, 함수형 프로그래밍의 차이"></a>2.4 객체지향 프로그래밍, 절차적 프로그래밍, 함수형 프로그래밍의 차이</h2><h3 id="2-4-1-절차적-프로그래밍"><a href="#2-4-1-절차적-프로그래밍" class="headerlink" title="2.4.1 절차적 프로그래밍"></a>2.4.1 절차적 프로그래밍</h3>절차적 프로그래밍은 프로그래밍 패러다임이기도하다 코드를 구성하기 위한 기본 단위로 메서드, 기능, 연산 처럼 절차가 필요 하며 멤버 변수,<br>속성과 같은 데이터가 메서드와 분리되어 있는 것이 특징이다</li></ul><h3 id="2-4-2-객체지향-프로그래밍과-절차적-프로그래밍의-비교"><a href="#2-4-2-객체지향-프로그래밍과-절차적-프로그래밍의-비교" class="headerlink" title="2.4.2 객체지향 프로그래밍과 절차적 프로그래밍의 비교"></a>2.4.2 객체지향 프로그래밍과 절차적 프로그래밍의 비교</h3><ul><li>객체지향 프로그래밍은 대규모의 복잡한 프로그램 개발에 더 적합하다</li><li>객체지향 프로그래밍 스타일은 코드는 재사용, 확장, 유지 관리가 쉽다</li><li>객체지향 프로그래밍 언어는 더 사용자 친화적이고 고급 언어이며 지능적이다</li></ul><h3 id="2-4-3-함수형-프로그래밍"><a href="#2-4-3-함수형-프로그래밍" class="headerlink" title="2.4.3 함수형 프로그래밍"></a>2.4.3 함수형 프로그래밍</h3><p>함수형 프로그래밍의 함수는 프로그래밍 언어에서 말하는 함수가 아니라 수학의 함수 또는 표현식을 말한다</p><p>스테이트리스 함수(stateless function)라는 점에서 절차적 프로그래밍과 다르다</p><ul><li>Stream 클래스</li><li>람다 표현식</li><li>함수형 인터페이스</li></ul><h3 id="2-4-4-객체지향-프로그래밍과-함수형-프로그래밍의-비교"><a href="#2-4-4-객체지향-프로그래밍과-함수형-프로그래밍의-비교" class="headerlink" title="2.4.4 객체지향 프로그래밍과 함수형 프로그래밍의 비교"></a>2.4.4 객체지향 프로그래밍과 함수형 프로그래밍의 비교</h3><p>객체 지향 프로그래밍의 프로그래밍 단위는 클래스 또는 객체<br>절차적 프로그래밍의 프로그래밍 단위는 함수<br>함수형 프로그래밍의 프로그래밍 단위는 스테이트리스 함수</p><h2 id="2-5-객체지향-프로그래밍처럼-보이지만-실제로는-절차적-프로그래밍"><a href="#2-5-객체지향-프로그래밍처럼-보이지만-실제로는-절차적-프로그래밍" class="headerlink" title="2.5 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍"></a>2.5 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍</h2><h3 id="2-5-1-getter-setter-메서드-남용"><a href="#2-5-1-getter-setter-메서드-남용" class="headerlink" title="2.5.1 getter, setter 메서드 남용"></a>2.5.1 getter, setter 메서드 남용</h3><p>캡슐화 위배</p><h3 id="2-5-2-전역-변수와-전역-메서드의-남용"><a href="#2-5-2-전역-변수와-전역-메서드의-남용" class="headerlink" title="2.5.2 전역 변수와 전역 메서드의 남용"></a>2.5.2 전역 변수와 전역 메서드의 남용</h3><h3 id="2-5-3-데이터와-메서드-분리로-클래스-정의하기"><a href="#2-5-3-데이터와-메서드-분리로-클래스-정의하기" class="headerlink" title="2.5.3 데이터와 메서드 분리로 클래스 정의하기"></a>2.5.3 데이터와 메서드 분리로 클래스 정의하기</h3><h2 id="2-6-빈약한-도메인-모델에-기반한-전통적인-개발-방식은-OOP를-위반하는가"><a href="#2-6-빈약한-도메인-모델에-기반한-전통적인-개발-방식은-OOP를-위반하는가" class="headerlink" title="2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?"></a>2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?</h2><h3 id="2-6-1-빈약한-도메인-모델에-기반한-전통적인-개발-방식"><a href="#2-6-1-빈약한-도메인-모델에-기반한-전통적인-개발-방식" class="headerlink" title="2.6.1 빈약한 도메인 모델에 기반한 전통적인 개발 방식"></a>2.6.1 빈약한 도메인 모델에 기반한 전통적인 개발 방식</h3><p>빈약한 도메인 모델</p><ul><li>데이터만 포함하고 비지니스 논리는 포함하지 않은 모델<h3 id="2-6-2-풍성한-도메인-모델에-기반한-DDD-개발-방식"><a href="#2-6-2-풍성한-도메인-모델에-기반한-DDD-개발-방식" class="headerlink" title="2.6.2 풍성한 도메인 모델에 기반한 DDD 개발 방식"></a>2.6.2 풍성한 도메인 모델에 기반한 DDD 개발 방식</h3>풍성한 도메인 모델</li><li>비지니스 논리와 데이터를 포함한 모델<h3 id="2-6-3-두-가지-개발-방식의-비교"><a href="#2-6-3-두-가지-개발-방식의-비교" class="headerlink" title="2.6.3 두 가지 개발 방식의 비교"></a>2.6.3 두 가지 개발 방식의 비교</h3></li><li>빈약한 도메인 모델<ul><li>기본 개발 방식에 의해 구현된 코드를 잘 이해하고 있어야 된다</li></ul></li><li>풍성한 도메인 모델</li></ul><p>Service Layer 책임</p><ul><li>저장소 계층과의 통신을 담당</li><li>여러 도메인 모델의 비즈니스 논리를 결합</li><li>타 시스템과의 상호작용 담당</li></ul><h3 id="2-6-4-빈약한-도메인-모델에-기반한-전통적인-개발-방식이-널리-사용되는-이유"><a href="#2-6-4-빈약한-도메인-모델에-기반한-전통적인-개발-방식이-널리-사용되는-이유" class="headerlink" title="2.6.4 빈약한 도메인 모델에 기반한 전통적인 개발 방식이 널리 사용되는 이유"></a>2.6.4 빈약한 도메인 모델에 기반한 전통적인 개발 방식이 널리 사용되는 이유</h3><ul><li>대부분 시나리로가 비교적 단순하고 복잡하지 않은 경우가 많다</li><li>풍성한 도메인 모델은 설계가 더 어렵다</li><li>사고방식의 전환은 어렵고 그만한 대가가 필요하다</li></ul><h2 id="2-7-추상-클래스와-인터페이스"><a href="#2-7-추상-클래스와-인터페이스" class="headerlink" title="2.7 추상 클래스와 인터페이스"></a>2.7 추상 클래스와 인터페이스</h2><h3 id="2-7-1-추상-클래스와-인터페이스의-정의와-차이점"><a href="#2-7-1-추상-클래스와-인터페이스의-정의와-차이점" class="headerlink" title="2.7.1 추상 클래스와 인터페이스의 정의와 차이점"></a>2.7.1 추상 클래스와 인터페이스의 정의와 차이점</h3><ul><li>추상 클래스<ul><li>인스턴스화할 수 없으며 상속만 가능하다</li><li>추상 클래스는 속성과 메서드를 포함할 수 있다</li><li>하위 클래스는 추상 클래스를 상속할 때 추상 클래스의 모든 추상 메서드를 실제로 구현해야 된다</li></ul></li><li>인터페이스<ul><li>속성을 포함할수 없다</li><li>메서드 선언만 가능하다</li><li>인터페이스를 구현할때는 선언된 모든 메서드를 구현해야 한다<h3 id="2-7-2-추상-클래스와-인터페이스의-의미"><a href="#2-7-2-추상-클래스와-인터페이스의-의미" class="headerlink" title="2.7.2 추상 클래스와 인터페이스의 의미"></a>2.7.2 추상 클래스와 인터페이스의 의미</h3>추상 클래스</li></ul></li><li>코드 재사용에 초점을 맞춤</li></ul><p>인터페이스</p><ul><li>디커플링에 초점</li></ul><h2 id="2-8-인터페이스-기반-프로그래밍-모든-클래스에-대해-인터페이스를-정의해야-할까"><a href="#2-8-인터페이스-기반-프로그래밍-모든-클래스에-대해-인터페이스를-정의해야-할까" class="headerlink" title="2.8 인터페이스 기반 프로그래밍: 모든 클래스에 대해 인터페이스를 정의해야 할까?"></a>2.8 인터페이스 기반 프로그래밍: 모든 클래스에 대해 인터페이스를 정의해야 할까?</h2><h3 id="2-8-1-인터페이스를-이해하는-다양한-방법"><a href="#2-8-1-인터페이스를-이해하는-다양한-방법" class="headerlink" title="2.8.1 인터페이스를 이해하는 다양한 방법"></a>2.8.1 인터페이스를 이해하는 다양한 방법</h3><p>인터페이스는 프로토콜 또는 규약의 집합으로 사용자에게 제공되는 기능 목록이다</p><h3 id="2-8-2-설계-철학을-실제로-적용해보자"><a href="#2-8-2-설계-철학을-실제로-적용해보자" class="headerlink" title="2.8.2 설계 철학을 실제로 적용해보자"></a>2.8.2 설계 철학을 실제로 적용해보자</h3><h3 id="2-8-3-인터페이스의-남용을-방지하려면-어떻게-해야-할까"><a href="#2-8-3-인터페이스의-남용을-방지하려면-어떻게-해야-할까" class="headerlink" title="2.8.3 인터페이스의 남용을 방지하려면 어떻게 해야 할까?"></a>2.8.3 인터페이스의 남용을 방지하려면 어떻게 해야 할까?</h3><p>시나리오에서 특정 기능에 대한 구현 방법이 하나 뿐이고 이후에도 다른 구현 방법으로 대체할 일이 없다면 인터페이스를 정의할 필요가 없다</p><h2 id="2-9-상속보다-합성"><a href="#2-9-상속보다-합성" class="headerlink" title="2.9 상속보다 합성"></a>2.9 상속보다 합성</h2><h3 id="2-9-2-합성이-상속에-비해-나은-장점"><a href="#2-9-2-합성이-상속에-비해-나은-장점" class="headerlink" title="2.9.2 합성이 상속에 비해 나은 장점"></a>2.9.2 합성이 상속에 비해 나은 장점</h3><p>합성, 인터페이스, 위임을 통해 상속문제를 해결할수 있다</p><h3 id="2-9-3-합성을-사용할지-상속을-사용할지-결정하기"><a href="#2-9-3-합성을-사용할지-상속을-사용할지-결정하기" class="headerlink" title="2.9.3 합성을 사용할지 상속을 사용할지 결정하기"></a>2.9.3 합성을 사용할지 상속을 사용할지 결정하기</h3><p>클래스 간의 상속 구조가 안정적이어서 쉽게 변경되지 않고 상속 단계가 2단계 이하로 비교적 얕아 상속관계가 복잡하지 않다면 상속을 사용할수도 있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/118859035">디자인 패턴의 아름다움</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-22-design_patterns_beauty_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Representation Learning 1</title>
      <link>https://sejoung.github.io/2024/02/2024-02-21-representation_learning_1/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-21-representation_learning_1/</guid>
      <pubDate>Wed, 21 Feb 2024 05:36:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Representation-Learning-1&quot;&gt;&lt;a href=&quot;#Representation-Learning-1&quot; class=&quot;headerlink&quot; title=&quot;Representation Learning 1&quot;&gt;&lt;/a&gt;Representat
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Representation-Learning-1"><a href="#Representation-Learning-1" class="headerlink" title="Representation Learning 1"></a>Representation Learning 1</h1><h2 id="Metric-Learning"><a href="#Metric-Learning" class="headerlink" title="Metric Learning"></a>Metric Learning</h2><p>메트릭이란 거리를 측정하는 함수를 말한다. 메트릭 러닝은 데이터의 표현을 학습하는 것이다.<br>이는 데이터의 표현을 학습하여 거리를 측정하는 함수를 학습하는 것이다. </p><p>유사도(Similarity)-거리(Distance)의 관계를 학습하는 것이다.</p><ul><li>Information retrieval - 정보 검색</li><li>Face identification&#x2F;verification - 얼굴 인식&#x2F;검증</li><li>Person re-identification - 개인 사찰 이슈</li><li>Visual object tracking - 객체 추적</li><li>Local patch matching for stereo imaging - 스테레오 이미징을 위한 로컬 패치 매칭</li><li>Visual representation learning</li></ul><p>시뮬러리티(Similarity)는 두 데이터가 얼마나 비슷한지를 나타내는 척도이다.</p><h3 id="Classical-Metric-Learning"><a href="#Classical-Metric-Learning" class="headerlink" title="Classical Metric Learning"></a>Classical Metric Learning</h3><ul><li>Mahalanobis Distance - 마할라노비스 거리<ul><li>M 을 데이터로 부터 학습한다.</li><li>A first approach to distance metric learning</li><li>Large Margin Nearest Neighbor (LMNN)</li></ul></li></ul><h3 id="Deep-Metric-Learning"><a href="#Deep-Metric-Learning" class="headerlink" title="Deep Metric Learning"></a>Deep Metric Learning</h3><ul><li>Deep Neural Networks 를 사용한다.</li><li>siamese networks<ul><li>siamese architecture</li><li>contrastive loss(클래스가 같은 것은 가깝게, 다른것은 멀게)</li><li>Euclidean distance - 유클리디안 거리</li><li>Triplet Networks<ul><li>anchor에 positive, negative를 모두 넣는다</li><li>positive는 가깝게, negative는 멀게</li><li>weight sharing</li></ul></li></ul></li></ul><h3 id="Sample-Selection"><a href="#Sample-Selection" class="headerlink" title="Sample Selection"></a>Sample Selection</h3><p>모든 데이터를 다 볼수 없으니, 샘플을 선택해야 한다.</p><p>너무 쉬운 샘플은 학습에 도움이 되지 않는다.<br>너무 어려운 샘플은 stable 하지 않다.</p><ul><li>uniform sampling</li><li>distance weighted margin base loss<ul><li>DWS(distance weighted sampling)</li><li>Margin-based loss</li></ul></li></ul><h3 id="Quadruplet-Networks"><a href="#Quadruplet-Networks" class="headerlink" title="Quadruplet Networks"></a>Quadruplet Networks</h3><ul><li>Triplet Networks 의 문제점<ul><li>관계가 충분하지 않다</li></ul></li><li>Quadruplet rank loss<ul><li>2개의 트러플 랭크를 이용한다</li></ul></li></ul><h3 id="Neighbor-Search"><a href="#Neighbor-Search" class="headerlink" title="Neighbor Search"></a>Neighbor Search</h3><ul><li>lable transfer</li><li>kNN</li><li>Image Retrieval<ul><li>most straightforward way  - 가장 직관적인 방법</li><li>working even for unseen classes - 본적 없는 클래스에도 작동한다</li></ul></li><li>Face Verification</li><li>Person Re-identification<ul><li>중국에서 많이 연구중 - 중국의 사찰 이슈 때문에… 윤리적….이슈…</li></ul></li><li>Online Visual Object Tracking<ul><li>실시간으로 오브젝트를 추적하는 것</li><li>candidate box를 만들고, 그중에서 가장 가까운 것을 찾는다</li></ul></li><li>Unsupervised Representation Learning</li></ul><h3 id="face-recognition"><a href="#face-recognition" class="headerlink" title="face recognition"></a>face recognition</h3><p><a href="https://github.com/davidsandberg/facenet">facenet</a></p><ul><li>beyond binary supervision</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/davidsandberg/facenet">facenet</a></li><li><a href="http://ai.stanford.edu/~jkrause/cars/car_dataset.html">cars196</a></li><li><a href="https://paperswithcode.com/dataset/cub-200-2011">CUB-200</a></li><li><a href="https://cvgl.stanford.edu/projects/lifted_struct/">Deep Metric Learning via Lifted Structured Feature Embedding</a></li><li><a href="https://mmlab.ie.cuhk.edu.hk/projects/DeepFashion/InShopRetrieval.html">DeepFashion: In-shop Clothes Retrieval</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-21-representation_learning_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 개요</title>
      <link>https://sejoung.github.io/2024/02/2024-02-21-design_patterns_beauty_1/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-21-design_patterns_beauty_1/</guid>
      <pubDate>Wed, 21 Feb 2024 01:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-1-개요&quot;&gt;&lt;a href=&quot;#CHAPTER-1-개요&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 1 개요&quot;&gt;&lt;/a&gt;CHAPTER 1 개요&lt;/h1&gt;&lt;h2 id=&quot;1-1-코드-설계를-배우는-이유&quot;&gt;&lt;a hre
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-1-개요"><a href="#CHAPTER-1-개요" class="headerlink" title="CHAPTER 1 개요"></a>CHAPTER 1 개요</h1><h2 id="1-1-코드-설계를-배우는-이유"><a href="#1-1-코드-설계를-배우는-이유" class="headerlink" title="1.1 코드 설계를 배우는 이유"></a>1.1 코드 설계를 배우는 이유</h2><p>코드 설계에 대한 지식은 확장성과 가독성이 높아 유지 보수가 용이한 고품질 코드를 작성할때 필요하다</p><h3 id="1-1-1-고품질의-코드-작성"><a href="#1-1-1-고품질의-코드-작성" class="headerlink" title="1.1.1 고품질의 코드 작성"></a>1.1.1 고품질의 코드 작성</h3><p>속도와 확장성을 맹목적으로 추구하는 현재의 개발 환경에서 안타깝게도 대다수의 소프트웨어 엔지니어는<br>고품질의 코드를 작성하는 방법에 대한 생각할 시간이 많지 않은것도 사실이다</p><p>높은 품질의 코드를 작성할 수 있도록 스킬을 향상하려면 어떻게 해야 될까?<br>먼저 코드 설계에 대한 이론적인 지식을 갖춰야 한다</p><h3 id="1-1-2-복잡한-코드-개발-다루기"><a href="#1-1-2-복잡한-코드-개발-다루기" class="headerlink" title="1.1.2 복잡한 코드 개발 다루기"></a>1.1.2 복잡한 코드 개발 다루기</h3><p>소프트웨어 개발의 복잡성을 다루는 방법</p><ul><li>계층화와 하위 모듈화 방법은 무엇인가?</li><li>클래스를 어떻게 나누는 것이 좋은가?</li><li>각 클래스에는 어떤 속성과 메서드가 있는가?</li><li>클래스 간의 상호작용을 설계하는 방법은 무엇인가?</li><li>상속이나 연관을 사용하는 것이 옳은가?</li><li>인터페이스나 추상 클래스를 사용하는 것이 옳은가?</li><li>결합도가 높은 코드와 낮는 코드는 무엇인가?</li><li>디커플링(decoupling)을 달성하는 방법은 무엇인가?</li><li>싱글턴 패턴이나 정적 메서드를 사용하는 것이 옳은가?</li><li>객체를 생성할 때 팩터리 패턴을 사용하는 것이 옳은가?</li><li>가독성을 유지하면서 확장성을 향상하기 위해 디자인 패턴을 도입하는 방법은 무엇인가?</li></ul><h3 id="1-1-3-프로그래머의-기본-능력"><a href="#1-1-3-프로그래머의-기본-능력" class="headerlink" title="1.1.3 프로그래머의 기본 능력"></a>1.1.3 프로그래머의 기본 능력</h3><p>기술의 넓이와 깊이를 모두 가지고 있어야 된다</p><p>소스코드를 읽으면서 종종 그것이 어떤 의미인지 이해 못하는 경우가 있다 이것의 원인은<br>코드를 완벽히 이해하기 위한 기본적인 지식이 부족하기 때문이다</p><h3 id="1-1-4-경력-개발에-필요한-기술"><a href="#1-1-4-경력-개발에-필요한-기술" class="headerlink" title="1.1.4 경력 개발에 필요한 기술"></a>1.1.4 경력 개발에 필요한 기술</h3><p>프레임워크를 잘쓰고 아키텍처에 대해 이야기하면서도 정작 코드가 나쁘면 결코 좋은 소프트웨어 엔지니어가 될수 없다</p><p>고품질 코드가 무엇인지, 고품질의 코드를 어떻게 작성해야 하는지 모른다면 어떻게 다른사람을 이끌고 설득할 수 있겠는가?</p><h2 id="1-2-코드-품질-평가-방법"><a href="#1-2-코드-품질-평가-방법" class="headerlink" title="1.2 코드 품질 평가 방법"></a>1.2 코드 품질 평가 방법</h2><p>코드 품질에 대한 설명 방법</p><ul><li>유연성 flexibility</li><li>확장성 extensibility</li><li>유지보수성 maintainability</li><li>가독성 readability</li><li>이해 용이성 understandability</li><li>가변성 changeability</li><li>재사용성 reusability</li><li>테스트 용이성 testability</li><li>모듈성 modularity</li><li>높은 응집도 와 낮은 결합도 high cohesion and low coupling</li><li>높은 효율성 high efficiency</li><li>고성능 high performance</li><li>보안성 security</li><li>호환성 compatibility</li><li>사용성 usability</li><li>깨끗함 clean</li><li>명확성 clarity</li><li>간결성 simplicity</li><li>직접성 straightforward</li><li>더 작은 코드가 더 많은 것을 담는다 less code does more</li><li>문서화가 잘 된 well-documented</li><li>계층화가 잘 이루어진 well-layered</li><li>정확성 correctness, bug free</li><li>강건성 robustness</li><li>신뢰성 reliability</li><li>확장성 scalability</li><li>안정성 stability</li><li>우아함 elegant</li></ul><p>서로 다른 평가 관점들은 완전히 독립적이지 않으며 일부는 포괄 관계, 중첩 관계이거나 서로 영향을 미칠 수 있다</p><h3 id="1-2-1-유지-보수성"><a href="#1-2-1-유지-보수성" class="headerlink" title="1.2.1 유지 보수성"></a>1.2.1 유지 보수성</h3><p>기존의 코드 설계를 손상시키거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태를 말한다</p><h3 id="1-2-2-가독성"><a href="#1-2-2-가독성" class="headerlink" title="1.2.2 가독성"></a>1.2.2 가독성</h3><p>컴퓨터가 이해할 수 있는 코드는 바보라도 작성할 수 있다 - 마틴파울러</p><p>any fool can write code that a computer can understand. Good programmers write code that humans can understand. - Martin Fowler</p><p>코드를 읽는 시간이 코드를 작성하는 시간보다 훨씬 많다</p><h3 id="1-2-3-확장성"><a href="#1-2-3-확장성" class="headerlink" title="1.2.3 확장성"></a>1.2.3 확장성</h3><p>기존 코드를 약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것을 말한다</p><h3 id="1-2-4-유연성"><a href="#1-2-4-유연성" class="headerlink" title="1.2.4 유연성"></a>1.2.4 유연성</h3><p>유연하다는 것은 추상적인 평가 기준이며 어떤 것이 유연한 것인지 한 마디로 정의하는 것은 쉽지 않다</p><h3 id="1-2-5-간결성"><a href="#1-2-5-간결성" class="headerlink" title="1.2.5 간결성"></a>1.2.5 간결성</h3><p>keep it simple, stupid - KISS</p><h3 id="1-2-6-재사용성"><a href="#1-2-6-재사용성" class="headerlink" title="1.2.6 재사용성"></a>1.2.6 재사용성</h3><p>객체 지향을 도입할 때 상속과 다형성의 목적 중 하나가 코드의 재사용성을 향상시키는 것이라고 언급 </p><p>D.R.Y. - Don’t Repeat Yourself</p><h3 id="1-2-7-테스트-용이성"><a href="#1-2-7-테스트-용이성" class="headerlink" title="1.2.7 테스트 용이성"></a>1.2.7 테스트 용이성</h3><p>코드 테스트 용이성 수준이 코드 품질 수준 측면을 정확하게 반영할 수 있다</p><h2 id="1-3-고품질-코드를-작성하는-방법"><a href="#1-3-고품질-코드를-작성하는-방법" class="headerlink" title="1.3 고품질 코드를 작성하는 방법"></a>1.3 고품질 코드를 작성하는 방법</h2><h3 id="1-3-1-객체지향"><a href="#1-3-1-객체지향" class="headerlink" title="1.3.1 객체지향"></a>1.3.1 객체지향</h3><p>프로그래밍 패더다임을 주도하는 세 가지 스타일이 있는데, 바로 절차적 프로그래밍, 함수형 프로그래밍, 객체지향 프로그래밍 이다</p><ul><li>객체지향의 네 가지 주요 특성 : 캡슐화, 상속, 다형성, 추상화</li><li>객체지향 프로그래밍과 절차적 프로그래밍의 차이점과 연계</li><li>객체지향 분석, 객체지향 설계, 객체지향 프로그래밍</li><li>인터페이스와 추상 클래스의 차이점과 각각의 응용 시나리오</li><li>구현이 아닌 인터페이스를 기반으로 한 설계 사상</li><li>절차적인 빈약한 도메인 모델과 객체지향적인 풍부한 도메인 모델</li></ul><h3 id="1-3-2-설계-원칙"><a href="#1-3-2-설계-원칙" class="headerlink" title="1.3.2 설계 원칙"></a>1.3.2 설계 원칙</h3><p>코드에서 배운 몇 가지 교훈</p><ul><li>단일 책임 원칙</li><li>개방 폐쇄 원칙</li><li>리스코프 치환 원칙</li><li>인터페이스 분리 원칙</li><li>의존 역전 원칙</li><li>KISS 원칙 keep it simple, stupid</li><li>YAGNI 원칙 you aren’t gonna need it</li><li>DRY 원칙 don’t repeat yourself</li><li>LoD 원칙 law of demeter</li></ul><h3 id="1-3-3-디자인-패턴"><a href="#1-3-3-디자인-패턴" class="headerlink" title="1.3.3 디자인 패턴"></a>1.3.3 디자인 패턴</h3><h3 id="1-3-4-코딩-규칙"><a href="#1-3-4-코딩-규칙" class="headerlink" title="1.3.4 코딩 규칙"></a>1.3.4 코딩 규칙</h3><p>주로 코드 가독성 문제를 해결한다</p><h3 id="1-3-5-리팩터링-기법"><a href="#1-3-5-리팩터링-기법" class="headerlink" title="1.3.5 리팩터링 기법"></a>1.3.5 리팩터링 기법</h3><ul><li>리팩터링 목적, 대상, 시기, 방법</li><li>리팩터링에 오류가 없는지 확인하기 위한 기술적 수단</li><li>두 가지 다른 규모의 리팩터링</li></ul><h2 id="1-4-과도한-설계를-피하는-방법"><a href="#1-4-과도한-설계를-피하는-방법" class="headerlink" title="1.4 과도한 설계를 피하는 방법"></a>1.4 과도한 설계를 피하는 방법</h2><h3 id="1-4-1-코드-설계의-원래-의도는-코드-품질을-향상시키는-것이다"><a href="#1-4-1-코드-설계의-원래-의도는-코드-품질을-향상시키는-것이다" class="headerlink" title="1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다"></a>1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다</h3><p>설계를 위한 설계가 되면 안된다</p><h3 id="1-4-2-코드-설계의-원칙은-앞에-문제가-있고-뒤에-방안이-있다는-것이다"><a href="#1-4-2-코드-설계의-원칙은-앞에-문제가-있고-뒤에-방안이-있다는-것이다" class="headerlink" title="1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다"></a>1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다</h3><p>페인 포인트(pain point)를 찾고 해결책을 찾는 것</p><h3 id="1-4-3-코드-설계의-응용-시나리오는-복잡한-코드에-적용되어야-한다"><a href="#1-4-3-코드-설계의-응용-시나리오는-복잡한-코드에-적용되어야-한다" class="headerlink" title="1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다"></a>1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다</h3><p>디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰코드 조작을 작은 클래스로 분활하여 코드가<br>높은 응집도와 낮은 결합도의 특성을 충족하도록 하는것</p><h3 id="1-4-4-지속적인-리팩터링은-과도한-설계를-효과적으로-방지할-수-있다"><a href="#1-4-4-지속적인-리팩터링은-과도한-설계를-효과적으로-방지할-수-있다" class="headerlink" title="1.4.4 지속적인 리팩터링은 과도한 설계를 효과적으로 방지할 수 있다"></a>1.4.4 지속적인 리팩터링은 과도한 설계를 효과적으로 방지할 수 있다</h3><p>잘못된 요구사항 예측으로 인한 과도한 설계를 피하기 위해 지속적인 리팩터링 개발 방법을 권장한다</p><h3 id="1-4-5-특정-시나리오-외의-코드-설계에-대해-이야기하지-않는다"><a href="#1-4-5-특정-시나리오-외의-코드-설계에-대해-이야기하지-않는다" class="headerlink" title="1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다"></a>1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다</h3><p>코드 설계는 매우 주간적이다. 코드 설계는 예술이라고 해도 과언이 아니다 따라서 코드 설계의 품질을 판단하기 매우 어렵다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/118859035">디자인 패턴의 아름다움</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-21-design_patterns_beauty_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 18 반응형 아키텍처와 어니언 아키텍처</title>
      <link>https://sejoung.github.io/2024/02/2024-02-20-Grokking_Simplicity_18/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-20-Grokking_Simplicity_18/</guid>
      <pubDate>Tue, 20 Feb 2024 01:04:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-18-반응형-아키텍처와-어니언-아키텍처&quot;&gt;&lt;a href=&quot;#CHAPTER-18-반응형-아키텍처와-어니언-아키텍처&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 18 반응형 아키텍처와 어니언 아키텍처&quot;&gt;&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-18-반응형-아키텍처와-어니언-아키텍처"><a href="#CHAPTER-18-반응형-아키텍처와-어니언-아키텍처" class="headerlink" title="CHAPTER 18 반응형 아키텍처와 어니언 아키텍처"></a>CHAPTER 18 반응형 아키텍처와 어니언 아키텍처</h1><p>반응형 아키텍처(reactive architecture)는 순차적인 액션을 표현하는 방식을 뒤집습니다<br>어니언 아키텍처(onion architecture)는 함수형 프로그래밍으로 현실 세계를 다루기 위한 고수준의 개념입니다</p><h2 id="두-아키텍처-패턴은-독립적입니다"><a href="#두-아키텍처-패턴은-독립적입니다" class="headerlink" title="두 아키텍처 패턴은 독립적입니다"></a>두 아키텍처 패턴은 독립적입니다</h2><ul><li>반응형 아키텍처<ul><li>코드에 나타난 순차적 액션의 순서를 뒤집는다</li><li>효과(effect)와 원인(cause)을 분리한다</li></ul></li><li>어니언 아키텍처<ul><li>웹 서비스나 온도 조절 장치 같은 현실 세계와 상호작용하기 위한 서비스 구조를 만든다</li></ul></li></ul><h2 id="반응형-아키텍처는-무엇인가요"><a href="#반응형-아키텍처는-무엇인가요" class="headerlink" title="반응형 아키텍처는 무엇인가요?"></a>반응형 아키텍처는 무엇인가요?</h2><ul><li>애플리케이션을 구조화하는 방법</li><li>이벤트에 대한 반응으로 일어날 일을 지정하는 것</li><li>웹 서비스와 UI에 잘 어울린다</li></ul><h2 id="반응형-아키텍처의-절충점"><a href="#반응형-아키텍처의-절충점" class="headerlink" title="반응형 아키텍처의 절충점"></a>반응형 아키텍처의 절충점</h2><ul><li>원인과 효과가 결합한 것을 분리한다</li><li>여러 단계를 파이프라인으로 처리한다</li><li>타임라인이 유연해진다</li><li>결합의 분리는 원인과 효과의 중심을 관리합니다</li></ul><h2 id="어니언-아키텍처는-무엇인가요"><a href="#어니언-아키텍처는-무엇인가요" class="headerlink" title="어니언 아키텍처는 무엇인가요?"></a>어니언 아키텍처는 무엇인가요?</h2><ul><li><p>인터랙션 계층</p><ul><li>바깥세상에 영향을 주거나 받는 액션</li></ul></li><li><p>도메인 계층</p><ul><li>비즈니스 규칙을 정의하는 계산</li></ul></li><li><p>언어 계층</p><ul><li>언어 유틸리티와 라이브러리</li></ul></li><li><p>현실 세계와 상호작용은 인터렉션 계층에서 해야 한다</p></li><li><p>계층에서 호출하는 방향은 중심 방향입니다</p></li><li><p>계층은 외부에 어떤 계층이 있는지 모른다</p></li></ul><h2 id="도메인-규칙은-도메인-용어를-사용합니다"><a href="#도메인-규칙은-도메인-용어를-사용합니다" class="headerlink" title="도메인 규칙은 도메인 용어를 사용합니다"></a>도메인 규칙은 도메인 용어를 사용합니다</h2><ul><li>프로그램의 핵심 로직을 도메인 규칙(domain rule) 또는 비즈니스 규칙(business rule)이라고 합니다<h2 id="가독성을-따져-봐야-합니다"><a href="#가독성을-따져-봐야-합니다" class="headerlink" title="가독성을 따져 봐야 합니다"></a>가독성을 따져 봐야 합니다</h2></li><li>특정 패러다임의 장점이 항상 좋은 것이 아니라는 것을 알았습니다</li><li>가독성을 결정하는 요소<ul><li>사용하는 언어</li><li>레거시 코드와 코드 스타일</li><li>사용하는 라이브러리</li><li>개발자들의 습관</li></ul></li><li>코드의 가독성<ul><li>일반적으로 함수형 코드는 읽기 좋습니다</li></ul></li><li>개발 속도</li><li>시스템 성능</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-20-Grokking_Simplicity_18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Deep Learning-2</title>
      <link>https://sejoung.github.io/2024/02/2024-02-19-deep_learning_2/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-19-deep_learning_2/</guid>
      <pubDate>Mon, 19 Feb 2024 02:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Deep-Learning-2&quot;&gt;&lt;a href=&quot;#Deep-Learning-2&quot; class=&quot;headerlink&quot; title=&quot;Deep Learning 2&quot;&gt;&lt;/a&gt;Deep Learning 2&lt;/h1&gt;&lt;h2 id=&quot;Beyond-ResNet
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Deep-Learning-2"><a href="#Deep-Learning-2" class="headerlink" title="Deep Learning 2"></a>Deep Learning 2</h1><h2 id="Beyond-ResNet"><a href="#Beyond-ResNet" class="headerlink" title="Beyond ResNet"></a>Beyond ResNet</h2><h3 id="DenseNet-Add-Dense-Connection"><a href="#DenseNet-Add-Dense-Connection" class="headerlink" title="DenseNet : Add Dense Connection"></a>DenseNet : Add Dense Connection</h3><ul><li>ResNet의 단점을 보완하기 위해 제안된 방법</li><li>ResNet은 입력과 출력을 더하는 방식으로 연결을 만들었지만, DenseNet은 입력과 출력을 Concatenation하는 방식으로 연결을 만듬</li></ul><h3 id="SENet-Squeeze-and-Excitation-module"><a href="#SENet-Squeeze-and-Excitation-module" class="headerlink" title="SENet : Squeeze and Excitation module"></a>SENet : Squeeze and Excitation module</h3><ul><li>각 채널의 중요도를 학습하여 채널의 중요도에 따라 가중치를 부여하는 방법</li></ul><h3 id="EfficientNet-Network-Depth-Network-Width-Input-Resolution-search"><a href="#EfficientNet-Network-Depth-Network-Width-Input-Resolution-search" class="headerlink" title="EfficientNet : Network Depth, Network Width, Input Resolution search."></a>EfficientNet : Network Depth, Network Width, Input Resolution search.</h3><ul><li>baseline에 스케일업을 한다</li><li>compound scaling을 통해 네트워크의 깊이, 너비, 입력 해상도를 조정하여 성능을 높임</li></ul><h2 id="Efficient-CNN"><a href="#Efficient-CNN" class="headerlink" title="Efficient CNN"></a>Efficient CNN</h2><ul><li>smail model을 만들어서 성능을 높이는 방법</li><li>best cnn 은 가장 정확한 cnn이 아니다</li><li>mobile net<ul><li>depthwise separable convolution</li></ul></li><li>shuffle net<ul><li>group convolution</li><li>channel shuffle</li></ul></li></ul><h2 id="Vision-Transformer"><a href="#Vision-Transformer" class="headerlink" title="Vision Transformer"></a>Vision Transformer</h2><ul><li>Attention을 이용하여 CNN을 대체하는 방법</li><li>soft-and-hard attention<ul><li>soft attention : 0~1을 이용하여 weighted sum</li><li>hard attention : 0~1을 이용하여 하나의 feature를 선택</li></ul></li><li>self-attention<ul><li>key, query, value를 이용하여 attention을 계산</li></ul></li><li>multi-head attention<ul><li>여러개의 attention을 이용하여 attention을 계산</li></ul></li><li>cross-attention<ul><li>다른 feature map을 이용하여 attention을 계산</li></ul></li><li>stand-alone self attention<ul><li>지역적인 정보를 이용하여 attention을 계산</li></ul></li></ul><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><ul><li>encoder-decoder 구조</li><li>self-attention을 이용하여 input을 처리</li><li>positional encoding을 이용하여 input의 위치 정보를 추가</li></ul><h2 id="Vision-Transformer-ViT"><a href="#Vision-Transformer-ViT" class="headerlink" title="Vision Transformer(ViT)"></a>Vision Transformer(ViT)</h2><ul><li>image를 patch로 나누어서 input으로 사용</li><li>masked self-attention을 이용하여 input을 처리</li><li>base model</li><li>large model</li><li>huge model</li></ul><h2 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin Transformer"></a>Swin Transformer</h2><ul><li>shift window를 이용하여 input을 처리</li><li>local attention을 이용하여 input을 처리</li><li>W-MSA<ul><li>window based multi-head self-attention(local attention)</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://arxiv.org/pdf/1409.0473.pdf">NEURAL MACHINE TRANSLATION BY JOINTLY LEARNING TO ALIGN AND TRANSLATE</a></li><li><a href="https://arxiv.org/pdf/1502.03044.pdf">Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</a></li><li><a href="https://www.youtube.com/watch?v=mMa2PmYJlCo">Visual Guide to Transformer Neural Networks - (Episode 2) Multi-Head &amp; Self-Attention</a></li><li><a href="https://arxiv.org/pdf/1906.05909.pdf">Stand-Alone Self-Attention in Vision Models</a></li><li><a href="https://towardsdatascience.com/master-positional-encoding-part-i-63c05d90a0c3">Master Positional Encoding: Part I</a></li><li><a href="https://arxiv.org/pdf/2010.11929.pdf">AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-19-deep_learning_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AnimateDiff: Stable Diffusion for Animation Generation with ComfyUI</title>
      <link>https://sejoung.github.io/2024/02/2024-02-19-comfyui_animatediff/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-19-comfyui_animatediff/</guid>
      <pubDate>Mon, 19 Feb 2024 01:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;AnimateDiff-Stable-Diffusion-for-Animation-Generation-with-ComfyUI&quot;&gt;&lt;a href=&quot;#AnimateDiff-Stable-Diffusion-for-Animation-Generation-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="AnimateDiff-Stable-Diffusion-for-Animation-Generation-with-ComfyUI"><a href="#AnimateDiff-Stable-Diffusion-for-Animation-Generation-with-ComfyUI" class="headerlink" title="AnimateDiff: Stable Diffusion for Animation Generation with ComfyUI"></a>AnimateDiff: Stable Diffusion for Animation Generation with ComfyUI</h1><p>지금 까지 comfyui에 AnimateDiff를 사용하여 애니메이션을 생성하는 플러그인은 2개 정도 인데<br><a href="https://github.com/Kosinkadink/ComfyUI-AnimateDiff-Evolved">Kosinkadink&#x2F;ComfyUI-AnimateDiff-Evolved</a> 플러그인은<br>img2img를 사용하여 애니메이션을 생성하지 못한다 그래서 <a href="https://github.com/ArtVentureX/comfyui-animatediff">ArtVentureX&#x2F;comfyui-animatediff</a> 플러그인을 사용하여 애니메이션을 생성하였다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>먼저 comfyui 플러그인을 설치한다. 설치 방법은 comfyui manager를 설치하면 쉽게 다운로드 할수 있다 </p><p>수동 설치를 원한다면 comfyui에 <code>custom_nodes</code> 폴더에 직접 다운로드 하면 된다</p><p>설치가 완료 되면 필수 모델을 다운로드 해야 된다 custom_nodes 폴더에 <code>comfyui-animatediff/models/</code> 폴더에 다운로드 하면 된다.</p><p><a href="https://huggingface.co/guoyww/animatediff">guoyww&#x2F;animatediff</a></p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p><a href="https://github.com/ArtVentureX/comfyui-animatediff/blob/main/README.md">comfyui-animatediff README</a> 파일에 잘 나와있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/ArtVentureX/comfyui-animatediff">ArtVentureX&#x2F;comfyui-animatediff</a></li><li><a href="https://github.com/Kosinkadink/ComfyUI-AnimateDiff-Evolved">Kosinkadink&#x2F;ComfyUI-AnimateDiff-Evolved</a></li><li><a href="https://huggingface.co/guoyww/animatediff">guoyww&#x2F;animatediff</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-19-comfyui_animatediff/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 17 타임라인 조율하기</title>
      <link>https://sejoung.github.io/2024/02/2024-02-19-Grokking_Simplicity_17/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-19-Grokking_Simplicity_17/</guid>
      <pubDate>Mon, 19 Feb 2024 00:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-17-타임라인-조율하기&quot;&gt;&lt;a href=&quot;#CHAPTER-17-타임라인-조율하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 17 타임라인 조율하기&quot;&gt;&lt;/a&gt;CHAPTER 17 타임라인 조율하기&lt;/h1&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-17-타임라인-조율하기"><a href="#CHAPTER-17-타임라인-조율하기" class="headerlink" title="CHAPTER 17 타임라인 조율하기"></a>CHAPTER 17 타임라인 조율하기</h1><h2 id="타임라인을-나누기-위한-동시성-기본형"><a href="#타임라인을-나누기-위한-동시성-기본형" class="headerlink" title="타임라인을 나누기 위한 동시성 기본형"></a>타임라인을 나누기 위한 동시성 기본형</h2><p>경쟁조건(race condition)은 어떤 동작이 먼저 끝나는 타임라인에 의존할 때 발생합니다</p><h2 id="코드에-Cut-적용하기"><a href="#코드에-Cut-적용하기" class="headerlink" title="코드에 Cut() 적용하기"></a>코드에 Cut() 적용하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cut</span>(<span class="params">num, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num_finished = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    num_finished += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num_finished === num)</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="title class_">Cut</span>(<span class="number">3</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3 timelines are finished&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="title function_">done</span>();</span><br><span class="line"><span class="title function_">done</span>();</span><br><span class="line"><span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calc_cart_total</span>(<span class="params">cart, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="title class_">Cut</span>(<span class="number">2</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(total);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">cost_ajax</span>(cart, <span class="keyword">function</span>(<span class="params">cost</span>) &#123;</span><br><span class="line">    total += cost;</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">shipping_ajax</span>(cart, <span class="keyword">function</span>(<span class="params">shipping</span>) &#123;</span><br><span class="line">    total += shipping;</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="딱-한-번만-호출하는-기본형"><a href="#딱-한-번만-호출하는-기본형" class="headerlink" title="딱 한 번만 호출하는 기본형"></a>딱 한 번만 호출하는 기본형</h2><p>최초 한 번만 효과가 발생하는 액션을 멱등원(idempotent)이라고 합니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendAddToCartText</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="title function_">sendTextAjax</span>(number, <span class="string">&quot;Thanks for adding something to your cart. Reply if you have any questions!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JustOnce</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> alreadyCalled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(alreadyCalled) <span class="keyword">return</span>;</span><br><span class="line">    alreadyCalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">action</span>(a, b, c);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendAddToCartTextOnce = <span class="title class_">JustOnce</span>(sendAddToCartText);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sendAddToCartTextOnce</span>(<span class="string">&quot;555-555-5555-55&quot;</span>);</span><br><span class="line"><span class="title function_">sendAddToCartTextOnce</span>(<span class="string">&quot;555-555-5555-55&quot;</span>);</span><br><span class="line"><span class="title function_">sendAddToCartTextOnce</span>(<span class="string">&quot;555-555-5555-55&quot;</span>);</span><br><span class="line"><span class="title function_">sendAddToCartTextOnce</span>(<span class="string">&quot;555-555-5555-55&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="요약-타임라인-사용하기"><a href="#요약-타임라인-사용하기" class="headerlink" title="요약: 타임라인 사용하기"></a>요약: 타임라인 사용하기</h2><ul><li>타임라인 수를 줄입니다</li><li>타임라인 길이를 줄입니다</li><li>공유 자원을 업앱니다</li><li>동시성 기본형으로 자원을 공유한다</li><li>동시성 기본형으로 조율한다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-19-Grokking_Simplicity_17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 16 타임라인 사이에 자원 공유하기</title>
      <link>https://sejoung.github.io/2024/02/2024-02-16-Grokking_Simplicity_16/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-16-Grokking_Simplicity_16/</guid>
      <pubDate>Fri, 16 Feb 2024 01:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-16-타임라인-사이에-자원-공유하기&quot;&gt;&lt;a href=&quot;#CHAPTER-16-타임라인-사이에-자원-공유하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 16 타임라인 사이에 자원 공유하기&quot;&gt;&lt;/a&gt;CHAPT
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-16-타임라인-사이에-자원-공유하기"><a href="#CHAPTER-16-타임라인-사이에-자원-공유하기" class="headerlink" title="CHAPTER 16 타임라인 사이에 자원 공유하기"></a>CHAPTER 16 타임라인 사이에 자원 공유하기</h1><h2 id="좋은-타임라인의-원칙"><a href="#좋은-타임라인의-원칙" class="headerlink" title="좋은 타임라인의 원칙"></a>좋은 타임라인의 원칙</h2><ul><li>타임라인은 적을수록 이해하기 쉽다</li><li>타임라인은 짧을수록 이해하기 쉽다</li><li>공유하는 자원이 적을수록 이해하기 쉽다</li><li>자원을 공유한다면 서로 조율해야 한다</li><li>시간을 일급으로 다룬다</li></ul><h2 id="자바스크립트에서-큐-만들기"><a href="#자바스크립트에서-큐-만들기" class="headerlink" title="자바스크립트에서 큐 만들기"></a>자바스크립트에서 큐 만들기</h2><ul><li>큐는 자료 구조지만 타임라인 조율에 사용한다면 동시성 기본형(concurrency primitive)이 라고 부른다<ul><li>동시성 기본형은 자원을 안전하게 공유할 수 있는 재사용 가능한 코드</li></ul></li><li>핸들러에서 처리할것과 큐에서 처리할 작업 나누기</li></ul><h2 id="큐를-건너뛰도록-만들기"><a href="#큐를-건너뛰도록-만들기" class="headerlink" title="큐를 건너뛰도록 만들기"></a>큐를 건너뛰도록 만들기</h2><ul><li>최대 저장 갯수를 1개로 만들어서 최종 작업만 저장 되도록 만든다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-16-Grokking_Simplicity_16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Deep Learning-1</title>
      <link>https://sejoung.github.io/2024/02/2024-02-15-deep_learning_1/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-15-deep_learning_1/</guid>
      <pubDate>Thu, 15 Feb 2024 02:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Deep-Learning-1&quot;&gt;&lt;a href=&quot;#Deep-Learning-1&quot; class=&quot;headerlink&quot; title=&quot;Deep Learning 1&quot;&gt;&lt;/a&gt;Deep Learning 1&lt;/h1&gt;&lt;h2 id=&quot;Perceptron-ML
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Deep-Learning-1"><a href="#Deep-Learning-1" class="headerlink" title="Deep Learning 1"></a>Deep Learning 1</h1><h2 id="Perceptron-MLP"><a href="#Perceptron-MLP" class="headerlink" title="Perceptron, MLP"></a>Perceptron, MLP</h2><ul><li><p>인공신경망의 기초 단위</p></li><li><p>activation function을 통해 입력값을 출력값으로 변환</p><ul><li>binary threshold function</li><li>sigmoid function</li><li>rectified linear unit (ReLU)</li></ul></li><li><p>loss 값을 최소화하는 방향으로 가중치를 조정(학습)</p><ul><li>경사하강법(Gradient Descent)<ul><li>로스를 가중치로 미분하면 0이 되는 지점을 찾아야 하는데, 이때 미분값이 0이 되는 지점을 찾는 것이 어려움. 이를 해결하기 위해 경사하강법을 사용함</li></ul></li><li>역전파(Backpropagation)</li></ul></li><li><p>momentum</p><ul><li>경사하강법의 단점을 보완하기 위해 사용</li><li>로컬 미니멈에 빠지는 것을 방지하기 위해 관성을 사용</li><li>관성을 사용하면 로컬 미니멈에 빠지지 않고 전역 미니멈으로 수렴할 수 있음</li></ul></li></ul><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><ul><li>Convolutional Neural Network</li><li>이미지 인식에 주로 사용</li></ul><h2 id="Overfitting-Network-Initialization"><a href="#Overfitting-Network-Initialization" class="headerlink" title="Overfitting, Network Initialization"></a>Overfitting, Network Initialization</h2><ul><li>Overfitting<ul><li>학습 데이터에만 잘 맞는 모델을 만드는 것</li><li>학습 데이터에만 잘 맞는 모델은 실제 데이터에 대해 잘 맞지 않을 수 있음</li><li>해결 방법<ul><li>early stopping <ul><li>training loss와 validation loss를 비교하여 validation loss가 증가하기 시작하면 학습을 중단</li></ul></li><li>드롭아웃(Dropout)</li></ul></li></ul></li><li>Network Weight Initialization<ul><li>가중치 초기화</li><li>가중치 초기화를 잘못하면 학습이 잘 되지 않을 수 있음</li><li>Xavier initialization</li><li>He initialization</li></ul></li><li>Learning Rate<ul><li>학습률</li><li>학습률을 잘못 설정하면 학습이 잘 되지 않을 수 있음</li><li>학습률을 잘 설정하면 학습이 빠르게 되고, 학습률을 잘못 설정하면 학습이 느리게 되거나 학습이 잘 되지 않을 수 있음</li></ul></li></ul><h2 id="AlexNet-LeNet-VGG"><a href="#AlexNet-LeNet-VGG" class="headerlink" title="AlexNet, LeNet, VGG"></a>AlexNet, LeNet, VGG</h2><p>AlexNet -&gt; ZFNet -&gt; VGGNet  -&gt; GoogLeNet -&gt; ResNet -&gt; DenseNet -&gt; SENet</p><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><ul><li>1998년에 발표된 최초의 CNN</li><li>Conv -&gt; polling -&gt; Conv -&gt; polling -&gt; FC -&gt; FC</li></ul><h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><ul><li>하드웨어에 옵티마이저 잘되어 있다</li></ul><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><ul><li>ReLu activation</li><li>Batch Normalization<ul><li>Optimization Landscape를 좋게 만들어 줌</li></ul></li><li>skip connection<ul><li>gradient vanishing 문제를 해결하기 위해 사용</li><li>입력값을 출력값에 더해주는 방법</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/ashutosh1919/explainable-cnn">Explainable CNNs</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-15-deep_learning_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 15 타임라인 격리하기</title>
      <link>https://sejoung.github.io/2024/02/2024-02-15-Grokking_Simplicity_15/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-15-Grokking_Simplicity_15/</guid>
      <pubDate>Thu, 15 Feb 2024 00:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-15-타임라인-격리하기&quot;&gt;&lt;a href=&quot;#CHAPTER-15-타임라인-격리하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 15 타임라인 격리하기&quot;&gt;&lt;/a&gt;CHAPTER 15 타임라인 격리하기&lt;/h1&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-15-타임라인-격리하기"><a href="#CHAPTER-15-타임라인-격리하기" class="headerlink" title="CHAPTER 15 타임라인 격리하기"></a>CHAPTER 15 타임라인 격리하기</h1><h2 id="타임라인-다이어그램은-시간에-따라-어떤-일이-일어나는지-보여줍니다"><a href="#타임라인-다이어그램은-시간에-따라-어떤-일이-일어나는지-보여줍니다" class="headerlink" title="타임라인 다이어그램은 시간에 따라 어떤 일이 일어나는지 보여줍니다"></a>타임라인 다이어그램은 시간에 따라 어떤 일이 일어나는지 보여줍니다</h2><h2 id="두-가지-타임라인-다이어그램-기본-규칙"><a href="#두-가지-타임라인-다이어그램-기본-규칙" class="headerlink" title="두 가지 타임라인 다이어그램 기본 규칙"></a>두 가지 타임라인 다이어그램 기본 규칙</h2><ul><li>두 액션이 순서대로 나타나면 같은 타임라인에 넣는다</li><li>두 액션이 동시에 실행되거나 순서를 예상할 수 없다면 분리된 타임라인에 넣는다<ul><li>액션은 순서대로 실행되거나 동시에 실행된다</li><li>순서대로 실행되는 액션은 같은 타임라인에서 하나가 끝나면 다른 하나가 실행된다</li><li>동시에 실행되는 액션은 여러 타임라인에 나란히 실행된다</li></ul></li></ul><h2 id="자세히-보면-놓칠-수-있는-액션-순서에-관한-두-가지-사실"><a href="#자세히-보면-놓칠-수-있는-액션-순서에-관한-두-가지-사실" class="headerlink" title="자세히 보면 놓칠 수 있는 액션 순서에 관한 두 가지 사실"></a>자세히 보면 놓칠 수 있는 액션 순서에 관한 두 가지 사실</h2><ul><li>++와 +&#x3D;는 사실 세 단계다<ul><li>이 연산자에는 세 단계로 연산을 한다는 사실이 숨어 있다</li></ul></li><li>인자는 함수를 부르기 전에 실행한다<ul><li>함수에 인자를 실행하면 인자는 함수에 전달되기 전에 실행된다</li></ul></li></ul><h2 id="서로-다른-언어-서로-다른-스레드-모델"><a href="#서로-다른-언어-서로-다른-스레드-모델" class="headerlink" title="서로 다른 언어, 서로 다른 스레드 모델"></a>서로 다른 언어, 서로 다른 스레드 모델</h2><ul><li>단일 스레드, 동기<ul><li>PHP 는 기본적으로 멀티스레드를 사용할 수 없습니다</li></ul></li><li>단일 스레드, 비동기<ul><li>자바스크립트</li></ul></li><li>멀티스레드<ul><li>자바, 루비, c, c#, 파이썬</li></ul></li><li>메시지 패싱(messaging passing) 프로세스<ul><li>엘릭서, 얼랭</li></ul></li></ul><h2 id="타임라인-다이어그램으로-순서대로-실행되는-코드에도-두-가지-종류가-있다는-것을-알-수-있습니다"><a href="#타임라인-다이어그램으로-순서대로-실행되는-코드에도-두-가지-종류가-있다는-것을-알-수-있습니다" class="headerlink" title="타임라인 다이어그램으로 순서대로 실행되는 코드에도 두 가지 종류가 있다는 것을 알 수 있습니다"></a>타임라인 다이어그램으로 순서대로 실행되는 코드에도 두 가지 종류가 있다는 것을 알 수 있습니다</h2><ul><li>순서가 섞일 수 있는 코드</li><li>순서가 섞이지 않는 코드</li></ul><h2 id="타임라인-다이어그램으로-동시에-실행되는-코드는-순서를-예측할-수-없다는-것을-알-수-있습니다"><a href="#타임라인-다이어그램으로-동시에-실행되는-코드는-순서를-예측할-수-없다는-것을-알-수-있습니다" class="headerlink" title="타임라인 다이어그램으로 동시에 실행되는 코드는 순서를 예측할 수 없다는 것을 알 수 있습니다"></a>타임라인 다이어그램으로 동시에 실행되는 코드는 순서를 예측할 수 없다는 것을 알 수 있습니다</h2><ul><li>여러 개의 타임라인은 시간에 따라 다양한 방식으로 실행 될 수 있다</li><li>타임라인이 실행 가능한 방법을 가능한 순서(possible order)라고 한다</li><li>타임라인이 하나면 실행 가능한 순서는 하나다<h2 id="좋은-타임라인의-원칙"><a href="#좋은-타임라인의-원칙" class="headerlink" title="좋은 타임라인의 원칙"></a>좋은 타임라인의 원칙</h2></li><li>타임라인은 적을수록 이해하기 쉽다</li><li>타임라인은 짧을수록 이해하기 쉽다</li><li>공유하는 자원이 적을수록 이해하기 쉽다</li><li>자원을 공유한다면 서로 조율해야 한다</li><li>시간을 일급으로 다룬다</li></ul><h2 id="자바스크립트의-비동기-큐"><a href="#자바스크립트의-비동기-큐" class="headerlink" title="자바스크립트의 비동기 큐"></a>자바스크립트의 비동기 큐</h2><ul><li>자바 스크립트는 작업 큐(job queue)라고 하는 큐를 가지고 있다</li><li>이벤트 루프에 의해 처리된다</li></ul><h3 id="작업이란-무엇인가"><a href="#작업이란-무엇인가" class="headerlink" title="작업이란 무엇인가?"></a>작업이란 무엇인가?</h3><ul><li>작업 큐에 있는 작업은 이벤트 데이터와 이벤트를 처리할 콜백으로 구성되어 있다</li><li>이벤트 루프는 이벤트 데이터를 인자로 콜백을 부른다</li><li>콜백은 이벤트 루프가 실행할 함수</li><li>이벤트 루프는 단순히 첫번째 인자에 이벤트 데이터를 넣어 콜백함수를 수행한다</li></ul><h3 id="작업은-큐에-어떻게-들어가나요"><a href="#작업은-큐에-어떻게-들어가나요" class="headerlink" title="작업은 큐에 어떻게 들어가나요?"></a>작업은 큐에 어떻게 들어가나요?</h3><ul><li>이벤트가 발행하면 큐에 작업이 추가된다</li><li>이벤트는 예측 불가능한(unpredictably) 시점에 작업 큐에 들어간다</li></ul><h3 id="작업이-없을-때-엔진은-무엇을-하나"><a href="#작업이-없을-때-엔진은-무엇을-하나" class="headerlink" title="작업이 없을 때 엔진은 무엇을 하나?"></a>작업이 없을 때 엔진은 무엇을 하나?</h3><ul><li>이벤트 루프는 대기 상태로 들어가고 전원을 아낀다</li><li>가비지 컬렉션 같은 관리 작업을 한다</li></ul><h2 id="자원을-공유하는-타임라인은-문제가-생길-수-있습니다"><a href="#자원을-공유하는-타임라인은-문제가-생길-수-있습니다" class="headerlink" title="자원을 공유하는 타임라인은 문제가 생길 수 있습니다"></a>자원을 공유하는 타임라인은 문제가 생길 수 있습니다</h2><ul><li>공유하는 자원을 없에 문제를 해결할 수 있습니다</li><li>전역변수를 지역변수로 바꾸기 </li><li>전역변수를 인자로 바꾸기 <ul><li>암묵적 인자 확인하기</li><li>암묵적 입력을 인자로 바꾸기</li></ul></li></ul><h2 id="원칙-비동기-호출에서-명시적인-출력을-위해-리턴값-대신-콜백을-사용할-수-있습니다"><a href="#원칙-비동기-호출에서-명시적인-출력을-위해-리턴값-대신-콜백을-사용할-수-있습니다" class="headerlink" title="원칙: 비동기 호출에서 명시적인 출력을 위해 리턴값 대신 콜백을 사용할 수 있습니다"></a>원칙: 비동기 호출에서 명시적인 출력을 위해 리턴값 대신 콜백을 사용할 수 있습니다</h2><ul><li>동기 함수<ul><li>호출하는 곳에서 리턴값을 사용할 수 있다</li><li>액션을 빼내기 위해 액션을 부르는 곳은 리턴값으로 바꾸고 액션에 리턴값을 인자로 전달한다</li></ul></li><li>비동기 함수<ul><li>미래에 어떤 시점에 콜백을 통해 결과를 받는다</li><li>액션을 빼내기 위해 액션을 부르는 곳은 콜백으로 바꾸고 액션에 콜백을 인자로 전달한다</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-15-Grokking_Simplicity_15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>고전적인 컴퓨터 비전</title>
      <link>https://sejoung.github.io/2024/02/2024-02-14-classical_computer_vision/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-14-classical_computer_vision/</guid>
      <pubDate>Wed, 14 Feb 2024 01:51:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Classical-Computer-Vision&quot;&gt;&lt;a href=&quot;#Classical-Computer-Vision&quot; class=&quot;headerlink&quot; title=&quot;Classical Computer Vision&quot;&gt;&lt;/a&gt;Classical C
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Classical-Computer-Vision"><a href="#Classical-Computer-Vision" class="headerlink" title="Classical Computer Vision"></a>Classical Computer Vision</h1><h2 id="Local-Image-Features"><a href="#Local-Image-Features" class="headerlink" title="Local Image Features"></a>Local Image Features</h2><ul><li>Image Feature<ul><li>이미지를 수치적 값의 관점에서 추출한 정보</li></ul></li></ul><p>좋은 로컬 피처란?(interest point)</p><ul><li>saliency<ul><li>눈에 띄는 정도가 높을수록 좋은 피처</li></ul></li><li>Locality<ul><li>이미지의 작은 부분에 대한 특징을 잘 나타내는 피처</li></ul></li><li>Repeatability<ul><li>변환이 되어도 같은 성질이 뽑혀야된다</li></ul></li></ul><h2 id="합성곱-Convolution"><a href="#합성곱-Convolution" class="headerlink" title="합성곱 (Convolution)"></a>합성곱 (Convolution)</h2><ul><li>교환법칙 성립</li><li>결합법칙 성립</li><li>분배법칙 성립</li></ul><p>가우시안 필터(Gaussian Filter)</p><ul><li>이미지를 부드럽게 만들어주는 필터</li></ul><p>그라디던트 필터(Gradient Filter)</p><ul><li>이미지의 경계를 찾아주는 필터</li></ul><p>padding</p><ul><li>zero padding</li><li>warp padding</li><li>clamp padding</li><li>mirror padding</li></ul><h2 id="edge-and-corner"><a href="#edge-and-corner" class="headerlink" title="edge and corner"></a>edge and corner</h2><ul><li>edge<ul><li>이미지의 경계를 찾아주는 피처</li><li>smoothing -&gt; gradient -&gt; non-maximum suppression -&gt; hysteresis thresholding</li></ul></li><li>corner<ul><li>이미지의 모서리를 찾아주는 피처</li><li>edge detection -&gt; corner detection</li><li>edge 들이 만나는 부분</li><li>harris corner detection<ul><li>이미지의 픽셀들이 변화하는 정도를 계산하여 모서리를 찾아내는 방법</li></ul></li></ul></li></ul><h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><ul><li>이미지의 리전인데 주변보다 밝거나 더 어두운 영역에 대해서 Blob이라고 한다</li><li>laplacian of gaussian<ul><li>이미지를 블러처리한 후 라플라시안 필터를 적용하여 Blob을 찾아내는 방법</li></ul></li><li>difference of gaussian<ul><li>이미지를 다양한 크기로 블러처리한 후 차이를 계산하여 Blob을 찾아내는 방법</li></ul></li></ul><h2 id="Scale-Invariant-Feature-Transform-SIFT"><a href="#Scale-Invariant-Feature-Transform-SIFT" class="headerlink" title="Scale Invariant Feature Transform (SIFT)"></a>Scale Invariant Feature Transform (SIFT)</h2><ul><li>이미지의 크기에 상관없이 특징을 추출하는 알고리즘</li><li>keypoint detection -&gt; keypoint description -&gt; keypoint matching</li><li>keypoint detection</li><li>keypoint description</li></ul><h2 id="model-fitting"><a href="#model-fitting" class="headerlink" title="model fitting"></a>model fitting</h2><ul><li>fitting problem<ul><li>image stitching</li><li>3d object recognition</li></ul></li><li>Least Square Method<ul><li>weighted least square</li><li>least square</li></ul></li><li>RANSAC(Random Sample Consensus)</li><li>Hough Transform</li></ul><h2 id="feature-matching"><a href="#feature-matching" class="headerlink" title="feature matching"></a>feature matching</h2><ul><li>global feature matching</li><li>nearest neighbor matching</li></ul><h2 id="visual-recognition"><a href="#visual-recognition" class="headerlink" title="visual recognition"></a>visual recognition</h2><ul><li>classification</li><li>object detection</li><li>segmentation</li><li>scene recognition</li><li>pedestrian detection<ul><li>보행자 검출</li></ul></li></ul><h2 id="image-representation"><a href="#image-representation" class="headerlink" title="image representation"></a>image representation</h2><ul><li>bag of words<ul><li>independent feature(codeword)</li><li>histogram representation</li></ul></li><li>spatial pyramid matching<ul><li>이미지를 여러개의 영역으로 나누어서 히스토그램을 만들어서 이미지를 표현하는 방법</li></ul></li></ul><h2 id="classification"><a href="#classification" class="headerlink" title="classification"></a>classification</h2><p>분류 문제를 해결하는 방법</p><ul><li><p>linear classifier</p></li><li><p>non-linear classifier</p></li><li><p>generative model</p></li><li><p>discriminative model</p></li><li><p>discriminative function model</p></li><li><p>k-nearest neighbor</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://places2.csail.mit.edu/index.html">place2</a></li><li><a href="https://image-net.org/challenges/LSVRC/">ImageNet Large Scale Visual Recognition Challenge (ILSVRC)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-14-classical_computer_vision/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 14 중첩된 데이터에 함수형 도구 사용하기</title>
      <link>https://sejoung.github.io/2024/02/2024-02-14-Grokking_Simplicity_14/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-14-Grokking_Simplicity_14/</guid>
      <pubDate>Wed, 14 Feb 2024 00:48:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-14-중첩된-데이터에-함수형-도구-사용하기&quot;&gt;&lt;a href=&quot;#CHAPTER-14-중첩된-데이터에-함수형-도구-사용하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 14 중첩된 데이터에 함수형 도구 사용하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-14-중첩된-데이터에-함수형-도구-사용하기"><a href="#CHAPTER-14-중첩된-데이터에-함수형-도구-사용하기" class="headerlink" title="CHAPTER 14 중첩된 데이터에 함수형 도구 사용하기"></a>CHAPTER 14 중첩된 데이터에 함수형 도구 사용하기</h1><h2 id="함수형-도구-update"><a href="#함수형-도구-update" class="headerlink" title="함수형 도구: update()"></a>함수형 도구: update()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">object, key, modify</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = object[key];</span><br><span class="line">  <span class="keyword">var</span> newValue = <span class="title function_">modify</span>(value);</span><br><span class="line">  <span class="keyword">var</span> newObject = <span class="title function_">objectSet</span>(object, key, newValue);</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withObjectCopy</span>(<span class="params">object, modify</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, object);</span><br><span class="line">    <span class="title function_">modify</span>(copy);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectSet</span>(<span class="params">object, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">withObjectCopy</span>(object, <span class="keyword">function</span>(<span class="params">copy</span>) &#123;</span><br><span class="line">        copy[key] = value;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>객체를 다루는 함수형 도구</p><h2 id="update2-도출하기"><a href="#update2-도출하기" class="headerlink" title="update2() 도출하기"></a>update2() 도출하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update2</span>(<span class="params">object, key1, key2, modify</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">update</span>(object, key1, <span class="keyword">function</span>(<span class="params">subObject</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">update</span>(subObject, key2, modify);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="incrementSizeByName-을-만드는-네-가지-방법"><a href="#incrementSizeByName-을-만드는-네-가지-방법" class="headerlink" title="incrementSizeByName()을 만드는 네 가지 방법"></a>incrementSizeByName()을 만드는 네 가지 방법</h2><h3 id="옵션1-update-와-incrementSize-로-만들기"><a href="#옵션1-update-와-incrementSize-로-만들기" class="headerlink" title="옵션1: update()와 incrementSize()로 만들기"></a>옵션1: update()와 incrementSize()로 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">incrementSizeByName</span>(<span class="params">cart, name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">update</span>(cart, name, incrementSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incrementSize</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> size = item[<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> newSize = size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> newItem = <span class="title function_">objectSet</span>(item, <span class="string">&#x27;size&#x27;</span>, newSize);</span><br><span class="line">    <span class="keyword">return</span> newItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="옵션2-update-와-update2-로-만들기"><a href="#옵션2-update-와-update2-로-만들기" class="headerlink" title="옵션2: update()와 update2()로 만들기"></a>옵션2: update()와 update2()로 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">incrementSizeByName</span>(<span class="params">cart, name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">update</span>(cart, name, <span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">update2</span>(item, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="keyword">function</span> (<span class="params">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="옵션3-update-로-만들기"><a href="#옵션3-update-로-만들기" class="headerlink" title="옵션3: update()로 만들기"></a>옵션3: update()로 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">incrementSizeByName</span>(<span class="params">cart, name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">update</span>(cart, name, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">update</span>(item, <span class="string">&#x27;options&#x27;</span>, <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">update</span>(options, <span class="string">&#x27;size&#x27;</span>, <span class="keyword">function</span>(<span class="params">size</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="옵션4-조회하고-바꾸고-설정하는-것을-직접만들기"><a href="#옵션4-조회하고-바꾸고-설정하는-것을-직접만들기" class="headerlink" title="옵션4: 조회하고 바꾸고 설정하는 것을 직접만들기"></a>옵션4: 조회하고 바꾸고 설정하는 것을 직접만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">incrementSizeByName</span>(<span class="params">cart, name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> item       = cart[name];</span><br><span class="line">  <span class="keyword">var</span> options    = item.<span class="property">options</span>;</span><br><span class="line">  <span class="keyword">var</span> size       = options.<span class="property">size</span>;</span><br><span class="line">  <span class="keyword">var</span> newSize    = size + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> newOptions = <span class="title function_">objectSet</span>(options, <span class="string">&#x27;size&#x27;</span>, newSize);</span><br><span class="line">  <span class="keyword">var</span> newItem    = <span class="title function_">objectSet</span>(item, <span class="string">&#x27;options&#x27;</span>, newOptions);</span><br><span class="line">  <span class="keyword">var</span> newCart    = <span class="title function_">objectSet</span>(cart, name, newItem);</span><br><span class="line">  <span class="keyword">return</span> newCart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="update3-도출하기"><a href="#update3-도출하기" class="headerlink" title="update3() 도출하기"></a>update3() 도출하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update3</span>(<span class="params">object, key1, key2, key3, modify</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">update</span>(object, key1, <span class="keyword">function</span>(<span class="params">object2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">update2</span>(object2, key2, key3, modify);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="nestedUpdate-도출하기"><a href="#nestedUpdate-도출하기" class="headerlink" title="nestedUpdate() 도출하기"></a>nestedUpdate() 도출하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nestedUpdate</span>(<span class="params">object, keys, modify</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(keys.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">modify</span>(object);</span><br><span class="line">  <span class="keyword">var</span> key1 = keys[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> restOfKeys = <span class="title function_">drop_first</span>(keys);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">update</span>(object, key1, <span class="keyword">function</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">nestedUpdate</span>(value1, restOfKeys, modify);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="안전한-재귀-사용법"><a href="#안전한-재귀-사용법" class="headerlink" title="안전한 재귀 사용법"></a>안전한 재귀 사용법</h2><ul><li>종료조건<ul><li>재귀를 멈추려면 종료 조건(base case)이 필요하다.</li></ul></li><li>재귀 호출<ul><li>재귀 호출을 하려면 자신을 호출하는 코드가 필요하다.</li></ul></li><li>종료 조건에 다가가기<ul><li>최소 하나 이상의 인자가 점점 줄어들어야 한다</li></ul></li></ul><h2 id="재귀-함수가-적합한-이유"><a href="#재귀-함수가-적합한-이유" class="headerlink" title="재귀 함수가 적합한 이유"></a>재귀 함수가 적합한 이유</h2><p>재귀나 호출 스택을 사용하지 않고 중첩된 데이터를 다루기는 어렵다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-14-Grokking_Simplicity_14/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
