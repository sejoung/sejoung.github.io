<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Tue, 13 Feb 2024 01:41:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CHAPTER 13 함수형 도구 체이닝</title>
      <link>https://sejoung.github.io/2024/02/2024-02-13-Grokking_Simplicity_13/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-13-Grokking_Simplicity_13/</guid>
      <pubDate>Tue, 13 Feb 2024 00:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-13-함수형-도구-체이닝&quot;&gt;&lt;a href=&quot;#CHAPTER-13-함수형-도구-체이닝&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 13 함수형 도구 체이닝&quot;&gt;&lt;/a&gt;CHAPTER 13 함수형 도구 체이닝&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-13-함수형-도구-체이닝"><a href="#CHAPTER-13-함수형-도구-체이닝" class="headerlink" title="CHAPTER 13 함수형 도구 체이닝"></a>CHAPTER 13 함수형 도구 체이닝</h1><p>여러 단계를 하나로 조합하는것을 체이닝(chaining)이라고 합니다.</p><h2 id="체인을-명확하게-만들기-1-단계에-이름-붙이기"><a href="#체인을-명확하게-만들기-1-단계에-이름-붙이기" class="headerlink" title="체인을 명확하게 만들기 1: 단계에 이름 붙이기"></a>체인을 명확하게 만들기 1: 단계에 이름 붙이기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">biggestPurchasesBestCustomers</span>(<span class="params">customers</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bestCustomers    = <span class="title function_">selectBestCustomers</span>(customers);</span><br><span class="line">  <span class="keyword">var</span> biggestPurchases = <span class="title function_">getBiggestPurchases</span>(bestCustomers);</span><br><span class="line">  <span class="keyword">return</span> biggestPurchases;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectBestCustomers</span>(<span class="params">customers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">filter</span>(customers, <span class="keyword">function</span>(<span class="params">customer</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> customer.<span class="property">purchases</span>.<span class="property">length</span> &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBiggestPurchases</span>(<span class="params">customers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">map</span>(customers, getBiggestPurchase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="체인을-명확하게-만들기-2-콜백에-이름-붙이기"><a href="#체인을-명확하게-만들기-2-콜백에-이름-붙이기" class="headerlink" title="체인을 명확하게 만들기 2: 콜백에 이름 붙이기"></a>체인을 명확하게 만들기 2: 콜백에 이름 붙이기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">biggestPurchasesBestCustomers</span>(<span class="params">customers</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bestCustomers    = <span class="title function_">filter</span>(customers, isGoodCustomer);</span><br><span class="line">  <span class="keyword">var</span> biggestPurchases = <span class="title function_">map</span>(bestCustomers, getBiggestPurchase);</span><br><span class="line">  <span class="keyword">return</span> biggestPurchases;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isGoodCustomer</span>(<span class="params">customer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> customer.<span class="property">purchases</span>.<span class="property">length</span> &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBiggestPurchase</span>(<span class="params">customer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">maxKey</span>(customer.<span class="property">purchases</span>, &#123;<span class="attr">total</span>: <span class="number">0</span>&#125;, getPurchaseTotal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="체인을-명확하게-만들기-3-두-방법을-비교"><a href="#체인을-명확하게-만들기-3-두-방법을-비교" class="headerlink" title="체인을 명확하게 만들기 3: 두 방법을 비교"></a>체인을 명확하게 만들기 3: 두 방법을 비교</h2><p>일반적으로는 콜백에 이름 붙이기가 더 명확하다</p><h2 id="반복문을-함수형-도구로-리팩터링하기"><a href="#반복문을-함수형-도구로-리팩터링하기" class="headerlink" title="반복문을 함수형 도구로 리팩터링하기"></a>반복문을 함수형 도구로 리팩터링하기</h2><p>지금 하는 것은 최적화이다 병목이 생겼을 때만 최적화를 하자</p><ul><li>이해하고 다시 만들기</li><li>단서를 찾아 리팩터링</li></ul><h3 id="값-하나에-map-두번-사용"><a href="#값-하나에-map-두번-사용" class="headerlink" title="값 하나에 map() 두번 사용"></a>값 하나에 map() 두번 사용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = <span class="title function_">map</span>(customers, getFullName);</span><br><span class="line"><span class="keyword">var</span> nameLengths = <span class="title function_">map</span>(names, stringLength);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameLengths = <span class="title function_">map</span>(customers, <span class="keyword">function</span>(<span class="params">customer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">stringLength</span>(<span class="title function_">getFullName</span>(customer));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="값-하나에-filter-두번-사용"><a href="#값-하나에-filter-두번-사용" class="headerlink" title="값 하나에 filter() 두번 사용"></a>값 하나에 filter() 두번 사용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goodCustomers = <span class="title function_">filter</span>(customers, isGoodCustomer);</span><br><span class="line"><span class="keyword">var</span> withAddresses = <span class="title function_">filter</span>(goodCustomers, hasAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> withAddresses = <span class="title function_">filter</span>(customers, <span class="keyword">function</span>(<span class="params">customer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isGoodCustomer</span>(customer) &amp;&amp; <span class="title function_">hasAddress</span>(customer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="map-다음에-reduce-사용하기"><a href="#map-다음에-reduce-사용하기" class="headerlink" title="map() 다음에 reduce() 사용하기"></a>map() 다음에 reduce() 사용하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> purchaseTotals = <span class="title function_">map</span>(purchases, getPurchaseTotal);</span><br><span class="line"><span class="keyword">var</span> purchaseSum = <span class="title function_">reduce</span>(purchaseTotals, <span class="number">0</span>, plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> purchaseSum = <span class="title function_">reduce</span>(purchases, <span class="number">0</span>, <span class="keyword">function</span>(<span class="params">total, purchase</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total + <span class="title function_">getPurchaseTotal</span>(purchase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="팁-1-데이터-만들기"><a href="#팁-1-데이터-만들기" class="headerlink" title="팁 1: 데이터 만들기"></a>팁 1: 데이터 만들기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = [];</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> w = <span class="number">0</span>; w &lt; <span class="variable language_">window</span>; w++) &#123;</span><br><span class="line">    <span class="keyword">var</span> idx = i + w;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; array.<span class="property">length</span>) &#123;</span><br><span class="line">      sum += array[idx];</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  answer.<span class="title function_">push</span>(sum/count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer = [];</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> subarray = array.<span class="title function_">slice</span>(i, i + <span class="variable language_">window</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> w = <span class="number">0</span>; w &lt; subarray.<span class="property">length</span>; w++) &#123;</span><br><span class="line">    sum += subarray[w];</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  answer.<span class="title function_">push</span>(sum/count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="팁-2-한-번에-전체-배열을-조작하기"><a href="#팁-2-한-번에-전체-배열을-조작하기" class="headerlink" title="팁 2: 한 번에 전체 배열을 조작하기"></a>팁 2: 한 번에 전체 배열을 조작하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = [];</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> subarray = array.<span class="title function_">slice</span>(i, i + <span class="variable language_">window</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> w = <span class="number">0</span>; w &lt; subarray.<span class="property">length</span>; w++) &#123;</span><br><span class="line">    sum += subarray[w];</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  answer.<span class="title function_">push</span>(sum/count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer = [];</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> subarray = array.<span class="title function_">slice</span>(i, i + <span class="variable language_">window</span>);</span><br><span class="line">  answer.<span class="title function_">push</span>(<span class="title function_">average</span>(subarray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="팁-3-작은-단계로-나누기"><a href="#팁-3-작은-단계로-나누기" class="headerlink" title="팁 3: 작은 단계로 나누기"></a>팁 3: 작은 단계로 나누기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = [];</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> subarray = array.<span class="title function_">slice</span>(i, i + <span class="variable language_">window</span>);</span><br><span class="line">  answer.<span class="title function_">push</span>(<span class="title function_">average</span>(subarray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> indices = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++)</span><br><span class="line">  indices.<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">window</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">map</span>(indices, <span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> subarray = array.<span class="title function_">slice</span>(i, i + <span class="variable language_">window</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">average</span>(subarray);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="체이닝-팁-요약"><a href="#체이닝-팁-요약" class="headerlink" title="체이닝 팁 요약"></a>체이닝 팁 요약</h2><ul><li>데이터 만들기</li><li>배열 전체를 다루기</li><li>작은 단계로 나누기</li><li>조건문을 filter()로 바꾸기</li><li>유용한 함수로 추출하기<h2 id="체이닝-디버깅을-위한-팁"><a href="#체이닝-디버깅을-위한-팁" class="headerlink" title="체이닝 디버깅을 위한 팁"></a>체이닝 디버깅을 위한 팁</h2></li><li>구체적인 것을 유지하기</li><li>출력해보기</li><li>타입을 따라가 보기<h2 id="다양한-함수형-도구"><a href="#다양한-함수형-도구" class="headerlink" title="다양한 함수형 도구"></a>다양한 함수형 도구</h2></li><li>pluck()</li><li>cancat()</li><li>frequenciesBy(), groupBy()</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-13-Grokking_Simplicity_13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>합성곱(Convolution)</title>
      <link>https://sejoung.github.io/2024/02/2024-02-07-convolution/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-07-convolution/</guid>
      <pubDate>Wed, 07 Feb 2024 04:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;합성곱-Convolution&quot;&gt;&lt;a href=&quot;#합성곱-Convolution&quot; class=&quot;headerlink&quot; title=&quot;합성곱(Convolution)&quot;&gt;&lt;/a&gt;합성곱(Convolution)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;grayscale 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="합성곱-Convolution"><a href="#합성곱-Convolution" class="headerlink" title="합성곱(Convolution)"></a>합성곱(Convolution)</h1><ul><li>grayscale 0~255 사이의 값을 가지는 이미지를 사용한다.</li><li>RGB 이미지는 channel이 3개</li><li>필터 연산 : 이미지에 필터를 적용하는 연산 방법</li><li>필터 : 3x3, 5x5, 7x7 등의 크기를 가지는 행렬</li><li>연산 : weighted sum</li></ul><p>이미지 정보를 나열하면 지역적 특성이 사라져서 정보를 잃어버릴 수 있다.<br>Convolution을 사용하면 지역적 특성을 유지하면서 정보를 추출할 수 있다.</p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>그냥 합성곱 연산을 하면 이미지의 크기가 줄어들게 된다. 이를 방지하기 위해 패딩을 사용한다.(주로 0으로 채움 zero padding)</p><h2 id="Stride"><a href="#Stride" class="headerlink" title="Stride"></a>Stride</h2><p>합성곱 연산을 할 때 필터를 몇 칸씩 이동할지를 결정하는 값 최종 데이터가 줄어든다</p><h2 id="필터"><a href="#필터" class="headerlink" title="필터"></a>필터</h2><ul><li>feature map : 필터를 적용한 결과</li><li>channel : 필터의 개수</li></ul><h2 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max Pooling"></a>Max Pooling</h2><ul><li>feature map에서 가장 큰수만 남기고 없애는 연산</li><li>파라미터수 감소 시키기 위해 사용</li></ul><h2 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h2><ul><li>fully connected layer : 모든 뉴런이 연결되어 있는 층</li><li>노드 갯수가 class의 갯수</li></ul><h2 id="기울기-소실-gradient-vanishing"><a href="#기울기-소실-gradient-vanishing" class="headerlink" title="기울기 소실(gradient vanishing)"></a>기울기 소실(gradient vanishing)</h2><ul><li>학습이 진행될수록 gradient가 점점 작아져서 학습이 잘 되지 않는 문제</li><li>ReLU를 사용하여 해결</li><li>ReLU : 0보다 작은 값은 0으로, 0보다 큰 값은 그대로 출력하는 함수</li><li>skip connection : 입력값을 출력값에 더해주는 방법</li></ul><h2 id="YOLO-You-Only-Look-Once"><a href="#YOLO-You-Only-Look-Once" class="headerlink" title="YOLO(You Only Look Once)"></a>YOLO(You Only Look Once)</h2><ul><li>one stage object detection</li><li>이미지를 그리드로 나누고 각 그리드에 대해 bounding box와 class를 예측하는 방법</li></ul><h2 id="YOLO-DeepSort"><a href="#YOLO-DeepSort" class="headerlink" title="YOLO + DeepSort"></a>YOLO + DeepSort</h2><ul><li>YOLO로 객체를 인식하고 DeepSort로 객체를 추적하는 방법</li><li>DeepSort : id switch, occlusion, missing detection 문제를 해결하기 위해 사용</li><li>Deep: deep association metric learning</li><li>SORT : Simple Online and Realtime Tracking<ul><li>Kalman filter를 사용하여 객체를 추적하는 방법</li><li>hungarian algorithm을 사용하여 객체를 매칭하는 방법</li></ul></li></ul><h2 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h2><ul><li>이미지 분할을 위한 네트워크</li><li>왼쪽 부분은 이미지를 줄이는 부분(contracting path, downsampling path)</li><li>오른쪽 부분은 이미지를 복원하는 부분(expansive path, upsampling path)</li><li>skip connection을 사용하여 이미지의 지역적 특성을 유지하면서 이미지를 복원한다.</li></ul><h2 id="pre-processing"><a href="#pre-processing" class="headerlink" title="pre-processing"></a>pre-processing</h2><ul><li>resize : 이미지의 크기를 줄이거나 늘리는 작업(이미지의 크기를 통일시키기 위해 사용) resoultion이 다르면 학습이 잘 되지 않을 수 있다.</li><li>color : 이미지의 색상을 변경하는 작업</li><li>normalization : 이미지의 픽셀값을 0~1사이의 값으로 변경하는 작업, min-max scaling</li></ul><h2 id="클래스-불균형-class-imbalance"><a href="#클래스-불균형-class-imbalance" class="headerlink" title="클래스 불균형(class imbalance)"></a>클래스 불균형(class imbalance)</h2><ul><li><p>클래스 간의 데이터의 갯수가 차이가 나는 경우</p></li><li><p>다양성이 작을 경우</p></li><li><p>over-sampling : 데이터의 갯수를 늘리는 방법(중복추출로 양을 늘림) 다양성이 충분하면 이것을 사용해도 된다</p></li><li><p>data augmentation : 이미지를 회전, 반전, 확대, 축소 등의 변형을 주어서 데이터의 다양성을 늘리는 방법</p><ul><li>epoch를 증가시킨다</li><li>random rain 같은 트랜스퍼를 진행했을때 다른데도 같이 진행해줘야 된다</li></ul></li><li><p>focal loss : 클래스 간의 데이터의 갯수가 차이가 나는 경우 사용하는 loss function</p><ul><li>데이터의 갯수가 적은 클래스에 가중치를 더 주는 방법</li><li>데이터의 갯수가 많은 클래스에 가중치를 적게 주는 방법</li></ul></li></ul><h2 id="과적합-overfitting"><a href="#과적합-overfitting" class="headerlink" title="과적합(overfitting)"></a>과적합(overfitting)</h2><ul><li>학습 데이터에 대해서는 정확도가 높지만, 테스트 데이터에 대해서는 정확도가 낮은 경우</li><li>일반화 성능을 높히는것이 목적이다</li><li>검증 손실이 증가하기 시작하면 학습을 중단한다</li><li>일반화(regularization)항 추가<ul><li>cost 계산시에 weight의 크기를 더해준다</li></ul></li><li>앙상블(ensemble) : 여러 모델을 합쳐서 사용하는 방법<ul><li>소프트 보팅(soft voting) : 각 모델의 예측값을 평균내어 사용하는 방법</li></ul></li><li>dropout : 학습시에 랜덤하게 뉴런을 제거하는 방법<ul><li>학습시에만 사용하고 예측시에는 사용하지 않는다</li></ul></li></ul><h2 id="이미지-증강-augmentation"><a href="#이미지-증강-augmentation" class="headerlink" title="이미지 증강(augmentation)"></a>이미지 증강(augmentation)</h2><ul><li>transformation : 이미지를 회전, 반전, 확대, 축소 등의 변형을 주어서 데이터의 다양성을 늘리는 방법<ul><li>flip : 이미지를 반전시키는 방법</li><li>rotation : 이미지를 회전시키는 방법</li><li>blur : 이미지를 흐리게 하는 방법</li><li>hueSaturation : 이미지의 채도를 변경하는 방법</li><li>gaussian noise : 이미지에 가우시안 노이즈를 추가하는 방법</li><li>CoarseDropout : 이미지의 일부분을 제거하는 방법</li><li>GrayScale : 이미지를 흑백으로 변경하는 방법</li><li>Mixup : 이미지를 섞는 방법</li><li>CutMix : 이미지를 잘라서 섞는 방법</li><li>Mosiac : 이미지를 섞는 방법</li><li>RandomErasing : 이미지의 일부분을 지우는 방법</li><li>RandomRain : 이미지에 빗방울을 추가하는 방법</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://setosa.io/ev/image-kernels/">Image Kernels</a></li><li><a href="https://neurohive.io/en/popular-networks/vgg16/">VGG16 – Convolutional Network for Classification and Detection</a></li><li><a href="https://oi.readthedocs.io/en/latest/">Organize everything I know</a></li><li><a href="https://github.com/darkpgmr/DarkLabel">DarkLabel</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-07-convolution/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 12 함수형 반복</title>
      <link>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_12/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_12/</guid>
      <pubDate>Wed, 07 Feb 2024 01:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-12-함수형-반복&quot;&gt;&lt;a href=&quot;#CHAPTER-12-함수형-반복&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 12 함수형 반복&quot;&gt;&lt;/a&gt;CHAPTER 12 함수형 반복&lt;/h1&gt;&lt;h2 id=&quot;함수형-도
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-12-함수형-반복"><a href="#CHAPTER-12-함수형-반복" class="headerlink" title="CHAPTER 12 함수형 반복"></a>CHAPTER 12 함수형 반복</h1><h2 id="함수형-도구-map"><a href="#함수형-도구-map" class="headerlink" title="함수형 도구: map()"></a>함수형 도구: map()</h2><ul><li>X 값이 있는 배열을 받아서 Y 값이 있는 배열로 변환 한다<h2 id="함수를-전달하는-세-가지-방법"><a href="#함수를-전달하는-세-가지-방법" class="headerlink" title="함수를 전달하는 세 가지 방법"></a>함수를 전달하는 세 가지 방법</h2></li><li>전역으로 정의하기</li><li>지역적으로 정의하기</li><li>인라인으로 정의하기<h2 id="함수형-도구-filter"><a href="#함수형-도구-filter" class="headerlink" title="함수형 도구: filter()"></a>함수형 도구: filter()</h2></li><li>배열에서 일부 항목을 선택하는 함수<h2 id="함수형-도구-reduce"><a href="#함수형-도구-reduce" class="headerlink" title="함수형 도구: reduce()"></a>함수형 도구: reduce()</h2></li><li>배열을 순회하면서 값을 누적한다<h2 id="reduce-로-할-수-있는-것들"><a href="#reduce-로-할-수-있는-것들" class="headerlink" title="reduce()로 할 수 있는 것들"></a>reduce()로 할 수 있는 것들</h2></li><li>실행 취소&#x2F;실행 복귀</li><li>테스트할 때 사용자 입력을 다시 실행하기</li><li>시간 여행 디버깅</li><li>회계 감사 추적<h2 id="세-가지-함수형-도구를-비교하기"><a href="#세-가지-함수형-도구를-비교하기" class="headerlink" title="세 가지 함수형 도구를 비교하기"></a>세 가지 함수형 도구를 비교하기</h2></li><li>map()은 배열의 모든 항복에 함수를 적용해 새로운 배열로 바꾼다</li><li>filter()는 배열의 하위 집합을 선택해 새로운 배열로 만든다</li><li>reduce()는 배열의 항목을 조합해 최종값을 만든다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 11 일급 함수 II</title>
      <link>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_11/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_11/</guid>
      <pubDate>Wed, 07 Feb 2024 00:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-11-일급-함수-II&quot;&gt;&lt;a href=&quot;#CHAPTER-11-일급-함수-II&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 11 일급 함수 II&quot;&gt;&lt;/a&gt;CHAPTER 11 일급 함수 II&lt;/h1&gt;&lt;h2 i
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-11-일급-함수-II"><a href="#CHAPTER-11-일급-함수-II" class="headerlink" title="CHAPTER 11 일급 함수 II"></a>CHAPTER 11 일급 함수 II</h1><h2 id="코드-냄새-하나와-리팩터링-두-개"><a href="#코드-냄새-하나와-리팩터링-두-개" class="headerlink" title="코드 냄새 하나와 리팩터링 두 개"></a>코드 냄새 하나와 리팩터링 두 개</h2><ul><li>코드의 냄새: 함수 이름에 있는 암묵적 인자<ul><li>거의 똑같이 구현된 함수가 있다</li><li>함수 이름이 구현에 있는 다른 부분을 가르킨다</li></ul></li><li>리팩터링: 암묵적 인자 드러내기</li><li>리팩터링: 함수를 본문을 콜백으로 바꾸기</li></ul><h2 id="카피-온-라이트-리팩터링하기"><a href="#카피-온-라이트-리팩터링하기" class="headerlink" title="카피-온-라이트 리팩터링하기"></a>카피-온-라이트 리팩터링하기</h2><ul><li>함수 본문을 콜백으로 바꾸기 단계<ul><li>본문과 앞부분 뒷부분을 확인하기</li><li>함수 빼내기</li><li>콜백 빼내기</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-07-Grokking_Simplicity_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 10 일급 함수 I</title>
      <link>https://sejoung.github.io/2024/02/2024-02-06-Grokking_Simplicity_10/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-06-Grokking_Simplicity_10/</guid>
      <pubDate>Tue, 06 Feb 2024 01:03:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-10-일급-함수-I&quot;&gt;&lt;a href=&quot;#CHAPTER-10-일급-함수-I&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 10 일급 함수 I&quot;&gt;&lt;/a&gt;CHAPTER 10 일급 함수 I&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-10-일급-함수-I"><a href="#CHAPTER-10-일급-함수-I" class="headerlink" title="CHAPTER 10 일급 함수 I"></a>CHAPTER 10 일급 함수 I</h1><ul><li>코드의 냄새: 함수 이름에 있는 암묵적 인자<ul><li>특징<ul><li>거의 똑같이 구현된 함수가 있다</li><li>함수 이름이 구현에 있는 다른 부분을 가리킨다</li></ul></li></ul></li><li>리팩터링: 암묵적 인자를 드러내기<ul><li>단계<ul><li>함수 이름에 있는 암묵적 인자를 확인한다</li><li>명시적인 인자를 추가한다</li><li>함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다</li><li>함수를 호출하는 곳을 고친다</li></ul></li></ul></li><li>리팩터링: 함수 본문을 콜백으로 바꾸기<ul><li>단계<ul><li>함수 본문에서 바꿀 부분의 앞부분과 뒷부분을 확인한다</li><li>리팩터링 할 코드를 함수로 빼낸다</li><li>빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 빼낸다</li></ul></li></ul></li></ul><h2 id="리팩터링-암묵적-인자를-드러내기"><a href="#리팩터링-암묵적-인자를-드러내기" class="headerlink" title="리팩터링: 암묵적 인자를 드러내기"></a>리팩터링: 암묵적 인자를 드러내기</h2><p>일급 값(first-class value)은 언어에 있는 다른 값처럼 쓸수 있다</p><h2 id="일급인-것과-일급이-아닌-것을-구별하기"><a href="#일급인-것과-일급이-아닌-것을-구별하기" class="headerlink" title="일급인 것과 일급이 아닌 것을 구별하기"></a>일급인 것과 일급이 아닌 것을 구별하기</h2><p>자바 스크립트에서 일급이 아닌것</p><ul><li>수식 연산자</li><li>반복문</li><li>조건문</li><li>try&#x2F;catch 블록</li></ul><h2 id="객체와-배열을-너무-많이-쓰게-됩니다"><a href="#객체와-배열을-너무-많이-쓰게-됩니다" class="headerlink" title="객체와 배열을 너무 많이 쓰게 됩니다"></a>객체와 배열을 너무 많이 쓰게 됩니다</h2><p>데이터 지향(data orientation)은 이벤트와 엔티티에 대한 사실을 표현하기 위해 일반 데이터 구조를 사용하는 프로그래밍 형식</p><h2 id="어떤-문법이든-일급-함수로-바꿀-수-있습니다"><a href="#어떤-문법이든-일급-함수로-바꿀-수-있습니다" class="headerlink" title="어떤 문법이든 일급 함수로 바꿀 수 있습니다"></a>어떤 문법이든 일급 함수로 바꿀 수 있습니다</h2><p>고차함수(higher-order function)는 함수를 인자로 받거나 함수를 반환하는 함수</p><h2 id="이것은-무슨-문법인가요"><a href="#이것은-무슨-문법인가요" class="headerlink" title="이것은 무슨 문법인가요?"></a>이것은 무슨 문법인가요?</h2><p>함수를 정의하는 방법</p><ul><li>전역으로 정의하기</li><li>지역적으로 정의하기</li><li>인라인으로 정의하기<h2 id="왜-본문을-함수로-감싸서-넘기나요"><a href="#왜-본문을-함수로-감싸서-넘기나요" class="headerlink" title="왜 본문을 함수로 감싸서 넘기나요?"></a>왜 본문을 함수로 감싸서 넘기나요?</h2>함수의 실행을 미루는 일반적인 방법</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-06-Grokking_Simplicity_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>선형 회귀(Linear Regression)</title>
      <link>https://sejoung.github.io/2024/02/2024-02-05-linear_regression/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-05-linear_regression/</guid>
      <pubDate>Mon, 05 Feb 2024 07:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;선형-회귀-Linear-Regression&quot;&gt;&lt;a href=&quot;#선형-회귀-Linear-Regression&quot; class=&quot;headerlink&quot; title=&quot;선형 회귀(Linear Regression)&quot;&gt;&lt;/a&gt;선형 회귀(Linear Reg
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="선형-회귀-Linear-Regression"><a href="#선형-회귀-Linear-Regression" class="headerlink" title="선형 회귀(Linear Regression)"></a>선형 회귀(Linear Regression)</h1><p>Linear -&gt; 선을 그려</p><p>Regression -&gt; 값을 예측</p><p>회귀(Regression)는 통계학과 머신러닝에서 사용되는 용어로, 어떤 변수의 값을 다른 변수의 값으로 예측하거나 설명하는 모델</p><ul><li>데이터를 일반화하는 선을 찾는다</li><li>그 선을 이용해 새로운 데이터를 예측한다</li></ul><p>y &#x3D; ax+b</p><p>가증합으로 새로운 특성을 만들어낸다</p><h2 id="로지스틱-회귀분석-logistic-regression"><a href="#로지스틱-회귀분석-logistic-regression" class="headerlink" title="로지스틱 회귀분석(logistic regression)"></a>로지스틱 회귀분석(logistic regression)</h2><p>input과 weight를 곱해서 더하는 과정은 linear combination(선형 결합)이다.<br>인공신경망의 학습은 각 뉴런에 곱해지는 ‘weight’라는 모수(parameter)를 추정(estimate)하는 과정이다</p><p>로지스틱 회귀분석은 generalized linear model(GLM)의 일종이다</p><p>로지스틱 함수가 바로 우리가 활성함수로 사용하는 sigmoid function이다</p><p>Sigmoid를 활성함수로 사용하는 multi layer perceptron neural network의 hidden layer의 각 뉴런은 로지스틱 회귀분석을 하는 것과 정확히 일치</p><h2 id="activation-function의-종류"><a href="#activation-function의-종류" class="headerlink" title="activation function의 종류"></a>activation function의 종류</h2><ul><li>sigmoid</li><li>tanh</li><li>ReLU(Rectified Linear Unit)</li></ul><h2 id="Bias-and-Variance-편향과-분산"><a href="#Bias-and-Variance-편향과-분산" class="headerlink" title="Bias and Variance (편향과 분산)"></a>Bias and Variance (편향과 분산)</h2><p>예측값들과 정답이 대처로 멀리 떨어져 있으면 결과의 편향(bias)이 높다고 말하고<br>예측값들이 자기들끼리 대체로 멀리 흩어져 있으면 결과의 분산(variance)이 높다고 말한다.</p><h2 id="독립변수와-종속변수"><a href="#독립변수와-종속변수" class="headerlink" title="독립변수와 종속변수"></a>독립변수와 종속변수</h2><p>표에서 변수는 열</p><ul><li>독립변수<ul><li>원인이 되는 것</li><li>결과랑 상관없는 것</li></ul></li><li>종속변수<ul><li>결과가 되는 것</li><li>원인에 종속되어 있는것</li></ul></li></ul><h3 id="상관관계"><a href="#상관관계" class="headerlink" title="상관관계"></a>상관관계</h3><p>한쪽의 값이 바뀌었을 때, 다른 쪽의 값도 바뀐다면,<br>두 개의 특성은 ‘서로 관련이 있다’고 추측할 수 있습니다.<br>그리고, 이런 관계를 ‘상관관계’라고 합니다.</p><h3 id="인과관계"><a href="#인과관계" class="headerlink" title="인과관계"></a>인과관계</h3><p>각 열이 원인과 결과의 관계일 때<br>인과관계가 있다고 합니다.</p><h2 id="지도-학습"><a href="#지도-학습" class="headerlink" title="지도 학습"></a>지도 학습</h2><ul><li>분류 (Classification)</li><li>회귀 (Regression)</li></ul><h3 id="분류-Classification"><a href="#분류-Classification" class="headerlink" title="분류(Classification)"></a>분류(Classification)</h3><p>결과가 숫자가 아니라 손톱, 정상과 같은 이름이면 분류(Classification)를 사용한다</p><h3 id="회귀-Regression"><a href="#회귀-Regression" class="headerlink" title="회귀(Regression)"></a>회귀(Regression)</h3><p>예측하고 싶은 종속변수가 숫자일 때 회귀(Regression)를 사용한다</p><h2 id="비지도-학습"><a href="#비지도-학습" class="headerlink" title="비지도 학습"></a>비지도 학습</h2><ul><li><p>군집 (Clustering)</p><ul><li>비슷한 것들끼리 모아서 적당한 그룹을 만들 것입니다 이렇게 그룹을 만드는 것이 군집</li><li>좌표 평면을 사용하면 군집을 쉽게 볼 수 있습니다</li></ul></li><li><p>연관 규칙 학습(Association Rule Learning)</p><ul><li>어떤 물건을 살 때 다른 물건도 같이 살 확률이 높다면, 그 물건들은 연관이 있다고 볼 수 있습니다</li><li>이런 연관을 찾는 것이 연관 규칙 학습</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://gaussian37.github.io/machine-learning-concept-bias_and_variance/">머신러닝에서의 Bias와 Variance</a></li><li><a href="https://pozalabs.github.io/Activation_Function/">Activation Function(활성함수)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-05-linear_regression/#disqus_thread</comments>
    </item>
    
    <item>
      <title>신경망(Neural Networks)</title>
      <link>https://sejoung.github.io/2024/02/2024-02-06-neural_networks/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-06-neural_networks/</guid>
      <pubDate>Mon, 05 Feb 2024 07:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;신경망-Neural-Networks&quot;&gt;&lt;a href=&quot;#신경망-Neural-Networks&quot; class=&quot;headerlink&quot; title=&quot;신경망(Neural Networks)&quot;&gt;&lt;/a&gt;신경망(Neural Networks)&lt;/h1&gt;&lt;h2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="신경망-Neural-Networks"><a href="#신경망-Neural-Networks" class="headerlink" title="신경망(Neural Networks)"></a>신경망(Neural Networks)</h1><h2 id="행렬곱"><a href="#행렬곱" class="headerlink" title="행렬곱"></a>행렬곱</h2><ul><li>one-hot encoding 통해서 행렬을 만들고 가중치 행렬과 행렬곱을 수행하여 예측값을 만들어낸다.</li></ul><h2 id="경사-하강법-Gradient-Descent"><a href="#경사-하강법-Gradient-Descent" class="headerlink" title="경사 하강법(Gradient Descent)"></a>경사 하강법(Gradient Descent)</h2><ul><li>경사 하강법은 함수의 기울기를 구하고, 기울기가 낮은 쪽으로 이동시키면서 최소값을 찾는 방법이다. (최소 cost&#x2F;loss를 찾는 방법)</li></ul><h2 id="Optimizer의-종류"><a href="#Optimizer의-종류" class="headerlink" title="Optimizer의 종류"></a>Optimizer의 종류</h2><ul><li>SGD(Stochastic Gradient Descent)</li><li>mini-batch SGD</li><li>Momentum</li><li>RMSprop</li><li>Adam</li></ul><h2 id="역전파-Backpropagation"><a href="#역전파-Backpropagation" class="headerlink" title="역전파(Backpropagation)"></a>역전파(Backpropagation)</h2><ul><li>연쇄 법칙(Chain Rule)을 신경망의 그래디언트 계산에 적용한 것</li></ul><h2 id="소프트-맥스-Softmax"><a href="#소프트-맥스-Softmax" class="headerlink" title="소프트 맥스(Softmax)"></a>소프트 맥스(Softmax)</h2><ul><li>소프트맥스 함수는 입력받은 값을 출력으로 0~1사이의 값으로 모두 정규화하며 출력 값들의 총합은 항상 1이 되는 특성을 가진 함수이다.</li><li>예측값을 확률값으로 변환</li><li>출력노드가 2개 이상일때</li></ul><h2 id="크로스엔트로피-Cross-Entropy"><a href="#크로스엔트로피-Cross-Entropy" class="headerlink" title="크로스엔트로피(Cross-Entropy)"></a>크로스엔트로피(Cross-Entropy)</h2><ul><li>모델에서 예측한 확률값이 실제값과 비교했을 때 틀릴 수 있는 정보량</li><li>cost function으로 사용</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.youtube.com/watch?v=d14TUNcbn1k">Lecture 4 | Introduction to Neural Networks</a></li><li><a href="https://aikorea.org/cs231n/optimization-2/">CS231n Convolutional Neural Networks for Visual Recognition kor</a></li><li><a href="https://cs231n.github.io/optimization-2/">CS231n Convolutional Neural Networks for Visual Recognition en</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-06-neural_networks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 9 계층형 설계 II</title>
      <link>https://sejoung.github.io/2024/02/2024-02-05-Grokking_Simplicity_9/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-05-Grokking_Simplicity_9/</guid>
      <pubDate>Mon, 05 Feb 2024 01:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-9-계층형-설계-II&quot;&gt;&lt;a href=&quot;#CHAPTER-9-계층형-설계-II&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 9 계층형 설계 II&quot;&gt;&lt;/a&gt;CHAPTER 9 계층형 설계 II&lt;/h1&gt;&lt;h2 i
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-9-계층형-설계-II"><a href="#CHAPTER-9-계층형-설계-II" class="headerlink" title="CHAPTER 9 계층형 설계 II"></a>CHAPTER 9 계층형 설계 II</h1><h2 id="계층형-설계-패턴"><a href="#계층형-설계-패턴" class="headerlink" title="계층형 설계 패턴"></a>계층형 설계 패턴</h2><ul><li>패턴 1: 직접구현</li><li>패턴 2: 추상화 벽</li><li>패턴 3: 작은 인터페이스</li><li>패턴 4: 편리한 계층</li></ul><h2 id="패턴-2-추상화-벽"><a href="#패턴-2-추상화-벽" class="headerlink" title="패턴 2: 추상화 벽"></a>패턴 2: 추상화 벽</h2><p>추상화의 벽(abstraction barrier)은 세부 구현을 감춘 함수로 이루어진 계층<br>팀 간 책임을 명확하게 나누는 것</p><h2 id="세부적인-것을-감추는-것은-대칭적입니다"><a href="#세부적인-것을-감추는-것은-대칭적입니다" class="headerlink" title="세부적인 것을 감추는 것은 대칭적입니다"></a>세부적인 것을 감추는 것은 대칭적입니다</h2><p>추상화의 벽이 잘작동 하면 세부사항 변경에 다른 팀은 알 필요가 없다</p><h2 id="추상화-벽이-있으면-구체적인-것을-신경-쓰지-않아도-됩니다"><a href="#추상화-벽이-있으면-구체적인-것을-신경-쓰지-않아도-됩니다" class="headerlink" title="추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됩니다"></a>추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됩니다</h2><p>추상화 벽은 필요하지 않은 것은 무시할 수 있도록 간접적인 단계를 만듭니다</p><h2 id="추상화-벽은-언제-사용하면-좋을까요"><a href="#추상화-벽은-언제-사용하면-좋을까요" class="headerlink" title="추상화 벽은 언제 사용하면 좋을까요?"></a>추상화 벽은 언제 사용하면 좋을까요?</h2><ul><li>쉽게 구현을 바꾸기 위해</li><li>코드를 읽고 쓰기 쉽게 만들기 위해</li><li>팀 간에 조율해야 할 것을 줄이기 위해</li><li>주어진 문제에 집중하기 위해</li></ul><h2 id="패턴-3-작은-인터페이스"><a href="#패턴-3-작은-인터페이스" class="headerlink" title="패턴 3: 작은 인터페이스"></a>패턴 3: 작은 인터페이스</h2><ul><li>추상화 벽에 만든 함수는 인터페이스라고 생각 할 수 있다</li><li>함수 목적에 맞는 계층이 어디인지 찾는 감각을 기르는 것이 가장 중요하다</li></ul><h2 id="패턴-4-편리한-계층"><a href="#패턴-4-편리한-계층" class="headerlink" title="패턴 4: 편리한 계층"></a>패턴 4: 편리한 계층</h2><p>편리한 계층(comfortable layer)은 계층을 추가하는 것이 좋은 이유를 찾는 것</p><p>지금 편리한지 생각하고 편리하면 설계를 멈춘다</p><h2 id="그래프로-알-수-있는-코드에-대한-정보는-무엇이-있을까요"><a href="#그래프로-알-수-있는-코드에-대한-정보는-무엇이-있을까요" class="headerlink" title="그래프로 알 수 있는 코드에 대한 정보는 무엇이 있을까요?"></a>그래프로 알 수 있는 코드에 대한 정보는 무엇이 있을까요?</h2><p>호출 그래프로 알수 있는 세 가지 비기능적 요구사항</p><ul><li>유지보수성</li><li>테스트성</li><li>재사용성</li></ul><h2 id="그래프의-가장-위에-있는-코드가-고치기-가장-쉽습니다"><a href="#그래프의-가장-위에-있는-코드가-고치기-가장-쉽습니다" class="headerlink" title="그래프의 가장 위에 있는 코드가 고치기 가장 쉽습니다"></a>그래프의 가장 위에 있는 코드가 고치기 가장 쉽습니다</h2><h2 id="아래에-있는-코드는-테스트가-중요합니다"><a href="#아래에-있는-코드는-테스트가-중요합니다" class="headerlink" title="아래에 있는 코드는 테스트가 중요합니다"></a>아래에 있는 코드는 테스트가 중요합니다</h2><h2 id="아래에-있는-코드가-재사용하기-더-좋습니다"><a href="#아래에-있는-코드가-재사용하기-더-좋습니다" class="headerlink" title="아래에 있는 코드가 재사용하기 더 좋습니다"></a>아래에 있는 코드가 재사용하기 더 좋습니다</h2><h2 id="요약-그래프가-코드에-대해-알려주는-것"><a href="#요약-그래프가-코드에-대해-알려주는-것" class="headerlink" title="요약: 그래프가 코드에 대해 알려주는 것"></a>요약: 그래프가 코드에 대해 알려주는 것</h2><ul><li>유지보수성<ul><li>위로 연결된 것이 적은 함수가 바꾸기 쉽다</li></ul></li><li>테스트성<ul><li>위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있다</li></ul></li><li>재사용성<ul><li>아래쪽에 함수가 적을수록 더 재사용하기 좋다</li></ul></li></ul><p>낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-05-Grokking_Simplicity_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 8 계층형 설계 I</title>
      <link>https://sejoung.github.io/2024/02/2024-02-02-Grokking_Simplicity_8/</link>
      <guid>https://sejoung.github.io/2024/02/2024-02-02-Grokking_Simplicity_8/</guid>
      <pubDate>Fri, 02 Feb 2024 02:01:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-8-계층형-설계-I&quot;&gt;&lt;a href=&quot;#CHAPTER-8-계층형-설계-I&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 8 계층형 설계 I&quot;&gt;&lt;/a&gt;CHAPTER 8 계층형 설계 I&lt;/h1&gt;&lt;h2 id=&quot;소
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-8-계층형-설계-I"><a href="#CHAPTER-8-계층형-설계-I" class="headerlink" title="CHAPTER 8 계층형 설계 I"></a>CHAPTER 8 계층형 설계 I</h1><h2 id="소프트웨어-설계란-무엇입니까"><a href="#소프트웨어-설계란-무엇입니까" class="headerlink" title="소프트웨어 설계란 무엇입니까?"></a>소프트웨어 설계란 무엇입니까?</h2><ul><li>소프트 웨어 설계 : 코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것</li></ul><h2 id="계층형-설계란-무엇인가요"><a href="#계층형-설계란-무엇인가요" class="headerlink" title="계층형 설계란 무엇인가요?"></a>계층형 설계란 무엇인가요?</h2><ul><li>계층형 설계는 소프트웨어를 계층으로 구성하는 기술<ul><li>각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의</li></ul></li></ul><h2 id="설계-감각을-키우기"><a href="#설계-감각을-키우기" class="headerlink" title="설계 감각을 키우기"></a>설계 감각을 키우기</h2><ul><li>전문가의 저주<ul><li>전문가는 자신의 지식을 다른 사람에게 전달하기 어렵다.</li></ul></li></ul><h2 id="계층형-설계-패턴"><a href="#계층형-설계-패턴" class="headerlink" title="계층형 설계 패턴"></a>계층형 설계 패턴</h2><ul><li>패턴 1: 직접 구현<ul><li>함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다</li></ul></li><li>패턴 2: 추상화의 벽<ul><li>중요한 세부 구현을 감추고 인터페이스로 제공한다</li></ul></li><li>패턴 3: 작은 인터페이스<ul><li>중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다</li></ul></li><li>패턴 4: 편리한 계층<ul><li>그냥 좋아서 계층을 추가하면 안됨 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다</li></ul></li></ul><h2 id="패턴-1-직접-구현"><a href="#패턴-1-직접-구현" class="headerlink" title="패턴 1: 직접 구현"></a>패턴 1: 직접 구현</h2><p>같은 계층에 있는 함수는 같은 목적을 가져야 한다</p><h2 id="3단계-줌-레벨"><a href="#3단계-줌-레벨" class="headerlink" title="3단계 줌 레벨"></a>3단계 줌 레벨</h2><ul><li>전역 줌 레벨<ul><li>전역 줌 레벨로 그래프 전체 중 필요한 부분을 살펴볼 수 있다</li><li>함수가 가르키는 화살표를 계층간에 비교할 수 있다</li></ul></li><li>계층 줌 레벨<ul><li>한계층과 연결된 바로 아래 계층을 볼수 있는 줌레벨</li><li>함수 하나가 가진 화살표를 비교 할수 있다</li></ul></li><li>함수 줌 레벨<ul><li>함수 하나와 바로 아래 연결된 함수들을 볼 수 있다</li></ul></li></ul><h2 id="직접-구현-패턴-리뷰"><a href="#직접-구현-패턴-리뷰" class="headerlink" title="직접 구현 패턴 리뷰"></a>직접 구현 패턴 리뷰</h2><ul><li>직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결합니다</li><li>계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와줍니다</li><li>호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다</li><li>함수를 추출하면 더 일반적인 함수로 만들수 있다</li><li>일반적인 함수가 많을수록 재사용하기 좋다</li><li>복잡성을 감추지 않는다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/02/2024-02-02-Grokking_Simplicity_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/</guid>
      <pubDate>Mon, 29 Jan 2024 05:01:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기&quot;&gt;&lt;a href=&quot;#CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 7 신뢰할 수 없는 코드를 쓰
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기"><a href="#CHAPTER-7-신뢰할-수-없는-코드를-쓰면서-불변성-지키기" class="headerlink" title="CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기"></a>CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기</h1><h2 id="레거시-코드와-불변성"><a href="#레거시-코드와-불변성" class="headerlink" title="레거시 코드와 불변성"></a>레거시 코드와 불변성</h2><p>방어적 복사 : 카피-온-라이트 원칙을 지키면서 안전하게 함수를 사용할수 있는 다른 원칙 </p><h2 id="우리가-만든-카피-온-라이트-코드는-신뢰할-수-없는-코드와-상호작용해야-합니다"><a href="#우리가-만든-카피-온-라이트-코드는-신뢰할-수-없는-코드와-상호작용해야-합니다" class="headerlink" title="우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다"></a>우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다</h2><p>모든 코드는 불변성이 지켜지는 안전지대에 있다</p><p>안전지대 밖으로 나가는 데이터는 바뀔수도 있다. 신뢰할 수 없는 코드가 데이터를 바꿀수 있기 때문이다<br>불변성을 지키면서 데이터를 주고 받는 법을 찾아야된다</p><p>레거시 코드를 바꿀수 없을때 방어적 복사를 사용할수도 있다</p><h2 id="방어적-복사는-원본이-바뀌는-것을-막아-줍니다"><a href="#방어적-복사는-원본이-바뀌는-것을-막아-줍니다" class="headerlink" title="방어적 복사는 원본이 바뀌는 것을 막아 줍니다"></a>방어적 복사는 원본이 바뀌는 것을 막아 줍니다</h2><p>들어오고 나가는 데이터의 복사본을 만드는 것이 방어적 복사가 동작하는 방식</p><h2 id="방어적-복사-구현하기"><a href="#방어적-복사-구현하기" class="headerlink" title="방어적 복사 구현하기"></a>방어적 복사 구현하기</h2><p>복사할때는 깊은 복사를 사용해야 된다</p><h2 id="방어적-복사-규칙"><a href="#방어적-복사-규칙" class="headerlink" title="방어적 복사 규칙"></a>방어적 복사 규칙</h2><ul><li>데이터가 안전한 코드에서 나갈 때 복사하기<ul><li>불변성 데이터를 위한 깊은 복사본을 만든다</li><li>신뢰할 수 없는 코드로 복사본을 전달한다</li></ul></li><li>안전한 코드로 데이터가 들어올 때 복사하기<ul><li>변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다</li><li>복사본을 안전한 코드에서 사용한다</li></ul></li></ul><h2 id="신뢰할-수-없는-코드-감싸기"><a href="#신뢰할-수-없는-코드-감싸기" class="headerlink" title="신뢰할 수 없는 코드 감싸기"></a>신뢰할 수 없는 코드 감싸기</h2><p>방어적 복사 코드를 분리해 새로운 함수로 만들어 두면 좋다</p><h2 id="방어적-복사가-익숙할-수도-있습니다"><a href="#방어적-복사가-익숙할-수도-있습니다" class="headerlink" title="방어적 복사가 익숙할 수도 있습니다"></a>방어적 복사가 익숙할 수도 있습니다</h2><ul><li>웹 API속에 방어적 복사<ul><li>JSON 으로 데이터를 주고 받을 때</li></ul></li><li>얼랭과 엘릭서에서 방어적 복사<ul><li>서로 메시지를 주고 받을때</li></ul></li></ul><h2 id="카피-온-라이트와-방어적-복사를-비교해-봅시다"><a href="#카피-온-라이트와-방어적-복사를-비교해-봅시다" class="headerlink" title="카피-온-라이트와 방어적 복사를 비교해 봅시다"></a>카피-온-라이트와 방어적 복사를 비교해 봅시다</h2><h3 id="카피-온-라이트"><a href="#카피-온-라이트" class="headerlink" title="카피-온-라이트"></a>카피-온-라이트</h3><p>언제 쓰나요?</p><ul><li>통제할수 있는 데이터를 바꿀때</li></ul><p>어디서 쓰나요?</p><ul><li>안전지대 어디에서나?</li></ul><p>복사방식</p><ul><li>얕은복사</li></ul><p>규칙</p><ul><li>바꿀 데이터의 얕은 복사를 만든다</li><li>복사본을 변경한다</li><li>복사본을 리턴한다</li></ul><h3 id="방어적-복사"><a href="#방어적-복사" class="headerlink" title="방어적 복사"></a>방어적 복사</h3><p>언제 쓰나요?</p><ul><li>신뢰할 수 없는 코드와 데이터를 주고받아야 할때<br>어디서 쓰나요?</li><li>안전지대의 경계에서 데이터가 오고 갈 때<br>복사방식</li><li>깊은 복사<br>규칙</li><li>안전지대로 들어오는 데이터에 깊은 복사를 만듬</li><li>안전지대에서 나가는 데이터에 깊은 복사를 만듬</li></ul><h2 id="깊은-복사는-얕은-복사보다-비쌉니다"><a href="#깊은-복사는-얕은-복사보다-비쌉니다" class="headerlink" title="깊은 복사는 얕은 복사보다 비쌉니다"></a>깊은 복사는 얕은 복사보다 비쌉니다</h2><p>깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는것이 얕은 복사와 차이점</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-29-Grokking_Simplicity_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/</guid>
      <pubDate>Fri, 26 Jan 2024 00:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기&quot;&gt;&lt;a href=&quot;#CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 6 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기"><a href="#CHAPTER-6-변경-가능한-데이터-구조를-가진-언어에서-불변성-유지하기" class="headerlink" title="CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기"></a>CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기</h1><h2 id="동작을-읽기-쓰기-또는-둘-다로-분류하기"><a href="#동작을-읽기-쓰기-또는-둘-다로-분류하기" class="headerlink" title="동작을 읽기, 쓰기 또는 둘 다로 분류하기"></a>동작을 읽기, 쓰기 또는 둘 다로 분류하기</h2><p>쓰기 동작은 불변성원칙에 따라 구현해야 한다<br>불변성 원칙은 카피-온-라이트(Copy-On-Write)라고 한다</p><h2 id="카피-온-라이트-원칙-세-단계"><a href="#카피-온-라이트-원칙-세-단계" class="headerlink" title="카피-온-라이트 원칙 세 단계"></a>카피-온-라이트 원칙 세 단계</h2><ul><li>복사본 만들기</li><li>복사본 변경하기</li><li>복사본 리턴하기</li></ul><h2 id="쓰기를-하면서-읽기도-하는-동작은-어떻게-해야-할까요"><a href="#쓰기를-하면서-읽기도-하는-동작은-어떻게-해야-할까요" class="headerlink" title="쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요?"></a>쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요?</h2><ul><li>읽기와 쓰기 함수로 각각 분리한다</li><li>함수에서 값을 두개 리턴한다</li></ul><h2 id="쓰면서-읽기도-하는-함수를-분리하기"><a href="#쓰면서-읽기도-하는-함수를-분리하기" class="headerlink" title="쓰면서 읽기도 하는 함수를 분리하기"></a>쓰면서 읽기도 하는 함수를 분리하기</h2><ul><li>읽기와 쓰기 동작으로 분리</li><li>쓰기 동작을 카피-온-라이트로 바꾸기</li></ul><h2 id="값을-두-개-리턴하는-함수로-만들기"><a href="#값을-두-개-리턴하는-함수로-만들기" class="headerlink" title="값을 두 개 리턴하는 함수로 만들기"></a>값을 두 개 리턴하는 함수로 만들기</h2><ul><li>동작 감싸기</li><li>읽으면서 쓰기도 하는 함수를 읽기 함수로 바꾸기</li><li>다른방법<ul><li>첫번째 접근방법(함수 분리)을 사용해 두값을 객체로 조합하는 방법</li></ul></li></ul><h2 id="불변-데이터-구조를-읽는-것은-계산입니다"><a href="#불변-데이터-구조를-읽는-것은-계산입니다" class="headerlink" title="불변 데이터 구조를 읽는 것은 계산입니다"></a>불변 데이터 구조를 읽는 것은 계산입니다</h2><ul><li>변경 가능한 데이터를 읽는 것은 액션</li><li>쓰기는 데이터를 변경 가능한 구조로 만듬</li><li>어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터</li><li>불변 데이터 구조를 읽는 것은 계산</li><li>쓰기를 읽기로 바꾸면 코드에 계산이 많아짐</li></ul><h2 id="애플리케이션에는-시간에-따라-변하는-상태가-있습니다"><a href="#애플리케이션에는-시간에-따라-변하는-상태가-있습니다" class="headerlink" title="애플리케이션에는 시간에 따라 변하는 상태가 있습니다"></a>애플리케이션에는 시간에 따라 변하는 상태가 있습니다</h2><h2 id="불변-데이터-구조는-충분히-빠릅니다"><a href="#불변-데이터-구조는-충분히-빠릅니다" class="headerlink" title="불변 데이터 구조는 충분히 빠릅니다"></a>불변 데이터 구조는 충분히 빠릅니다</h2><p>일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다<br>하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다<br>이런 사례는 불변 데이터도 충분히 빠르다는 증거 입니다</p><ul><li>언제든 최적화할 수 있다</li><li>가비지 콜렉터는 매우 빠르다</li><li>생각보다 많이 복사하지 않다<ul><li>얕은 복사(Shallow Copy) : 데이터의 최상위 단계만 복사</li><li>얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다 이것은 구조적 공유(Structural Sharing)라고 한다</li><li>앝은 복사는 공유된 복사본이 변경되지 않는한 안전하다</li></ul></li><li>함수형 프로그래밍 언어에는 빠른 구현체가 있다</li></ul><h3 id="앝은-복사를-구조적-복사라고-하는-이유"><a href="#앝은-복사를-구조적-복사라고-하는-이유" class="headerlink" title="앝은 복사를 구조적 복사라고 하는 이유"></a>앝은 복사를 구조적 복사라고 하는 이유</h3><p>아래처럼 최상위는 정상적으로 복사 된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = [<span class="string">&quot;beni&quot;</span>, <span class="string">&quot;hans&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> copy = original.<span class="title function_">slice</span>();</span><br><span class="line">original.<span class="title function_">push</span>(<span class="string">&quot;grace&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">// [ &#x27;beni&#x27;, &#x27;hans&#x27;, &#x27;grace&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">// [ &#x27;beni&#x27;, &#x27;hans&#x27; ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;<span class="attr">name</span>: <span class="string">&quot;beni&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">custom</span>: [&#123;<span class="attr">hair</span>: <span class="string">&quot;black&quot;</span>, <span class="attr">eyes</span>: <span class="string">&quot;brown&quot;</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br><span class="line">copy.<span class="property">name</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;brown&#x27; &#125; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">//&#123; name: &#x27;black&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;brown&#x27; &#125; ] &#125;</span></span><br></pre></td></tr></table></figure><p>아래처럼 하지만 하위 값은 복사가 안된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;<span class="attr">name</span>: <span class="string">&quot;beni&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">custom</span>: [&#123;<span class="attr">hair</span>: <span class="string">&quot;black&quot;</span>, <span class="attr">eyes</span>: <span class="string">&quot;brown&quot;</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br><span class="line">copy.<span class="property">custom</span>[<span class="number">0</span>].<span class="property">eyes</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;black&#x27; &#125; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy);<span class="comment">//&#123; name: &#x27;beni&#x27;, age: 30, custom: [ &#123; hair: &#x27;black&#x27;, eyes: &#x27;black&#x27; &#125; ] &#125;</span></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-26-Grokking_Simplicity_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 5 더 좋은 액션 만들기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/</guid>
      <pubDate>Thu, 25 Jan 2024 00:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-5-더-좋은-액션-만들기&quot;&gt;&lt;a href=&quot;#CHAPTER-5-더-좋은-액션-만들기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 5 더 좋은 액션 만들기&quot;&gt;&lt;/a&gt;CHAPTER 5 더 좋은 액션 만들기&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-5-더-좋은-액션-만들기"><a href="#CHAPTER-5-더-좋은-액션-만들기" class="headerlink" title="CHAPTER 5 더 좋은 액션 만들기"></a>CHAPTER 5 더 좋은 액션 만들기</h1><h2 id="비즈니스-요구-사항과-설계를-맞추기"><a href="#비즈니스-요구-사항과-설계를-맞추기" class="headerlink" title="비즈니스 요구 사항과 설계를 맞추기"></a>비즈니스 요구 사항과 설계를 맞추기</h2><p>액션에서 계산으로 리팩터링하는 과정은 단순하고 기계적이였다</p><p>기계적인 리팩터링이 항상 최선의 구조를 만들어 주는 것은 아니다<br>좋은 구조를 만들기 위해서 사람의 손길이 필요하다</p><p>중복이 항상 나쁜것은 아니지만 코드에서 나는 냄새이다. 코드 냄새는 나중에 문제가 될수도 있다</p><h2 id="비즈니스-요구-사항과-함수를-맞추기"><a href="#비즈니스-요구-사항과-함수를-맞추기" class="headerlink" title="비즈니스 요구 사항과 함수를 맞추기"></a>비즈니스 요구 사항과 함수를 맞추기</h2><p>함수의 동작을 바꿨기 때문에 엄밀히 말하면 리팩터링이라고 할 수 없다</p><h2 id="원칙-암묵적-입력과-출력은-적을수록-좋습니다"><a href="#원칙-암묵적-입력과-출력은-적을수록-좋습니다" class="headerlink" title="원칙: 암묵적 입력과 출력은 적을수록 좋습니다"></a>원칙: 암묵적 입력과 출력은 적을수록 좋습니다</h2><ul><li>계산 : 암묵적 입력과 출력이 없는 함수</li></ul><p>어떤 함수에 암묵적 입력과 출력이 있다면 다른 컴포넌트와 강하게 연결된 컴포넌트라고 할 수 있다<br>다른 곳에서 사용할 수 없기 때문에 모듈이 아니다</p><h2 id="계산-분류하기"><a href="#계산-분류하기" class="headerlink" title="계산 분류하기"></a>계산 분류하기</h2><p>계층을 구분해보자 비지니스 규칙과 나머지 동작을 구분해보면 힌트가 될수도 있다</p><h2 id="원칙-설계는-엉켜있는-코드를-푸는-것이다"><a href="#원칙-설계는-엉켜있는-코드를-푸는-것이다" class="headerlink" title="원칙: 설계는 엉켜있는 코드를 푸는 것이다"></a>원칙: 설계는 엉켜있는 코드를 푸는 것이다</h2><ul><li>재사용하기 쉽다</li><li>유지보수하기 쉽다</li><li>테스트하기 쉽다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-25-Grokking_Simplicity_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 4 액션에서 계산 빼내기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/</guid>
      <pubDate>Wed, 24 Jan 2024 00:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-4-액션에서-계산-빼내기&quot;&gt;&lt;a href=&quot;#CHAPTER-4-액션에서-계산-빼내기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 4 액션에서 계산 빼내기&quot;&gt;&lt;/a&gt;CHAPTER 4 액션에서 계산 빼내기&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-4-액션에서-계산-빼내기"><a href="#CHAPTER-4-액션에서-계산-빼내기" class="headerlink" title="CHAPTER 4 액션에서 계산 빼내기"></a>CHAPTER 4 액션에서 계산 빼내기</h1><h2 id="테스트하기-쉽게-만들기"><a href="#테스트하기-쉽게-만들기" class="headerlink" title="테스트하기 쉽게 만들기"></a>테스트하기 쉽게 만들기</h2><ul><li>DOM 업데이트와 비즈니스 규칙은 분리되어야 한다</li><li>전역변수가 없어야 한다</li></ul><h2 id="재사용하기-쉽게-만들기"><a href="#재사용하기-쉽게-만들기" class="headerlink" title="재사용하기 쉽게 만들기"></a>재사용하기 쉽게 만들기</h2><ul><li>전역변수에 의존하지 않아야 한다</li><li>DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안됩니다</li><li>함수가 결과값을 리턴해야 한다<h2 id="함수에는-입력과-출력이-있습니다"><a href="#함수에는-입력과-출력이-있습니다" class="headerlink" title="함수에는 입력과 출력이 있습니다"></a>함수에는 입력과 출력이 있습니다</h2></li><li>입력은 함수가 계산을 하기 위한 외부정보</li><li>출력은 함수 밖으로 나오는 정보나 어떤 동작</li></ul><p>입력과 출력은 명시적이거나 암묵적일 수 있다</p><p>함수의 암묵적 입력과 출력이 있으면 액션이 된다</p><h2 id="테스트와-재사용성은-입출력과-관련-있습니다"><a href="#테스트와-재사용성은-입출력과-관련-있습니다" class="headerlink" title="테스트와 재사용성은 입출력과 관련 있습니다"></a>테스트와 재사용성은 입출력과 관련 있습니다</h2><ul><li>DOM 업데이트와 비즈니스 규칙은 분리되어야 한다</li><li>전역변수가 없어야 한다</li><li>전역변수에 의존하지 않아야 한다</li><li>DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안됩니다</li><li>함수가 결과값을 리턴해야 한다<ul><li>암묵적 출력 대신 명시적 출력을 사용하자</li></ul></li></ul><h2 id="액션에서-계산-빼내기"><a href="#액션에서-계산-빼내기" class="headerlink" title="액션에서 계산 빼내기"></a>액션에서 계산 빼내기</h2><ul><li>서브루틴 추출하기</li><li>암묵적 입출력 제거<ul><li>명시적으로 표현</li></ul></li></ul><h2 id="계산-추출을-단계별로-알아보기"><a href="#계산-추출을-단계별로-알아보기" class="headerlink" title="계산 추출을 단계별로 알아보기"></a>계산 추출을 단계별로 알아보기</h2><ul><li>계산 코드를 찾아 빼낸다</li><li>새 함수에 암묵적 입력과 출력을 찾는다</li><li>암묵적 입력은 인자로 암묵적 출력은 리턴값으로 바꿉니다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-24-Grokking_Simplicity_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 3 액션과 계산, 데이터의 차이를 알기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/</guid>
      <pubDate>Tue, 23 Jan 2024 00:47:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-3-액션과-계산-데이터의-차이를-알기&quot;&gt;&lt;a href=&quot;#CHAPTER-3-액션과-계산-데이터의-차이를-알기&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 3 액션과 계산, 데이터의 차이를 알기&quot;&gt;&lt;/a&gt;C
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-3-액션과-계산-데이터의-차이를-알기"><a href="#CHAPTER-3-액션과-계산-데이터의-차이를-알기" class="headerlink" title="CHAPTER 3 액션과 계산, 데이터의 차이를 알기"></a>CHAPTER 3 액션과 계산, 데이터의 차이를 알기</h1><p>일반적으로 코드에 액션이 너무 많이 사용되고 있는 반면에 계산은 거의 찾아보기 힘든 이유를 알수 있다</p><h2 id="액션과-계산-데이터"><a href="#액션과-계산-데이터" class="headerlink" title="액션과 계산, 데이터"></a>액션과 계산, 데이터</h2><p>함수형 프로그래머는 액션 계산 데이터를 구분한다</p><h3 id="문제에-대해-생각할-때"><a href="#문제에-대해-생각할-때" class="headerlink" title="문제에 대해 생각할 때"></a>문제에 대해 생각할 때</h3><p>문제에 대해 고민하고 있을 때도 문제를 액션과 계산 데이터로 나눠 생각해 볼 수 있다</p><h3 id="코딩할떄"><a href="#코딩할떄" class="headerlink" title="코딩할떄"></a>코딩할떄</h3><p>함수형 프로그래머는 최대한 액션에서 계산을 빼내려고 한다<br>또 계산에서는 데이터를 분리할 수 있는지 생각한다<br>더 나아가 액션이 계산이 될수 있는지 계산이 데이터가 될수 있는지 생각한다</p><h3 id="코드를-읽을-때"><a href="#코드를-읽을-때" class="headerlink" title="코드를 읽을 때"></a>코드를 읽을 때</h3><p>함수형 프로그래머는 더 좋은 코드를 만들기 위해 이미 있는 코드를 액션과 계산, 데이터로 리팩터링하는 방법을 찾을것이다</p><h2 id="액션과-계산-데이터는-어디에나-적용할-수-있습니다"><a href="#액션과-계산-데이터는-어디에나-적용할-수-있습니다" class="headerlink" title="액션과 계산, 데이터는 어디에나 적용할 수 있습니다"></a>액션과 계산, 데이터는 어디에나 적용할 수 있습니다</h2><h3 id="냉장고-확인하기"><a href="#냉장고-확인하기" class="headerlink" title="냉장고 확인하기"></a>냉장고 확인하기</h3><p>냉장고를 확인하는 일은 시점이 중요하기 때문에 액션이다<br>냉장고가 가지고 있는 제품은 데이터이다</p><h3 id="운전해서-상점으로-가기"><a href="#운전해서-상점으로-가기" class="headerlink" title="운전해서 상점으로 가기"></a>운전해서 상점으로 가기</h3><p>운전해서 상점으로 가는 것은 복잡한 행동이고 시점이 중요하기 때문에 액션이다<br>사실 여기엔 데이터가 숨어 있다 상점 위치나 가는 경로</p><h3 id="필요한-것-구입하기"><a href="#필요한-것-구입하기" class="headerlink" title="필요한 것 구입하기"></a>필요한 것 구입하기</h3><p>구입하는 일도 확실히 액션이다 하지만 구입하기를 몇단계로 나눠 생각해보면 계산과 데이터로 나눠 생각할 수 있다</p><p>현재 재고(데이터) -&gt; 필요한 재고(데이터) -&gt; 재고 빼기(계산) -&gt; 장보기 목록(데이터) -&gt; 목록에 있는 것 구입하기(액션)</p><p>액션과 계산, 데이터를 더 명확하게 하기 위해 액션과 계산, 데이터에 해당하는 단계를 각각 다른 열에 그려서 선으로 연결해보면 어느정도 보인다</p><h2 id="장보기-과정에서-배운-것"><a href="#장보기-과정에서-배운-것" class="headerlink" title="장보기 과정에서 배운 것"></a>장보기 과정에서 배운 것</h2><ul><li>액션과 계산, 데이터는 어디에나 적용할수 있다</li><li>액션 안에는 계산과 데이터 또 다른 액션이 숨어 있을지도 모른다</li><li>계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다</li><li>데이터는 데이터만 조합할 수 있다</li><li>계산은 때로 우리 머리속에서 일어난다<ul><li>계산이 잘보이지 않는 이유는 계싼이 우리 사고 과정에 녹아 있어서</li></ul></li></ul><h2 id="쿠폰-보내는-과정을-그려보기"><a href="#쿠폰-보내는-과정을-그려보기" class="headerlink" title="쿠폰 보내는 과정을 그려보기"></a>쿠폰 보내는 과정을 그려보기</h2><h3 id="데이터베이스에서-구독자를-가져오는-것부터-시작"><a href="#데이터베이스에서-구독자를-가져오는-것부터-시작" class="headerlink" title="데이터베이스에서 구독자를 가져오는 것부터 시작"></a>데이터베이스에서 구독자를 가져오는 것부터 시작</h3><p>이단계는 액션이다</p><h3 id="데이터베이스에서-쿠폰-목록-가져오기"><a href="#데이터베이스에서-쿠폰-목록-가져오기" class="headerlink" title="데이터베이스에서 쿠폰 목록 가져오기"></a>데이터베이스에서 쿠폰 목록 가져오기</h3><p>이것도 액션이다 </p><p>한번 가져온 쿠폰목록은 데이터이다</p><h3 id="보내야-할-이메일-목록-만들기"><a href="#보내야-할-이메일-목록-만들기" class="headerlink" title="보내야 할 이메일 목록 만들기"></a>보내야 할 이메일 목록 만들기</h3><p>이메일 목록 계획하기에서 생성된 이메일 목록은 다음 단계에서 사용할 데이터이다</p><h3 id="이메일-전송하기"><a href="#이메일-전송하기" class="headerlink" title="이메일 전송하기"></a>이메일 전송하기</h3><p>이메일 전송은 간단하다 목록을 미리 만들어서 목록을 순회하면서 그냥 보내면 된다</p><h3 id="이메일-만들는-부분-자세히-살펴보기"><a href="#이메일-만들는-부분-자세히-살펴보기" class="headerlink" title="이메일 만들는 부분 자세히 살펴보기"></a>이메일 만들는 부분 자세히 살펴보기</h3><ul><li>왜 계산을 만드냐?<ul><li>가능한 계산을 사용하려고 하는 이유는 테스트하기 쉽기 때문</li></ul></li></ul><h2 id="쿠폰-보내는-과정-구현하기"><a href="#쿠폰-보내는-과정-구현하기" class="headerlink" title="쿠폰 보내는 과정 구현하기"></a>쿠폰 보내는 과정 구현하기</h2><h3 id="테이터베이스에서-가져온-구독자-데이터"><a href="#테이터베이스에서-가져온-구독자-데이터" class="headerlink" title="테이터베이스에서 가져온 구독자 데이터"></a>테이터베이스에서 가져온 구독자 데이터</h3><p>데이터는 언어에서 제공하는 단순한 데이터 타입으로 표현한다. 언어에서 제공하는 데이터 타입은 알아보기 쉽고 사용하려고 하는 목적에도 잘 맞는다</p><h3 id="쿠폰-등급은-문자열입니다"><a href="#쿠폰-등급은-문자열입니다" class="headerlink" title="쿠폰 등급은 문자열입니다"></a>쿠폰 등급은 문자열입니다</h3><p>쿠폰 등급은 문자열로 표현한다 다른 타입을 써도 좋지만 문자열이 편하다</p><h3 id="쿠폰-등급을-결정하는-것은-함수이다"><a href="#쿠폰-등급을-결정하는-것은-함수이다" class="headerlink" title="쿠폰 등급을 결정하는 것은 함수이다"></a>쿠폰 등급을 결정하는 것은 함수이다</h3><p>계산은 함수로 구현된다. 입력값은 함수 인자이고 출력값은 함수의 리턴값이다</p><h3 id="데이터베이스에서-가져온-쿠폰-데이터"><a href="#데이터베이스에서-가져온-쿠폰-데이터" class="headerlink" title="데이터베이스에서 가져온 쿠폰 데이터"></a>데이터베이스에서 가져온 쿠폰 데이터</h3><p>자바스크립트 객체로 표현할수 있다</p><h3 id="특정-등급의-쿠폰-목록을-선택하는-계산은-함수-입니다"><a href="#특정-등급의-쿠폰-목록을-선택하는-계산은-함수-입니다" class="headerlink" title="특정 등급의 쿠폰 목록을 선택하는 계산은 함수 입니다"></a>특정 등급의 쿠폰 목록을 선택하는 계산은 함수 입니다</h3><p>특정 등급의 쿠폰 목록을 선택하는 계산도 함수로 구현</p><h3 id="이메일은-그냥-데이터-입니다"><a href="#이메일은-그냥-데이터-입니다" class="headerlink" title="이메일은 그냥 데이터 입니다"></a>이메일은 그냥 데이터 입니다</h3><p>데이터</p><h3 id="구독자가-받을-이메일을-계획하는-계산"><a href="#구독자가-받을-이메일을-계획하는-계산" class="headerlink" title="구독자가 받을 이메일을 계획하는 계산"></a>구독자가 받을 이메일을 계획하는 계산</h3><p>계산 </p><h3 id="보낼-이메일-목록-준비하기"><a href="#보낼-이메일-목록-준비하기" class="headerlink" title="보낼 이메일 목록 준비하기"></a>보낼 이메일 목록 준비하기</h3><p>계산</p><h3 id="이메일-보내기는-액션"><a href="#이메일-보내기는-액션" class="headerlink" title="이메일 보내기는 액션"></a>이메일 보내기는 액션</h3><p>액션</p><h3 id="일반적인-구현-순서"><a href="#일반적인-구현-순서" class="headerlink" title="일반적인 구현 순서"></a>일반적인 구현 순서</h3><p>데이터 -&gt; 계산 -&gt; 액션</p><p>계산은 보통 순수 함수(pure function) 또는 수학 함수(mathematical function)로 부른다</p><h2 id="이미-있는-코드에-함수형-사고-적용하기"><a href="#이미-있는-코드에-함수형-사고-적용하기" class="headerlink" title="이미 있는 코드에 함수형 사고 적용하기"></a>이미 있는 코드에 함수형 사고 적용하기</h2><h2 id="액션은-코드-전체로-퍼집니다"><a href="#액션은-코드-전체로-퍼집니다" class="headerlink" title="액션은 코드 전체로 퍼집니다"></a>액션은 코드 전체로 퍼집니다</h2><p>액션은 사용하기 참 어렵다. 액션을 부는 함수가 있다면 그함수도 액션이된다. 이렇게 액션은 코드 전체로 퍼집니다</p><h2 id="액션은-다양한-형태로-나타납니다"><a href="#액션은-다양한-형태로-나타납니다" class="headerlink" title="액션은 다양한 형태로 나타납니다"></a>액션은 다양한 형태로 나타납니다</h2><ul><li>함수호출</li><li>메서드 호출</li><li>생성자</li><li>표현식</li><li>상태</li></ul><p>액션은 보통 순수하지 않은 삼후(impure function) 또는 부수효과 함수(side effect function) 또는 부수효과가 있는 함수(function with side effect)라고 부른다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-23-Grokking_Simplicity_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 2 현실에서의 함수형 사고</title>
      <link>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</guid>
      <pubDate>Mon, 22 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-2-현실에서의-함수형-사고&quot;&gt;&lt;a href=&quot;#CHAPTER-2-현실에서의-함수형-사고&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 2 현실에서의 함수형 사고&quot;&gt;&lt;/a&gt;CHAPTER 2 현실에서의 함수형 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-2-현실에서의-함수형-사고"><a href="#CHAPTER-2-현실에서의-함수형-사고" class="headerlink" title="CHAPTER 2 현실에서의 함수형 사고"></a>CHAPTER 2 현실에서의 함수형 사고</h1><h2 id="토니-피자에-오신-것을-환영합니다"><a href="#토니-피자에-오신-것을-환영합니다" class="headerlink" title="토니 피자에 오신 것을 환영합니다"></a>토니 피자에 오신 것을 환영합니다</h2><p>계층형 설계(stratifed design)원칙이 어떤것인지 알아 본다</p><p>분산시스템을 이해 하려고 타임라인 다이어그램(timeline diagram)을 사용</p><h2 id="파트-I-액션과-계산-데이터"><a href="#파트-I-액션과-계산-데이터" class="headerlink" title="파트 I: 액션과 계산, 데이터"></a>파트 I: 액션과 계산, 데이터</h2><ul><li>액션: 호출 횟수와 시점에 의존하는 것</li><li>계산: 어떤 것을 결정하거나 계획하는 것은 계산 입니다</li><li>데이터: 유연하기 때문에 저장하거나 네트워크로 전송하는 등 다양하게 쓸 수 있다</li></ul><h2 id="변경-가능성에-따라-코드-나누기"><a href="#변경-가능성에-따라-코드-나누기" class="headerlink" title="변경 가능성에 따라 코드 나누기"></a>변경 가능성에 따라 코드 나누기</h2><p>계층형설계는 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눕니다</p><h2 id="파트-II-일급-추상"><a href="#파트-II-일급-추상" class="headerlink" title="파트 II: 일급 추상"></a>파트 II: 일급 추상</h2><p>타임라인 다이어 그램은 로봇 한대가 피가를 만들기 위한 액션들을 보여 줍니다</p><h2 id="분산-시스템을-타임라인으로-시각화하기"><a href="#분산-시스템을-타임라인으로-시각화하기" class="headerlink" title="분산 시스템을 타임라인으로 시각화하기"></a>분산 시스템을 타임라인으로 시각화하기</h2><p>분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모른다</p><h2 id="각각의-타임라인은-다른-순서로-실행됩니다"><a href="#각각의-타임라인은-다른-순서로-실행됩니다" class="headerlink" title="각각의 타임라인은 다른 순서로 실행됩니다"></a>각각의 타임라인은 다른 순서로 실행됩니다</h2><p>타입라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다</p><h2 id="어려운-경험을-통해-분산-시스템에-대해-배운-것"><a href="#어려운-경험을-통해-분산-시스템에-대해-배운-것" class="headerlink" title="어려운 경험을 통해 분산 시스템에 대해 배운 것"></a>어려운 경험을 통해 분산 시스템에 대해 배운 것</h2><ul><li>기본적으로 타임라인은 서로 순서를 맞추지 않습니다</li><li>액션이 실행되는 시간은 중요하지 않다</li><li>드물지만 타이밍이 어긋나는 경우는 실제 일어난다</li><li>타임라인 다이어그램으로 시스템의 문제를 알 수 있다</li></ul><h2 id="타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기"><a href="#타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기" class="headerlink" title="타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기"></a>타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기</h2><p>커팅(cutting) : 타임라인의 시간을 맞추는 작업</p><p>타임라인 커팅은 고차동작(higher-order operation)으로 구현 </p><h2 id="좋은-경험을-통해-타임라인에-대해-배운-것"><a href="#좋은-경험을-통해-타임라인에-대해-배운-것" class="headerlink" title="좋은 경험을 통해 타임라인에 대해 배운 것"></a>좋은 경험을 통해 타임라인에 대해 배운 것</h2><ul><li>타임라인 커팅으로 서로 다른 작업들을 쉽게 이해 할 수 있다</li><li>타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다</li><li>타임라인 다이어그램은 유연하다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</title>
      <link>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</guid>
      <pubDate>Fri, 19 Jan 2024 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot;&gt;&lt;a href=&quot;#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 1 쏙쏙 들어오는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다"><a href="#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다" class="headerlink" title="CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다"></a>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</h1><h2 id="함수형-프로그래밍은-무엇인가요"><a href="#함수형-프로그래밍은-무엇인가요" class="headerlink" title="함수형 프로그래밍은 무엇인가요?"></a>함수형 프로그래밍은 무엇인가요?</h2><p>함수형 프로그래밍(functional programming)</p><ul><li>수학 함수를 사용하고 부수 효과(side effect)를 피하는것이 특성인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수(pure function)만 사용하는 프로그래밍 패러다임</li></ul><p>부수 효과(side effect)</p><ul><li>함수가 리턴값 이외에 하는 모든 일을 말한다</li></ul><p>순수 함수(pure function)</p><ul><li>인자에만 의존하고 부수 효과가 없는 함수</li><li>수학 함수라 볼수 있다</li></ul><h2 id="실용적인-측면에서-함수형-프로그래밍-정의의-문제점"><a href="#실용적인-측면에서-함수형-프로그래밍-정의의-문제점" class="headerlink" title="실용적인 측면에서 함수형 프로그래밍 정의의 문제점"></a>실용적인 측면에서 함수형 프로그래밍 정의의 문제점</h2><p>함수형 프로그래밍</p><ul><li>수학 함수를 사용하고 부수 효과를 피하는것이 특징인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일</li></ul><h3 id="문제-1-부수-효과는-필요합니다"><a href="#문제-1-부수-효과는-필요합니다" class="headerlink" title="문제 1. 부수 효과는 필요합니다"></a>문제 1. 부수 효과는 필요합니다</h3><p>부수 효과는 소프트웨어를 실행하는 이유이다</p><h2 id="문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다"><a href="#문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다" class="headerlink" title="문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다"></a>문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다</h2><p>순수 함수만 쓰라는 것처럼 되어 있지만 순수하지 않은 함수도 사용합니다</p><h2 id="문제-3-함수형-프로그래밍은-실용적이다"><a href="#문제-3-함수형-프로그래밍은-실용적이다" class="headerlink" title="문제 3. 함수형 프로그래밍은 실용적이다"></a>문제 3. 함수형 프로그래밍은 실용적이다</h2><p>함수형 프로그래밍이 수학적이라 실제 소프트웨어 개발에서 사용하지 않는 것 처럼 느껴집니다</p><h2 id="함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기"><a href="#함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기" class="headerlink" title="함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기"></a>함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기</h2><p>중요한 기술 </p><ul><li>액션 action</li><li>계산 calculation</li><li>데이터 data</li></ul><h2 id="액션과-계산-데이터-구분하기"><a href="#액션과-계산-데이터-구분하기" class="headerlink" title="액션과 계산, 데이터 구분하기"></a>액션과 계산, 데이터 구분하기</h2><p>함수형 프로그래머는 직감적으로 코드를 세 분류로 나눈다</p><ul><li>액션</li><li>계산</li><li>데이터</li></ul><h2 id="함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다"><a href="#함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다"></a>함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다</h2><ul><li>액션: 호출하는 시점과 횟수에 의존한다</li><li>액션이 아닌 코드 : 호출하는 시점과 횟수에 의존하지 않는다</li></ul><h2 id="함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다"><a href="#함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다"></a>함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다</h2><p>계산 과 데이터는 둘다 부르는 시점이나 횟수가 중요하지 않다</p><ul><li>데이터 : 정적이고 보이는 그대로</li><li>계산 : 동적이고 보이지 않는다</li></ul><p>함수형 프로그래머는 코드를 액션과 계산 데이터로 구분</p><h2 id="함수형-프로그래머는-액션과-계산-데이터를-구분합니다"><a href="#함수형-프로그래머는-액션과-계산-데이터를-구분합니다" class="headerlink" title="함수형 프로그래머는 액션과 계산, 데이터를 구분합니다"></a>함수형 프로그래머는 액션과 계산, 데이터를 구분합니다</h2><h3 id="1단계-사용자가-작업-완료-표시를-함"><a href="#1단계-사용자가-작업-완료-표시를-함" class="headerlink" title="1단계: 사용자가 작업 완료 표시를 함"></a>1단계: 사용자가 작업 완료 표시를 함</h3><p>UI 이벤트인데 실행 횟수에 의존하기 때문에 액션입니다</p><h3 id="2단계-클라이언트가-서버로-메시지를-보냄"><a href="#2단계-클라이언트가-서버로-메시지를-보냄" class="headerlink" title="2단계: 클라이언트가 서버로 메시지를 보냄"></a>2단계: 클라이언트가 서버로 메시지를 보냄</h3><p>메시지를 보내는것도 액션이다<br>메시지 자체는 나중에 서버에서 해석해야 되는 값이기 때문에 데이터다</p><h3 id="3단계-서버가-메시지를-받음"><a href="#3단계-서버가-메시지를-받음" class="headerlink" title="3단계: 서버가 메시지를 받음"></a>3단계: 서버가 메시지를 받음</h3><p>메시지를 받는 횟수에 의존하므로 액션</p><h3 id="4단계-서버가-데이터-베이스를-변경"><a href="#4단계-서버가-데이터-베이스를-변경" class="headerlink" title="4단계: 서버가 데이터 베이스를 변경"></a>4단계: 서버가 데이터 베이스를 변경</h3><p>내부 상태를 바꾸는 것은 액션</p><h3 id="5단계-서버가-누구에서-알림을-보낼지-결정"><a href="#5단계-서버가-누구에서-알림을-보낼지-결정" class="headerlink" title="5단계: 서버가 누구에서 알림을 보낼지 결정"></a>5단계: 서버가 누구에서 알림을 보낼지 결정</h3><p>결정하는 것은 계산이다. 입력값이 같다면 서버는 항상 같은 결정을 내리기 때문</p><h3 id="6단계-서버가-이메일로-알림을-보냄"><a href="#6단계-서버가-이메일로-알림을-보냄" class="headerlink" title="6단계: 서버가 이메일로 알림을 보냄"></a>6단계: 서버가 이메일로 알림을 보냄</h3><p>이메일 보내기는 액션</p><h2 id="함수형-프로그래밍에서는-코드를-세-가지로-분류합니다"><a href="#함수형-프로그래밍에서는-코드를-세-가지로-분류합니다" class="headerlink" title="함수형 프로그래밍에서는 코드를 세 가지로 분류합니다"></a>함수형 프로그래밍에서는 코드를 세 가지로 분류합니다</h2><ul><li>액션<ul><li>호출하는 시점과 횟수에 둘다 의존한다</li></ul></li><li>계산<ul><li>입력값을 출력값으로 만드는 것</li></ul></li><li>데이터<ul><li>이벤트에 대해 기록한 사실<h2 id="액션-계산-데이터를-구분하면-어떤-장점이-있나요"><a href="#액션-계산-데이터를-구분하면-어떤-장점이-있나요" class="headerlink" title="액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?"></a>액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?</h2>요즘 유행하는 분산 시스템에 잘 어울린다</li></ul></li></ul><p>시간에 따라 바뀌는 값을 모델링 할때 동작 방법을 이해하는 것은 중요하지만 쉽지 않다<br>실행시점이나 횟수에 의존하는 코드를 없애면 코드를 더 쉽게 이해할수 있고 심각한 버그를 막을수 있다</p><p>데이터와 계산은 실행 시점이나 횟수에 의존하지 않는다</p><p>액션은 실행시점이나 횟수에 의존하지만 코드 전체에 영향을 주지 않도록 격리시키면 된다</p><h2 id="함수형-사고가-무엇인가요"><a href="#함수형-사고가-무엇인가요" class="headerlink" title="함수형 사고가 무엇인가요?"></a>함수형 사고가 무엇인가요?</h2><p>함수형 사고(functional thinking)</p><ul><li>액션, 계산, 데이터</li><li>일급 추상</li></ul><h2 id="이-책을-읽는-기본-규칙"><a href="#이-책을-읽는-기본-규칙" class="headerlink" title="이 책을 읽는 기본 규칙"></a>이 책을 읽는 기본 규칙</h2><ul><li>특정 언어 기능에 의존하지 않아야 한다</li><li>실용적이라 바로 쓸 수 있어야 한다</li><li>여러분의 현재 가지고 있는 코드와 관계 없이 쓸 수 있어야 된다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장. 단위 테스트 안티 패턴</title>
      <link>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</guid>
      <pubDate>Thu, 18 Jan 2024 01:39:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-단위-테스트-안티-패턴&quot;&gt;&lt;a href=&quot;#11장-단위-테스트-안티-패턴&quot; class=&quot;headerlink&quot; title=&quot;11장. 단위 테스트 안티 패턴&quot;&gt;&lt;/a&gt;11장. 단위 테스트 안티 패턴&lt;/h1&gt;&lt;h2 id=&quot;비공개-메서드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-단위-테스트-안티-패턴"><a href="#11장-단위-테스트-안티-패턴" class="headerlink" title="11장. 단위 테스트 안티 패턴"></a>11장. 단위 테스트 안티 패턴</h1><h2 id="비공개-메서드-단위-테스트"><a href="#비공개-메서드-단위-테스트" class="headerlink" title="비공개 메서드 단위 테스트"></a>비공개 메서드 단위 테스트</h2><p>전혀 하지 말아야 된다</p><h3 id="비공개-메서드와-테스트-취약성"><a href="#비공개-메서드와-테스트-취약성" class="headerlink" title="비공개 메서드와 테스트 취약성"></a>비공개 메서드와 테스트 취약성</h3><p>단위 테스트를 하려고 비공개 메서드를 노출하는 경우에는 식별할수 있는 동작만 테스트하는 것을 위반한다</p><h3 id="비공개-메서드와-불필요한-커버리지"><a href="#비공개-메서드와-불필요한-커버리지" class="headerlink" title="비공개 메서드와 불필요한 커버리지"></a>비공개 메서드와 불필요한 커버리지</h3><ul><li>죽은 코드다</li><li>추상화가 누락되어 있다</li></ul><h3 id="비공개-메서드-테스트가-타당한-경우"><a href="#비공개-메서드-테스트가-타당한-경우" class="headerlink" title="비공개 메서드 테스트가 타당한 경우"></a>비공개 메서드 테스트가 타당한 경우</h3><p>비공개 메서드를 테스트하는 것 자체는 나쁘지 않다<br>비공개 메서드가 구현 세부사항의 프록시에 해당하므로 나쁜것</p><h2 id="비공개-상태-노출"><a href="#비공개-상태-노출" class="headerlink" title="비공개 상태 노출"></a>비공개 상태 노출</h2><p>안티패턴으로 단위 테스트 목적만으로 비공개 상태를 노출하는것이 있다</p><p>테스트 유의성을 위해 공개 API의 노출 영역을 넓히는 것은 좋지 않은 습관이다</p><h2 id="테스트로-유출된-도메인-지식"><a href="#테스트로-유출된-도메인-지식" class="headerlink" title="테스트로 유출된 도메인 지식"></a>테스트로 유출된 도메인 지식</h2><p>도메인 지식을 테스트로 유출하는 것은 또하나의 흔한 안티 패턴</p><h2 id="코드-오염"><a href="#코드-오염" class="headerlink" title="코드 오염"></a>코드 오염</h2><p>테스트에만 필요한 제품 코드를 추가하는것</p><h2 id="구체-클래스를-목으로-처리하기"><a href="#구체-클래스를-목으로-처리하기" class="headerlink" title="구체 클래스를 목으로 처리하기"></a>구체 클래스를 목으로 처리하기</h2><p>일부 기능을 지키려고 구체 클래스를 목으로 처리해야 하면 이는 단일 책임 원칙을 위한하는 결과다</p><h2 id="시간-처리하기"><a href="#시간-처리하기" class="headerlink" title="시간 처리하기"></a>시간 처리하기</h2><p>시간에 따라 달라지는 기능을 테스트하면 거짓 양성이 발생할 수 있다</p><h3 id="앰비언트-컨텍스트로서의-시간"><a href="#앰비언트-컨텍스트로서의-시간" class="headerlink" title="앰비언트 컨텍스트로서의 시간"></a>앰비언트 컨텍스트로서의 시간</h3><p>로거 기능과 마찬가지로 시간을 엠비언트 컨텍스트로 사용하는것도 안티 패턴이다</p><h3 id="명시적-의존성으로서의-시간"><a href="#명시적-의존성으로서의-시간" class="headerlink" title="명시적 의존성으로서의 시간"></a>명시적 의존성으로서의 시간</h3><p>더나은 방법으로 시간의존성을 명시적으로 주입하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장. 데이터베이스 테스트</title>
      <link>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</guid>
      <pubDate>Wed, 17 Jan 2024 01:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-데이터베이스-테스트&quot;&gt;&lt;a href=&quot;#10장-데이터베이스-테스트&quot; class=&quot;headerlink&quot; title=&quot;10장. 데이터베이스 테스트&quot;&gt;&lt;/a&gt;10장. 데이터베이스 테스트&lt;/h1&gt;&lt;p&gt;통합 테스트라는 퍼즐의 마지막 조각은
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-데이터베이스-테스트"><a href="#10장-데이터베이스-테스트" class="headerlink" title="10장. 데이터베이스 테스트"></a>10장. 데이터베이스 테스트</h1><p>통합 테스트라는 퍼즐의 마지막 조각은 프로세스 외부 관리 의존성이다. 가장 일반적인 예는 애플리케이션 데이터베이스다</p><p>실제 데이터베이스를 테스트하면 회귀 방지가 아주 뛰어나지만 설정하기 쉽지 않다</p><h2 id="데이터베이스-테스트를-위한-전제-조건"><a href="#데이터베이스-테스트를-위한-전제-조건" class="headerlink" title="데이터베이스 테스트를 위한 전제 조건"></a>데이터베이스 테스트를 위한 전제 조건</h2><ul><li>형상 관리 시스템에 데이터베이스 유지</li><li>개발자마다 별도의 데이터베이스 인스턴스 사용</li><li>데이터베이스 배포에 마이그레이션 기반 방식 적용</li></ul><h3 id="데이터베이스를-형상-관리-시스템에-유지"><a href="#데이터베이스를-형상-관리-시스템에-유지" class="headerlink" title="데이터베이스를 형상 관리 시스템에 유지"></a>데이터베이스를 형상 관리 시스템에 유지</h3><p>데이터베이스 스키마를 일반 코드로 취급하는것 </p><p>모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다</p><ul><li>변경 내역 부재</li><li>복수의 원천 정보</li></ul><h3 id="참조-데이터도-데이터베이스-스키마다"><a href="#참조-데이터도-데이터베이스-스키마다" class="headerlink" title="참조 데이터도 데이터베이스 스키마다"></a>참조 데이터도 데이터베이스 스키마다</h3><p>참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터다.</p><p>참조 데이터와 일반데이터를 구별할 수 있는 간단한 방법이 있다 애플리케이션이 데이터를 수정할 수 있으면 일반데이터고 그렇지 않으면 참조 데이터다.</p><h3 id="모든-개발자를-위한-별도의-데이터베이스-인스턴스"><a href="#모든-개발자를-위한-별도의-데이터베이스-인스턴스" class="headerlink" title="모든 개발자를 위한 별도의 데이터베이스 인스턴스"></a>모든 개발자를 위한 별도의 데이터베이스 인스턴스</h3><p>공유 데이터베이스를 사용하면 개발 프로세스를 방해 하게 된다</p><ul><li>서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문이다</li><li>하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있다</li></ul><p>테스트 실행 속도를 극대화 하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하라</p><h3 id="상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포"><a href="#상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포" class="headerlink" title="상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포"></a>상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포</h3><p>데이터베이스 배포 방식</p><ul><li>상태기반<ul><li>상태를 형상 관리에 저장함으로써 상태를 명시하고 비교도구가 마이그레이션을 암묵적으로 제어할 수 있게 한다</li></ul></li><li>마이그레이션 기반<ul><li>마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다</li></ul></li></ul><p>결과적으로 상태 기반 방식은 대다수의 프로젝트에서 실용적이지 않다</p><h2 id="데이터베이스-트랜잭션-관리"><a href="#데이터베이스-트랜잭션-관리" class="headerlink" title="데이터베이스 트랜잭션 관리"></a>데이터베이스 트랜잭션 관리</h2><h3 id="제품-코드에서-데이터베이스-트랜잭션-관리하기"><a href="#제품-코드에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="제품 코드에서 데이터베이스 트랜잭션 관리하기"></a>제품 코드에서 데이터베이스 트랜잭션 관리하기</h3><h3 id="통합-테스트에서-데이터베이스-트랜잭션-관리하기"><a href="#통합-테스트에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="통합 테스트에서 데이터베이스 트랜잭션 관리하기"></a>통합 테스트에서 데이터베이스 트랜잭션 관리하기</h3><p>테스트에서 트랜젝션이나 작업 단위를 재사용하지 말라</p><h2 id="테스트-데이터-생명-주기"><a href="#테스트-데이터-생명-주기" class="headerlink" title="테스트 데이터 생명 주기"></a>테스트 데이터 생명 주기</h2><ul><li>통합 테스트를 순차적으로 실행하라</li><li>테스트 실행 간에 남은 데이터를 제거하라</li></ul><h3 id="병렬-테스트-실행과-순차적-테스트-실행"><a href="#병렬-테스트-실행과-순차적-테스트-실행" class="headerlink" title="병렬 테스트 실행과 순차적 테스트 실행"></a>병렬 테스트 실행과 순차적 테스트 실행</h3><p>컨테이너를 사용해 테스트를 병렬로 실행시킬수 있다</p><p>단점은</p><ul><li>도커 이미지를 유지 보수해야함</li><li>각 테스트마다 컨테이너 인스턴스가 있는지 확인해야 함</li><li>통합 테스트를 일괄 처리하고</li><li>다 사용한 컨테이너는 폐기해야 한다</li></ul><p>통합 테스트의 실행 시간을 최소화 해야 하는 경우가 아니라면 컨테이너를 사용하지 않는 것이 좋다</p><p>데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 더 실용적이다</p><h3 id="테스트-실행-간-데이터-정리"><a href="#테스트-실행-간-데이터-정리" class="headerlink" title="테스트 실행 간 데이터 정리"></a>테스트 실행 간 데이터 정리</h3><ul><li>각 테스트 전에 데이터베이스 백업 복원하기</li><li>테스트 종료 시점에 데이터 정리하기</li><li>데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기</li><li>테스트 시작 시점에 데이터 정리하기</li></ul><h3 id="인메모리-데이터베이스-피하기"><a href="#인메모리-데이터베이스-피하기" class="headerlink" title="인메모리 데이터베이스 피하기"></a>인메모리 데이터베이스 피하기</h3><p>인메모리 데이터베이스의 장점</p><ul><li>테스트 데이터를 제거할 필요가 없음</li><li>작업 속도 향상</li><li>테스트가 실행될 때마다 인스턴스화 가능</li></ul><p>하지만 기능적 일관성이 없기 때문에 사용하지 않는것이 좋다</p><h2 id="테스트-구절에서-코드-재사용하기"><a href="#테스트-구절에서-코드-재사용하기" class="headerlink" title="테스트 구절에서 코드 재사용하기"></a>테스트 구절에서 코드 재사용하기</h2><p>통합 테스트가 너무 빨리 커지면 유지 보수 지표가 나빠질 수 있다</p><h3 id="준비-구절에서-코드-재사용하기"><a href="#준비-구절에서-코드-재사용하기" class="headerlink" title="준비 구절에서 코드 재사용하기"></a>준비 구절에서 코드 재사용하기</h3><p>오브젝트 마더(Object Mother) 패턴</p><p>테스트 데이터 빌더(Test Data Builder) 패턴</p><h3 id="실행-구절에서-코드-재사용하기"><a href="#실행-구절에서-코드-재사용하기" class="headerlink" title="실행 구절에서 코드 재사용하기"></a>실행 구절에서 코드 재사용하기</h3><p>대리자(Delegate) 패턴을 활용해서 실행구절을 줄일수 있따</p><h3 id="검증-구절에서-코드-재사용하기"><a href="#검증-구절에서-코드-재사용하기" class="headerlink" title="검증 구절에서 코드 재사용하기"></a>검증 구절에서 코드 재사용하기</h3><p>플루언트 인터페이스를 사용하면 검증문이 읽기 쉬워진다</p><h3 id="테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가"><a href="#테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가" class="headerlink" title="테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?"></a>테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?</h3><p>빠른 피드백과 유지 보수성의 절충</p><h2 id="데이터베이스-테스트에-대한-일반적인-질문"><a href="#데이터베이스-테스트에-대한-일반적인-질문" class="headerlink" title="데이터베이스 테스트에 대한 일반적인 질문"></a>데이터베이스 테스트에 대한 일반적인 질문</h2><h3 id="읽기-테스트를-해야-하는가"><a href="#읽기-테스트를-해야-하는가" class="headerlink" title="읽기 테스트를 해야 하는가?"></a>읽기 테스트를 해야 하는가?</h3><p>읽기를 테스트하기로 결정한 경우에는 실제 데이터베이스에서 통합 테스트하라</p><h3 id="리포지터리-테스트를-해야-하는가"><a href="#리포지터리-테스트를-해야-하는가" class="headerlink" title="리포지터리 테스트를 해야 하는가?"></a>리포지터리 테스트를 해야 하는가?</h3><p>리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트의 일부로 취급</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장. 목 처리에 대한 모범 사례</title>
      <link>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</guid>
      <pubDate>Tue, 16 Jan 2024 00:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-목-처리에-대한-모범-사례&quot;&gt;&lt;a href=&quot;#9장-목-처리에-대한-모범-사례&quot; class=&quot;headerlink&quot; title=&quot;9장. 목 처리에 대한 모범 사례&quot;&gt;&lt;/a&gt;9장. 목 처리에 대한 모범 사례&lt;/h1&gt;&lt;p&gt;목은 테스트 대
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-목-처리에-대한-모범-사례"><a href="#9장-목-처리에-대한-모범-사례" class="headerlink" title="9장. 목 처리에 대한 모범 사례"></a>9장. 목 처리에 대한 모범 사례</h1><p>목은 테스트 대상 시스템과 의존성 간의 상호 작용을 모방하고 검사하는 데 도움이 되는 테스트 대역이다</p><p>목은 비관리 의존성에만 적용해야 된다</p><h2 id="목의-가치를-극대화하기"><a href="#목의-가치를-극대화하기" class="headerlink" title="목의 가치를 극대화하기"></a>목의 가치를 극대화하기</h2><p>비관리 의존성에만 목을 사용하게끔 제한하는 것이 중요하지만 이는 목의 가치를 극대화 하기 위한 첫 번째 단계일 뿐이다</p><h3 id="시스템-끝에서-상호-작용-검증하기"><a href="#시스템-끝에서-상호-작용-검증하기" class="headerlink" title="시스템 끝에서 상호 작용 검증하기"></a>시스템 끝에서 상호 작용 검증하기</h3><p>시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라.</p><h3 id="목을-스파이로-대체하기"><a href="#목을-스파이로-대체하기" class="headerlink" title="목을 스파이로 대체하기"></a>목을 스파이로 대체하기</h3><p>스파이는 목과 같은 목적을 수행하는 테스트 대역이다<br>스파이는 수동으로 작성하는 반면에 목은 목프레임워크의 도움을 받아 생성한다는 것이 유일한 차이점이다</p><p>시스템 끝에 있는 클래스의 경우 스파이가 목보다 낫다</p><h2 id="목-처리에-대한-모범-사례"><a href="#목-처리에-대한-모범-사례" class="headerlink" title="목 처리에 대한 모범 사례"></a>목 처리에 대한 모범 사례</h2><ul><li>비관리 의존성에만 목 적용하기</li><li>시스템 끝에 있는 의존성에 대해 상호 작용 검증하기</li><li>통합 테스트에서만 목을 사용하고 단위 테스트에서는 하지 않기</li><li>항상 목 호출 수 확인하기</li><li>보유 타입만 목으로 처리하기</li></ul><h3 id="목은-통합-테스트만을-위한-것"><a href="#목은-통합-테스트만을-위한-것" class="headerlink" title="목은 통합 테스트만을 위한 것"></a>목은 통합 테스트만을 위한 것</h3><p>비지니스 로직과 오케이스레이션의 분리에서 비롯된다</p><h3 id="테스트당-목이-하나일-필요는-없음"><a href="#테스트당-목이-하나일-필요는-없음" class="headerlink" title="테스트당 목이 하나일 필요는 없음"></a>테스트당 목이 하나일 필요는 없음</h3><p>단위 테스트의 단위는 코드의 단위가 아니라 동작의 단위이다</p><h3 id="호출-횟수-검증하기"><a href="#호출-횟수-검증하기" class="headerlink" title="호출 횟수 검증하기"></a>호출 횟수 검증하기</h3><p>비관리 의존성과의 통신에 관해서 다음 두가지 모두 확인하는 것이 중요하다</p><ul><li>예상하는 호출이 있는가?</li><li>예상치 못한 호출이 있는가?</li></ul><h3 id="보유-타입만-목으로-처리하기"><a href="#보유-타입만-목으로-처리하기" class="headerlink" title="보유 타입만 목으로 처리하기"></a>보유 타입만 목으로 처리하기</h3><p>보유 타입만 목으로 처리하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장. 통합 테스트를 하는 이유</title>
      <link>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</guid>
      <pubDate>Fri, 12 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-통합-테스트를-하는-이유&quot;&gt;&lt;a href=&quot;#8장-통합-테스트를-하는-이유&quot; class=&quot;headerlink&quot; title=&quot;8장. 통합 테스트를 하는 이유&quot;&gt;&lt;/a&gt;8장. 통합 테스트를 하는 이유&lt;/h1&gt;&lt;p&gt;단위 테스트에만 전적으
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-통합-테스트를-하는-이유"><a href="#8장-통합-테스트를-하는-이유" class="headerlink" title="8장. 통합 테스트를 하는 이유"></a>8장. 통합 테스트를 하는 이유</h1><p>단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다</p><p>단위 테스트가 비즈니스 로직을 확인하는데 좋지만 비즈니스 로직을 외부와 단절된 상태로 확인하는 것만으로는 충분하지 않다</p><h2 id="통합-테스트는-무엇인가"><a href="#통합-테스트는-무엇인가" class="headerlink" title="통합 테스트는 무엇인가?"></a>통합 테스트는 무엇인가?</h2><h3 id="통합-테스트의-역할"><a href="#통합-테스트의-역할" class="headerlink" title="통합 테스트의 역할"></a>통합 테스트의 역할</h3><p>단위 테스트는 세가지 요구사항을 충족하는 테스트다</p><ul><li>단일 동작 단위를 검증하고</li><li>빠르게 수행하고</li><li>다른 테스트와 별도로 처리한다</li></ul><p>단위테스트가 아닌 모든 테스트는 통합테스트다</p><h3 id="다시-보는-테스트-피라미드"><a href="#다시-보는-테스트-피라미드" class="headerlink" title="다시 보는 테스트 피라미드"></a>다시 보는 테스트 피라미드</h3><p>유지비 증가 이유</p><ul><li>프로세스 외부 의존성 운영이 필요함</li><li>관련된 협력자가 많아서 테스트가 비대해짐</li></ul><p>단위 테스트로 가능한 많이 비즈니스 시나리오의 예외 상황을 확인하고 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룬다</p><h3 id="통합-테스트와-빠른-실패"><a href="#통합-테스트와-빠른-실패" class="headerlink" title="통합 테스트와 빠른 실패"></a>통합 테스트와 빠른 실패</h3><p>통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라<br>상호작용을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가로 작성하라</p><h2 id="어떤-프로세스-외부-의존성을-직접-테스트해야-하는가"><a href="#어떤-프로세스-외부-의존성을-직접-테스트해야-하는가" class="headerlink" title="어떤 프로세스 외부 의존성을 직접 테스트해야 하는가"></a>어떤 프로세스 외부 의존성을 직접 테스트해야 하는가</h2><h3 id="프로세스-외부-의존성의-두-가지-유형"><a href="#프로세스-외부-의존성의-두-가지-유형" class="headerlink" title="프로세스 외부 의존성의 두 가지 유형"></a>프로세스 외부 의존성의 두 가지 유형</h3><ul><li>관리 의존성<ul><li>테스트에서 제어할 수 있는 의존성</li><li>데이터베이스</li></ul></li><li>비관리 의존성<ul><li>테스트에서 제어할 수 없는 의존성</li><li>SMTP 서버</li></ul></li></ul><p>관리 의존성은 실제 인스턴스를 사용하고 비관리 의존성은 목으로 대체하라</p><h3 id="관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기"><a href="#관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기" class="headerlink" title="관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기"></a>관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기</h3><p>프로세스 외부 의존성(데이터 베이스)</p><p>데이터 베이스와의 상호작용을 검증하지 말고 데이터베이스의 최종 상태를 확인하라</p><h3 id="통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까"><a href="#통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까" class="headerlink" title="통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?"></a>통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?</h3><p>통합 테스트에서 관리 의존성을 실제 버전으로 사용할 수 없는 경우도 있다</p><p>그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라</p><h2 id="의존성-추상화를-위한-인터페이스-사용"><a href="#의존성-추상화를-위한-인터페이스-사용" class="headerlink" title="의존성 추상화를 위한 인터페이스 사용"></a>의존성 추상화를 위한 인터페이스 사용</h2><h3 id="인터페이스와-느슨한-결합"><a href="#인터페이스와-느슨한-결합" class="headerlink" title="인터페이스와 느슨한 결합"></a>인터페이스와 느슨한 결합</h3><p>인터페이스를 사용하는 이유</p><ul><li>프로세스 외부 의존성을 추상화해 느슨한 결합을 달성</li><li>기존 코드를 변경하지 않고 새로운 기능을 추가해 개방 폐쇄 원칙을 달성</li></ul><p>위에 2가지 이유 모두 오해</p><p>단일 구현을 위한 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다<br>진정한 추상화는 발견하는것이지 발명하는것이 아니다</p><p>YAGNI 원칙을 위반하는 생각이다<br>YAGNI 원칙은 현재 필요하지 않는 기능에 시간을 드리지 말라는 원칙이다</p><ul><li>기회비용</li><li>프로젝트 코드는 적을수록 좋다</li></ul><h3 id="프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가"><a href="#프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가" class="headerlink" title="프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?"></a>프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?</h3><p>목을 사용하기 위함</p><p>인터페이스가 없으면 테스트 대역을 만들수 없음</p><h2 id="통합-테스트-모범-사례"><a href="#통합-테스트-모범-사례" class="headerlink" title="통합 테스트 모범 사례"></a>통합 테스트 모범 사례</h2><p>통합 테스트를 최대한 활용하는 데 도움이 되는 몇가지 지침</p><ul><li>도메인 모델 경계 명시하기</li><li>애플리케이션 내 계층 줄이기</li><li>순환 의존성 제거하기</li></ul><h3 id="도메인-모델-경계-명시하기"><a href="#도메인-모델-경계-명시하기" class="headerlink" title="도메인 모델 경계 명시하기"></a>도메인 모델 경계 명시하기</h3><p>항상 도메인 모델을 코드베이스에서 명시적이고 잘알려진 위치에 두도록 하라<br>도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘 보여주고 더 잘 설명할 수 있다</p><h3 id="계층-수-줄이기"><a href="#계층-수-줄이기" class="headerlink" title="계층 수 줄이기"></a>계층 수 줄이기</h3><p>대부분의 프로그래머는 간접 계층을 추가해서 코드를 추상화하고 일반화 하려고 한다</p><p>추상계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기 너무 어려워진다</p><h3 id="순환-의존성-제거하기"><a href="#순환-의존성-제거하기" class="headerlink" title="순환 의존성 제거하기"></a>순환 의존성 제거하기</h3><p>순환 의존성의 대표적인 예는 콜백이다</p><p>순한 의존성은 코드를 읽고 이해할때 알아야 할것들이 너무 많아서 큰 부담이 된다</p><p>순한 의존성은 테스트를 방해 한다</p><h3 id="테스트에서-다중-실행-구절-사용"><a href="#테스트에서-다중-실행-구절-사용" class="headerlink" title="테스트에서 다중 실행 구절 사용"></a>테스트에서 다중 실행 구절 사용</h3><p>통합 테스트에서 두 유스케이스를 모두 확인하려고 할때 아래의 구조가 된다</p><ul><li>준비</li><li>실행</li><li>검증</li><li>실행</li><li>검증</li></ul><p>이러한 방식은 사용자의 상태가 자연스럽게 흐르기 때문에 설득력이 있고 첫 번째 실행은 두 번째 실행의 준비 단계 역활을 할수 있다<br>문제는 이러한 테스트가 초점을 잃고 순식간에 너무 커질수 있다</p><h2 id="로깅-기능을-테스트하는-방법"><a href="#로깅-기능을-테스트하는-방법" class="headerlink" title="로깅 기능을 테스트하는 방법"></a>로깅 기능을 테스트하는 방법</h2><ul><li>로깅을 조금이라도 테스트 해야 하는가?</li><li>만약 그렇다면 어떻게 테스트 해야 하는가?</li><li>로깅이 얼마나 많으면 충분한가?</li><li>로거 인스턴스를 어떻게 전달할까?</li></ul><h3 id="로깅을-테스트해야-하는가"><a href="#로깅을-테스트해야-하는가" class="headerlink" title="로깅을 테스트해야 하는가?"></a>로깅을 테스트해야 하는가?</h3><p>로깅은 횡단 기능으로 코드베이스 어느 부분에서나 필요로 할 수 있다</p><p>로깅의 종류 </p><ul><li>지원 로깅</li><li>진단 로깅</li></ul><h3 id="로깅을-어떻게-테스트해야-하는가"><a href="#로깅을-어떻게-테스트해야-하는가" class="headerlink" title="로깅을 어떻게 테스트해야 하는가?"></a>로깅을 어떻게 테스트해야 하는가?</h3><p>목으로 테스트 하지 마라</p><h3 id="로깅이-얼마나-많으면-충분한가"><a href="#로깅이-얼마나-많으면-충분한가" class="headerlink" title="로깅이 얼마나 많으면 충분한가?"></a>로깅이 얼마나 많으면 충분한가?</h3><ul><li>과도한 로깅은 코드를 혼란스럽게 한다</li><li>핵심은 로그의 신호 대비 잡음 비율이다</li></ul><h3 id="로거-인스턴스를-어떻게-전달하는가"><a href="#로거-인스턴스를-어떻게-전달하는가" class="headerlink" title="로거 인스턴스를 어떻게 전달하는가?"></a>로거 인스턴스를 어떻게 전달하는가?</h3><ul><li>정적 메서드를 사용하는 것</li></ul><p>앰비언트 컨텍스트라고 부른다 이는 안티 패턴이며 다음과 같은 두가지 단점</p><ul><li>의존성이 숨어 있고 변경하기가 어렵다</li><li>테스트가 더 어려워진다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
