<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Tue, 14 Nov 2023 02:14:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>04장: 부호화와 발전</title>
      <link>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/</guid>
      <pubDate>Tue, 14 Nov 2023 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-중심-애플리케이션-설계&quot;&gt;&lt;a href=&quot;#데이터-중심-애플리케이션-설계&quot; class=&quot;headerlink&quot; title=&quot;데이터 중심 애플리케이션 설계&quot;&gt;&lt;/a&gt;데이터 중심 애플리케이션 설계&lt;/h1&gt;&lt;h2 id=&quot;04장-부호화와-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-중심-애플리케이션-설계"><a href="#데이터-중심-애플리케이션-설계" class="headerlink" title="데이터 중심 애플리케이션 설계"></a>데이터 중심 애플리케이션 설계</h1><h2 id="04장-부호화와-발전"><a href="#04장-부호화와-발전" class="headerlink" title="04장: 부호화와 발전"></a>04장: 부호화와 발전</h2><p>만물은 변한다 그대로 있는 것은 아무것도 없다 - 헤라클레이토스</p><p>시스템이 계속 원활하게 실행되게 하려면 양방향 호환성을 유지해야 된다</p><ul><li>하위호환성 (backwards compatibility) 새로운 코드는 예전 코드가 기록한 데이터를 읽을수 있어야 된다</li><li>상위호환성 (forward compatibility) 예전 코드는 새로운 코드가 기록한 데이터를 읽을수 있어야 된다</li></ul><h3 id="데이터-부호화-형식"><a href="#데이터-부호화-형식" class="headerlink" title="데이터 부호화 형식"></a>데이터 부호화 형식</h3><p>프로그램은 보통 두가지 형태로 표현된 데이터를 사용<br>    - 메모리에 자료구조<br>    - 파일에 쓰거나 바이트 형태</p><p>마샬링 언마샬링</p><ul><li><p>언어별 형식</p><ul><li>부호화는 보통 특정 프로그램밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다</li><li>동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다</li><li>테이터 버전 관리는 보통 부호화 라이브러리에서 나중에 생각하게 된다</li><li>효율성도 나중에 생각하게 된다</li></ul></li><li><p>JSON과 XML, 이진 변형</p><ul><li>문제? <ul><li>JSON과 XML은 텍스트 형식이라서 사람이 읽을수 있고 기계가 읽을수 있어서 인기가 많다</li><li>JSON과 XML은 표준 라이브러리가 있어서 다른 언어에서도 읽고 쓸수 있다</li><li>JSON과 XML은 텍스트 형식이라서 크기가 크고 이진 형식보다 느리다</li><li>JSON과 XML은 모두 스키마를 지원한다</li><li>CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이션이 해야 한다</li></ul></li><li>이진 부호화<ul><li>좀더 간편하고 파싱이 빠른 형식</li></ul></li></ul></li><li><p>스리프트와 프로토콜 버퍼</p><ul><li>이진 부호화 라이브러리</li><li>프로토 버퍼는 구글</li><li>스리프트는 페이스북</li><li>필드태그와 스키마 발전<ul><li>스키마 발전</li><li>테그번호로 상위호환 하위호환을 유지</li></ul></li><li>데이터타입과 스키마 발전<ul><li>불가능하진 않지만 값이 정확하지 않거나 짤릴 위험이 있다</li></ul></li></ul></li><li><p>아브로</p><ul><li>하둡의 하위호환 프로젝트</li><li>스키마를 사용</li><li>스키마는 JSON으로 정의</li><li>쓰기 스키마 - 데이터를 쓸때 사용</li><li>읽기 스키마 - 데이터를 읽을때 사용</li><li>두개의 스키마가 동일하지 않아도 되며 호환가능하면 된다</li><li>스키마 발전 규칙<ul><li>호환성을 유지하기 위해서 기본값이 있는 필드만 추가하거나 삭제할수 있다</li><li>필드에서 널을 허용하려면 유니온 타입을 사용해야 된다</li></ul></li><li>동적 생성 스키마</li><li>코드 생성과 동적 타입언어</li></ul></li><li><p>스키마의 장점</p><ul><li>유효성 검사를 지원</li><li>문서화</li><li>코드 생성</li><li>데이터베이스 스키마를 유지하면 스키마 변경이 적용되지 전에 상위 호환성과 하위 호환성을 확인할 수 있다</li></ul></li></ul><h3 id="데이터플로-모드"><a href="#데이터플로-모드" class="headerlink" title="데이터플로 모드"></a>데이터플로 모드</h3><ul><li>데이터베이스를 통한 데이터플로<ul><li>다양한 시점에 기록된 다양한 값<ul><li>데이터가 코드보다 더 오래 산다</li><li>마이그레이션은 값비싼 작업이다</li></ul></li><li>보관 저장서<ul><li>데이터베이스 스냅샷</li></ul></li></ul></li><li>서비스를 통한 데이터플로: REST와 RPC<ul><li>서비스 지향 설계</li><li>마이크로서이스 설계</li><li>웹서비스<ul><li>REST<ul><li>HTTP 프로토콜</li></ul></li><li>SOAP<ul><li>XML, WSDL, XSD</li></ul></li></ul></li><li>RCP 문제<ul><li>서비스가 다운되면 클라이언트도 다운된다</li><li>서비스가 다운되면 클라이언트가 다운되지 않더라도 서비스를 사용할수 없다</li></ul></li><li>RCP의 현재 방향<ul><li>서비스 디스커버리</li></ul></li><li>데이터 부호화와 RPC의 발전<ul><li>클라인언트와 서버를 독립적으로 변경하고 배포할수 있어야 된다 </li><li>요청은 하위호환성만 필요</li><li>응답은 상위 호환성만 필요</li></ul></li></ul></li><li>메시지 전달 데이터플로<ul><li>비동기 메시지 전달 시스템<ul><li>메시지 브로커<ul><li>상용에서 오픈소스로 바뀜</li></ul></li><li>메시지 큐</li></ul></li><li>분산 액터 프레임워크<ul><li>엑터 모델<ul><li>엑터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다</li><li>스레드를 직접 처리하는 대신 액터에 캡슐화 된다</li><li>보통 하나의 액터는 하나의 클라이언트나 엔티티를 나타낸다</li><li>액터는 로컬 상태를 가질수 있도 비동기 메시지의 송수신으로 다른 액터와 통신한다</li><li>액터는 메시지 전달을 보장하지 않는다</li><li>각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없고 각 액터는 프레임워클와 독립적으로 실행할 수 있다</li></ul></li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>데이터 구조를 네트워크나 디스크 상의 바이트열로 변환하는 다양한 방법을 살펴봤다</p><p>순회식 업그레이드 하위호환성 상위 호환성</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>03장: 저장소와 검색</title>
      <link>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/</guid>
      <pubDate>Thu, 09 Nov 2023 01:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-중심-애플리케이션-설계&quot;&gt;&lt;a href=&quot;#데이터-중심-애플리케이션-설계&quot; class=&quot;headerlink&quot; title=&quot;데이터 중심 애플리케이션 설계&quot;&gt;&lt;/a&gt;데이터 중심 애플리케이션 설계&lt;/h1&gt;&lt;h2 id=&quot;03장-저장소와-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-중심-애플리케이션-설계"><a href="#데이터-중심-애플리케이션-설계" class="headerlink" title="데이터 중심 애플리케이션 설계"></a>데이터 중심 애플리케이션 설계</h1><h2 id="03장-저장소와-검색"><a href="#03장-저장소와-검색" class="headerlink" title="03장: 저장소와 검색"></a>03장: 저장소와 검색</h2><p>데이터베이스의 두가지 작업 - 데이터를 저장하고 데이터를 조회하는 것</p><p>로그 구조 계열 저장소 엔진, 페이지 지향 계열 저장소 엔진</p><h3 id="데이터베이스를-강력하게-만드는-데이터-구조"><a href="#데이터베이스를-강력하게-만드는-데이터-구조" class="headerlink" title="데이터베이스를 강력하게 만드는 데이터 구조"></a>데이터베이스를 강력하게 만드는 데이터 구조</h3><p>데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서 필요한 데이터 구조는 색인 이다</p><p>색인의 일반적인 개념은 부가적인 메타테이터를 유지하는 것이다.</p><p>색인은 기본데이터(primary data)에서 파생된 추가적인 구조다.</p><p>많은 데이터베이스에서는 색인의 추가 삭제만 허용</p><p>어떤 종류에 색인이라도 대개 쓰기 속도를 느리게 만든다 데이터를 쓸때 마다 색인도 갱신 해줘야 되기 때문이다. - 저장소 시스템의 중요한 트레이트 오프</p><ul><li><p>해시 색인</p><ul><li>키값 저장소 - 해시맵(해시 테이블)</li><li>키를 데이터 파일의 바이트 오프셋에 매칭 하여 저장</li><li>문제<ul><li>파일형식</li><li>레코드 삭제</li><li>고장 복구</li><li>부분적으로 레코드 쓰기</li><li>동시성 제어</li></ul></li></ul></li><li><p>SS테이블과 LSM 트리</p><ul><li>키로 정렬된 형식을 정렬된 문자열 테이블(sorted string table, SSTable)이라고 한다.<ul><li>장점<ul><li>새그먼트 병합은 파일이 사용가능한 메모리보다 크더라도 간단하고 효율적이다</li><li>파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다</li><li>읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다</li></ul></li><li>SS 테이블 생성과 유지<ul><li>쓰기가 들어오면 인메모리 균형 트리 데이터 구조(멤테이블)에 추가한다</li><li>멤테이블이 일정 크기에 도달하면 디스크에 SSTable 파일로 기록한다</li><li>읽기 요청이 들어오면 먼저 멤테이블에서 키를 찾고 디스크 상의 가장 최신 세그먼트를 찾는다</li><li>가끔 세그먼트 파일을 합치고 덥어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다 이과정은 백그라운드에서 수행</li></ul></li><li>SS테이블에서 LSM 트리 만들기<ul><li>로그 구조화 병합 트리(Log-Structured Merge-Tree, LSM 트리) 패트릭 오닐등이 발표</li></ul></li><li>성능 최적화<ul><li>데이터베이스에 존재하지 않는 키를 찾는 경우 느려짐<ul><li>블룸 필터 - 키가 존재하는지 여부를 빠르게 확인</li></ul></li><li>SSTable 압축하고 병합하는 순서와 시기를 결정<ul><li>크기 계층</li><li>레벨 컴팩션</li></ul></li></ul></li></ul></li></ul></li><li><p>B 트리</p><ul><li>가장 널리 알려진 색인 구조</li><li>4kb 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다</li><li>한 페이지는 B 트리의 루트로 지정된다</li><li>색인에서 키를 찾으려면 루트에서 시작한다</li><li>신뢰할수 있는 B 트리 만들기<ul><li>기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓴다</li><li>즉 페이지를 덮어쓰더라도 페이지를 가리키는 값은 변하지 않는다</li><li>데이터를 복구 하기 위해 쓰기전 로그 (redo log)</li></ul></li><li>최적화<ul><li>일부 데이터베이스는 쓰기 복사 방식을 사용한다</li><li>페이지에 전체 키를 저장하는 게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다</li><li>일반적으로 페이지는 디스크 상 어디에나 위치 할수 있다 트리가 커지면 순서를 유지하기 힘들다 - LSM 트리는 병합하는 과정에서 큰 세그먼트를 다시 한번 쓰기 때문에 순서를 유기하기 쉽다</li><li>트리에 포인터를 추가한다</li><li>프랙탈 트리</li></ul></li></ul></li><li><p>B 트리와 LSM 트리 비교</p><ul><li>LSM 트리는 쓰기 성능이 뛰어나다</li><li>B 트리는 읽기 성능이 뛰어나다</li><li>LSM 트리의 장점<ul><li>쓰기 증폭이 더 낮다<ul><li>데이터를 덮어 쓰는게 아니라 순차적으로 쓰기 때문이다</li></ul></li><li>압축률이 좋다</li></ul></li><li>LSM 트리의 단점<ul><li>컴팩션 과정이 따로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다</li><li>높은 쓰기 처리량에서 발생</li></ul></li></ul></li><li><p>기타 색인 구조</p><ul><li>키-값 색인의 대표적인 예는 관계형 모델의 기본키 색인</li><li>보조색인을 사용하는 방식도 매우 일반적</li><li>클러스터 색인(clustered index) - 색인 안에 색인된 로우를 저장</li><li>커버링 색인(covering index)</li><li>포괄열이 있는 색인(index with included columns)</li><li>다중 칼럼 색인<ul><li>결합 색인(concatenated index)</li></ul></li><li>전문 검색과 퍼지 색인<ul><li>유한 상태 오토마론(finite state automaton, FSA) 트라이(trie)</li><li>레벨슈타인 오토마론(Levenshtein automaton)</li></ul></li><li>모든걸 메모리에 보관<ul><li>인메모리 데이터베이스</li></ul></li></ul></li></ul><h3 id="트랜잭션-처리나-분석"><a href="#트랜잭션-처리나-분석" class="headerlink" title="트랜잭션 처리나 분석?"></a>트랜잭션 처리나 분석?</h3><p>커머셜 트랜잭션 - 초창기 비즈니스 데이터 처리<br>온라인 트랜잭션 처리 - OLTP(Online Transaction Processing)<br>온라인 분석 처리 - OLAP(Online Analytical Processing)</p><ul><li><p>데이터 웨어하우징</p><ul><li>ETL(Extract-Transform-Load) - 데이터를 추출하고 변환한 다음 데이터 웨어하우스에 적재</li></ul></li><li><p>분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마</p><ul><li>별 모양 스키마 - 중앙의 큰 테이블을 기준으로 여러 개의 작은 차원 테이블이 연결된 형태</li><li>눈 꽃송이 모양 스키마 - 여러 차원 테이블이 서로 연결된 형태</li></ul></li></ul><h3 id="칼럼-지향-저장소"><a href="#칼럼-지향-저장소" class="headerlink" title="칼럼 지향 저장소"></a>칼럼 지향 저장소</h3><p>모든 값을 하나의 로우에 함께 저장하지 않는대신 각 칼럼별로 모든 값을 함께 저장한다</p><ul><li><p>칼럼 압축</p><ul><li>압축에 용이하다</li><li>비트맵 부호화</li><li>메모리 대역폭과 벡터화 처리<ul><li>벡터화 처리 - 하나의 명령으로 여러 개의 데이터를 한꺼번에 처리하는 것</li></ul></li></ul></li><li><p>칼럼 저장소의 순서 정렬</p><ul><li>각 칼럼은 독립적으로 정렬할수 없다</li><li>데이터는 한번에 전체 로우를 정렬해야 한다</li><li>다양한 순서 정렬<ul><li>C-store</li></ul></li></ul></li><li><p>칼럼 지향 저장소에 쓰기</p><ul><li>B 트리와 같은 제자리 갱신이 불가능 하다</li><li>집계 : 데이터 큐브와 구체화뷰<ul><li>데이터 큐브 - 다차원의 데이터를 집계한 것</li></ul></li></ul></li><li><p>집계: 데이터 큐브와 구체화 뷰</p></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul><li>OLAP - 데이터 웨어하우스에 저장된 데이터를 집계하고 분석하는 일</li><li>OLTP - 비즈니스 데이터 처리</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>02장: 데이터 모델과 질의 언어</title>
      <link>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/</guid>
      <pubDate>Mon, 06 Nov 2023 04:48:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-중심-애플리케이션-설계&quot;&gt;&lt;a href=&quot;#데이터-중심-애플리케이션-설계&quot; class=&quot;headerlink&quot; title=&quot;데이터 중심 애플리케이션 설계&quot;&gt;&lt;/a&gt;데이터 중심 애플리케이션 설계&lt;/h1&gt;&lt;h2 id=&quot;02장-데이터-모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-중심-애플리케이션-설계"><a href="#데이터-중심-애플리케이션-설계" class="headerlink" title="데이터 중심 애플리케이션 설계"></a>데이터 중심 애플리케이션 설계</h1><h2 id="02장-데이터-모델과-질의-언어"><a href="#02장-데이터-모델과-질의-언어" class="headerlink" title="02장: 데이터 모델과 질의 언어"></a>02장: 데이터 모델과 질의 언어</h2><p>대부분의 애플리케이션은 하나의 데이터 모델 위에 다른 데이터 모델을 계층을 둬서 만듬</p><h3 id="관계형-모델과-문서-모델"><a href="#관계형-모델과-문서-모델" class="headerlink" title="관계형 모델과 문서 모델"></a>관계형 모델과 문서 모델</h3><p>가장 잘알려진 데이터 모델은 1970년 에드가 코드가 제안한 관계형 모델을 기반으로 한 SQL </p><p>데이터는 관계로(테이블) 구성되고 각 관계는 튜플(로우) 모음</p><ul><li><p>NoSQL의 탄생 : 관계형 모델의 우위를 뒤집으려는 가장 최신 시도</p><ul><li>가까운 미래에는 관계형 데이터 베이스와 비관계형 데이터스토어와 함께 사용될 것이다. - 이미 사용중</li></ul></li><li><p>객체 관계형 불일치</p><ul><li>임피던스 불일치</li></ul></li><li><p>다대일과 다대다 관계</p><ul><li>쓰기 오버해드 불일치</li><li>중복된 데이터를 정규화 하려면 다대일 관계</li></ul></li><li><p>문서 데이터베이스는 역사를 반복하고 있나?</p><ul><li>관계형 모델<ul><li>모든 데이터를 배치하는것</li></ul></li><li>네트워크 모델<ul><li>코다실 모델 : 코다실이라고 부르는 위원회에서 표준화됨</li><li>레코드간의 연결은 외래 키 보다 포인터와 더 비슷하다</li><li>레코드에 접근하는 유일한 방법은 최상위 레코드에서 부터 연속된 연결 경로를 따르는 방법 - 접근경로</li></ul></li><li>문서 데이터베이스와의 비교<ul><li>한 가지 측면에서 계층 모델로 되돌아갔다</li><li>별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다</li></ul></li></ul></li><li><p>관계형 데이터베이스와 오늘날의 문서 데이터베이스</p><ul><li>내결함성과 동시성처리를 포함 고려해야할 차이점이 많이 있다.</li><li>애플리케이션 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는게 좋다</li><li>사딩은 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킴</li><li>애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다</li><li>문서 데이터 베이스는 암묵적인 스키마가 있지만 강요하지 않는다</li></ul></li></ul><h3 id="데이터를-위한-질의-언어"><a href="#데이터를-위한-질의-언어" class="headerlink" title="데이터를 위한 질의 언어"></a>데이터를 위한 질의 언어</h3><p>SQL은 선언형 질의 언어</p><p>IMS와 코다실은 명령형 코드</p><ul><li>웹에서의 선언형 질의<ul><li>CSS selector</li><li>DOM</li></ul></li><li>맵리듀스 질의<ul><li>map 과 reduce 함수를 기반<ul><li>map 함수는 각 입력 데이터를 독립적으로 처리</li><li>reduce 함수는 map 함수의 출력을 하나로 합침</li></ul></li></ul></li></ul><h3 id="그래프형-데이터-모델"><a href="#그래프형-데이터-모델" class="headerlink" title="그래프형 데이터 모델"></a>그래프형 데이터 모델</h3><p>다대다 관계가 일반적일때는 그래프로 데이터를 모델링하기 시작하는 편이 더 좋다</p><p>정점 vertex : 노드나 엔티티<br>간선 edge : 관계나 호(arc)</p><p>페이지 랭크</p><ul><li>속성 그래프(neo4j)<ul><li>고유한 식별자</li><li>유출(outgoing) 간선 집합</li><li>유입(incoming) 간선 집합</li><li>속성 컬렉션(키-값 쌍)</li></ul></li><li>사이퍼 질의 언어<ul><li>속성 그래프를 위한 선언형 질의 언어</li></ul></li><li>SQL의 그래프 질의<ul><li>재귀 공통 테이블 식(recursive common table expression, CTE) with recursive</li><li>SQL은 복잡하다</li></ul></li><li>트리플 저장소와 스파클(Datomic)<ul><li>속성 그래프랑 거의 비슷</li><li>주어, 서술어, 목적어 (subject, predicate, object) 를 트리플(triple) 이라고 부름</li><li>시멘틱웹</li><li>RDF 데이터 모델</li><li>스파클(SPARQL) 질의 언어는 RDF 데이터 모델을 사용한 트리플</li></ul></li><li>초석: 데이터로그<ul><li>스파클이나 사이퍼보다 훨씬 오래된 언어로 1980년대 학계에서 연구됨</li><li>트리플을 작성하는 대신 서술어로 작성한다</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>애플리케이션의 요구사항에 가장 적합한 모델을 찾고 싶은 욕구를 충분히 자극</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</title>
      <link>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/</guid>
      <pubDate>Thu, 02 Nov 2023 12:33:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-중심-애플리케이션-설계&quot;&gt;&lt;a href=&quot;#데이터-중심-애플리케이션-설계&quot; class=&quot;headerlink&quot; title=&quot;데이터 중심 애플리케이션 설계&quot;&gt;&lt;/a&gt;데이터 중심 애플리케이션 설계&lt;/h1&gt;&lt;h2 id=&quot;01장-신뢰할-수
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-중심-애플리케이션-설계"><a href="#데이터-중심-애플리케이션-설계" class="headerlink" title="데이터 중심 애플리케이션 설계"></a>데이터 중심 애플리케이션 설계</h1><h2 id="01장-신뢰할-수-있고-확장-가능하며-유지보수하기-쉬운-애플리케이션"><a href="#01장-신뢰할-수-있고-확장-가능하며-유지보수하기-쉬운-애플리케이션" class="headerlink" title="01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"></a>01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</h2><p>오늘날 소프트웨어는 계산 중심 과는 다르게 데이터 중심적이다</p><ul><li>데이터 베이스</li><li>캐시</li><li>검색 색인</li><li>스트림 처리</li><li>일괄 처리</li></ul><p>소프트웨어 시스템의 관심사</p><ul><li>신뢰성</li><li>확장성</li><li>유지보수성</li></ul><h3 id="신뢰성"><a href="#신뢰성" class="headerlink" title="신뢰성"></a>신뢰성</h3><ul><li>애플리케이션은 사용자가 기대한 기능을 수행한다</li><li>시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할수 있다</li><li>시스템 성능은 예상된 부하와 데이터 망에서 필수적인 사용 사례를 충분히 만족한다</li><li>시스템은 허가되지 않은 접근과 오남용을 방지한다</li></ul><p>잘못될수 있는 일을 결함이라고 부른다 결함을 예측하고 대처할수 있는 시스템을 내결함성 또는 탄력성을 지녔다고 말한다<br>고의적으로 결함을 유도함 -&gt; 카오스 몽키</p><ul><li>하드웨어 결함</li><li>소프트웨어 오류</li><li>인적 오류</li></ul><p>신뢰성은 얼마나 중요할까? </p><h3 id="확장성"><a href="#확장성" class="headerlink" title="확장성"></a>확장성</h3><p>확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어</p><ul><li>부하 기술하기</li><li>성능 기술하기<ul><li>처리량, 응답시간</li></ul></li><li>부하 대응 접근 방식<ul><li>스케일업, 스케일 아웃</li><li>비공유 아키텍처</li></ul></li></ul><h3 id="유지보수성"><a href="#유지보수성" class="headerlink" title="유지보수성"></a>유지보수성</h3><ul><li>운용성: 운영의 편리함 만들기</li><li>단순성: 복잡도 관리<ul><li>우발적 복잡도를 줄인다</li></ul></li><li>발전성: 변화를 쉽게 만들기<ul><li>조직 프로세스 애자일</li></ul></li></ul><p>요구사항에는 기능적 요구사항과 비기능적요구사항</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion 이해를 위한 자료 모음</title>
      <link>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/</guid>
      <pubDate>Tue, 31 Oct 2023 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Stable-Diffusion-이해를-위한-자료-모음&quot;&gt;&lt;a href=&quot;#Stable-Diffusion-이해를-위한-자료-모음&quot; class=&quot;headerlink&quot; title=&quot;Stable Diffusion 이해를 위한 자료 모음&quot;&gt;&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Stable-Diffusion-이해를-위한-자료-모음"><a href="#Stable-Diffusion-이해를-위한-자료-모음" class="headerlink" title="Stable Diffusion 이해를 위한 자료 모음"></a>Stable Diffusion 이해를 위한 자료 모음</h1><h2 id="Diffusion-Model"><a href="#Diffusion-Model" class="headerlink" title="Diffusion Model"></a>Diffusion Model</h2><p><a href="https://arxiv.org/abs/1503.03585">https://arxiv.org/abs/1503.03585</a></p><p>2015년 발표</p><p><code>Diffusion(확산)은 액체나 기체에 다른 물질이 섞이고, 그것이 조금씩 번져가다가 마지막에는 일률적인 농도로 바뀌는 현상이다.</code> 위키피디아</p><p><img src="https://mblogthumb-phinf.pstatic.net/20131015_167/todaudrhkwkd_13817975412967wfk3_JPEG/1.jpg?type=w2" alt="확산"></p><p>물리의 확산 현상에 영감을 받아 모델을 설계</p><p>가우시안 노이즈</p><p>마르코프 체인(특정 상태의 확률은 오직 과거의 기인한다)</p><p><img src="https://velog.velcdn.com/images/fermi99/post/364897c1-5d8f-4951-ab7e-128bfe699b95/image.png" alt="디퓨전모델"></p><h2 id="Denoising-Diffusion-Probabilistic-Models-DDPM"><a href="#Denoising-Diffusion-Probabilistic-Models-DDPM" class="headerlink" title="Denoising Diffusion Probabilistic Models (DDPM)"></a>Denoising Diffusion Probabilistic Models (DDPM)</h2><p><a href="https://arxiv.org/abs/2006.11239">https://arxiv.org/abs/2006.11239</a></p><p>유넷을 활용 → 정답 상태를 유추</p><p>정답만 유추 하기 때문에 좀더 간단해짐 → 노이즈 성분을 예측하니깐 조금 더 품질이 좋아짐</p><p>해결 컨셉은 노이즈화 할때의 수식을 조금 다르게 수정</p><p><code>문제점 : 너무 느리다 스텝이 1000 사용해야 됨(GAN 은 1번)</code></p><h2 id="Denoising-Diffusion-Implicit-Models-DDIM"><a href="#Denoising-Diffusion-Implicit-Models-DDIM" class="headerlink" title="Denoising Diffusion Implicit Models (DDIM)"></a>Denoising Diffusion Implicit Models (DDIM)</h2><p><a href="https://arxiv.org/abs/2010.02502">https://arxiv.org/abs/2010.02502</a></p><p>아이디어 느리니깐 스템을 10, 20, 50 ,100 1000 으로 사용해도 크게 나빠지지 않는다.</p><p><img src="https://user-images.githubusercontent.com/79881119/233402047-07361544-87f3-4d51-8d6f-718fab06dcfc.png" alt="DDIM"></p><h2 id="VariationalAutoEncoder-VAE"><a href="#VariationalAutoEncoder-VAE" class="headerlink" title="VariationalAutoEncoder (VAE)"></a>VariationalAutoEncoder (VAE)</h2><ul><li>supervised learning : 데이터와 라벨이 페어<ul><li>classification</li><li>object detection</li><li>semantic segmentation</li><li>image captioning</li></ul></li><li>unsupervised learning : 데이터만 존재<ul><li>clustering</li><li>dimensionality reduction</li><li>feature learning</li><li>density estimation</li></ul></li></ul><p>이미지를 넣어서 차원이 작은 벡터를 나오면 이것으로 이미지를 만든다 </p><p>explicit density estimation : 확률밀도함수를 직접적으로 구하는 방법</p><p>implicit density estimation :  확률밀도함수를 직접적으로 구하지 않고, 확률밀도함수를 구하는 것을 목적으로 하지 않는 방법</p><p>작은 차원에 피처만으로 이미지를 만들수 있다</p><p>최대 가능도를 써서 트레이닝을 시킨다 </p><p>문제는 계산을 할수가 없다 실제 값을 아는게 아니라 샘플링만 가능</p><p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*_5GpdejeOvt61ew4aPtT_g.png"></p><p><img src="https://github.com/CompVis/latent-diffusion/raw/main/assets/modelfigure.png" alt="LDM"></p><ul><li>denoising 과정에서 autoencoder를 사용</li><li>denoising이 pixel space 가 아닌 latent space 에서 일어남(픽셀단위가 아니라 인코딩된 잠재공간 내에서 노이즈를 추가 제거)</li><li>cross-attention layers를(transformer 아키텍처?) 도입함으로 다른 도메인 conditioning 을 같이 사용할수 있게됨 -&gt;</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/CompVis/latent-diffusion">Latent Diffusion Models</a></li><li><a href="https://github.com/CompVis/stable-diffusion">Stable Diffusion</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/diffusion-model-basic/">Diffusion Model 설명 – 기초부터 응용까지</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/stable-diffusion/">Stable Diffusion : High-Resolution Image Synthesis with Latent Diffusion Models</a></li><li><a href="https://www.youtube.com/watch?v=AVvlDmhHgC4">GAN: Generative Adversarial Networks (꼼꼼한 딥러닝 논문 리뷰와 코드 실습)</a></li><li><a href="https://www.youtube.com/watch?v=sSxdQq9CCx0">머신러닝&#x2F;딥러닝 강의 - 004 UNet 네트워크 구현하기</a></li><li><a href="https://www.youtube.com/watch?reload=9&v=n_FDGMr4MxE">U-Net: Convolutional Networks for Biomedical Image Segmentation (MICCAI 2015)</a></li><li><a href="https://www.youtube.com/watch?v=7fBQDaJkcSU">Stable Diffusion 논문 리뷰</a></li><li><a href="https://laion.ai/">laion.ai</a></li><li><a href="https://stability.ai/">stability.ai</a></li><li><a href="https://www.youtube.com/watch?v=e2rFsn93o0U">불과 1년 만의 쾌거, 생성 모델 특집 - Diffusion Model 이 이루어낸 모든 것을 AI 전문가로부터 들어봅니다!</a></li><li><a href="https://www.youtube.com/watch?v=WQuwkTKvUfg">요즘 핫한 생성모델 stable diffusion 찍먹해보기</a></li><li><a href="https://www.youtube.com/watch?v=nthpXARTduk">guided diffusion에서 StableDiffusion, 그리고 Plug&amp;Play와 DiffStyle까지</a></li><li><a href="https://dacon.io/codeshare/4652">가우시안 노이즈(Gaussian Noise)</a></li><li><a href="https://www.youtube.com/watch?v=uFoGaIVHfoE">Diffusion Model 수학이 포함된 tutorial</a></li><li><a href="https://drive.google.com/file/d/1u8EWfDvaJQGKKC4akQDy50kP-qF_MT09/view?pli=1">Diffusion Model 수학이 포함된 tutorial 발표자료</a></li><li><a href="https://jang-inspiration.com/ddpm-2">[논문리뷰] DDPM: Denoising Diffusion Probabilistic Model</a></li><li><a href="https://velog.io/@hanlyang0522/DDPM-Denoising-Diffusion-Probabilistic-Models-%EB%85%BC%EB%AC%B8-%EB%A6%AC%EB%B7%B0">DDPM: Denoising Diffusion Probabilistic Models 논문 리뷰</a></li><li><a href="https://junia3.github.io/blog/ddim">DDIM(Denoising Diffusion Implicit Models) 이해하기</a></li><li><a href="https://www.youtube.com/watch?v=zcEe78I_4TU">[DLD 2022] Denoising Diffusion Implicit Models</a></li><li><a href="https://arxiv.org/abs/2010.02502">Denoising Diffusion Implicit Models</a></li><li><a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Models</a></li><li><a href="https://arxiv.org/abs/1503.03585">Deep Unsupervised Learning using Nonequilibrium Thermodynamics</a></li><li><a href="https://pebpung.github.io/autoencoder/2021/09/11/Auto-Encoder-1.html">오토인코더(AutoEncoder)</a></li><li><a href="https://www.youtube.com/watch?v=54hyK1J4wTc">[#32.Lec] AutoEncoder and Variational AutoEncoder - 딥러닝 홀로서기</a></li><li><a href="https://bookdown.org/mathemedicine/Stat_book/probability-vs-likelihood.html">Chapter 2 확률(Probability) vs 가능도(Likelihood)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Diffusion Models 이란</title>
      <link>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/</guid>
      <pubDate>Mon, 30 Oct 2023 08:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Diffusion-Models-이란&quot;&gt;&lt;a href=&quot;#Diffusion-Models-이란&quot; class=&quot;headerlink&quot; title=&quot;Diffusion Models 이란?&quot;&gt;&lt;/a&gt;Diffusion Models 이란?&lt;/h1&gt;&lt;p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Diffusion-Models-이란"><a href="#Diffusion-Models-이란" class="headerlink" title="Diffusion Models 이란?"></a>Diffusion Models 이란?</h1><p><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">diffusion-models</a> 이글을 번역한 내용 입니다</p><p>지금까지 세 가지 유형의 생성 모델, 즉 GAN, VAE 및 흐름 기반(FLOW-based) 모델에 대해 작성했습니다.<br>이 모델들은 고품질 샘플을 생성하는 데 큰 성공을 거두었지만 각각 몇 가지 한계가 있습니다.<br>GAN 모델은 적대적 훈련 특성으로 인해 잠재적으로 불안정한 훈련과 생성의 다양성이 떨어지는 것으로 알려져 있습니다.<br>VAE는 대리 손실에 의존합니다.<br>FLOW 모델은 가역적 변환을 구축하기 위해 특수 아키텍처를 사용해야 합니다.</p><p>확산 모델(Diffusion models)은 비평형 열역학(non-equilibrium thermodynamics)에서 영감을 얻었습니다.<br>확산 단계의 마르코프 체인(Markov chain)을 정의하여 데이터에 무작위 노이즈를 천천히 추가한 다음,<br>확산 과정을 역으로 학습하여 노이즈에서 원하는 데이터 샘플을 구성하는 방법을 학습합니다.<br>확산 모델은 VAE 또는 흐름 모델과 달리 고정된 절차로 학습되며 잠재 변수는 높은 차원(원본 데이터와 동일)을 갖습니다.</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/generative-overview.png" alt="그림 1. 다양한 유형의 생성 모델 개요."></p><h2 id="확산-모델이란"><a href="#확산-모델이란" class="headerlink" title="확산 모델이란?"></a>확산 모델이란?</h2><p>Several diffusion-based generative models have been proposed with similar ideas underneath, including diffusion probabilistic models <a href="https://arxiv.org/abs/1503.03585">(Sohl-Dickstein et al., 2015)</a>,<br>noise-conditioned score network <a href="https://arxiv.org/abs/1907.05600">(NCSN; Yang &amp; Ermon, 2019)</a>,<br>and denoising diffusion probabilistic models <a href="https://arxiv.org/abs/2006.11239">(DDPM; Ho et al. 2020)</a>.</p><h3 id="순방향-확산-프로세스-Forward-diffusion-process"><a href="#순방향-확산-프로세스-Forward-diffusion-process" class="headerlink" title="순방향 확산 프로세스 (Forward diffusion process)"></a>순방향 확산 프로세스 (Forward diffusion process)</h3><p>실제 데이터 분포에서 샘플링된 데이터 포인트가 주어지면<br>샘플에 소량의 가우시안(Gaussian) 노이즈를 추가하는 순방향 확산 프로세스를 정의해 보겠습니다.<br>T 단계, 시끄러운 샘플 시퀀스 생성  x…x 단계 크기는 분산 일정에 의해 제어됩니다.<br>데이터 샘플 점차적으로 단계적으로 구별되는 특징을 잃습니다. 더 커집니다. 결국 언제 등방성 가우스 분포와 동일합니다.</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/DDPM.png" alt="그림 2. 노이즈를 천천히 추가(제거)하여 샘플을 생성하는 순방향(역방향) 확산 과정의 마르코프 체인. (이미지 출처: Ho et al. 2020, 몇 가지 추가 주석 포함)"></p><h3 id="확률적-경사-Langevin-역학과의-연결"><a href="#확률적-경사-Langevin-역학과의-연결" class="headerlink" title="확률적 경사 Langevin 역학과의 연결"></a>확률적 경사 Langevin 역학과의 연결</h3><p>Langevin 역학은 분자 시스템을 통계적으로 모델링하기 위해 개발된 물리학의 개념입니다.<br>확률적 경사하강법과 결합된 Stochastic Gradient Langevin 역학 <a href="https://www.stats.ox.ac.uk/~teh/research/compstats/WelTeh2011a.pdf">Bayesian Learning via Stochastic Gradient Langevin Dynamics</a><br>은 확률 밀도에서 샘플을 생성할 수 있습니다.</p><h3 id="역확산-과정-Reverse-diffusion-process"><a href="#역확산-과정-Reverse-diffusion-process" class="headerlink" title="역확산 과정(Reverse diffusion process)"></a>역확산 과정(Reverse diffusion process)</h3><p>위의 과정을 반대로 하고 샘플을 추출할 수 있다면 가우스 노이즈 입력에서 실제 샘플을 다시 생성할 수 있습니다. 안타깝게도 쉽게 추정할 수는 없습니다.<br>전체 데이터 세트를 사용해야 하므로 모델을 학습해야 하기 때문입니다. 역확산 프로세스를 실행하기 위해 이러한 조건부 확률을 근사화합니다 .</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/diffusion-example.png" alt="그림 3. 2D 스위스롤 데이터 모델링을 위한 확산 모델 훈련의 예. (이미지 출처: Sohl-Dickstein 외, 2015 )"></p><h2 id="확산-모델-샘플링-속도-향상"><a href="#확산-모델-샘플링-속도-향상" class="headerlink" title="확산 모델 샘플링 속도 향상"></a>확산 모델 샘플링 속도 향상</h2><p>역확산 과정의 마르코프 체인을 따라 DDPM에서 샘플을 생성하는 것은 다음과 같이 매우 느립니다.<br>최대 1단계 또는 수천 단계일 수 있습니다. Song et al. 의 한 데이터 포인트 . 2020 :<br>“예를 들어 DDPM에서 32 × 32 크기의 이미지 50,000개를 샘플링하는 데 약 20시간이 걸리지만 Nvidia 2080 Ti GPU의 GAN에서는 1분도 채 걸리지 않습니다.”</p><p>간단한 방법 중 하나는 샘플링 업데이트를 매번 수행하여 점진적인 샘플링 일정( Nichol &amp; Dhariwal, 2021 )을 실행하는 것입니다.</p><p>DDPM과 비교하여 DDIM은 다음을 수행할 수 있습니다.</p><ul><li>훨씬 적은 수의 단계를 사용하여 고품질 샘플을 생성합니다.</li><li>생성 프로세스는 결정론적이므로 “일관성” 속성을 갖습니다. 즉, 동일한 잠재 변수에 대해 조건화된 여러 샘플이 유사한 상위 수준 특징을 가져야 함을 의미합니다.</li><li>일관성으로 인해 DDIM은 잠재 변수에서 의미상 의미 있는 보간을 수행할 수 있습니다.</li></ul><p>잠재 확산 모델(LDM ; Rombach &amp; Blattmann, et al. 2022 )은 픽셀 공간 대신 잠재 공간에서 확산 프로세스를 실행하므로 훈련 비용이 낮아지고 추론 속도가 빨라집니다.<br>이미지의 대부분의 비트가 지각적 세부 사항에 기여하고 공격적인 압축 후에도 의미론적 및 개념적 구성이 여전히 남아 있다는 관찰에 의해 동기가 부여되었습니다.<br>LDM은 먼저 자동 인코더로 픽셀 수준 중복성을 제거한 다음 학습된 잠재성에 대한 확산 프로세스를 통해 의미론적 개념을 조작&#x2F;생성하여 생성 모델링 학습을 통해 지각 압축과<br>의미론적 압축을 느슨하게 분해합니다.</p><p>지각적 압축 프로세스는 오토인코더 모델에 의존합니다. 인코더 입력 이미지를 압축하는 데 사용됩니다.<br>더 작은 2D 잠재 벡터로 여기서 다운샘플링 속도는. 그런 다음 디코더  잠재 벡터로부터 이미지를 재구성합니다.<br>이 논문에서는 잠재 공간에서 임의로 높은 분산을 방지하기 위해 오토인코더 훈련에서 두 가지 유형의 정규화를 탐구했습니다.</p><ul><li>KL-reg: 학습된 잠재성에 대한 표준 정규 분포에 대한 작은 KL 페널티로, VAE 와 유사합니다 .</li><li>VQ-reg: VQVAE 와 같이 디코더 내에서 벡터 양자화 계층을 사용 하지만 양자화 계층은 디코더에 의해 흡수됩니다.</li></ul><p>확산 및 노이즈 제거 프로세스는 잠재 벡터에서 발생합니다.<br>잡음 제거 모델은 이미지 생성을 위한 유연한 조건화 정보(예: 클래스 레이블, 의미 지도, 이미지의 흐릿한 변형)를<br>처리하기 위해 교차 주의 메커니즘이 강화된 시간 조건화된 U-Net입니다.<br>이 디자인은 교차 주의 메커니즘을 사용하여 다양한 양식의 표현을 모델에 융합하는 것과 동일합니다.<br>각 유형의 조건화 정보는 도메인별 인코더와 쌍을 이룹니다. 조건 입력을 투영하기 위해 교차 주의 구성 요소에 매핑될 수 있는 중간 표현으로,</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/latent-diffusion-arch.png" alt="그림 9. 잠재 확산 모델의 구조. (이미지 출처: Rombach &amp; Blattmann, et al. 2022 )"></p><h2 id="Conditioned-Generation"><a href="#Conditioned-Generation" class="headerlink" title="Conditioned Generation"></a>Conditioned Generation</h2><p>ImageNet 데이터세트와 같은 조건부 정보가 있는 이미지에 대해 생성 모델을 훈련하는 동안 클래스 레이블이나 설명 텍스트를 기준으로 조건부 샘플을 생성하는 것이 일반적입니다.</p><h3 id="Classifier-Guided-Diffusion"><a href="#Classifier-Guided-Diffusion" class="headerlink" title="Classifier Guided Diffusion"></a>Classifier Guided Diffusion</h3><p>클래스 정보를 확산 프로세스에 명시적으로 통합하기 위해 Dhariwal &amp; Nichol(2021)은 분류기를 교육했습니다.<br>시끄러운 이미지에 그리고 그라디언트를 사용하세요 컨디셔닝 정보에 대한 확산 샘플링 프로세스를 안내합니다.<br>(예: 대상 클래스 레이블) 노이즈 예측을 변경합니다. 그것을 기억해 공동 분포에 대한 점수 함수를 작성할 수 있습니다.  다음과 같이,</p><p>따라서 새로운 분류기 안내 예측기는 다음과 같은 형식을 취합니다.</p><p>분류자 지침의 강도를 제어하기 위해 가중치를 추가할 수 있습니다.</p><p>결과적으로 제거된 확산 모델 ( ADM )과 추가 분류자 지침이 있는 모델( ADM-G )은 SOTA 생성 모델(예: BigGAN)보다 더 나은 결과를 얻을 수 있습니다.</p><p>또한 U-Net 아키텍처를 일부 수정하여 <a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a>은 확산 모델을 사용하는 GAN보다 더 나은 성능을 보여주었습니다.<br>아키텍처 수정에는 더 큰 모델 깊이&#x2F;너비, 더 많은 주의 헤드, 다중 해상도 주의, 업&#x2F;다운샘플링을 위한 BigGAN 잔여 블록, 잔여 연결 재조정이 포함됩니다.</p><h3 id="Classifier-Free-Guidance"><a href="#Classifier-Free-Guidance" class="headerlink" title="Classifier-Free Guidance"></a>Classifier-Free Guidance</h3><p>독립적인 분류기가 없는 경우 , 조건부 확산 모델과 무조건 확산 모델의 점수를 통합하여 조건부 확산 단계를 실행하는 것이 여전히 가능합니다( Ho &amp; Salimans, 2021 ).<br>무조건적 노이즈 제거 확산 모델을 보자 점수 추정기를 통해 매개변수화됨 그리고 조건부 모델<br>매개변수화를 통해. 이 두 모델은 단일 신경망을 통해 학습할 수 있습니다. 정확히 말하면 조건부 확산 모델  쌍을 이루는 데이터에 대해 학습됩니다.<br>여기서 조건화 정보는 모델이 무조건 이미지를 생성하는 방법을 알 수 있도록 주기적으로 무작위로 삭제됩니다.</p><p>암시적 분류기의 기울기는 조건부 및 무조건 점수 추정기로 표현될 수 있습니다. 분류자가 안내하는 수정된 점수에 연결되면 점수는 별도의 분류자에 대한 종속성을 포함하지 않습니다.</p><p>그들의 실험에서는 분류기가 없는 지침이 FID(합성 이미지와 생성된 이미지 구별)와 IS(품질과 다양성) 사이에서 좋은 균형을 이룰 수 있음을 보여주었습니다.</p><p>안내 확산 모델인 GLIDE( Nichol, Dhariwal &amp; Ramesh, et al. 2022 )는 안내 전략, CLIP 안내 및 분류자 없는 안내를 모두 탐색한 결과 후자가 더 선호되는 것으로 나타났습니다.<br>그들은 CLIP 지침이 더 잘 일치하는 이미지 생성을 최적화하는 대신 CLIP 모델에 대한 적대적인 예를 사용하여 모델을 활용하기 때문이라고 가정했습니다.</p><h2 id="Scale-up-Generation-Resolution-and-Quality"><a href="#Scale-up-Generation-Resolution-and-Quality" class="headerlink" title="Scale up Generation Resolution and Quality"></a>Scale up Generation Resolution and Quality</h2><p>고해상도에서 고품질 이미지를 생성하기 위해 Ho et al. (2021)은 증가하는 해상도에서 다중 확산 모델의 파이프라인을 사용할 것을 제안했습니다.<br>파이프라인 모델 간의 노이즈 조절 증대는 최종 이미지 품질에 매우 중요하며, 이는 조절 입력에 강력한 데이터 증대를 적용하는 것입니다.</p><p>각 초해상도 모델의 컨디셔닝 노이즈는 파이프라인 설정의 복합 오류를 줄이는 데 도움이 됩니다.<br>U-net은 고해상도 이미지 생성을 위한 확산 모델링에서 일반적인 모델 아키텍처 선택입니다.</p><p>![그림 11. 증가하는 해상도에서 다중 확산 모델의 계단식 파이프라인. (이미지 출처: Ho et al. 2021 ])](<a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/cascaded-diffusion.png">https://lilianweng.github.io/posts/2021-07-11-diffusion-models/cascaded-diffusion.png</a>)</p><p>그들은 가장 효과적인 노이즈가 낮은 해상도에서 가우스 노이즈를 적용하고 고해상도에서 가우시안 블러를 적용하는 것임을 발견했습니다.<br>또한 그들은 훈련 과정에 약간의 수정이 필요한 두 가지 형태의 컨디셔닝 강화도 탐구했습니다. 컨디셔닝 노이즈는 훈련에만 적용되고 추론에는 적용되지 않습니다.</p><ul><li>Truncated Conditioning Augment는 단계 초기에 확산 프로세스를 중지합니다. 저해상도용.</li><li>잘리지 않은 조건화 확대는 0단계까지 전체 저해상도 역 프로세스를 실행하지만 다음과 같이 손상됩니다.</li><li>그런 다음 부패한 동물에게 먹이를 줍니다. 초해상도 모델에 들어갑니다.</li></ul><p>2단계 확산 모델 unCLIP ( Ramesh et al. 2022 )은 CLIP 텍스트 인코더를 많이 활용하여 고품질의 텍스트 안내 이미지를 생성합니다. 사전 훈련된 CLIP 모델이 주어지면<br>확산 모델에 대한 쌍을 이루는 훈련 데이터,, 어디  이미지이고 해당 캡션을 사용하면 CLIP 텍스트 및 이미지 임베딩을 계산할 수 있습니다.<br>그리고, 각각. unCLIP은 두 가지 모델을 병렬로 학습합니다.</p><ul><li>이전 모델 :CLIP 이미지 임베딩을 출력합니다. 주어진 텍스트</li><li>디코더 : 이미지를 생성합니다 주어진 CLIP 이미지 임베딩 선택적으로 원본 텍스트 . 이 두 모델은 조건부 생성을 가능하게 합니다.</li></ul><p>unCLIP은 2단계 이미지 생성 프로세스를 따릅니다.</p><ul><li>텍스트가 주어짐 CLIP 모델은 먼저 텍스트 임베딩을 생성하는 데 사용됩니다. CLIP 잠재 공간을 사용하면 텍스트를 통해 제로샷 이미지 조작이 가능해집니다.</li><li>확산 또는 자기회귀 사전 이 CLIP 텍스트 임베딩을 처리하여 이미지를 먼저 구성한 다음 확산 디코더를 구성합니다. 사전 조건에 따라 이미지를 생성합니다.<br>이 디코더는 이미지 입력에 따라 이미지 변형을 생성하여 스타일과 의미를 보존할 수도 있습니다.</li></ul><p>CLIP 모델 대신 Imagen ( Saharia et al. 2022 )은 사전 훈련된 대형 LM(즉, 고정된 T5-XXL 텍스트 인코더)을 사용하여 이미지 생성을 위한 텍스트를 인코딩합니다.<br>모델 크기가 클수록 이미지 품질이 향상되고 텍스트-이미지 정렬이 향상되는 일반적인 경향이 있습니다.<br>그들은 T5-XXL과 CLIP 텍스트 인코더가 MS-COCO에서 유사한 성능을 달성하지만 인간 평가에서는 DrawBench(11개 범주를 다루는 프롬프트 모음)에서 T5-XXL을 선호한다는 것을 발견했습니다.</p><p>분류자 없는 지침을 적용하면 증가합니다. 이미지-텍스트 정렬은 향상되지만 이미지 충실도는 저하될 수 있습니다. 그들은 훈련-테스트 불일치, 즉 훈련 데이터 때문에 발생한다는 것을 발견했습니다.<br>범위 내에서 유지됩니다., 테스트 데이터도 그래야 합니다. 두 가지 임계값 전략이 도입되었습니다</p><ul><li>정적 임계값: 클립 에 대한 예측</li><li>동적 임계값: 각 샘플링 단계에서 다음을 계산합니다. 특정 백분위수 절대 픽셀 값으로; 만약에 예측을 다음으로 자릅니다. 그리고 다음으로 나눈다</li></ul><p>Imagen은 U- net을 효율적으로 만들기 위해 U-net의 여러 디자인을 수정합니다 .</p><ul><li>낮은 해상도에 더 많은 잔여 잠금(residual locks)을 추가하여 모델 매개변수를 고해상도 블록에서 저해상도로 전환합니다.</li><li>건너뛰기 연결 크기 조정</li><li>순방향 전달 속도를 향상시키기 위해 다운샘플링(컨볼루션 전에 이동) 및 업샘플링 작업(컨볼루션 후 이동)의 순서를 반대로 바꿉니다.</li></ul><p>그들은 잡음 조절 증대, 동적 임계값 지정 및 효율적인 U-Net이 이미지 품질에 중요하지만 텍스트 인코더 크기 조정이 U-Net 크기보다 더 중요하다는 것을 발견했습니다.</p><h2 id="빠른-요약"><a href="#빠른-요약" class="headerlink" title="빠른 요약"></a>빠른 요약</h2><ul><li><p>장점 : 다루기 쉽고 유연성은 생성 모델링에서 두 가지 상충되는 목표입니다.<br>다루기 쉬운 모델은 분석적으로 평가하고 데이터를 저렴하게 맞출 수 있지만(예: Gaussian 또는 Laplace를 통해) 풍부한 데이터세트의 구조를 쉽게 설명할 수는 없습니다.<br>유연한 모델은 데이터의 임의 구조에 적합할 수 있지만 이러한 모델의 평가, 훈련 또는 샘플링에는 일반적으로 비용이 많이 듭니다. 확산 모델은 분석적으로 다루기 쉽고 유연합니다.</p></li><li><p>단점 : 확산 모델은 샘플을 생성하기 위해 긴 Markov 확산 단계 체인을 사용하므로 시간과 계산 측면에서 상당히 비쌀 수 있습니다.<br>프로세스를 훨씬 빠르게 만들기 위해 새로운 방법이 제안되었지만 샘플링은 여전히 GAN보다 느립니다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">diffusion-models</a></li><li><a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EB%A5%B4%EC%BD%94%ED%94%84_%EC%97%B0%EC%87%84">마르코프 연쇄</a></li><li><a href="https://www.puzzledata.com/blog190423/">마르코프 체인에 관하여</a></li><li><a href="https://arxiv.org/abs/1503.03585">Deep Unsupervised Learning using Nonequilibrium Thermodynamics</a></li><li><a href="https://arxiv.org/abs/1907.05600">Generative Modeling by Estimating Gradients of the Data Distribution</a></li><li><a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Models</a></li><li><a href="https://lilianweng.github.io/posts/2018-08-12-vae/#reparameterization-trick">Reparameterization Trick</a></li><li><a href="https://www.stats.ox.ac.uk/~teh/research/compstats/WelTeh2011a.pdf">Bayesian Learning via Stochastic Gradient Langevin Dynamics</a></li><li><a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a></li><li><a href="https://process-mining.tistory.com/182">Diffusion model 설명 (Diffusion model이란? Diffusion model 증명)</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/diffusion-model-basic/">Diffusion Model 설명 – 기초부터 응용까지</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FirebaseError Installations: Could not process request. Application offline.</title>
      <link>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/</guid>
      <pubDate>Thu, 26 Oct 2023 08:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;FirebaseError-Installations-Could-not-process-request-Application-offline&quot;&gt;&lt;a href=&quot;#FirebaseError-Installations-Could-not-process-r
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="FirebaseError-Installations-Could-not-process-request-Application-offline"><a href="#FirebaseError-Installations-Could-not-process-request-Application-offline" class="headerlink" title="FirebaseError Installations: Could not process request. Application offline."></a>FirebaseError Installations: Could not process request. Application offline.</h1><p>갑자기 특정 페이지에서 에러가나면서 랜더링이 되지 않은 이슈가 있었다 콘솔 로그를 보니 아래에 에러메시지가 나오고 있었다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirebaseError Installations: Could not process request. Application offline.</span><br></pre></td></tr></table></figure><p>플러그인 문제인줄 알고 모든 플러그인 삭제 및 캐쉬 삭제 후에도 동일한 이슈가 발생하였다.</p><p>구글링을 해보니 아래와 같은 이슈가 있었다.</p><ul><li><a href="https://github.com/firebase/firebase-js-sdk/issues/4922">FirebaseError Installations: Could not process request. Application offline.</a></li></ul><p>해결은 되지 않았지만 한명이 와이파이를 온오프 해보라는 메시지가 있었다 그것으로 해결이 되었다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/firebase/firebase-js-sdk/issues/4922">FirebaseError Installations: Could not process request. Application offline.</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stable-diffusion-webui docker 설치</title>
      <link>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/</guid>
      <pubDate>Thu, 26 Oct 2023 01:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;stable-diffusion-webui-docker-설치&quot;&gt;&lt;a href=&quot;#stable-diffusion-webui-docker-설치&quot; class=&quot;headerlink&quot; title=&quot;stable-diffusion-webui docke
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="stable-diffusion-webui-docker-설치"><a href="#stable-diffusion-webui-docker-설치" class="headerlink" title="stable-diffusion-webui docker 설치"></a>stable-diffusion-webui docker 설치</h1><p>먼저 docker를 설치해야 한다.</p><h2 id="docker-설치"><a href="#docker-설치" class="headerlink" title="docker 설치"></a>docker 설치</h2><p>도커의 자동 설치 스크립트 사용</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -qO- http://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>우분투 직접 설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line">sudo ln -sf /usr/bin/docker.io /usr/local/bin/docker</span><br></pre></td></tr></table></figure><p>도커 권한 부여</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker group 추가</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker group에 현재의 사용자 추가</span></span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker-compose 설치"></a>docker-compose 설치</h2><p><a href="https://github.com/docker/compose/releases">docker compose releases</a> 여기에서 최신버전을 확인후에 설치한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/$&#123;최신버전&#125;/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>권한추가</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="NVIDIA-Container-Toolkit-설치"><a href="#NVIDIA-Container-Toolkit-설치" class="headerlink" title="NVIDIA Container Toolkit 설치"></a>NVIDIA Container Toolkit 설치</h2><p>그리고 엔비디아의 NVIDIA Container Toolkit을 설치해야 한다.</p><p>저장소 등록 및 업데이트</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | \</span><br><span class="line">    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list \</span><br><span class="line">  &amp;&amp; \</span><br><span class="line">    sudo apt-get update</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nvidia-container-toolkit</span><br></pre></td></tr></table></figure><h2 id="stable-diffusion-webui-docker-설치-1"><a href="#stable-diffusion-webui-docker-설치-1" class="headerlink" title="stable-diffusion-webui-docker 설치"></a>stable-diffusion-webui-docker 설치</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/AbdBarho/stable-diffusion-webui-docker.git</span><br><span class="line"></span><br><span class="line">cd stable-diffusion-webui-docker</span><br><span class="line"></span><br><span class="line">docker compose --profile download up --build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wait</span> until its <span class="keyword">done</span>, <span class="keyword">then</span>:</span></span><br><span class="line">docker compose --profile [ui] up --build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">where</span> [ui] is one of: invoke | auto | auto-cpu | comfy | comfy-cpu</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위에 도커 컴포즈 파일에서는 같은 포트를 사용해서 기동하도록 되어 있다 여러개를 동시해 실행하고 싶으면 포트를 변경해야 한다.<br>아래 처럼 실행 가능하다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WEBUI_PORT=7861 docker compose --profile comfy up --build</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html">Installing the NVIDIA Container Toolkit</a></li><li><a href="https://github.com/docker/compose/releases">docker compose releases</a></li><li><a href="https://github.com/AbdBarho/stable-diffusion-webui-docker">stable-diffusion-webui-docker</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Please make sure you have the correct access rights and the repository exists</title>
      <link>https://sejoung.github.io/2023/10/2023-10-24-git_error/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-24-git_error/</guid>
      <pubDate>Tue, 24 Oct 2023 03:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러&quot;&gt;&lt;a href=&quot;#Please-make-sure-you-have-the-correct-ac
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러"><a href="#Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러" class="headerlink" title="Please make sure you have the correct access rights and the repository exists 에러"></a>Please make sure you have the correct access rights and the repository exists 에러</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ERROR: Repository not found.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l -E md5</span><br></pre></td></tr></table></figure><p>위에 명령어를 실행했을때 아래의 메시지가 나오면</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The agent has no identities.</span><br></pre></td></tr></table></figure><p>아래의 명령어로 등록을 하면 좋다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://stackoverflow.com/questions/25927914/git-error-please-make-sure-you-have-the-correct-access-rights-and-the-reposito">stackoverflow git error</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-24-git_error/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP 405 – Python Virtual Environments</title>
      <link>https://sejoung.github.io/2023/10/2023-10-23-python_venv/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-23-python_venv/</guid>
      <pubDate>Mon, 23 Oct 2023 02:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Python-Virtual-Environments&quot;&gt;&lt;a href=&quot;#Python-Virtual-Environments&quot; class=&quot;headerlink&quot; title=&quot;Python Virtual Environments&quot;&gt;&lt;/a&gt;Pytho
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Python-Virtual-Environments"><a href="#Python-Virtual-Environments" class="headerlink" title="Python Virtual Environments"></a>Python Virtual Environments</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>이 PEP는 자체 사이트 디렉토리가 있는 경량 “가상 환경”을 위한 메커니즘을 Python에 추가하고 선택적으로 시스템 사이트 디렉토리에서 격리할 것을 제안합니다.<br>각 가상 환경에는 고유한 Python 바이너리(다양한 Python 버전으로 환경 생성 가능)가 있으며 사이트 디렉터리에 독립적으로 설치된 Python 패키지 세트가 있을 수 있지만<br>기본 설치된 Python과 표준 라이브러리를 공유합니다.</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Python 가상 환경의 유용성은 주로 Ian Bicking의 virtualenv와 같은 기존 타사 가상 환경 도구의 인기로 인해 이미 잘 확립되었습니다.<br>가상 환경은 종속성 관리 및 격리, 시스템 관리자 액세스 없이 Python 패키지를 쉽게 설치 및 사용하고<br>여러 Python 버전에 걸쳐 Python 소프트웨어를 자동으로 테스트하는 등의 용도로 이미 널리 사용되고 있습니다.</p><p>기존 가상 환경 도구는 Python 자체의 동작으로 인한 지원 부족으로 어려움을 겪습니다.<br>Python 바이너리를 가상 환경에 복사하지 않는 virtualenv 와 같은 도구는 시스템 사이트 디렉터리로부터 안정적인 격리를 제공할 수 없습니다.<br>sitePython 바이너리를 복사하는 Virtualenv는 시작할 때마다 섬세한 부트 스트랩 댄스를 수행하기 위해 Python 모듈의 대부분을 복제하고 끊임없이 변화하는<br>표준 라이브러리 모듈 세트를 가상 환경에 수동으로 심볼릭 링크&#x2F;복사해야 합니다.<br>(Virtualenv는 격리를 제공하기 위해 바이너리를 복사해야 합니다.)</p><p>PYTHONHOME가상 환경을 위한 Python의 유일한 기존 내장 솔루션인 환경 변수는 전체 표준 라이브러리를 모든 환경에 복사&#x2F;심볼링 연결해야 합니다.<br>전체 표준 라이브러리를 복사하는 것은 간단한 솔루션이 아니며 심볼릭 링크에 대한 크로스 플랫폼 지원은 일관성이 없습니다<br>(심지어 이를 지원하는 Windows 플랫폼에서도 이를 생성하려면 관리자 권한이 필요한 경우가 많습니다).</p><p>Python과 통합되고 기존 타사 도구에 대한 수년간의 경험을 활용하는 가상 환경 메커니즘은 유지 관리를 줄이고 안정성을 높이며 모든 Python 사용자가 더 쉽게 사용할 수 있습니다.</p><h2 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h2><p>Python 바이너리가 실행되면 접두사(에 저장됨 sys.prefix)를 결정하려고 시도한 다음 표준 라이브러리 및 기타 주요 파일을 찾는 데 사용되며<br>모듈은 site사이트 패키지 디렉터리의 위치를 결정합니다.<br>현재 접두사는 먼저 표준 라이브러리의 존재를 나타내는 PYTHONHOME마커 파일(os.py바이너리)</p><p>이 PEP는 이 검색에 새로운 첫 번째 단계를 추가할 것을 제안합니다.<br>파일 pyvenv.cfg이 Python 실행 파일 옆에 있거나 그 위의 한 디렉터리에서<br>발견되면(실행 파일이 심볼릭 링크인 경우 역참조되지 않음) 이 파일에서 형식의 줄을 검색합니다.<br>키가 발견 되면 이는 Python 바이너리가 가상 환경에 속하고 키의 값이 이 가상 환경을 만드는 데 사용된 Python 실행 파일이 포함된 디렉터리임을 의미합니다. key &#x3D; valuehomehome</p><p>home이 경우 접두사 찾기 는 기본 설치의 접두사를 찾는 효과적인 Python 바이너리 위치로 키 값을 사용하여 정상적으로 계속됩니다.<br>sys.base_prefix은 이 값으로 설정되고 는 가 sys.prefix포함된 디렉터리로 설정됩니다 pyvenv.cfg.<br>(pyvenv.cfg가 발견되지 않거나 키를 포함하지 않는 경우 home접두사 찾기는 정상적으로 계속되며 와 sys.prefix같습니다 sys.base_prefix.)</p><p>또한 sys.base_exec_prefix가 추가되고 와 관련하여 유사하게 처리됩니다 sys.exec_prefix.<br>(sys.exec_prefix와 동일 sys.prefix하지만 플랫폼별 파일의 경우 기본적으로 와 동일한 값을 갖습니다 sys.prefix.)</p><p>및 표준 라이브러리 모듈은 표준 라이브러리와 헤더 파일이 &#x2F; 를 기준으로 검색되는 반면 사이트 패키지 디렉터리(“purelib” 및 “platlib”)<br>site는 여전히 &#x2F; 를 기준으로 검색되도록 수정됩니다 .sysconfigsys.base_prefixsys.base_exec_prefixsysconfigsys.prefixsys.exec_prefix</p><p>pyvenv.cfg따라서 가장 간단한 형태의 Python 가상 환경은 파일 및 사이트 패키지 디렉터리 와 함께 제공되는 Python 바이너리의 복사본 또는 심볼릭 링크로만 구성됩니다 .</p><h3 id="시스템-사이트-패키지로부터-격리"><a href="#시스템-사이트-패키지로부터-격리" class="headerlink" title="시스템 사이트 패키지로부터 격리"></a>시스템 사이트 패키지로부터 격리</h3><p>기본적으로 가상 환경은 시스템 수준 사이트 패키지 디렉터리와 완전히 격리됩니다.</p><p>파일에 값이 대소문자를 구분하지 않는 pyvenv.cfg키가 포함되어 있는 경우 모듈은 가상 환경 사이트 디렉터리 뒤에 시스템 사이트 디렉터리도 추가합니다.<br>따라서 시스템에 설치된 패키지는 계속 가져올 수 있지만 가상 환경에 설치된 동일한 이름의 패키지가 우선적으로 적용됩니다.include-system-site-packagestruesitesys.path</p><p>PEP 370 사용자 수준 사이트 패키지는 venv 목적을 위한 시스템 사이트 패키지의 일부로 간주됩니다.<br>격리된 venv에서는 사용할 수 없지만 venv에서는 사용할 수 있습니다 .include-system-site-packages &#x3D; true</p><h3 id="가상-환경-만들기"><a href="#가상-환경-만들기" class="headerlink" title="가상 환경 만들기"></a>가상 환경 만들기</h3><p>venv또한 이 PEP 에서는 가상 환경 생성을 구현하는 표준 라이브러리에 새 모듈을 추가할 것을 제안합니다.<br>이 모듈은 다음 플래그를 사용하여 실행할 수 있습니다 -m</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><p>이를 더욱 편리하게 하기 위해 설치된 스크립트 pyvenv도 제공됩니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyvenv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><p>이 명령을 실행하면 대상 디렉터리가 생성되고(아직 존재하지 않는 상위 디렉터리 생성) 해당 디렉터리 pyvenv.cfg에 home명령이 실행된 Python 설치를 가리키는 키가 포함된 파일이 배치됩니다.<br>또한 실행 파일 의 복사본(또는 심볼릭 링크) 과 표준 라이브러리 모듈 의 스크립트가 포함된 하위 디렉터리 bin&#x2F;(또는 Windows의 경우) 를 생성합니다<br>(PyPI에서 새 venv로 패키지를 쉽게 설치할 수 있도록 함).<br>그리고 (처음에는 비어 있는) (또는 Windows의 경우) 하위 디렉터리를 만듭니다</p><p>대상 디렉터리가 이미 존재하는 경우 옵션이 제공되지 않는 한 오류가 발생하며, –clear이 경우 대상 디렉터리가 삭제되고 가상 환경 생성이 평소대로 진행됩니다.</p><p>생성된 파일에는 기본적으로 옵션과 함께 실행되는 경우 로 설정된 키 pyvenv.cfg도 포함됩니다</p><p>에 여러 경로를 지정할 수 있으며 pyvenv, 이 경우 제공된 각 경로에 지정된 옵션에 따라 동일한 가상 환경이 생성됩니다.</p><p>이 모듈은 또한 venv의 또는 디렉터리 venv에 POSIX 및 Windows 시스템용 “셸 활성화 스크립트”를 배치합니다. 이러한 스크립트는 단순히 가상 환경의 (또는 )<br>디렉터리를 사용자의 셸 PATH 앞에 추가합니다. 이는 가상 환경을 사용하는 데 반드시 필요한 것은 아니지만<br>(venv의 Python 바이너리 또는 스크립트에 대한 명시적 경로를 사용할 수도 있으므로) 편리합니다.</p><p>pysetup다른 Python 패키지 관리자가 일반 Python 설치에 설치하는 것과 동일한 방식으로 가상 환경에 패키지를<br>설치할 수 있도록 허용 하고 적절한 경우 sysconfig대신 사용할 수 있는 특수한 가상 환경을 피하기 위해 내부 가상 환경 레이아웃은 다음을 모방 합니다.<br>각 플랫폼의 Python 설치 자체 레이아웃. 따라서 POSIX 시스템의 일반적인 가상 환경 레이아웃은 다음과 같습니다.</p><p>가상 환경에 설치된 타사 패키지의 Python 모듈은 디렉터리에 배치되고 site-packages해당 실행 파일은 bin&#x2F;또는 에 배치됩니다 Scripts.</p><h3 id="Sysconfig-설치-구성표-및-사용자-사이트"><a href="#Sysconfig-설치-구성표-및-사용자-사이트" class="headerlink" title="Sysconfig 설치 구성표 및 사용자 사이트"></a>Sysconfig 설치 구성표 및 사용자 사이트</h3><p>이 접근 방식은 venvs에 대한 새로운 sysconfig 설치 체계를 도입하지 않도록 명시적으로 선택합니다.<br>오히려 수정을 통해 sys.prefix위치 기반이 되는 기존 설치 구성표가 sys.prefix가상 환경에서 작동하도록 보장합니다.<br>경로가 에 상대적이지 않은 다른 설치 구성표(예: 사용자 사이트 구성표)에 대한 설치는 sys.prefixvenv의 영향을 전혀 받지 않습니다.</p><p>가상 특정 sysconfig 체계를 기반으로 Python 가상 환경의 대체 구현을 만드는 것이 가능할 수 있지만 가상 환경 내에서 작동하는지 여부를 인식하려면 더 많은 코드가 필요하므로 덜 강력합니다.</p><h3 id="복사본과-심볼릭-링크"><a href="#복사본과-심볼릭-링크" class="headerlink" title="복사본과 심볼릭 링크"></a>복사본과 심볼릭 링크</h3><p>이 PEP의 기술은 일반적으로 복사되거나 심볼릭 링크된 Python 바이너리(및 Windows에서 필요한 기타 DLL)와 동일하게 작동합니다.<br>기본 Python 설치로 업그레이드하는 경우 venv에 복사된 Python 실행 파일이 설치된 표준 라이브러리와 동기화되지 않아 수동 업그레이드가 필요할 수 있으므로 가능한 경우<br>Symlinking을 사용하는 것이 좋습니다.</p><p>심볼릭 링크에는 몇 가지 크로스 플랫폼 문제가 있습니다.</p><ul><li>모든 Windows 버전이 심볼릭 링크를 지원하는 것은 아니며, 지원하는 경우에도 심볼릭 링크를 생성하려면 관리자 권한이 필요한 경우가 많습니다.</li><li>Python의 OS X 프레임워크 빌드에서 sys.executable은 실제 Python 바이너리를 실행하는 스텁일 뿐입니다.<br>이 스텁을 심볼릭 링크하는 것은 작동하지 않습니다. 복사해야 합니다.<br>(다행히도 스텁도 작고 Python으로의 버그 수정 업그레이드로 변경되지 않으므로 복사하는 것은 문제가 되지 않습니다.)</li></ul><p>따라서 이 PEP는 Windows 및 OS X 프레임워크 빌드를 제외한 모든 플랫폼에서 바이너리를 심볼릭 링크하도록 제안합니다. –symlink<br>적절한 권한이 있는 경우 이를 지원하는 Windows 버전에서 심볼릭 링크를 강제로 사용하도록 하는 옵션을 사용할 수 있습니다.<br>(이 옵션은 OS X 프레임워크 빌드에 영향을 미치지 않습니다. 왜냐하면 심볼릭 링크는 그곳에서 작동할 수 없고 이점도 없기 때문입니다.)</p><p>Windows에서 가 –symlink사용되지 않는 경우 이는 기본 Python 설치가 업그레이드되면 venv의 Python 바이너리 및 DLL이 업데이트되어야 함을 의미합니다.<br>그렇지 않으면 업그레이드된 표준 라이브러리와 불일치 문제가 발생할 수 있습니다. pyvenv 스크립트는 –upgrade기존 venv에서 이 업그레이드를 쉽게 수행하기 위한 옵션을 허용합니다.</p><h3 id="Include-files"><a href="#Include-files" class="headerlink" title="Include files"></a>Include files</h3><p>현재 virtualenv 핸들에는 다음과 같은 방식으로 파일이 포함됩니다.</p><p>설치된 Python의 포함 파일이 에 있는 POSIX 시스템 에서 ${base_prefix}&#x2F;include&#x2F;pythonX.Xvirtualenv ${venv}&#x2F;include&#x2F;는.<br>Python의 포함 파일이 있고 심볼릭 링크를 안정적으로 사용할 수 없는 Windows에서는 virtualenv 가.<br>이렇게 하면 virtualenv 내에 빌드되고 설치된 확장 모듈이 항상</p><p>이 솔루션은 확장 모듈이 자체 헤더 파일을 설치할 때 이상적이지 않습니다.<br>해당 헤더 파일의 기본 설치 위치가 쓰기 불가능한 시스템 디렉터리에 대한 심볼릭 링크일 수 있기 때문입니다.<br>한 설치 프로그램인 pip는 헤더 파일을 비표준 위치에 설치하여 명시적으로 이 문제를 해결합니다 ${venv}&#x2F;include&#x2F;site&#x2F;pythonX.X&#x2F;. Python에는<br>현재 사이트별 포함 디렉터리에 대한 표준 추상화가 없기 때문입니다.</p><p>이 PEP는 약간 다른 접근 방식을 제안하지만 본질적으로 동일한 효과와 동일한 장단점을 갖습니다.<br>포함 파일을 venv에 심볼릭 링크하거나 복사하는 대신 헤더 파일이 base_prefix항상 prefix.<br>(우리는 또한 include&#x2F;venv 내에 디렉토리를 생성하므로 설치 프로그램은 env 내에 설치된 포함 파일을 저장할 위치를 갖습니다.)</p><p>distutils&#x2F;packaging 및 확장에 따라 pyvenv의 포함 파일을 더 잘 처리하는 것은 자체 미래 PEP를 받을 자격이 있는 영역입니다.<br>지금은 virtualenv의 동작이 실제로 적어도 “충분히 좋은” 것으로 입증되었다고 제안합니다.</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>위에 설명된 상위 수준 방법은 타사 가상 환경 생성자가 필요에 따라 환경 생성을 사용자 정의할 수 있는 메커니즘을 제공하는 간단한 API를 사용합니다.</p><p>모듈 에는 인스턴스화 시 다음 키워드 인수를 허용하는 클래스가 venv포함되어 있습니다 .EnvBuilder</p><ul><li>system_site_packages- 시스템 Python 사이트 패키지를 환경에서 사용할 수 있어야 함을 나타내는 부울 값입니다. 기본값은 False.</li><li>clear- true인 경우 예외를 발생시키는 대신 기존 대상 디렉터리를 삭제하는 부울 값입니다. 기본값은 False.</li><li>symlinkspythonw.exe- 복사하는 대신 Python 바이너리(및 필요한 DLL 또는 기타 바이너리(예: ))를 심볼릭 링크할지 여부를 나타내는 부울 값입니다 . 기본값은 False.</li></ul><p>인스턴스화된 env-builder에는 create가상 환경을 포함할 대상 디렉터리의 경로(현재 디렉터리에 대한 절대 또는 상대 경로)를 필수 인수로 사용하는 메서드가 있습니다.<br>이 create메서드는 지정된 디렉터리에 환경을 생성하거나 적절한 예외를 발생시킵니다.</p><p>모듈 은 편의를 위해 venv모듈 수준 기능도 제공합니다 .create</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">env_dir,</span></span><br><span class="line"><span class="params">           system_site_packages=<span class="literal">False</span>, clear=<span class="literal">False</span>, use_symlinks=<span class="literal">False</span></span>):</span><br><span class="line">    builder = EnvBuilder(</span><br><span class="line">        system_site_packages=system_site_packages,</span><br><span class="line">        clear=clear,</span><br><span class="line">        use_symlinks=use_symlinks)</span><br><span class="line">    builder.create(env_dir)</span><br></pre></td></tr></table></figure><p>타사 가상 환경 도구 작성자는 제공된 EnvBuilder클래스를 기본 클래스로 자유롭게 사용할 수 있습니다.</p><p>create클래스 의 메소드는 사용자 EnvBuilder정의에 사용할 수 있는 후크를 보여줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, env_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create a virtualized Python environment in a directory.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param env_dir: The target directory to create an environment in.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    env_dir = os.path.abspath(env_dir)</span><br><span class="line">    context = self.create_directories(env_dir)</span><br><span class="line">    self.create_configuration(context)</span><br><span class="line">    self.setup_python(context)</span><br><span class="line">    self.post_setup(context)</span><br></pre></td></tr></table></figure><p>create_directories, create_configuration, setup_python및 각 메소드는 post_setup재정의될 수 있습니다. 이러한 메소드의 기능은 다음과 같습니다.</p><ul><li><p>create_directories- 환경 디렉터리와 필요한 모든 디렉터리를 생성하고 컨텍스트 개체를 반환합니다. 이는 다른 메소드에서 사용하기 위한 속성(예: 경로)의 홀더일 뿐입니다.</p></li><li><p>create_configuration- pyvenv.cfg환경에 구성 파일을 생성합니다.</p></li><li><p>setup_python- 환경에 Python 실행 파일(및 Windows에서는 DLL)의 복사본을 생성합니다.</p></li><li><p>post_setup- 패키지를 사전 설치하거나 가상 환경에 스크립트를 설치하기 위해 타사 서브클래스에서 재정의할 수 있는(기본적으로 무작동) 후크 방법입니다.</p></li></ul><p>또한 가상 환경에 사용자 정의 스크립트를 설치하는 데 도움이 되도록 하위 클래스 EnvBuilder에서 호출할 수 있는 유틸리티 메서드를 제공합니다.<br>post_setup이 메서드는 개체(위 참조)와 디렉터리 경로를 install_scripts인수로 받아들입니다.<br>context디렉터리에는 하위 디렉터리 “common”, “posix”, “nt”가 포함되어야 하며 각 디렉터리에는 환경의 bin 디렉터리로 향하는 스크립트가 포함되어 있습니다.<br>“common”의 내용과 해당 디렉터리는 os.name자리 표시자의 일부 텍스트 교체를 수행한 후 복사됩니다.</p><ul><li>__VENV_DIR__환경 디렉터리의 절대 경로로 대체됩니다.</li><li>__VENV_NAME__환경 이름(환경 디렉터리의 최종 경로 세그먼트)으로 대체됩니다.</li><li>__VENV_BIN_NAME__은 bin 디렉토리의 이름(또는 bin) 으로 대체됩니다 Scripts.</li><li>__VENV_PYTHON__환경 실행 파일의 절대 경로로 대체됩니다.</li></ul><p>참조 구현의 서브 클래스 DistributeEnvBuilder는 가상 환경에 Distribute를 사전 설치하기 위해 실제로 사용자 정의 후크를 사용하는 방법을 보여줍니다.<br>Python 코어에 실제로 추가될 것이라고 는 예상되지 않지만 DistributeEnvBuilder참조 구현을 테스트 및 탐색 목적에 더 즉각적으로 유용하게 만듭니다.</p><h2 id="Backwards-Compatibility"><a href="#Backwards-Compatibility" class="headerlink" title="Backwards Compatibility"></a>Backwards Compatibility</h2><h3 id="sys-prefix-의미를-나누다"><a href="#sys-prefix-의미를-나누다" class="headerlink" title="sys.prefix 의미를 나누다"></a>sys.prefix 의미를 나누다</h3><p>이 라인에 따른 모든 가상 환경 도구(사이트 패키지를 분리하려고 시도하면서 가상 환경에 심볼릭 링크할 필요 없이 기본 Python의 표준 라이브러리를 계속 사용함)는<br>두 가지 다른 의미 사이의 분할을 제안합니다. )는 현재 둘 다 sys.prefix”표준 라이브러리는 어디에 있습니까?”라는 질문에 대한 답변으로 요약되어 있습니다.<br>및 “타사 모듈을 설치해야 하는 사이트 패키지 위치는 어디에 있습니까?”</p><p>sys이 분할은 전자 접두사 또는 후자 접두사에 대한 새 속성을 도입하여 처리할 수 있습니다.<br>어느 옵션이든 sys.prefix. (이러한 소프트웨어는 이러한 질문에 대답하기 위해 직접 사용하는 것보다 site및 모듈 의 API를 사용하는 것이 바람직합니다.<br>이 경우 이전 버전과의 호환성 문제는 없지만 실제로는 때때로 사용됩니다.)</p><p>sys.prefix 에 대한 문서 에서는 이를 “플랫폼 독립적인 Python 파일이 설치된 사이트별 디렉터리 접두사를 제공하는 문자열”이라고 설명하고,<br>에 있는 표준 라이브러리 및 헤더 파일을 구체적으로 언급합니다 sys.prefix. 에 대해서는 언급하지 않습니다 site-packages.</p><p>sys.prefix이 문서화된 정의를 유지한다는 것은 기본 시스템 설치(표준 라이브러리와 헤더 파일이 있는 위치)를 가리키는 것을 그대로 두고 의 접두사를 가리키도록 에 새 값 sys(예: )을<br>도입하는 것을 의미합니다 . 이렇게 하면 문서화된 의미 체계가 유지되지만 타사 코드에서 적절한 API를 사용 하여 사이트 패키지 디렉터리를 찾는 경우<br>격리가 중단될 위험이 있습니다.</p><p>가장 주목할만한 사례는 아마도 API를 주로 사용 하지만 파일을 유용하게 배치할 수 있는 비행 전 확인을 위해 사이트 디렉터리 목록을 작성하는 데 직접 사용하는<br>setuptools 및 해당 포크 배포 일 것입니다.</p><p>sys.prefix그렇지 않으면 Google 코드 검색 은 사이트 패키지 경로를 구축하는 데 사용하는 패키지와 이를 사용하여 코드 실행 추적에서 표준 라이브러리를 제거하는 데<br>사용하는 패키지 간의 사용법이 대략 균일하게 혼합된 것처럼 보이는 것을 나타냅니다 .</p><p>의 문서화된 정의를 수정해야 하지만 sys.prefix이 PEP는 sys.prefix가상 환경(이 site-packages발견된 위치) 을 가리키고 sys.base_prefix표준 라이브러리 및<br>Python 헤더 파일을 가리키도록 소개하는 것을 선호합니다. 이 선택의 근거:</p><ul><li>가상 환경을 더 많이 격리하는 편이 더 좋습니다.</li><li>Virtualenv는 이미 sys.prefix가상 환경을 가리키도록 수정되었으며 실제로는 문제가 되지 않았습니다.</li><li>setuptools&#x2F;distribute에는 수정이 필요하지 않습니다.</li></ul><h3 id="다른-Python-구현에-미치는-영향"><a href="#다른-Python-구현에-미치는-영향" class="headerlink" title="다른 Python 구현에 미치는 영향"></a>다른 Python 구현에 미치는 영향</h3><p>이 PEP 변경 사항의 대부분은 다른 Python 구현과 공유되는 표준 라이브러리에서 발생하며 문제가 발생하지 않습니다.</p><p>다른 Python 구현에서는 파일 찾기 및 구문 분석(있는 경우)을 sys.prefix포함하여 인터프리터 부트스트랩의 새로운 찾기 동작을 복제해야 합니다 .pyvenv.cfg</p><h2 id="Reference-Implementation"><a href="#Reference-Implementation" class="headerlink" title="Reference Implementation"></a>Reference Implementation</h2><p>참조 구현은 CPython Mercurial 저장소의 복제본 에서 찾을 수 있습니다. 테스트하려면 빌드하고 실행하여 가상 환경을 만듭니다.bin&#x2F;pyvenv &#x2F;path&#x2F;to&#x2F;new&#x2F;venv</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://peps.python.org/pep-0405/">PEP 405 – Python Virtual Environments</a></li><li><a href="https://docs.python.org/ko/3/library/venv.html">venv</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-23-python_venv/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stable-diffusion-webui 우분투에 설치</title>
      <link>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/</guid>
      <pubDate>Wed, 18 Oct 2023 04:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;stable-diffusion-webui-우분투에-설치&quot;&gt;&lt;a href=&quot;#stable-diffusion-webui-우분투에-설치&quot; class=&quot;headerlink&quot; title=&quot;stable-diffusion-webui 우분투에 설치&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="stable-diffusion-webui-우분투에-설치"><a href="#stable-diffusion-webui-우분투에-설치" class="headerlink" title="stable-diffusion-webui 우분투에 설치"></a>stable-diffusion-webui 우분투에 설치</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install git python3.10-venv -y</span><br><span class="line">git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui &amp;&amp; cd stable-diffusion-webui</span><br><span class="line">python3.10 -m venv venv</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="시작-방법"><a href="#시작-방법" class="headerlink" title="시작 방법"></a>시작 방법</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webui.sh</span><br></pre></td></tr></table></figure><h2 id="외부에서-접속가능하게-설정"><a href="#외부에서-접속가능하게-설정" class="headerlink" title="외부에서 접속가능하게 설정"></a>외부에서 접속가능하게 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./webui.sh --listen</span><br></pre></td></tr></table></figure><h2 id="팁"><a href="#팁" class="headerlink" title="팁"></a>팁</h2><p>아래 처럼 모델 다운로드시에는 꼭 lfs로 해야 된다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://huggingface.co/lllyasviel/ControlNet-v1-1</span><br></pre></td></tr></table></figure><p>플러그인 설치는 외부로 오픈된 상태에서는 설정이 되지 않는다</p><h2 id="오류"><a href="#오류" class="headerlink" title="오류"></a>오류</h2><p>아래 오류에서 저는 모델 이 잘못됨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2023-10-18 13:56:20,737 - ControlNet - INFO - Loading model: control_v11e_sd15_ip2p [e3b0c442]</span><br><span class="line">*** Error running process: /repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/modules/scripts.py&quot;, line 619, in process</span><br><span class="line">        script.process(p, *script_args)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 977, in process</span><br><span class="line">        self.controlnet_hack(p)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 966, in controlnet_hack</span><br><span class="line">        self.controlnet_main_entry(p)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 688, in controlnet_main_entry</span><br><span class="line">        model_net = Script.load_control_model(p, unet, unit.model)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 321, in load_control_model</span><br><span class="line">        model_net = Script.build_control_model(p, unet, model)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 349, in build_control_model</span><br><span class="line">        state_dict = load_state_dict(model_path)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/utils.py&quot;, line 20, in load_state_dict</span><br><span class="line">        state_dict = unsafe_torch_load(ckpt_path, map_location=torch.device(location))</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/venv/lib/python3.10/site-packages/torch/serialization.py&quot;, line 815, in load</span><br><span class="line">        return _legacy_load(opened_file, map_location, pickle_module, **pickle_load_args)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/venv/lib/python3.10/site-packages/torch/serialization.py&quot;, line 1033, in _legacy_load</span><br><span class="line">        magic_number = pickle_module.load(f, **pickle_load_args)</span><br><span class="line">    _pickle.UnpicklingError: invalid load key, &#x27;v&#x27;.</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui#installation-and-running">installation-and-running</a></li><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/88">Can this be made avalable network-wide, not just on localhost? #88</a></li><li><a href="https://github.com/Mikubill/sd-webui-controlnet/issues/1617">Could not set ControlNet value: invalid literal for int() with base 10: ‘initial’</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>우분투에 CUDA 11.8 설치</title>
      <link>https://sejoung.github.io/2023/10/2023-10-18-ubuntu_cuda_install/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-18-ubuntu_cuda_install/</guid>
      <pubDate>Wed, 18 Oct 2023 01:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;우분투에-CUDA-11-8-설치&quot;&gt;&lt;a href=&quot;#우분투에-CUDA-11-8-설치&quot; class=&quot;headerlink&quot; title=&quot;우분투에 CUDA 11.8 설치&quot;&gt;&lt;/a&gt;우분투에 CUDA 11.8 설치&lt;/h1&gt;&lt;h2 id=&quot;GPU가-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="우분투에-CUDA-11-8-설치"><a href="#우분투에-CUDA-11-8-설치" class="headerlink" title="우분투에 CUDA 11.8 설치"></a>우분투에 CUDA 11.8 설치</h1><h2 id="GPU가-있는지-확인"><a href="#GPU가-있는지-확인" class="headerlink" title="GPU가 있는지 확인"></a>GPU가 있는지 확인</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i nvidia</span><br></pre></td></tr></table></figure><h2 id="기존의-설치된것-삭제"><a href="#기존의-설치된것-삭제" class="headerlink" title="기존의 설치된것 삭제"></a>기존의 설치된것 삭제</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get purge `.*nvidia.*`</span><br><span class="line">sudo apt remove `.*nvidia.*`</span><br><span class="line">sudo rm /etc/apt/sources.list.d/cuda*</span><br><span class="line">sudo apt-get autoremove &amp;&amp; sudo apt-get autoclean</span><br><span class="line">sudo rm -rf /usr/local/cuda*</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="system-update"><a href="#system-update" class="headerlink" title="system update"></a>system update</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="install-other-import-packages"><a href="#install-other-import-packages" class="headerlink" title="install other import packages"></a>install other import packages</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure><h2 id="PPA-repository-driver-추가"><a href="#PPA-repository-driver-추가" class="headerlink" title="PPA repository driver 추가"></a>PPA repository driver 추가</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="install-nvidia-driver-with-dependencies"><a href="#install-nvidia-driver-with-dependencies" class="headerlink" title="install nvidia driver with dependencies"></a>install nvidia driver with dependencies</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install libnvidia-common-515</span><br><span class="line">sudo apt install libnvidia-gl-515</span><br><span class="line">sudo apt install nvidia-driver-515</span><br><span class="line"></span><br><span class="line">sudo wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin</span><br><span class="line">sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/3bf863cc.pub</span><br><span class="line">sudo add-apt-repository &quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/ /&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="system-update-1"><a href="#system-update-1" class="headerlink" title="system update"></a>system update</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="installing-CUDA-11-8"><a href="#installing-CUDA-11-8" class="headerlink" title="installing CUDA-11.8"></a>installing CUDA-11.8</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cuda-11-8</span><br></pre></td></tr></table></figure><p>아래의 오류가 나면 처리 방법</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libnvidia-extra-525 : Conflicts: libnvidia-extra</span><br><span class="line"> libnvidia-extra-535 : Conflicts: libnvidia-extra</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt full-upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="paths-설정"><a href="#paths-설정" class="headerlink" title="paths 설정"></a>paths 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo &#x27;export PATH=/usr/local/cuda-11.8/bin:$PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &#x27;export LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line">sudo ldconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cuda-버전이-불일치-함"><a href="#cuda-버전이-불일치-함" class="headerlink" title="cuda 버전이 불일치 함?"></a>cuda 버전이 불일치 함?</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line"></span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>문제 없다고 함???</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://gist.github.com/MihailCosmin/affa6b1b71b43787e9228c25fe15aeba">cuda_11.8_installation_on_Ubuntu_22.04</a></li><li><a href="https://itecnote.com/tecnote/different-cuda-versions-shown-by-nvcc-and-nvidia-smi/">Different CUDA versions shown by nvcc and NVIDIA-smi</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-18-ubuntu_cuda_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>getting started with conda</title>
      <link>https://sejoung.github.io/2023/10/2023-11-13-Getting_started_with_conda/</link>
      <guid>https://sejoung.github.io/2023/10/2023-11-13-Getting_started_with_conda/</guid>
      <pubDate>Wed, 18 Oct 2023 01:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;getting-started-with-conda&quot;&gt;&lt;a href=&quot;#getting-started-with-conda&quot; class=&quot;headerlink&quot; title=&quot;getting started with conda&quot;&gt;&lt;/a&gt;getting 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="getting-started-with-conda"><a href="#getting-started-with-conda" class="headerlink" title="getting started with conda"></a>getting started with conda</h1><p>Conda는 Windows용 Anaconda Prompt나 macOS 또는 Linux용 터미널 창에서 명령줄 명령과 함께 사용하는 강력한 패키지 관리자이자 환경 관리자입니다.</p><p>Conda 시작을 위한 이 20분 가이드를 통해 Conda의 주요 기능을 시험해 볼 수 있습니다. 이 가이드를 마치면 conda가 어떻게 작동하는지 이해해야 합니다.</p><h2 id="콘다-관리"><a href="#콘다-관리" class="headerlink" title="콘다 관리"></a>콘다 관리</h2><p>다음을 입력하여 시스템에 conda가 설치되어 실행되고 있는지 확인하세요.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>Conda를 최신 버전으로 업데이트합니다. 다음을 입력하세요.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h2 id="환경-관리"><a href="#환경-관리" class="headerlink" title="환경 관리"></a>환경 관리</h2><p>Conda를 사용하면 다른 환경과 상호 작용하지 않는 파일, 패키지 및 해당 종속성을 포함하는 별도의 환경을 만들 수 있습니다.</p><p>conda를 사용하기 시작하면 이미 이라는 기본 환경이 있습니다 base. 하지만 기본 환경에 프로그램을 넣고 싶지는 않습니다. 프로그램을 서로 격리하려면 별도의 환경을 만드세요.</p><p>새 환경을 만들고 여기에 패키지를 설치합니다.</p><p>환경 이름을 지정 snowflakes하고 BioPython 패키지를 설치하겠습니다. Anaconda 프롬프트 또는 터미널 창에 다음을 입력하십시오.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name snowflakes biopython</span><br></pre></td></tr></table></figure><p>새 환경을 사용하거나 “활성화”하려면 다음을 입력하십시오.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">conda activate snowflakes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>모든 환경 목록을 보려면 다음을 입력하세요.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>현재 환경을 기본값(base)으로 다시 변경합니다. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br></pre></td></tr></table></figure><h2 id="Python-관리"><a href="#Python-관리" class="headerlink" title="Python 관리"></a>Python 관리</h2><p>새 환경을 생성하면 conda는 Anaconda를 다운로드하고 설치할 때 사용한 것과 동일한 Python 버전을 설치합니다.<br>Python 3.5와 같은 다른 버전의 Python을 사용하려면 새 환경을 만들고 원하는 Python 버전을 지정하기만 하면 됩니다.</p><p>Python 3.9가 포함된 “snakes”라는 새 환경을 만듭니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name snakes python=3.9</span><br></pre></td></tr></table></figure><p>새 환경을 활성화합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate snakes</span><br></pre></td></tr></table></figure><p>snakes 환경이 추가되었고 활성화되었는지 확인합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>활성 환경은 프롬프트 앞에 다음과 같이 (괄호) 또는 [괄호]로 표시됩니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(snakes) $</span><br></pre></td></tr></table></figure><p>현재 환경에 어떤 버전의 Python이 있는지 확인합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><h2 id="패키지-관리"><a href="#패키지-관리" class="headerlink" title="패키지 관리"></a>패키지 관리</h2><p>이미 설치한 패키지를 찾으려면 먼저 검색하려는 환경을 활성화하세요. 위에서 스네이크 환경을 활성화 하는 명령을 찾아보세요.</p><p>설치하지 않은 “beautifulsoup4” 패키지가 Anaconda 저장소에서 사용 가능한지 확인하십시오(인터넷에 연결되어 있어야 함).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search beautifulsoup4</span><br></pre></td></tr></table></figure><p>현재 환경에 이 패키지를 설치합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install beautifulsoup4</span><br></pre></td></tr></table></figure><p>새로 설치된 프로그램이 이 환경에 있는지 확인하십시오.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://conda.io/projects/conda/en/latest/user-guide/getting-started.html">콘다 시작하기</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-11-13-Getting_started_with_conda/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리눅스에서 gpu 사용량 모니터링 툴</title>
      <link>https://sejoung.github.io/2023/10/2023-10-17-gpu_monitoring/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-17-gpu_monitoring/</guid>
      <pubDate>Tue, 17 Oct 2023 05:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;리눅스에서-gpu-사용량-모니터링&quot;&gt;&lt;a href=&quot;#리눅스에서-gpu-사용량-모니터링&quot; class=&quot;headerlink&quot; title=&quot;리눅스에서 gpu 사용량 모니터링&quot;&gt;&lt;/a&gt;리눅스에서 gpu 사용량 모니터링&lt;/h1&gt;&lt;h2 id=&quot;n
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="리눅스에서-gpu-사용량-모니터링"><a href="#리눅스에서-gpu-사용량-모니터링" class="headerlink" title="리눅스에서 gpu 사용량 모니터링"></a>리눅스에서 gpu 사용량 모니터링</h1><h2 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 nvidia-smi</span><br></pre></td></tr></table></figure><h2 id="nvitop"><a href="#nvitop" class="headerlink" title="nvitop"></a>nvitop</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade nvitop</span><br><span class="line"></span><br><span class="line">nvitop</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/XuehaiPan/nvitop">nvitop</a></li><li><a href="https://github.com/wookayin/gpustat">gpustat</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-17-gpu_monitoring/#disqus_thread</comments>
    </item>
    
    <item>
      <title>스타트업 지분</title>
      <link>https://sejoung.github.io/2023/09/2023-09-22-startup/</link>
      <guid>https://sejoung.github.io/2023/09/2023-09-22-startup/</guid>
      <pubDate>Fri, 22 Sep 2023 13:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;스타트업-지분&quot;&gt;&lt;a href=&quot;#스타트업-지분&quot; class=&quot;headerlink&quot; title=&quot;스타트업 지분&quot;&gt;&lt;/a&gt;스타트업 지분&lt;/h1&gt;&lt;p&gt;관련 유튜브 링크들 모음&lt;/p&gt;
&lt;h1 id=&quot;참조&quot;&gt;&lt;a href=&quot;#참조&quot; class=
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="스타트업-지분"><a href="#스타트업-지분" class="headerlink" title="스타트업 지분"></a>스타트업 지분</h1><p>관련 유튜브 링크들 모음</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.youtube.com/watch?v=3Lb_iNAO538">스톡옵션 10% 좋은 제안인걸까?</a></li><li><a href="https://www.youtube.com/watch?v=ZTs5Tkw3Xzg&t=2s">전 실리콘밸리 기술이사가 말하는 회사 지분 vs 봉급</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/09/2023-09-22-startup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>테라폼 커멘드</title>
      <link>https://sejoung.github.io/2023/07/2023-07-17-terraform_command/</link>
      <guid>https://sejoung.github.io/2023/07/2023-07-17-terraform_command/</guid>
      <pubDate>Mon, 17 Jul 2023 08:03:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;테라폼-커멘드&quot;&gt;&lt;a href=&quot;#테라폼-커멘드&quot; class=&quot;headerlink&quot; title=&quot;테라폼 커멘드&quot;&gt;&lt;/a&gt;테라폼 커멘드&lt;/h1&gt;&lt;h2 id=&quot;설치&quot;&gt;&lt;a href=&quot;#설치&quot; class=&quot;headerlink&quot; title=&quot;설
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="테라폼-커멘드"><a href="#테라폼-커멘드" class="headerlink" title="테라폼 커멘드"></a>테라폼 커멘드</h1><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/terraform</span><br></pre></td></tr></table></figure><h2 id="업데이트"><a href="#업데이트" class="headerlink" title="업데이트"></a>업데이트</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew upgrade hashicorp/tap/terraform</span><br></pre></td></tr></table></figure><h2 id="자동완성-설치"><a href="#자동완성-설치" class="headerlink" title="자동완성 설치"></a>자동완성 설치</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.zshrc</span><br><span class="line">terraform -install-autocomplete</span><br></pre></td></tr></table></figure><h2 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure><h2 id="포멧-확인"><a href="#포멧-확인" class="headerlink" title="포멧 확인"></a>포멧 확인</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform fmt</span><br></pre></td></tr></table></figure><h2 id="검증"><a href="#검증" class="headerlink" title="검증"></a>검증</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform validate</span><br></pre></td></tr></table></figure><h2 id="인프라-계획"><a href="#인프라-계획" class="headerlink" title="인프라 계획"></a>인프라 계획</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure><h2 id="인프라-생성"><a href="#인프라-생성" class="headerlink" title="인프라 생성"></a>인프라 생성</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure><h2 id="상태-검사"><a href="#상태-검사" class="headerlink" title="상태 검사"></a>상태 검사</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform show</span><br></pre></td></tr></table></figure><h2 id="인프라-삭제"><a href="#인프라-삭제" class="headerlink" title="인프라 삭제"></a>인프라 삭제</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://developer.hashicorp.com/terraform/docs">terraform docs</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/07/2023-07-17-terraform_command/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mybatis 멀티 모듈 셋팅시 Invalid bound statement (not found) 오류</title>
      <link>https://sejoung.github.io/2023/06/2023-06-14-mybatis_spring_boot_starter/</link>
      <guid>https://sejoung.github.io/2023/06/2023-06-14-mybatis_spring_boot_starter/</guid>
      <pubDate>Wed, 14 Jun 2023 08:36:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mybatis-멀티-모듈-셋팅시-Invalid-bound-statement-not-found-오류&quot;&gt;&lt;a href=&quot;#mybatis-멀티-모듈-셋팅시-Invalid-bound-statement-not-found-오류&quot; class=&quot;hea
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mybatis-멀티-모듈-셋팅시-Invalid-bound-statement-not-found-오류"><a href="#mybatis-멀티-모듈-셋팅시-Invalid-bound-statement-not-found-오류" class="headerlink" title="mybatis 멀티 모듈 셋팅시 Invalid bound statement (not found) 오류"></a>mybatis 멀티 모듈 셋팅시 Invalid bound statement (not found) 오류</h1><p>gradle 멀티 모듈을 셋팅하고 slice test로 mybatis 모듈이 정상적으로 기동이 되는데<br>여러 모듈에 mybatis xml이 나눠줘있고 root 프로젝트에서 모듈을 추가 받아서 처리 하면 아래 와 같이 해당 mapper를 찾을수 없다고 나온다</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): persistence.rdbms.mybatis.arena.excel.repository.ArenaExcelMybatisRepository.selectKartRushArenaApplyUserList</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod$SqlCommand.&lt;init&gt;(MapperMethod.java:229)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.&lt;init&gt;(MapperMethod.java:53)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.lambda$cachedInvoker$0(MapperProxy.java:96)</span><br><span class="line">at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)</span><br><span class="line">at org.apache.ibatis.util.MapUtil.computeIfAbsent(MapUtil.java:36)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.cachedInvoker(MapperProxy.java:94)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>스프링 부트를 사용해서 mybatis 의 spring-boot-starter 를 사용해서 아래처럼 설정을 했다 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/**/**/**.xml</span></span><br></pre></td></tr></table></figure><p>아무리 해도 보이지 않아서 디버깅을 했는데 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code> 코드의 <code>this.properties.resolveMapperLocations</code>를 보면 되는데 아래의 코드 이다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        factory.setVfs(SpringBootVFS.class);</span><br><span class="line">        .....</span><br><span class="line">        Resource[] mapperLocations = <span class="built_in">this</span>.properties.resolveMapperLocations();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(mapperLocations)) &#123;</span><br><span class="line">            factory.setMapperLocations(mapperLocations);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보면 리소스 패턴을 찾는데 spring의 <code>PathMatchingResourcePatternResolver</code> 를 사용해서 찾는다 그래서 <code>PathMatchingResourcePatternResolver</code> 코드를 보니</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title class_">ResourcePatternResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Assert.notNull(locationPattern, <span class="string">&quot;Location pattern must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">            <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">                <span class="comment">// a class path resource pattern</span></span><br><span class="line">                <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// all class path resources with the given name</span></span><br><span class="line">                <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generally only look for a pattern after a prefix here,</span></span><br><span class="line">            <span class="comment">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prefixEnd</span> <span class="operator">=</span> (locationPattern.startsWith(<span class="string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="string">&quot;*/&quot;</span>) + <span class="number">1</span> :</span><br><span class="line">                locationPattern.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">                <span class="comment">// a file pattern</span></span><br><span class="line">                <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a single resource with the given name</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Resource</span>[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pseudo URL prefix for all matching resources from the class path: &quot;classpath*:&quot;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This differs from ResourceLoader&#x27;s classpath URL prefix in that it</span></span><br><span class="line"><span class="comment"> * retrieves all matching resources for a given name (e.g. &quot;/beans.xml&quot;),</span></span><br><span class="line"><span class="comment"> * for example in the root of all deployed JAR files.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">CLASSPATH_ALL_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve the given location pattern into &#123;<span class="doctag">@code</span> Resource&#125; objects.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Overlapping resource entries that point to the same physical</span></span><br><span class="line"><span class="comment"> * resource should be avoided, as far as possible. The result should</span></span><br><span class="line"><span class="comment"> * have set semantics.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locationPattern the location pattern to resolve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the corresponding &#123;<span class="doctag">@code</span> Resource&#125; objects</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특별한 프리픽스를 사용하는데 <code>classpath*:</code> 이다<br>스프링 6.0 부터 추가 되었다고 하고 <code>classpath:</code> 이것은 제일 처음 매칭되는 값을 하나만 가지고 오고 <code>classpath*:</code> 는 전체를 모두 가지고 오게 된다 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:mybatis/mapper/**/**/**.xml</span></span><br></pre></td></tr></table></figure><p>이렇게 사용하면 전체 모듈을 스캔해서 리소스를 찾게 된다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/support/PathMatchingResourcePatternResolver.html">PathMatchingResourcePatternResolver doc</a></li><li><a href="https://mybatis.org/spring-boot-starter/">mybatis spring-boot-starter</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/06/2023-06-14-mybatis_spring_boot_starter/#disqus_thread</comments>
    </item>
    
    <item>
      <title>오픈렌즈(OpenLens) 자동 업데이트 막기</title>
      <link>https://sejoung.github.io/2023/05/2023-05-29-OpenLens_update_stop/</link>
      <guid>https://sejoung.github.io/2023/05/2023-05-29-OpenLens_update_stop/</guid>
      <pubDate>Mon, 29 May 2023 13:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;오픈렌즈-OpenLens-자동-업데이트-막기&quot;&gt;&lt;a href=&quot;#오픈렌즈-OpenLens-자동-업데이트-막기&quot; class=&quot;headerlink&quot; title=&quot;오픈렌즈(OpenLens) 자동 업데이트 막기&quot;&gt;&lt;/a&gt;오픈렌즈(OpenLens
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="오픈렌즈-OpenLens-자동-업데이트-막기"><a href="#오픈렌즈-OpenLens-자동-업데이트-막기" class="headerlink" title="오픈렌즈(OpenLens) 자동 업데이트 막기"></a>오픈렌즈(OpenLens) 자동 업데이트 막기</h1><p>오픈렌즈는 렌즈를 빌드해주는 프로젝트인데 오픈소스다 보니 업데이트가 되는데 에러가 생기는 버전이 존재한다 </p><p>그럴때 유용한 방법으로 업데이트를 막는 방법이다</p><h2 id="업데이트-막기"><a href="#업데이트-막기" class="headerlink" title="업데이트 막기"></a>업데이트 막기</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 000 ~/Library/Application\ Support/Caches/open-lens-updater/pending</span><br></pre></td></tr></table></figure><h2 id="업데이트-풀기"><a href="#업데이트-풀기" class="headerlink" title="업데이트 풀기"></a>업데이트 풀기</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 755 ~/Library/Application\ Support/Caches/open-lens-updater/pending</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/MuhammedKalkan/OpenLens">OpenLens</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/05/2023-05-29-OpenLens_update_stop/#disqus_thread</comments>
    </item>
    
    <item>
      <title>실용주의 프로그래머 20주년 기념판 3장</title>
      <link>https://sejoung.github.io/2023/04/2023-04-24-The_Pragmatic_Programmer_02/</link>
      <guid>https://sejoung.github.io/2023/04/2023-04-24-The_Pragmatic_Programmer_02/</guid>
      <pubDate>Mon, 24 Apr 2023 01:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;실용주의-프로그래머&quot;&gt;&lt;a href=&quot;#실용주의-프로그래머&quot; class=&quot;headerlink&quot; title=&quot;실용주의 프로그래머&quot;&gt;&lt;/a&gt;실용주의 프로그래머&lt;/h1&gt;&lt;h2 id=&quot;3장-기본도구&quot;&gt;&lt;a href=&quot;#3장-기본도구&quot; class
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="실용주의-프로그래머"><a href="#실용주의-프로그래머" class="headerlink" title="실용주의 프로그래머"></a>실용주의 프로그래머</h1><h2 id="3장-기본도구"><a href="#3장-기본도구" class="headerlink" title="3장. 기본도구"></a>3장. 기본도구</h2><h3 id="16-일반-텍스트의-힘"><a href="#16-일반-텍스트의-힘" class="headerlink" title="16. 일반 텍스트의 힘"></a>16. 일반 텍스트의 힘</h3><p>일반 텍스트로는 데이터 그자체로 의미가 드러나는 데이터를 만들수 있다.<br>지식을 일반 텍스트로 저장하라</p><p>일반텍스트의 장점</p><ul><li>지원 중단에 대한 보험</li><li>기존 도구의 활용</li><li>더 쉬운 테스트<h3 id="17-셀-가지고-놀기"><a href="#17-셀-가지고-놀기" class="headerlink" title="17. 셀 가지고 놀기"></a>17. 셀 가지고 놀기</h3></li></ul><p>명령어 셀의 힘들 사용하라</p><h3 id="18-파워-에디팅"><a href="#18-파워-에디팅" class="headerlink" title="18. 파워 에디팅"></a>18. 파워 에디팅</h3><p>에디터를 유창하게 쓸 수 있게 하라</p><h3 id="19-버전-관리"><a href="#19-버전-관리" class="headerlink" title="19. 버전 관리"></a>19. 버전 관리</h3><p>공유 디렉토리는 버전관리 시스템이 아니다</p><p>언제나 버전관리 시스템을 사용하라</p><h3 id="20-디버깅"><a href="#20-디버깅" class="headerlink" title="20. 디버깅"></a>20. 디버깅</h3><p>비난 대신 문제를 해결하라</p><p>당황하지 마라</p><p>가장 속이기 쉬운 사람은 자기 자신이다</p><p>코드를 고치기전 실패하는 테스트 부터</p><p>오류 메시지를 읽어라</p><p>가정하지 말라 증명하라</p><h3 id="21-텍스트-처리"><a href="#21-텍스트-처리" class="headerlink" title="21. 텍스트 처리"></a>21. 텍스트 처리</h3><p>텍스트 처리 언어를 익혀라</p><h3 id="22-엔지니어-일지"><a href="#22-엔지니어-일지" class="headerlink" title="22. 엔지니어 일지"></a>22. 엔지니어 일지</h3><p>엔지니어 일지를 남겨 보아라</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.yes24.com/Product/Goods/106225986">이펙티브 코틀린</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/04/2023-04-24-The_Pragmatic_Programmer_02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JEP 425: Virtual Threads (Preview)</title>
      <link>https://sejoung.github.io/2023/04/2023-04-13-JEP_425/</link>
      <guid>https://sejoung.github.io/2023/04/2023-04-13-JEP_425/</guid>
      <pubDate>Thu, 13 Apr 2023 03:25:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;JEP-425-Virtual-Threads-Preview&quot;&gt;&lt;a href=&quot;#JEP-425-Virtual-Threads-Preview&quot; class=&quot;headerlink&quot; title=&quot;JEP 425: Virtual Threads (Prev
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="JEP-425-Virtual-Threads-Preview"><a href="#JEP-425-Virtual-Threads-Preview" class="headerlink" title="JEP 425: Virtual Threads (Preview)"></a>JEP 425: Virtual Threads (Preview)</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Java 플랫폼에 가상 스레드를 도입합니다.<br>가상 스레드는 처리량이 많은 동시 응용 프로그램을 작성, 유지 관리 및 관찰하는 노력을 크게 줄이는 경량 스레드입니다.<br>이것은 미리보기 API 입니다.</p><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><ul><li>간단한 요청당 스레드 스타일로 작성된 서버 애플리케이션을 거의 최적의 하드웨어 활용으로 확장할 수 있습니다.</li><li>API를 사용하는 기존 코드를 활성화하여 java.lang.Thread최소한의 변경으로 가상 스레드를 채택합니다.</li><li>기존 JDK 도구를 사용하여 가상 스레드의 문제 해결, 디버깅 및 프로파일링을 쉽게 수행할 수 있습니다.</li></ul><h2 id="Non-Goals"><a href="#Non-Goals" class="headerlink" title="Non-Goals"></a>Non-Goals</h2><ul><li>전통적인 스레드 구현을 제거하거나 가상 스레드를 사용하도록 기존 애플리케이션을 자동으로 마이그레이션하는 것이 목표가 아닙니다.</li><li>Java의 기본 동시성 모델을 변경하는 것이 목표가 아닙니다.</li><li>Java 언어나 Java 라이브러리에서 새로운 데이터 병렬 구조를 제공하는 것이 목표가 아닙니다. Stream API는 대용량 데이터 세트를 병렬로 처리하는 데 선호되는 방법입니다.</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Java 개발자는 거의 30년 동안 동시 서버 응용 프로그램의 빌딩 블록으로 스레드에 의존해 왔습니다.<br>모든 메서드의 모든 명령문은 스레드 내에서 실행되며 Java는 다중 스레드이므로 한 번에 여러 스레드가 실행됩니다.<br>스레드는 Java의 동시성 단위입니다.이러한 다른 단위와 동시에 실행되는(거의 독립적인) 순차적 코드 조각입니다.<br>각 스레드는 로컬 변수를 저장하고 메서드 호출을 조정하는 스택과 상황이 잘못되었을 때 컨텍스트를 제공합니다.<br>동일한 스레드의 메서드에서 예외가 발생하고 포착되므로 개발자는 스레드의 스택 추적을 사용하여 무슨 일이 일어났는지 알아낼 수 있습니다.<br>스레드는 도구의 중심 개념이기도 합니다.<br>디버거는 스레드 메서드의 명령문을 단계별로 실행하고 프로파일러는 여러 스레드의 동작을 시각화하여 성능을 이해하는 데 도움을 줍니다.</p><h3 id="The-thread-per-request-style-요청당-스레드-스타일"><a href="#The-thread-per-request-style-요청당-스레드-스타일" class="headerlink" title="The thread-per-request style (요청당 스레드 스타일)"></a>The thread-per-request style (요청당 스레드 스타일)</h3><p>서버 응용 프로그램은 일반적으로 서로 독립적인 동시 사용자 요청을 처리하므로 응용 프로그램이 전체 기간 동안 해당 요청에 스레드를 전용하여 요청을 처리하는 것이 좋습니다.<br>이 요청당 스레드 스타일은 애플리케이션의 동시성 단위를 나타내기 위해 플랫폼의 동시성 단위를 사용하기 때문에 이해하기 쉽고, 프로그래밍하기 쉽고, 디버그 및 프로파일링하기 쉽습니다.</p><p>서버 응용 프로그램의 확장성은 대기 시간, 동시성 및 처리량과 관련된 Little의 법칙 에 따라 결정됩니다.<br>주어진 요청 처리 기간(즉, 대기 시간) 동안 응용 프로그램이 동시에 처리하는 요청 수(즉, 동시성)는 도착률(즉, 처리량)에 비례하여 증가합니다.<br>예를 들어 평균 대기 시간이 50ms인 애플리케이션이 10개의 요청을 동시에 처리하여 초당 200개의 요청 처리량을 달성한다고 가정합니다.<br>해당 애플리케이션이 초당 2000개의 요청 처리량으로 확장하려면 100개의 요청을 동시에 처리해야 합니다.<br>각 요청이 요청 기간 동안 스레드에서 처리되는 경우 애플리케이션이 이를 따라잡으려면 처리량이 증가함에 따라 스레드 수가 증가해야 합니다.</p><p>불행히도 사용 가능한 스레드의 수는 JDK가 운영 체제(OS) 스레드 주변의 래퍼로 스레드를 구현하기 때문에 제한됩니다.<br>OS 스레드는 비용이 많이 들기 때문에 스레드를 너무 많이 가질 수 없으므로 구현이 요청당 스레드 스타일에 적합하지 않습니다.<br>각 요청이 해당 기간 동안 스레드, 즉 OS 스레드를 사용하는 경우 CPU 또는 네트워크 연결과 같은 다른 리소스가 고갈되기 오래 전에 스레드 수가 제한 요소가 되는 경우가 많습니다.<br>JDK의 현재 스레드 구현은 애플리케이션의 처리량을 하드웨어가 지원할 수 있는 것보다 훨씬 낮은 수준으로 제한합니다.<br>이는 스레드가 풀링된 경우에도 발생합니다. 풀링은 새 스레드를 시작하는 높은 비용을 방지하는 데 도움이 되지만 총 스레드 수를 늘리지는 않기 때문입니다.</p><h3 id="Improving-scalability-with-the-asynchronous-style-비동기-스타일로-확장성-향상"><a href="#Improving-scalability-with-the-asynchronous-style-비동기-스타일로-확장성-향상" class="headerlink" title="Improving scalability with the asynchronous style (비동기 스타일로 확장성 향상)"></a>Improving scalability with the asynchronous style (비동기 스타일로 확장성 향상)</h3><p>하드웨어를 최대한 활용하고자 하는 일부 개발자는 스레드 공유 스타일을 선호하여 요청당 스레드 스타일을 포기했습니다.<br>하나의 스레드에서 처음부터 끝까지 요청을 처리하는 대신 요청 처리 코드는 스레드가 다른 요청을 처리할 수 있도록 I&#x2F;O 작업이 완료될 때까지 대기할 때 해당 스레드를 풀로 반환합니다.<br>코드가 I&#x2F;O를 기다릴 때가 아니라 계산을 수행할 때만 스레드를 유지하는 이 세분화된 스레드 공유는 많은 수의 스레드를 소비하지 않고도 많은 수의 동시 작업을 허용합니다.<br>이는 OS 스레드의 부족 으로 인한 처리량의 제한을 제거하지만 높은 비용이 듭니다.<br>I&#x2F;O 작업이 완료될 때까지 기다리지 않고 나중에 완료 신호를 콜백에 보내는 별도의 I&#x2F;O 메서드 집합을 사용하는 프로그래밍 스타일.<br>전용 스레드가 없으면 개발자는 요청 처리 논리를 일반적으로 람다 식으로 작성된 작은 단계로 분해한 다음 API를 사용하여 순차적 파이프라인으로 구성해야 합니다(예를 들어 CompletableFuture 또는 소위 “반응형” 프레임워크 참조 ) . ).<br>따라서 루프 및 블록과 같은 언어의 기본 순차 구성 연산자를 버립니다 try&#x2F;catch.</p><p>비동기 스타일에서는 요청의 각 단계가 다른 스레드에서 실행될 수 있으며 모든 스레드는 인터리브 방식으로 다른 요청에 속하는 단계를 실행합니다.<br>이는 프로그램 동작을 이해하는 데 깊은 영향을 미칩니다. 스택 추적은 사용 가능한 컨텍스트를 제공하지 않으며 디버거는 요청 처리 논리를 단계별로 실행할 수 없으며 프로파일러는 작업 비용을 호출자와 연결할 수 없습니다.<br>람다 식 구성은 짧은 파이프라인에서 데이터를 처리하기 위해 Java의 스트림 API를 사용할 때 관리할 수 있지만 애플리케이션의 모든 요청 처리 코드를 이 방식으로 작성해야 하는 경우 문제가 됩니다.<br>이 프로그래밍 스타일은 애플리케이션의 동시성 단위(비동기 파이프라인)가 더 이상 플랫폼의 동시성 단위가 아니기 때문에 Java 플랫폼과 상충됩니다.</p><h3 id="Preserving-the-thread-per-request-style-with-virtual-threads-가상-스레드로-요청당-스레드-스타일-유지"><a href="#Preserving-the-thread-per-request-style-with-virtual-threads-가상-스레드로-요청당-스레드-스타일-유지" class="headerlink" title="Preserving the thread-per-request style with virtual threads (가상 스레드로 요청당 스레드 스타일 유지)"></a>Preserving the thread-per-request style with virtual threads (가상 스레드로 요청당 스레드 스타일 유지)</h3><p>애플리케이션이 플랫폼과 조화를 이루면서 확장할 수 있도록 하려면 스레드를 보다 효율적으로 구현하여<br>요청당 스레드 스타일을 유지하기 위해 노력해야 스레드가 더 많아질 수 있습니다.<br>운영 체제는 다른 언어와 런타임이 다른 방식으로 스레드 스택을 사용하기 때문에 OS 스레드를 보다 효율적으로 구현할 수 없습니다.<br>그러나 Java 런타임이 OS 스레드에 대한 일대일 대응을 분리하는 방식으로 Java 스레드를 구현하는 것은 가능합니다.<br>운영 체제가 큰 가상 주소 공간을 제한된 양의 물리적 RAM에 매핑하여 메모리가 풍부한 것처럼 보이게 하는 것처럼<br>Java 런타임은 많은 수의 가상 스레드를 적은 수의 OS 스레드에 매핑하여 스레드가 많은 것처럼 보이게 할 수 있습니다.</p><p>가상 스레드는 특정 java.lang.ThreadOS 스레드에 연결되지 않은 인스턴스입니다.<br>대조적으로 플랫폼 스레드는 java.lang.Thread OS 스레드 주변의 얇은 래퍼로 전통적인 방식으로 구현된 인스턴스입니다.</p><p>요청당 스레드 스타일의 애플리케이션 코드는 전체 요청 기간 동안 가상 스레드에서 실행될 수 있지만<br>가상 스레드는 CPU에서 계산을 수행하는 동안에만 OS 스레드를 소비합니다. 결과는 투명하게 달성된다는 점을 제외하면 비동기식 스타일과 동일한 확장성입니다.<br>가상 스레드에서 실행 중인 코드가 java.*API, 런타임은 비차단 OS 호출을 수행하고 나중에 다시 시작할 수 있을 때까지<br>가상 스레드를 자동으로 일시 중단합니다. Java 개발자에게 가상 스레드는 생성 비용이 저렴하고 거의 무한대로 풍부한 스레드일 뿐입니다.<br>하드웨어 활용도는 최적에 가까워 높은 수준의 동시성과 결과적으로 높은 처리량을 허용하는 동시에 응용 프로그램은<br>Java 플랫폼 및 해당 도구의 다중 스레드 설계와 조화를 이룹니다.</p><h3 id="Implications-of-virtual-threads-가상-스레드의-의미"><a href="#Implications-of-virtual-threads-가상-스레드의-의미" class="headerlink" title="Implications of virtual threads (가상 스레드의 의미)"></a>Implications of virtual threads (가상 스레드의 의미)</h3><p>가상 스레드는 저렴하고 풍부하므로 풀링해서는 안 됩니다. 모든 애플리케이션 작업에 대해 새로운 가상 스레드를 생성해야 합니다.<br>따라서 대부분의 가상 스레드는 수명이 짧고 얕은 호출 스택을 가지며 단일 HTTP 클라이언트 호출 또는 단일 JDBC 쿼리만큼 적게 수행됩니다.<br>반대로 플랫폼 스레드는 무겁고 비용이 많이 들기 때문에 종종 풀링되어야 합니다.<br>수명이 길고 호출 스택이 깊으며 많은 작업 간에 공유되는 경향이 있습니다.</p><p>요약하면 가상 스레드는 하드웨어를 최적으로 활용하면서 Java 플랫폼의 설계와 조화를 이루는 안정적인 요청당 스레드 스타일을 유지합니다.<br>가상 스레드를 사용하는 데 새로운 개념을 학습할 필요는 없지만 오늘날의 높은 스레드 비용에 대처하기 위해 학습하지 않는 습관을 개발해야 할 수도 있습니다.<br>가상 스레드는 애플리케이션 개발자를 도울 뿐만 아니라 프레임워크 설계자가 확장성을 손상시키지 않으면서 플랫폼 설계와 호환되는 사용하기<br>쉬운 API를 제공하는 데도 도움이 됩니다.</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>java.lang.Thread 오늘날 JDK의 모든 인스턴스는 플랫폼 스레드 입니다.<br>플랫폼 스레드는 기본 OS 스레드에서 Java 코드를 실행하고 코드의 전체 수명 동안 OS 스레드를 캡처합니다.<br>플랫폼 스레드 수는 OS 스레드 수로 제한됩니다.</p><p>가상 스레드는 java.lang.Thread 기본 OS 스레드에서 Java 코드를 실행하지만 코드의 전체 수명 동안 OS 스레드를 캡처하지 않는 인스턴스입니다.<br>이는 많은 가상 스레드가 동일한 OS 스레드에서 Java 코드를 실행하여 효과적으로 공유할 수 있음을 의미합니다.<br>플랫폼 스레드가 소중한 OS 스레드를 독점하는 반면 가상 스레드는 그렇지 않습니다.<br>가상 스레드의 수는 OS 스레드의 수보다 훨씬 클 수 있습니다.</p><p>가상 스레드는 OS가 아닌 JDK에서 제공하는 경량 스레드 구현입니다.<br>다른 다중 스레드 언어(예: Go의 고루틴 및 Erlang의 프로세스)에서 성공한 사용자 모드 스레드 의 한 형태입니다.<br>사용자 모드 스레드는 OS 스레드가 아직 성숙하고 널리 보급되지 않은 초기 Java 버전에서 소위 “그린 스레드” 로 기능하기도 했습니다.<br>그러나 Java의 그린 스레드는 모두 하나의 OS 스레드(M:1 스케줄링)를 공유했으며 결국 OS 스레드용 래퍼로 구현된 플랫폼 스레드(1:1 스케줄링)보다 성능이 뛰어났습니다.<br>가상 스레드는 M:N 스케줄링을 사용하는데, 여기서 많은 수(M)의 가상 스레드가 더 적은 수(N)의 OS 스레드에서 실행되도록 스케줄됩니다.</p><h3 id="Using-virtual-threads-vs-platform-threads-가상-스레드-대-플랫폼-스레드-사용"><a href="#Using-virtual-threads-vs-platform-threads-가상-스레드-대-플랫폼-스레드-사용" class="headerlink" title="Using virtual threads vs. platform threads (가상 스레드 대 플랫폼 스레드 사용)"></a>Using virtual threads vs. platform threads (가상 스레드 대 플랫폼 스레드 사용)</h3><p>개발자는 가상 스레드 또는 플랫폼 스레드를 사용할지 여부를 선택할 수 있습니다.<br>다음은 다수의 가상 스레드를 생성하는 예제 프로그램입니다.<br>프로그램은 먼저 제출된 각 작업에 대해 새 가상 스레드를 생성할 ExecutorService를 얻습니다.<br>그런 다음 10,000개의 작업을 제출하고 모두 완료될 때까지 기다립니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  <span class="comment">// executor.close() is called implicitly, and waits</span></span><br></pre></td></tr></table></figure><p>이 예제의 작업은 간단한 코드(1초 동안 절전 모드)이며 최신 하드웨어는 이러한 코드를 동시에 실행하는 10,000개의 가상 스레드를 쉽게 지원할 수 있습니다.<br>배후에서 JDK는 소수의 OS 스레드(아마도 하나 정도)에서 코드를 실행합니다.</p><p>이 프로그램 이 ExecutorService. Executors.newCachedThreadPool()는 ExecutorService 10,000개의 플랫폼 스레드와 10,000개의 OS 스레드를 생성하려고 시도하며<br>시스템과 운영 체제에 따라 프로그램이 충돌할 수 있습니다.</p><p>대신 프로그램이 ExecutorService 풀에서 플랫폼 스레드를 가져오는 Executors.newFixedThreadPool(200).<br>그러면 ExecutorService10,000개의 모든 작업에서 공유할 200개의 플랫폼 스레드가 생성되므로 많은 작업이 동시가 아닌 순차적으로 실행되고 프로그램을 완료하는 데<br>오랜 시간이 걸립니다. 이 프로그램의 경우 200개의 플랫폼 스레드가 있는 풀은 초당 200개의 작업 처리량만 달성할 수 있는 반면<br>가상 스레드는 초당 약 10,000개의 작업 처리량을 달성할 수 있습니다(충분한 워밍업 후).<br>또한 10_000예제 프로그램의 가 로 변경되면 1_000_000프로그램은 1,000,000개의 작업을 제출하고 동시에 실행되는 1,000,000개의 가상 스레드를 생성하며<br>(충분한 워밍업 후) 초당 약 1,000,000개의 작업 처리량을 달성합니다.</p><p>이 프로그램의 작업이 단순히 휴면 상태가 아니라 1초 동안 계산(예: 거대한 배열 정렬)을 수행했다면<br>가상 스레드이든 플랫폼 스레드든 프로세서 코어 수 이상으로 스레드 수를 늘리는 것은 도움이 되지 않습니다.<br>가상 스레드는 더 빠른 스레드가 아닙니다. 가상 스레드는 플랫폼 스레드보다 더 빠르게 코드를 실행하지 않습니다.<br>속도(낮은 대기 시간)가 아니라 확장성(높은 처리량)을 제공하기 위해 존재합니다.<br>플랫폼 스레드보다 더 많을 수 있으므로 리틀의 법칙에 따라 더 높은 처리량에 필요한 더 높은 동시성을 가능하게 합니다.</p><p>달리 말하면 가상 스레드는 다음과 같은 경우 애플리케이션 처리량을 크게 향상시킬 수 있습니다.</p><ul><li>동시 작업의 수가 많고(수천 개 이상),</li><li>이 경우 프로세서 코어보다 더 많은 스레드가 있으면 처리량을 향상시킬 수 없기 때문에 워크로드는 CPU에 제한되지 않습니다.</li></ul><p>가상 스레드는 이러한 응용 프로그램이 대기 시간의 대부분을 소비하는 많은 수의 동시 작업으로 구성되기 때문에<br>일반적인 서버 응용 프로그램의 처리량을 향상시키는 데 도움이 됩니다.</p><p>가상 스레드는 플랫폼 스레드가 실행할 수 있는 모든 코드를 실행할 수 있습니다.<br>특히 가상 스레드는 플랫폼 스레드와 마찬가지로 스레드 로컬 변수 및 스레드 중단을 지원합니다.<br>이는 요청을 처리하는 기존 Java 코드가 가상 스레드에서 쉽게 실행됨을 의미합니다. 많은 서버 프레임워크는 들어오는<br>모든 요청에 대해 새로운 가상 스레드를 시작하고 그 안에서 애플리케이션의 비즈니스 로직을 실행하여 이 작업을 자동으로 수행하도록 선택할 것입니다.</p><p>다음은 다른 두 서비스의 결과를 집계하는 서버 애플리케이션의 예입니다.<br>handle가상의 서버 프레임워크(표시되지 않음)는 각 요청에 대해 새로운 가상 스레드를 생성하고 해당 가상 스레드에서 애플리케이션의 코드를 실행합니다.<br>그러면 애플리케이션 코드는 두 개의 새 가상 스레드를 생성하여 ExecutorService 첫 번째 예와 동일한 방법으로 리소스를 동시에 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">oid <span class="title function_">handle</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">url1</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">var</span> <span class="variable">url2</span> <span class="operator">=</span> ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">future1</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url1));</span><br><span class="line">        <span class="type">var</span> <span class="variable">future2</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url2));</span><br><span class="line">        response.send(future1.get() + future2.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        response.fail(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">String <span class="title function_">fetchURL</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> url.openStream()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(in.readAllBytes(), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>간단한 차단 코드가 있는 이와 같은 서버 응용 프로그램은 많은 수의 가상 스레드를 사용할 수 있기 때문에 잘 확장됩니다.</p><p>Executor.newVirtualThreadPerTaskExecutor() 가상 스레드를 생성하는 유일한 방법은 아닙니다.<br>아래에서 설명하는 새 java.lang.Thread.BuilderAPI는 가상 스레드를 만들고 시작할 수 있습니다.<br>또한 구조화된 동시성은 특히 이 서버 예제와 유사한 코드에서 가상 스레드를 생성하고 관리하기 위한 보다 강력한 API를 제공합니다.<br>이에 따라 스레드 간의 관계가 플랫폼과 해당 도구에 알려집니다.</p><h3 id="Virtual-threads-are-a-preview-API-disabled-by-default-가상-스레드는-기본적으로-비활성화된-미리보기-API-입니다"><a href="#Virtual-threads-are-a-preview-API-disabled-by-default-가상-스레드는-기본적으로-비활성화된-미리보기-API-입니다" class="headerlink" title="Virtual threads are a preview API, disabled by default (가상 스레드는 기본적으로 비활성화된 미리보기 API 입니다.)"></a>Virtual threads are a preview API, disabled by default (가상 스레드는 기본적으로 비활성화된 미리보기 API 입니다.)</h3><p>위의 프로그램은 이 Executors.newVirtualThreadPerTaskExecutor() 방법을 사용하므로 JDK 19에서 실행하려면 다음과 같이 미리 보기 API를 활성화해야 합니다.</p><ul><li>javac –release 19 –enable-preview Main.java 로 프로그램을 컴파일 하고 java –enable-preview 실행</li><li>소스 코드 런처를 사용할 때 java –source 19 –enable-preview Main.java; 로 프로그램을 실행하십시오 . 또는,</li><li>jshell을 사용할 때 로 시작하십시오 jshell –enable-preview.</li></ul><h3 id="Do-not-pool-virtual-threads-가상-스레드를-풀링하지-않음"><a href="#Do-not-pool-virtual-threads-가상-스레드를-풀링하지-않음" class="headerlink" title="Do not pool virtual threads(가상 스레드를 풀링하지 않음)"></a>Do not pool virtual threads(가상 스레드를 풀링하지 않음)</h3><p>ExecutorService 개발자는 일반적으로 응용 프로그램 코드를 기존 ExecutorService스레드 풀 기반 에서 작업당 가상 스레드로 마이그레이션합니다.<br>모든 리소스 풀과 마찬가지로 스레드 풀은 값비싼 리소스를 공유하기 위한 것이지만 가상 스레드는 비용이 많이 들지 않으며 풀링할 필요가 전혀 없습니다.</p><p>개발자는 때때로 스레드 풀을 사용하여 제한된 리소스에 대한 동시 액세스를 제한합니다.<br>예를 들어 서비스가 20개 이상의 동시 요청을 처리할 수 없는 경우 크기 20의 풀에 제출된 작업을 통해<br>서비스에 대한 모든 액세스를 수행하면 이를 보장할 수 있습니다.<br>플랫폼 스레드의 높은 비용으로 인해 스레드 풀이 유비쿼터스화되었기 때문에 이 관용구도 유비쿼터스가 되었지만<br>개발자는 동시성을 제한하기 위해 가상 스레드를 풀링하려는 유혹을 받아서는 안 됩니다.<br>제한된 리소스에 대한 액세스를 보호하기 위해 세마포어와 같이 해당 목적을 위해 특별히 설계된 구조를 사용해야 합니다.<br>이는 스레드 풀보다 더 효과적이고 편리하며 스레드 로컬 데이터가 실수로 한 작업에서 다른 작업으로 누출될 위험이 없기 때문에 더 안전합니다.</p><h3 id="Observing-virtual-threads-가상-스레드-관찰"><a href="#Observing-virtual-threads-가상-스레드-관찰" class="headerlink" title="Observing virtual threads(가상 스레드 관찰)"></a>Observing virtual threads(가상 스레드 관찰)</h3><p>명확한 코드를 작성하는 것이 전부는 아닙니다.<br>실행 중인 프로그램의 상태를 명확하게 표시하는 것도 문제 해결, 유지 관리 및 최적화에 필수적이며<br>JDK는 오랫동안 스레드를 디버그, 프로필 및 모니터링하는 메커니즘을 제공했습니다. 이러한 도구는 결국 java.lang.Thread.</p><p>Java 디버거는 가상 스레드를 단계별로 실행하고, 호출 스택을 표시하고, 스택 프레임의 변수를 검사할 수 있습니다.<br>JDK의 낮은 오버헤드 프로파일링 및 모니터링 메커니즘인 JFR(JDK Flight Recorder)은<br>애플리케이션 코드의 이벤트(예: 개체 할당 및 I&#x2F;O 작업)를 올바른 가상 스레드와 연결할 수 있습니다.<br>이러한 도구는 비동기 스타일로 작성된 애플리케이션에 대해 이러한 작업을 수행할 수 없습니다.<br>이 스타일에서 작업은 스레드와 관련이 없으므로 디버거는 작업의 상태를 표시하거나 조작할 수 없으며<br>프로파일러는 작업이 I&#x2F;O를 기다리는 데 소요되는 시간을 알 수 없습니다.</p><p>스레드 덤프는 요청당 스레드 스타일로 작성된 응용 프로그램 문제 해결을 위한 또 다른 인기 있는 도구입니다.<br>불행하게도  jstack 또는 jcmd 로 얻은 JDK의 기존 스레드 덤프는 단순한 스레드 목록을 제공합니다.<br>이는 수십 또는 수백 개의 플랫폼 스레드에 적합하지만 수천 또는 수백만 개의 가상 스레드에는 적합하지 않습니다.<br>따라서 가상 스레드를 포함하도록 기존의 스레드 덤프를 확장하지 않고 의미 있는 방식으로<br>모두 그룹화된 플랫폼 스레드와 함께 가상 스레드를 제공하기 위해 새로운 종류의 스레드 덤프를 도입할 것입니다.<br>프로그램이 구조화된 동시성을 사용할 때 스레드 간의 보다 풍부한 관계를 표시할 수 있습니다 .</p><p>많은 스레드를 시각화하고 분석하면 도구의 이점을 얻을 수 있으므로 는 일반 텍스트 외에도 JSON 형식으로 새 스레드 덤프를 내보낼 수 있습니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;file&gt;</span><br></pre></td></tr></table></figure><p>ExecutorService 새 스레드 덤프 형식은 네트워크 I&#x2F;O 작업에서 차단된 가상 스레드와 위에 표시된<br>태스크당 새 스레드에 의해 생성된 가상 스레드를 나열합니다.<br>개체 주소, 잠금, JNI 통계, 힙 통계 및 기존 스레드 덤프에 표시되는 기타 정보는 포함되지 않습니다.<br>또한 많은 스레드를 나열해야 할 수 있으므로 새 스레드 덤프를 생성해도 응용 프로그램이 일시 중지되지 않습니다.</p><p>다음은 JSON 뷰어에서 렌더링된 위 의 두 번째 예와 유사한 애플리케이션에서 가져온 스레드 덤프의 예입니다 (확대하려면 클릭).</p><p>가상 스레드는 JDK에서 구현되고 특정 OS 스레드에 연결되지 않기 때문에 OS에서는 보이지 않으며 존재를 인식하지 못합니다.<br>OS 레벨 모니터링은 JDK 프로세스가 가상 스레드보다 적은 수의 OS 스레드를 사용함을 관찰합니다.</p><h3 id="Scheduling-virtual-threads-가상-스레드-예약"><a href="#Scheduling-virtual-threads-가상-스레드-예약" class="headerlink" title="Scheduling virtual threads(가상 스레드 예약)"></a>Scheduling virtual threads(가상 스레드 예약)</h3><p>유용한 작업을 수행하려면 스레드를 예약해야 합니다. 즉, 프로세서 코어에서 실행하도록 할당해야 합니다.<br>OS 스레드로 구현되는 플랫폼 스레드의 경우 JDK는 OS의 스케줄러에 의존합니다.<br>반대로 가상 스레드의 경우 JDK에는 자체 스케줄러가 있습니다.<br>가상 스레드를 프로세서에 직접 할당하는 대신 JDK의 스케줄러는 가상 스레드를 플랫폼 스레드에 할당합니다(앞서 언급한 가상 스레드의 M:N 스케줄링).<br>그런 다음 플랫폼 스레드는 평소와 같이 OS에 의해 예약됩니다.</p><p>ForkJoinPoolJDK의 가상 스레드 스케줄러는 FIFO 모드로 작동하는 작업 도용입니다.<br>스케줄러의 병렬성 은 가상 스레드 스케줄링을 위해 사용 가능한 플랫폼 스레드의 수입니다.<br>기본적으로 사용 가능한 프로세서 수와 동일 하지만 시스템 속성으로 조정할 수 있습니다<br>jdk.virtualThreadScheduler.parallelism. 이것은 예를 들어 병렬 스트림 구현에 사용되고<br>LIFO 모드에서 작동하는 공통 풀과 구별ForkJoinPool 된다는 점에 유의하십시오.</p><p>스케줄러가 가상 스레드를 할당하는 플랫폼 스레드를 가상 스레드의 캐리어 라고 합니다.<br>가상 스레드는 수명 동안 다른 캐리어에서 예약될 수 있습니다. 즉, 스케줄러는 가상 스레드와 특정 플랫폼 스레드 간의 선호도를 유지하지 않습니다.<br>Java 코드의 관점에서 실행 중인 가상 스레드는 현재 캐리어와 논리적으로 독립적입니다.</p><ul><li>캐리어의 ID는 가상 스레드에서 사용할 수 없습니다. 에서 반환되는 값은 Thread.currentThread()항상 가상 스레드 자체입니다.</li><li>캐리어와 가상 스레드의 스택 추적은 별개입니다. 가상 스레드에서 발생한 예외에는 캐리어의 스택 프레임이 포함되지 않습니다. 스레드 덤프는 캐리어의 스택 프레임을 가상 스레드의 스택에 표시하지 않으며 그 반대도 마찬가지입니다.</li><li>캐리어의 스레드 로컬 변수는 가상 스레드에서 사용할 수 없으며 그 반대도 마찬가지입니다.</li></ul><p>또한 Java 코드의 관점에서 볼 때 가상 스레드와 해당 캐리어가 일시적으로 OS 스레드를 공유한다는 사실은 보이지 않습니다.<br>반대로 네이티브 코드의 관점에서 볼 때 가상 스레드와 캐리어는 모두 동일한 네이티브 스레드에서 실행됩니다.<br>따라서 동일한 가상 스레드에서 여러 번 호출되는 네이티브 코드는 호출할 때마다 다른 OS 스레드 식별자를 관찰할 수 있습니다.</p><p>스케줄러는 현재 가상 스레드에 대한 시간 공유를 구현하지 않습니다. 시간 공유는 할당된 양의 CPU 시간을 사용한 스레드의 강제 선점입니다.<br>상대적으로 적은 수의 플랫폼 스레드가 있고 CPU 사용률이 100%일 때 시분할이 일부 작업의 대기 시간을 줄이는 데 효과적일 수 있지만<br>시분할이 백만 개의 가상 스레드에서만큼 효과적일지는 확실하지 않습니다.</p><h3 id="Executing-virtual-threads-가상-스레드-실행"><a href="#Executing-virtual-threads-가상-스레드-실행" class="headerlink" title="Executing virtual threads(가상 스레드 실행)"></a>Executing virtual threads(가상 스레드 실행)</h3><p>가상 스레드를 활용하기 위해 프로그램을 다시 작성할 필요는 없습니다.<br>가상 스레드는 응용 프로그램 코드가 명시적으로 제어를 스케줄러로 되돌려줄 것을 요구하거나 기대하지 않습니다.<br>즉, 가상 스레드는 협력적이 지 않습니다. 사용자 코드는 플랫폼 스레드가 프로세서 코어에 할당되는 방법 또는 시기에 대해 가정하는 것 이상으로<br>가상 스레드가 플랫폼 스레드에 할당되는 방법 또는 시기에 대해 가정해서는 안 됩니다.</p><p>가상 스레드에서 코드를 실행하기 위해 JDK의 가상 스레드 스케줄러는 가상 스레드를 플랫폼 스레드에 마운트하여<br>플랫폼 스레드에서 실행할 가상 스레드를 할당합니다.<br>이렇게 하면 플랫폼 스레드가 가상 스레드의 캐리어가 됩니다.<br>나중에 일부 코드를 실행한 후 가상 스레드는 캐리어에서 마운트 해제 할 수 있습니다.<br>이 시점에서 플랫폼 스레드는 사용 가능하므로 스케줄러가 다른 가상 스레드를 플랫폼에 마운트하여 다시 캐리어로 만들 수 있습니다.</p><p>일반적으로 가상 스레드는 I&#x2F;O 또는 JDK의 다른 차단 작업(예: BlockingQueue.take().<br>차단 작업이 완료될 준비가 되면(예: 소켓에 바이트가 수신됨) 스케줄러에 가상 스레드를 다시 제출하고 스케줄러는 가상 스레드를 캐리어에 탑재하여 실행을 재개합니다.</p><p>가상 스레드의 마운트 및 마운트 해제는 OS 스레드를 차단하지 않고 자주 투명하게 발생합니다.<br>예를 들어 이전에 표시된 서버 응용 프로그램에는 차단 작업에 대한 호출이 포함된 다음 코드 줄이 포함되어 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.send(future1.get() + future2.get());</span><br></pre></td></tr></table></figure><p>이러한 작업으로 인해 가상 스레드는 일반적으로 각 호출에 대해 한 번, send(…) 에서 get() I&#x2F;O를 수행하는 동안 여러 번 마운트 및 마운트 해제됩니다 </p><p>JDK에서 대부분의 차단 작업은 가상 스레드를 마운트 해제하여 캐리어와 기본 OS 스레드가 새로운 작업을 수행하도록 해제합니다.<br>그러나 JDK의 일부 차단 작업은 가상 스레드를 마운트 해제하지 않으므로 캐리어와 기본 OS 스레드를 모두 차단합니다.<br>이는 OS 수준(예: 많은 파일 시스템 작업) 또는 JDK 수준(예: Object.wait())의 제한 사항 때문입니다.<br>이러한 차단 작업을 구현하면 스케줄러의 병렬 처리를 일시적으로 확장하여 OS 스레드 캡처를 보상합니다.<br>결과적으로 스케줄러의 플랫폼 스레드 수가 ForkJoinPool일시적으로 사용 가능한 프로세서 수를 초과할 수 있습니다.<br>스케줄러가 사용할 수 있는 최대 플랫폼 스레드 수는 시스템 속성으로 조정할 수 있습니다 jdk.virtualThreadScheduler.maxPoolSize.</p><p>캐리어에 고정되어 있기 때문에 차단 작업 중에 가상 스레드를 마운트 해제할 수 없는 두 가지 시나리오가 있습니다 .</p><ul><li>블록이나 메서드 내에서 코드를 실행할 때 synchronized또는</li><li>native 메서드나 외부 함수를 실행할 때.</li></ul><p>고정은 응용 프로그램을 잘못 만들지는 않지만 확장성을 방해할 수 있습니다.<br>가상 스레드가 I&#x2F;O와 같은 차단 작업을 수행하거나 BlockingQueue.take()고정된 상태에서 작업이 지속되는 동안 해당 캐리어와 기본 OS 스레드가 차단됩니다.<br>오랜 기간 동안 빈번한 고정은 캐리어 캡처로 인해 애플리케이션의 확장성을 손상시킬 수 있습니다.</p><p>스케줄러는 병렬 처리를 확장하여 고정을 보상하지 않습니다.<br>대신 자주 synchronized실행되는 블록이나 메서드를 수정하여 빈번 하고<br>오래 지속되는 고정을 피하고 java.util.concurrent.locks.ReentrantLock대신 사용할 잠재적으로 긴 I&#x2F;O 작업을 보호하세요.<br>synchronized드물게 사용되거나(예: 시작 시에만 수행됨) 메모리 내 작업을 보호하는 블록 및 메서드를 교체할 필요가 없습니다.<br>항상 그렇듯이 잠금 정책을 간단하고 명확하게 유지하기 위해 노력하십시오.</p><p>synchronized새로운 진단 기능은 코드를 가상 스레드로 마이그레이션하고 java.util.concurrent 의 특정 용도를 잠금으로 대체해야 하는지 여부를 평가하는 데 도움이 됩니다.</p><ul><li>고정된 동안 스레드가 차단되면 JFR(JDK Flight Recorder) 이벤트가 발생합니다( JDK Flight Recorder 참조 ).</li><li>고정된 상태에서 스레드가 차단되면 시스템 속성이 jdk.tracePinnedThreads스택 추적을 트리거합니다. 함께 실행하면 -Djdk.tracePinnedThreads&#x3D;full고정된 상태에서 스레드가 차단될 때 전체 스택 추적이 인쇄되며 네이티브 프레임과 프레임이 모니터를 강조 표시합니다. 함께 실행하면 -Djdk.tracePinnedThreads&#x3D;short문제가 있는 프레임으로만 출력이 제한됩니다.</li></ul><p>향후 릴리스에서는 위의 첫 번째 제한 사항( 내부 고정)을 제거할 수 있습니다 synchronized.<br>네이티브 코드와의 적절한 상호 작용을 위해서는 두 번째 제한 사항이 필요합니다.</p><h3 id="Memory-use-and-interaction-with-garbage-collection-메모리-사용-및-가비지-수집과의-상호-작용"><a href="#Memory-use-and-interaction-with-garbage-collection-메모리-사용-및-가비지-수집과의-상호-작용" class="headerlink" title="Memory use and interaction with garbage collection(메모리 사용 및 가비지 수집과의 상호 작용)"></a>Memory use and interaction with garbage collection(메모리 사용 및 가비지 수집과의 상호 작용)</h3><p>가상 스레드의 스택은 Java의 가비지 수집된 힙에 스택 청크 개체 로 저장됩니다.<br>애플리케이션이 실행됨에 따라 스택이 확장 및 축소되어 메모리 효율성이 향상되고 임의 깊이의 스택(JVM의 구성된 플랫폼 스레드 스택 크기까지)을 수용할 수 있습니다.<br>이러한 효율성은 많은 수의 가상 스레드를 가능하게 하고 따라서 서버 애플리케이션에서 요청당 스레드 스타일의 지속적인 실행 가능성을 가능하게 합니다.</p><p>위의 두 번째 예 에서 가상의 프레임워크가 새 가상 스레드를 만들고 메서드를 호출하여 각 요청을 처리한다는 점을 상기하십시오 handle.<br>handle깊은 호출 스택의 끝에서 호출하더라도 (인증, 트랜잭션 등 이후) handle자체적으로 단기 작업만 수행하는 여러 가상 스레드를 생성합니다.<br>따라서 깊은 호출 스택이 있는 각 가상 스레드에 대해 적은 메모리를 사용하는 얕은 호출 스택이 있는 여러 가상 스레드가 있습니다.</p><p>가상 스레드에 필요한 힙 공간 및 가비지 수집기 활동의 양은 일반적으로 비동기 코드와 비교하기 어렵습니다.<br>백만 개의 가상 스레드에는 최소한 백만 개의 개체가 필요하지만 플랫폼 스레드 풀을 공유하는 백만 개의 작업도 마찬가지입니다.<br>또한 요청을 처리하는 애플리케이션 코드는 일반적으로 I&#x2F;O 작업 전반에 걸쳐 데이터를 유지합니다.<br>요청당 스레드 코드는 해당 데이터를 힙의 가상 스레드 스택에 저장되는 로컬 변수에 보관할 수 있는<br>반면, 비동기식 코드는 파이프라인의 한 단계에서 다음 단계로 전달되는 힙 개체에 동일한 데이터를 보관해야 합니다.<br>한편으로 가상 스레드에 필요한 스택 프레임 레이아웃은 압축 개체보다 더 낭비입니다.<br>반면에, 가상 스레드는 다양한 상황에서(낮은 수준의 GC 상호 작용에 따라) 스택을 변경하고 재사용할 수 있는<br>반면, 비동기 파이프라인은 항상 새 개체를 할당해야 하므로 가상 스레드는 더 적은 할당이 필요할 수 있습니다.<br>전반적으로 요청당 스레드 대 비동기 코드의 힙 소비 및 가비지 수집기 활동은 거의 유사해야 합니다.<br>시간이 지남에 따라 가상 스레드 스택의 내부 표현이 훨씬 더 간결해질 것으로 예상됩니다.</p><p>플랫폼 스레드 스택과 달리 가상 스레드 스택은 GC 루트가 아니므로 여기에 포함된 참조는 동시 힙 스캔을 수행하는 G1과 같은 가비지 수집기에 의한<br>top-the-world 일시 중지에서 순회되지 않습니다. BlockingQueue.take()이것은 또한 가상 스레드가 예를 들어 에서 차단되고 다른 스레드가<br>가상 스레드나 대기열에 대한 참조를 얻을 수 없는 경우 스레드가 가비지 수집될 수 있음을 의미합니다 . 중단되거나 차단 해제됩니다.<br>물론 가상 스레드는 실행 중이거나 차단되어 차단 해제될 수 있는 경우 가비지 수집되지 않습니다.</p><p>가상 스레드의 현재 제한 사항은 G1 GC가 거대한 스택 청크 개체를 지원하지 않는다는 것입니다.<br>가상 스레드의 스택이 영역 크기의 절반(512KB 정도로 작을 수 있음)에 도달하면 a가 StackOverflowError발생할 수 있습니다.</p><h2 id="Detailed-changes-세부-변경-사항"><a href="#Detailed-changes-세부-변경-사항" class="headerlink" title="Detailed changes(세부 변경 사항)"></a>Detailed changes(세부 변경 사항)</h2><ul><li>java.lang.Thread </li><li>스레드 로컬 변수 </li><li>java.util.concurrent </li><li>네트워킹 </li><li>java.io </li><li>자바 네이티브 인터페이스(JNI)</li><li>디버깅(JVM TI, JDWP 및 JDI)</li><li>JDK 비행 기록기(JFR)</li><li>JMX(Java 관리 확장)</li><li>java.lang.ThreadGroup</li></ul><h3 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h3><p>다음과 같이 API를 업데이트합니다 java.lang.Thread.</p><p>Thread.Builder, Thread.ofVirtual()및 은 Thread.ofPlatform()가상 및 플랫폼 스레드를 생성하는 새로운 API입니다. 예를 들어,<br><code>Thread thread = Thread.ofVirtual().name(&quot;duke&quot;).unstarted(runnable);</code><br>라는 새로운 시작되지 않은 가상 스레드를 생성합니다</p><p>Thread.startVirtualThread(Runnable)가상 스레드를 생성하고 시작하는 편리한 방법입니다.</p><p>A는 Thread.Builder스레드 또는 를 생성할 수 있으며 ThreadFactory, 그러면 동일한 속성을 가진 여러 스레드를 생성할 수 있습니다.</p><p>Thread.isVirtual()스레드가 가상 스레드인지 여부를 테스트합니다.</p><p>의 새로운 오버로드 Thread.join및 의 Thread.sleep인스턴스로 대기 및 절전 시간을 수락합니다 java.time.Duration.</p><p>새로운 최종 메서드는 Thread.threadId()스레드의 식별자를 반환합니다. 기존의 최종이 아닌 메서드는 Thread.getId()이제 더 이상 사용되지 않습니다.</p><p>Thread.getAllStackTraces()이제 모든 스레드가 아닌 모든 플랫폼 스레드의 맵을 반환합니다.</p><p>그렇지 않으면 API java.lang.Thread가 변경되지 않습니다.<br>클래스 에 의해 정의된 생성자는 Thread 이전과 같이 플랫폼 스레드를 생성합니다.<br>새로운 공개 생성자가 없습니다.</p><p>가상 스레드와 플랫폼 스레드 간의 주요 API 차이점은 다음과 같습니다.</p><p>공용 Thread생성자는 가상 스레드를 만들 수 없습니다.</p><p>가상 스레드는 항상 데몬 스레드입니다. 이 Thread.setDaemon(boolean)메서드는 가상 스레드를 데몬이 아닌 스레드로 변경할 수 없습니다.</p><p>가상 스레드는 의 고정 우선 순위를 갖습니다 Thread.NORM_PRIORITY. 이 Thread.setPriority(int)방법은 가상 스레드에 영향을 주지 않습니다.<br>이 제한 사항은 향후 릴리스에서 다시 검토될 수 있습니다.</p><p>가상 스레드는 스레드 그룹의 활성 구성원이 아닙니다.<br>가상 스레드에서 호출되면 Thread.getThreadGroup()이름이 있는 자리 표시자 스레드 그룹을 반환합니다 “VirtualThreads”.<br>API Thread.Builder는 가상 스레드의 스레드 그룹을 설정하는 방법을 정의하지 않습니다.</p><p>가상 스레드는 세트로 실행할 때 권한이 없습니다 SecurityManager.</p><p>stop()가상 스레드는 , suspend()또는 메서드를 지원하지 않습니다 resume(). 이러한 메서드는 가상 스레드에서 호출될 때 예외를 throw합니다.</p><h3 id="Thread-local-variables-스레드-로컬-변수"><a href="#Thread-local-variables-스레드-로컬-변수" class="headerlink" title="Thread-local variables(스레드 로컬 변수)"></a>Thread-local variables(스레드 로컬 변수)</h3><p>가상 스레드는 플랫폼 스레드와 마찬가지로 스레드 로컬 변수(ThreadLocal) 및 상속 가능한 스레드 로컬 변수(InheritableThreadLocal)를 지원하므로<br>스레드 로컬을 사용하는 기존 코드를 실행할 수 있습니다.<br>그러나 가상 스레드가 매우 많을 수 있으므로 신중하게 고려한 후 스레드 로컬을 사용하십시오.<br>특히 스레드 풀에서 동일한 스레드를 공유하는 여러 작업 간에 비용이 많이 드는 리소스를 풀링하기 위해 스레드 로컬을 사용하지 마십시오.<br>가상 스레드는 풀링되지 않아야 합니다. 각 스레드는 수명 기간 동안 단일 작업만 실행하도록 되어 있기 때문입니다.<br>java.base수백만 개의 스레드로 실행할 때 메모리 공간을 줄이기 위해 가상 스레드를 준비하기 위해 모듈 에서 스레드 로컬의 많은 사용을 제거했습니다 .</p><ul><li>API 는 스레드를 생성할 때 스레드 로컬을 옵트아웃하는 방법을Thread.Builder 정의합니다. </li><li>또한 상속 가능한 thread-locals 의 초기 값 상속을 거부하는 방법을 정의합니다.<br>스레드 로컬을 지원하지 않는 스레드에서 호출되면 초기 값을 반환하고 예외를 throw합니다.ThreadLocal.get()ThreadLocal.set(T)</li><li>레거시 컨텍스트 클래스 로더는 이제 상속 가능한 스레드 로컬처럼 작동하도록 지정되었습니다.<br>Thread.setContextClassLoader(ClassLoader)스레드 로컬을 지원하지 않는 스레드에서 호출되면 예외가 발생합니다 .</li></ul><p>범위 로컬 변수는 일부 사용 사례에서 스레드 로컬에 대한 더 나은 대안이 될 수 있습니다.</p><h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>잠금을 지원하는 원시 API는 java.util.concurrent.LockSupport이제 가상 스레드를 지원합니다.<br>가상 스레드를 파킹하면 다른 작업을 수행하기 위해 기본 플랫폼 스레드가 해제되고 가상 스레드를 파킹 해제하면 계속되도록 예약됩니다.<br>이 변경으로 LockSupport 이를 사용하는 모든 API(Locks, Semaphores, 차단 대기열 등)가 가상 스레드에서 호출될 때 정상적으로 파킹할 수 있습니다.</p><ul><li><p>Executors.newThreadPerTaskExecutor(ThreadFactory)각 작업에 대해 새 스레드를 생성하는 Executors.newVirtualThreadPerTaskExecutor()을 생성합니다.<br>ExecutorService이러한 메서드를 사용하면 스레드 풀 및 ExecutorService.</p></li><li><p>ExecutorService이제 extends AutoCloseable이므로 이 API를 위의 예와 같이 try-with-resource 구성과 함께 사용할 수 있습니다.</p></li><li><p>Future이제 완료된 작업의 결과 또는 예외를 가져오고 작업의 상태를 가져오는 메서드를 정의합니다.<br>이러한 추가 기능을 결합하면 개체를 스트림의 요소로 쉽게 사용할 수 있고 Future, 퓨처 스트림을 필터링하여 완료된 작업을 찾은 다음<br>이를 매핑하여 결과 스트림을 얻을 수 있습니다. 이러한 방법은 구조화된 동시성을 위해 제안된 API 추가에도 유용합니다.</p></li></ul><h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><p>java.net및 패키지 의 네트워킹 API 구현은 java.nio.channels이제 가상 스레드와 함께 작동합니다.<br>예를 들어 네트워크 연결 설정 또는 소켓에서 읽기를 차단하는 가상 스레드에 대한 작업은 다른 작업을 수행하기 위해 기본 플랫폼 스레드를 해제합니다.</p><p>중단 및 취소를 허용하기 위해 , java.net.Socket및 ServerSocket에 의해 정의된 차단 I&#x2F;O 메서드는 이제 가상 스레드에서 호출될 때<br>중단 가능DatagramSocket 하도록 지정됩니다. 소켓에서 차단된 가상 스레드를 중단하면 스레드가 언파킹되고 소켓이 닫힙니다.<br>에서 가져올 때 이러한 유형의 소켓에 대한 I&#x2F;O 작업 차단은 항상 인터럽트할 수 있으므로<br>이 변경 사항은 채널에서 가져올 때 해당 동작과 생성자로 생성될 때 이러한 API의 동작을 정렬합니다.InterruptibleChannel</p><h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><p>이 java.io패키지는 바이트 및 문자 스트림에 대한 API를 제공합니다.<br>이러한 API의 구현은 심하게 동기화되며 가상 스레드에서 사용될 때 고정을 방지하기 위해 변경이 필요합니다.</p><p>close()배경으로 바이트 지향 입력&#x2F;출력 스트림은 스레드로부터 안전하도록 지정되지 않았으며<br>스레드가 읽기 또는 쓰기 메서드에서 차단된 동안 호출될 때 예상되는 동작을 지정하지 않습니다.<br>대부분의 시나리오에서 여러 동시 스레드의 특정 입력 또는 출력 스트림을 사용하는 것은 의미가 없습니다.<br>문자 지향 리더&#x2F;라이터도 스레드로부터 안전하도록 지정되지 않았지만 하위 클래스에 대한 잠금 개체를 노출합니다.<br>고정 외에도 이러한 클래스의 동기화는 문제가 있고 일관성이 없습니다.<br>예를 들어 잠금 개체가 아닌 스트림 개체에서 사용 InputStreamReader하고 동기화하는 스트림 디코더 및 인코더입니다 .OutputStreamWriter</p><p>고정을 방지하기 위해 구현은 이제 다음과 같이 작동합니다.</p><ul><li><p>BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriterPrintStreamPrintWriter,<br>그리고 이제 직접 사용할 때 모니터가 아닌 명시적 잠금을 사용합니다 . 이러한 클래스는 하위 클래스로 분류될 때 이전과 같이 동기화됩니다.</p></li><li><p>InputStreamReader 에서 사용하는 스트림 디코더 및 인코더는 이제 OutputStreamWriter둘러싸는 InputStreamReader<br>또는 OutputStreamWriter 와 동일한 잠금을 사용합니다</p></li></ul><p>더 나아가 불필요한 잠금을 모두 제거하는 것은 이 JEP의 범위를 벗어납니다.</p><p>BufferedOutputStream또한 , BufferedWriter및 스트림 인코더 에서 사용하는 버퍼의 초기 크기는 OutputStreamWriter이제<br>힙에 많은 스트림 또는 작성자가 있을 때 메모리 사용량을 줄이기 위해 더 작아졌습니다. 소켓 연결에서 버퍼링된 스트림.</p><h3 id="Java-Native-Interface-JNI"><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface (JNI)"></a>Java Native Interface (JNI)</h3><p>IsVirtualThreadJNI는 개체가 가상 스레드인지 테스트하기 위해 하나의 새 함수를 정의합니다 .</p><p>그렇지 않으면 JNI 사양이 변경되지 않습니다.</p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>디버깅 아키텍처는 JVM TI(JVM Tool Interface), JDWP(Java Debug Wire Protocol) 및 JDI(Java Debug Interface)의 세 가지 인터페이스로 구성됩니다.<br>이제 세 가지 인터페이스 모두 가상 스레드를 지원합니다.</p><p>JVM TI 에 대한 업데이트는 다음과 같습니다.</p><ul><li><p>jthread(즉, 객체에 대한 JNI 참조 ) 로 호출되는 대부분의 함수는 Thread가상 스레드에 대한 참조로 호출될 수 있습니다.<br>소수의 함수, 즉 PopFrame, ForceEarlyReturn, StopThread, AgentStartFunction및 은 GetThreadCpuTime가상 스레드에서 지원되지 않습니다.<br>기능 SetLocal*은 중단점 또는 단일 단계 이벤트에서 일시 중단된 가상 스레드의 최상위 프레임에서 로컬 변수를 설정하는 것으로 제한됩니다.</p></li><li><p>이제 모든 스레드가 아닌 모든 플랫폼 스레드를 반환하도록 GetAllThreads및 함수 가 지정되었습니다.GetAllStackTraces</p></li><li><p>초기 VM 시작 또는 힙 반복 중에 게시된 이벤트를 제외한 모든 이벤트는 가상 스레드 컨텍스트에서 호출된 이벤트 콜백을 가질 수 있습니다.</p></li><li><p>일시 중단&#x2F;재개 구현을 사용하면 디버거에서 가상 스레드를 일시 중단 및 재개할 수 있으며 가상 스레드가 마운트될 때 플랫폼 스레드를 일시 중단할 수 있습니다.</p></li><li><p>새 기능인 은 can_support_virtual_threads에이전트가 가상 스레드의 스레드 시작 및 종료 이벤트를 보다 세밀하게 제어할 수 있도록 합니다.</p></li><li><p>새로운 기능은 가상 스레드의 대량 일시 중지 및 재개를 지원합니다. 여기에는 can_support_virtual_threads 기능이 필요합니다.</p></li></ul><p>기존 JVM TI 에이전트는 대부분 이전과 동일하게 작동하지만 가상 스레드에서 지원되지 않는 기능을 호출하는 경우 오류가 발생할 수 있습니다.<br>가상 스레드를 인식하지 못하는 에이전트가 가상 스레드를 사용하는 애플리케이션과 함께 사용되는 경우 이러한 오류가 발생합니다.<br>GetAllThreads플랫폼 스레드만 포함하는 배열을 반환하도록 변경하면 일부 에이전트에서 문제가 될 수 있습니다.<br>ThreadStart및 이벤트를 활성화하는 기존 에이전트는 ThreadEnd이러한 이벤트를 플랫폼 스레드로 제한하는 기능이 없기 때문에 성능 문제가 발생할 수 있습니다.</p><p>JDWP 에 대한 업데이트는 다음과 같습니다.</p><ul><li>새 명령을 사용하면 디버거가 스레드가 가상 스레드인지 테스트할 수 있습니다.</li><li>명령 의 새 수정자는 EventRequest디버거가 스레드 시작 및 종료 이벤트를 플랫폼 스레드로 제한할 수 있도록 합니다.</li></ul><p>JDI 에 대한 업데이트는 다음과 같습니다.</p><ul><li>com.sun.jdi.ThreadReference스레드가 가상 스레드인지 여부를 테스트하는 새로운 방법입니다</li><li>새로운 메서드는 플랫폼 스레드에 대한 요청에 대해 생성된 이벤트를 제한합니다 com.sun.jdi.request.ThreadStartRequest.com.sun.jdi.request.ThreadDeathRequest</li></ul><p>위에서 언급한 것처럼 가상 스레드는 스레드 그룹에서 활성 스레드로 간주되지 않습니다.<br>따라서 JVM TI 함수 GetThreadGroupChildren, JDWP 명령 ThreadGroupReference&#x2F;Children및 JDI 메서드 에서 반환된 스레드 목록<br>com.sun.jdi.ThreadGroupReference.threads()에는 플랫폼 스레드만 포함됩니다.</p><h3 id="JDK-Flight-Recorder-JFR"><a href="#JDK-Flight-Recorder-JFR" class="headerlink" title="JDK Flight Recorder (JFR)"></a>JDK Flight Recorder (JFR)</h3><p>JFR은 몇 가지 새로운 이벤트로 가상 스레드를 지원합니다.</p><ul><li>jdk.VirtualThreadStart가상 스레드 시작 및 종료를 나타 냅니다 jdk.VirtualThreadEnd. 이러한 이벤트는 기본적으로 비활성화되어 있습니다.</li><li>jdk.VirtualThreadPinned고정된 동안 즉, 플랫폼 스레드를 해제하지 않고 가상 스레드가 정지되었음을 나타냅니다( 토론 참조 ).<br>이 이벤트는 기본적으로 활성화되며 임계값은 20ms입니다.</li><li>jdk.VirtualThreadSubmitFailed리소스 문제로 인해 가상 스레드 시작 또는 언파킹이 실패했음을 나타냅니다. 이 이벤트는 기본적으로 활성화되어 있습니다.</li></ul><h3 id="Java-Management-Extensions-JMX"><a href="#Java-Management-Extensions-JMX" class="headerlink" title="Java Management Extensions (JMX)"></a>Java Management Extensions (JMX)</h3><p>java.lang.management.ThreadMXBean플랫폼 스레드의 모니터링 및 관리만 지원합니다.<br>이 findDeadlockedThreads()메서드는 교착 상태에 있는 플랫폼 스레드의 주기를 찾습니다.<br>교착 상태에 있는 가상 스레드의 주기는 찾지 않습니다.</p><p>의 새로운 메서드는 위에서com.sun.management.HotSpotDiagnosticsMXBean 설명한 새로운 스타일의 스레드 덤프를 생성합니다.<br>이 메서드는 로컬 또는 원격 JMX 도구에서 플랫폼을 통해 간접적으로 호출할 수도 있습니다 .MBeanServer</p><h3 id="java-lang-ThreadGroup"><a href="#java-lang-ThreadGroup" class="headerlink" title="java.lang.ThreadGroup"></a>java.lang.ThreadGroup</h3><p>java.lang.ThreadGroup최신 애플리케이션에서 거의 사용되지 않고 가상 스레드 그룹화에 적합하지 않은 스레드 그룹화를 위한 레거시 API입니다.<br>우리는 지금 그것을 더 이상 사용하지 않고 성능을 저하시키며 구조화된 동시성 의 일부로 미래에 새로운 스레드 구성 구조를 도입할 것으로 예상합니다 .</p><p>배경으로 ThreadGroupAPI는 Java 1.0부터 시작됩니다. 원래 그룹의 모든 스레드 중지와 같은 작업 제어 작업을 제공하기 위한 것이었습니다.<br>java.util.concurrent최신 코드는 Java 5에 도입된 패키지 의 스레드 풀 API를 사용할 가능성이 더 높습니다 ThreadGroup.<br>초기 Java 릴리스에서 애플릿의 격리를 지원했지만 Java 보안 아키텍처는 Java 1.2에서 크게 발전했으며 스레드 그룹은 더 이상 중요한 역할을 하지 않았습니다.<br>ThreadGroup진단 목적에도 유용하도록 의도되었지만 그 역할은 API를 포함하여 Java 5에 도입된 모니터링 및 관리 기능으로 대체되었습니다 java.lang.management.</p><p>현재 거의 관련이 없는 것 외에도 ThreadGroupAPI 및 구현에는 여러 가지 중요한 문제가 있습니다.</p><ul><li>스레드 그룹을 파괴하는 API 및 메커니즘에 결함이 있습니다.</li><li>API는 구현이 그룹의 모든 라이브 스레드에 대한 참조를 갖도록 요구합니다. 이는 스레드 생성, 스레드 시작 및 스레드 종료에 동기화 및 경합 오버헤드를 추가합니다.</li><li>API는 enumerate()본질적으로 정확성이 있는 메서드를 정의합니다.</li><li>API는 본질적으로 교착 상태가 발생 suspend()하기 쉽고 안전하지 않은 , resume()및 stop()메서드를 정의합니다.</li></ul><p>ThreadGroup이제 다음과 같이 지정, 더 이상 사용되지 않으며 성능이 저하됩니다.</p><ul><li>명시적으로 스레드 그룹을 제거하는 기능이 제거되었습니다. 최종적으로 더 이상 사용되지 않는 destroy()메서드는 아무 작업도 수행하지 않습니다.</li><li>데몬 스레드 그룹의 개념이 제거되었습니다. 최종적으로 더 이상 사용되지 않는 메서드에 의해 설정되고 검색된 데몬 상태가 setDaemon(boolean)무시 isDaemon()됩니다.</li><li>구현 시 더 이상 하위 그룹에 대한 강력한 참조를 유지하지 않습니다. 스레드 그룹은 이제 그룹에 활성 스레드가 없고 스레드 그룹을 활성 상태로 유지하는 다른 항목이 없을 때 가비지 수집 대상이 됩니다.</li><li>최종적으로 사용되지 않는 suspend(), resume()및 stop()메소드는 항상 예외를 발생시킵니다.</li></ul><h2 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h2><ul><li><p>계속해서 비동기 API를 사용합니다. 비동기식 API는 동기식 API와 통합하기 어렵고, 동일한 I&#x2F;O 작업의 두 가지 표현으로 분리된 세계를 생성하며,<br>문제 해결, 모니터링, 디버깅을 위한 컨텍스트로 플랫폼에서 사용할 수 있는 일련의 작업에 대한 통합 개념을 제공하지 않습니다. , 그리고 프로파일링 목적.</p></li><li><p>구문 스택리스 코루틴 (예: async&#x2F;await )을 Java 언어에 추가합니다 .<br>이들은 사용자 모드 스레드보다 구현하기 쉽고 일련의 작업 컨텍스트를 나타내는 통합 구조를 제공합니다.<br>그러나 그 구성은 새롭고 여러 측면에서 유사하지만 일부 미묘한 방식에서 다른 스레드와 별개입니다.<br>그것은 스레드용으로 설계된 API와 코루틴용으로 설계된 API 사이에서 세계를 분할하고 플랫폼 및 해당 도구의 모든 계층에 도입되는<br>새로운 스레드와 유사한 구성을 요구합니다.<br>이것은 생태계가 채택하는 데 더 오래 걸리며 사용자 모드 스레드만큼 플랫폼과 우아하고 조화롭지 않을 것입니다.</p></li></ul><p>구문적 코루틴을 채택한 대부분의 언어는 사용자 모드 스레드(예: Kotlin),<br>레거시 의미 체계 보장(예: 본질적으로 단일 스레드 JavaScript) 또는 언어별 기술적 제약(예: C++)을 구현할 수 없기 때문에 그렇게 했습니다. ).<br>이러한 제한은 Java에 적용되지 않습니다.</p><ul><li>java.lang.Thread_ Thread25년 동안 학급이 쌓아온 불필요한 짐을 버릴 수 있는 기회가 될 것이다.<br>우리는 이 접근 방식의 여러 변형을 탐색하고 프로토타입을 만들었지만 모든 경우에 기존 코드를 실행하는 방법에 대한 문제와 씨름했습니다.</li></ul><p>주된 문제는 이것이 Thread.currentThread()직간접적으로 기존 코드에 광범위하게 사용된다는 것입니다(예: 잠금 소유권 결정 또는 스레드 로컬 변수).<br>이 메서드는 현재 실행 스레드를 나타내는 개체를 반환해야 합니다. 사용자 모드 스레드를 나타내는 새 클래스를 도입한 경우 처럼 보이지만<br>사용자 모드 스레드 개체에 위임하는 currentThread()일종의 래퍼 개체를 반환해야 합니다 .Thread</p><p>두 개체가 현재 실행 스레드를 나타내는 것은 혼란스러울 수 있으므로 결국 이전 ThreadAPI를 유지하는 것이 큰 장애물이 아니라는 결론을 내렸습니다.<br>와 같은 몇 가지 방법을 제외하고 개발자는 API를 직접 currentThread()사용하는 경우가 거의 없습니다 .<br>Thread그들은 주로 ExecutorService. 시간이 지남에 따라 더 이상 사용되지 않는 메서드 를 사용하지 않고 제거하여 Thread클래스 및<br>관련 클래스 에서 불필요한 짐을 버릴 것입니다 .ThreadGroup</p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><ul><li>기존 테스트는 여기에서 제안하는 변경 사항이 실행되는 다양한 구성 및 실행 모드에서 예기치 않은 회귀를 일으키지 않도록 합니다.</li><li>jtreg가상 스레드 컨텍스트에서 기존 테스트를 실행할 수 있도록 테스트 도구를 확장할 것입니다 . 이렇게 하면 많은 테스트의 두 가지 버전이 필요하지 않습니다.</li><li>새로운 테스트는 모든 신규 및 수정된 API와 가상 스레드를 지원하도록 변경된 모든 영역을 실행합니다.</li><li>새로운 스트레스 테스트는 안정성과 성능에 중요한 영역을 대상으로 합니다.</li><li>새로운 마이크로벤치마크는 성능이 중요한 영역을 대상으로 합니다.</li><li>대규모 테스트를 위해 Helidon 및 Jetty를 포함한 여러 기존 서버를 사용할 것입니다.</li></ul><h2 id="Risks-and-Assumptions"><a href="#Risks-and-Assumptions" class="headerlink" title="Risks and Assumptions"></a>Risks and Assumptions</h2><p>이 제안의 주요 위험은 기존 API 및 해당 구현의 변경으로 인한 호환성 위험입니다.</p><p>java.io.BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter, PrintStream및 클래스 에서 사용되는 내부(및 문서화되지 않은)<br>잠금 프로토콜에 대한 개정은 PrintWriterI&#x2F;O 메서드가 호출되는 스트림에서 동기화된다고 가정하는 코드에 영향을 줄 수 있습니다.<br>이러한 변경 사항은 이러한 클래스를 확장하고 슈퍼클래스에 의한 잠금을 가정하는 코드에 영향을 주지 않으며<br>해당 API에서 노출하는 잠금 개체를 확장 java.io.Reader하거나 사용하는 코드에도 영향을 주지 않습니다 .java.io.Writer</p><p>java.lang.ThreadGroup더 이상 스레드 그룹이 파괴 되는 것을 허용하지 않으며 더 이상 데몬<br>스레드 그룹 의 개념을 지원하지 않으며 해당 suspend(), resume()및 stop()메소드는 항상 예외를 발생시킵니다.</p><p>다음은 확장하는 코드에 영향을 미칠 수 있는 몇 가지 소스 비호환 API 변경 사항과 하나의 바이너리 비호환 변경 사항입니다 java.lang.Thread.</p><ul><li>기존 소스 파일의 코드가 확장되고 Thread하위 클래스의 메서드가 새 Thread메서드와 충돌하는 경우 파일은 변경 없이 컴파일되지 않습니다.</li><li>Thread.Builder중첩 인터페이스로 추가됩니다. 기존 소스 파일의 코드가 를 확장하고 라는<br>Thread클래스를 가져오고 Builder하위 클래스의 코드가 “빌더”를 단순 이름으로 참조하는 경우 파일은 변경 없이 컴파일되지 않습니다.</li><li>Thread.threadId()스레드의 식별자를 반환하는 최종 메서드로 추가됩니다. 기존 소스 파일의 코드가 확장되고<br>Thread하위 클래스가 매개 변수 없이 명명된 메서드를 선언하면 threadId컴파일되지 않습니다.<br>확장하는 기존 컴파일된 코드가 있고 하위 클래스가 반환 유형이 있고 매개 변수가 없는 Thread이름의 메서드를 정의하는 경우<br>하위 클래스가 로드되면 런타임에 throw됩니다.threadIdlongIncompatibleClassChangeError</li></ul><p>가상 스레드 또는 새 API를 활용하는 최신 코드와 기존 코드를 혼합할 때 플랫폼 스레드와 가상 스레드 간의 몇 가지 동작 차이가 관찰될 수 있습니다.</p><ul><li><p>이 Thread.setPriority(int)방법은 항상 우선 순위가 있는 가상 스레드에 영향을 주지 않습니다 Thread.NORM_PRIORITY.</p></li><li><p>이 Thread.setDaemon(boolean)메서드는 항상 데몬 스레드인 가상 스레드에 영향을 주지 않습니다.</p></li><li><p>스레드 . stop(), suspend()및 메서드는 가상 스레드에서 호출될 때 resume()발생합니다 .UnsupportedOperationException</p></li><li><p>API Thread는 스레드 로컬 변수를 지원하지 않는 스레드 생성을 지원합니다.<br>스레드 로컬을 지원하지 않는 스레드 컨텍스트에서 호출될 때 ThreadLocal.set(T)throw Thread.setContextClassLoader(ClassLoader)합니다<br>.UnsupportedOperationException</p></li><li><p>Thread.getAllStackTraces()이제 모든 스레드의 맵이 아닌 모든 플랫폼 스레드의 맵을 반환합니다.</p></li><li><p>java.net.Socket, ServerSocket및 에 의해 정의된 차단 I&#x2F;O 메서드는 DatagramSocket이제 가상 스레드 컨텍스트에서 호출될 때 인터럽트할 수 있습니다.<br>기존 코드는 소켓 작업에서 차단된 스레드가 중단되어 스레드를 깨우고 소켓을 닫을 때 중단될 수 있습니다.</p></li><li><p>가상 스레드는 의 활성 구성원이 아닙니다 ThreadGroup. Thread.getThreadGroup()가상 스레드에서 호출하면 “VirtualThreads” 비어 있는 더미 그룹이 반환됩니다.</p></li><li><p>가상 스레드는 세트로 실행할 때 권한이 없습니다 SecurityManager.</p></li><li><p>JVM TI에서 GetAllThreads및 GetAllStackTraces함수는 가상 스레드를 반환하지 않습니다.<br>ThreadStart및 이벤트를 활성화하는 기존 에이전트는 ThreadEnd 이벤트를 플랫폼 스레드로 제한하는 기능이 없기 때문에 성능 문제가 발생할 수 있습니다.</p></li><li><p>API java.lang.management.ThreadMXBean는 플랫폼 스레드의 모니터링 및 관리를 지원하지만 가상 스레드는 지원하지 않습니다.</p></li><li><p>플래그 -XX:+PreserveFramePointer는 가상 스레드 성능에 크게 부정적인 영향을 미칩니다.</p></li></ul><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><ul><li><p>JDK 18의 JEP 416(Reimplement Core Reflection with Method Handles)은 VM 네이티브 리플렉션 구현을 제거했습니다.<br>이렇게 하면 메서드가 반사적으로 호출될 때 가상 스레드가 정상적으로 주차할 수 있습니다.</p></li><li><p>JDK 13의 JEP 353(레거시 소켓 API 재구현) 및 JDK 15의 JEP 373(레거시 DatagramSocket API 재구현)은java.net.Socket , ServerSocket및 의<br>구현을 DatagramSocket가상 스레드와 함께 사용하도록 설계된 새 구현으로 대체했습니다.</p></li><li><p>JDK 18의 JEP 418(Internet-Address Resolution SPI)은 호스트 이름 및 주소 조회를 위한 서비스 공급자 인터페이스를 정의했습니다.<br>이렇게 하면 타사 라이브러리가 java.net.InetAddress호스트 조회 중에 스레드를 고정하지 않는 대체 해결 프로그램을 구현할 수 있습니다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://openjdk.java.net/jeps/425">JEP_425</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/04/2023-04-13-JEP_425/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
