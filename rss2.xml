<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Fri, 05 Jan 2024 04:21:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>3장. 단위 테스트 구조</title>
      <link>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</guid>
      <pubDate>Fri, 05 Jan 2024 01:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;3장-단위-테스트-구조&quot;&gt;&lt;a href=&quot;#3장-단위-테스트-구조&quot; class=&quot;headerlink&quot; title=&quot;3장. 단위 테스트 구조&quot;&gt;&lt;/a&gt;3장. 단위 테스트 구조&lt;/h1&gt;&lt;h2 id=&quot;단위-테스트를-구성하는-방법&quot;&gt;&lt;a hre
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="3장-단위-테스트-구조"><a href="#3장-단위-테스트-구조" class="headerlink" title="3장. 단위 테스트 구조"></a>3장. 단위 테스트 구조</h1><h2 id="단위-테스트를-구성하는-방법"><a href="#단위-테스트를-구성하는-방법" class="headerlink" title="단위 테스트를 구성하는 방법"></a>단위 테스트를 구성하는 방법</h2><h3 id="AAA-arrange-act-assert-패턴-사용"><a href="#AAA-arrange-act-assert-패턴-사용" class="headerlink" title="AAA(arrange act assert) 패턴 사용"></a>AAA(arrange act assert) 패턴 사용</h3><p>3A 패턴은 테스트를 준비(arrange), 실행(act), 검증(assert) 세 단계로 나누는 것을 의미한다.</p><p>AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는데 도움이 된다</p><p>일관성이 이 패턴의 가장 큰 장점 중 하나다</p><p>Given-When-Then 패턴</p><ul><li>Given: 테스트를 위한 사전 조건을 설정한다</li><li>When: 테스트를 수행한다</li><li>Then: 테스트 결과를 검증한다</li></ul><h3 id="여러-개의-준비-실행-검증-구절-피하기"><a href="#여러-개의-준비-실행-검증-구절-피하기" class="headerlink" title="여러 개의 준비, 실행, 검증 구절 피하기"></a>여러 개의 준비, 실행, 검증 구절 피하기</h3><p>여러 개의 준비 실행 검증 구절은 테스트가 너무 많은 것을 한 번에 검증한다는 의미다</p><p>검증 구절로 구분된 여러 개의 실행 구절을 보면 려러 개의 동작 단위를 검증 하는 테스트를 뜻한다 이건 더 이상 단위 테스트가 아니라 통합 테스트다</p><h3 id="테스트-내-if-문-피하기"><a href="#테스트-내-if-문-피하기" class="headerlink" title="테스트 내 if 문 피하기"></a>테스트 내 if 문 피하기</h3><p>이것도 안티 패턴이다</p><p>이러한 테스트는 반드시 여러 개의 테스트로 분리해야 한다</p><p>테스트에 분기가 있어서 얻는 이점은 없다</p><h3 id="각-구절은-얼마나-커야-하는가"><a href="#각-구절은-얼마나-커야-하는가" class="headerlink" title="각 구절은 얼마나 커야 하는가?"></a>각 구절은 얼마나 커야 하는가?</h3><p>일반적으로 준비 구절이 세 구절 중 가장 크다.<br>실행과 검증을 합친 만큼 클 수도 있다</p><p>그러나 준비 구절이 너무 크면 코드 재사용에 도움이 되는 두가지 패턴으로<br>오브젝트 마더(object mother)와 테스트 데이터 빌더(test data builder)가 있다</p><p>실행 구절은 보통 한 줄이다. 실행 구절이 두줄 이상인 경우는 sut의 공개 API에 문제가 있을수도 있다</p><p>불변 위반(jnvariant violation) 잠재적인 모순으로 부터 코드를 보호 하는 행위를 캡슐화라고 한다</p><h3 id="검증-구절에는-검증문이-얼마나-있어야-하는가"><a href="#검증-구절에는-검증문이-얼마나-있어야-하는가" class="headerlink" title="검증 구절에는 검증문이 얼마나 있어야 하는가"></a>검증 구절에는 검증문이 얼마나 있어야 하는가</h3><p>단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다<br>단일 동작 단위는 여러 결과를 낼 수 있으며 하나의 테스트로 모든 결과를 평가하는것이 좋다</p><h3 id="종료-단계는-어떤가"><a href="#종료-단계는-어떤가" class="headerlink" title="종료 단계는 어떤가"></a>종료 단계는 어떤가</h3><p>준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다</p><p>AAA 패턴에는 이 단계를 포함하지 않는다</p><p>종료는 통합 테스트의 영역이다</p><h3 id="테스트-대상-시스템-구별하기"><a href="#테스트-대상-시스템-구별하기" class="headerlink" title="테스트 대상 시스템 구별하기"></a>테스트 대상 시스템 구별하기</h3><p>SUT(System Under Test) 테스트에서 중요한 역할을 하는데 애플리케이션을 호출하고자 하는 동작에 대한 진입점을 제공한다</p><p>SUT와 의존성과 구분하는 것이 중요하다</p><h3 id="준비-실행-검증-주석-제거하기"><a href="#준비-실행-검증-주석-제거하기" class="headerlink" title="준비, 실행, 검증 주석 제거하기"></a>준비, 실행, 검증 주석 제거하기</h3><p>의존성에서 SUT를 떼어내는 것이 중요하듯이 주석으로 하는것 보다 빈 줄로 구절을 구분한다</p><ul><li>AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라</li><li>그렇지 않으면 구절 주석을 유지하라</li></ul><h2 id="테스트-간-테스트-픽스처-재사용"><a href="#테스트-간-테스트-픽스처-재사용" class="headerlink" title="테스트 간 테스트 픽스처 재사용"></a>테스트 간 테스트 픽스처 재사용</h2><p>테스트 픽처스</p><ul><li>테스트 픽스처는 테스트 실행 대상 객체이다</li><li>NUnit에서 [TestFixture] 특성을 사용하여 테스트가 포함된 클래스를 표시한다</li></ul><p>준비 구절을 생성자로 추출 할때 단점</p><ul><li>테스트 간 결합도가 높아진다</li><li>테스트 가독성이 떨어진다</li></ul><h3 id="테스트-간의-높은-결합도는-안티-패턴이다"><a href="#테스트-간의-높은-결합도는-안티-패턴이다" class="headerlink" title="테스트 간의 높은 결합도는 안티 패턴이다"></a>테스트 간의 높은 결합도는 안티 패턴이다</h3><p>테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다.</p><h3 id="테스트-가독성을-떨어뜨리는-생성자-사용"><a href="#테스트-가독성을-떨어뜨리는-생성자-사용" class="headerlink" title="테스트 가독성을 떨어뜨리는 생성자 사용"></a>테스트 가독성을 떨어뜨리는 생성자 사용</h3><p>준비 코드를 생성자로 추출할 때 테스트 가독성을 떨어뜨린다</p><h3 id="더-나은-테스트-픽스처-재사용법"><a href="#더-나은-테스트-픽스처-재사용법" class="headerlink" title="더 나은 테스트 픽스처 재사용법"></a>더 나은 테스트 픽스처 재사용법</h3><p>테스트 픽스처를 재사용할때 생성자 사용이 최선의 방법은 아니다</p><ul><li>비공개 팩토리 매서드를 두는것도 하나의 방법이다</li><li>기초 클래스 내 공통 초기화 코드를 두는법</li></ul><h2 id="단위-테스트-명명법"><a href="#단위-테스트-명명법" class="headerlink" title="단위 테스트 명명법"></a>단위 테스트 명명법</h2><p>가장 도움 되지 않는 명명법</p><p>[테스트 대상]<em>[시나리오]</em>[예상 결과]</p><ul><li>테스트 대상 메서드 : 테스트 중인 메서드의 이름</li><li>시나리오 : 메서드를 테스트하는 조건</li><li>현재 시나리오에서 테스트 대상 메서드에 기대하는 것</li></ul><p>프로그래머가 아닌 사람들에게 이름을 어떻게 생각하는지 중요하지 않다고 말할 수 있다 테스트는 프로그래머를 위한것이라서 그렇게 생각한다</p><h3 id="단위-테스트-명명-지침"><a href="#단위-테스트-명명-지침" class="headerlink" title="단위 테스트 명명 지침"></a>단위 테스트 명명 지침</h3><ul><li>엄격한 명명 정책을 따르지 않는다</li><li>문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자</li><li>단어를 밑줄 표시(_)로 구분한다</li></ul><h3 id="예제-지침에-따른-테스트-이름-변경"><a href="#예제-지침에-따른-테스트-이름-변경" class="headerlink" title="예제: 지침에 따른 테스트 이름 변경"></a>예제: 지침에 따른 테스트 이름 변경</h3><p>테스트 이름에 SYUT(System Under Test)에 메서드 이름을 포함하지 말라</p><h2 id="매개변수화된-테스트-리팩터링하기"><a href="#매개변수화된-테스트-리팩터링하기" class="headerlink" title="매개변수화된 테스트 리팩터링하기"></a>매개변수화된 테스트 리팩터링하기</h2><p>동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말라</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장. 단위 테스트란 무엇인가</title>
      <link>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</guid>
      <pubDate>Thu, 04 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;2장-단위-테스트란-무엇인가&quot;&gt;&lt;a href=&quot;#2장-단위-테스트란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;2장. 단위 테스트란 무엇인가&quot;&gt;&lt;/a&gt;2장. 단위 테스트란 무엇인가&lt;/h1&gt;&lt;p&gt;고전파(classical sc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="2장-단위-테스트란-무엇인가"><a href="#2장-단위-테스트란-무엇인가" class="headerlink" title="2장. 단위 테스트란 무엇인가"></a>2장. 단위 테스트란 무엇인가</h1><p>고전파(classical school)는 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식</p><p>런던파(London school)는 단위 테스트와 테스트 주도 개발에 실용적으로 접근하는 방식</p><h2 id="‘단위-테스트’의-정의"><a href="#‘단위-테스트’의-정의" class="headerlink" title="‘단위 테스트’의 정의"></a>‘단위 테스트’의 정의</h2><p>단위 테스트의 속성</p><ul><li>작은 코드 조각을 검증하고</li><li>빠르게 수행하고</li><li>격리된 방식으로 처리하는 자동화된 테스트다</li></ul><p>세번째에서 논란의 여지가 있는데 격리된 방식에 차이가 런던파와 고전파의 차이다.</p><h3 id="격리-문제에-대한-런던파의-접근"><a href="#격리-문제에-대한-런던파의-접근" class="headerlink" title="격리 문제에 대한 런던파의 접근"></a>격리 문제에 대한 런던파의 접근</h3><p>테스트 대상 시스템을 협력자에게서 격리하는 것을 말한다. 즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 된다</p><p>장점</p><ul><li>단위 테스트를 의존성과 별개로 수행할수 있다</li><li>테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알수 있다</li><li>객체 그래프를 분할할 수 있다</li></ul><h3 id="격리-문제에-대한-고전파의-접근"><a href="#격리-문제에-대한-고전파의-접근" class="headerlink" title="격리 문제에 대한 고전파의 접근"></a>격리 문제에 대한 고전파의 접근</h3><p>테스트는 서로 격리해서 실행해야 한다</p><ul><li>공유 의존성(shared dependency) : 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성</li><li>비공개 의존성(private dependency) : 공유하지 않은 의존성</li><li>프로세스 외부 의존성(out of process dependency) : 애플리케이션 실행 프로세스 외부에서 실행되는 의존성</li></ul><p>결리 문제에 대한 이러한 해석에는 목과 기타 테스트 대역을 적당히 쓰려는 견해가 있다</p><p>공유의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다<br>테스트 실행 속도를 높이기 의해 공유의존성을 대체한다</p><h2 id="단위-테스트의-런던파와-고전파"><a href="#단위-테스트의-런던파와-고전파" class="headerlink" title="단위 테스트의 런던파와 고전파"></a>단위 테스트의 런던파와 고전파</h2><table><thead><tr><th></th><th>격리주체</th><th>단위의 크기</th><th>테스트 대역 사용 대상</th></tr></thead><tbody><tr><td>런던파</td><td>단위</td><td>단일 클래스</td><td>불변의존성 외 모든 의존성</td></tr><tr><td>고전파</td><td>단위테스트</td><td>단일 클래스 또는 클래스 세트</td><td>공유 의존성</td></tr></tbody></table><h3 id="고전파와-런던파가-의존성을-다루는-방법"><a href="#고전파와-런던파가-의존성을-다루는-방법" class="headerlink" title="고전파와 런던파가 의존성을 다루는 방법"></a>고전파와 런던파가 의존성을 다루는 방법</h3><p>테스트 대역을 어디에서나 흔히 사용할수 있지만 런던파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 하고 있다</p><ul><li>협력자(collaborator) : 공유하거나 변경 가능한 의존성</li><li>의존성 : 일반적인 클래스는 두가지 유형의 의존성으로 동작한다 협력자, 값</li></ul><h2 id="고전파와-런던파-비교"><a href="#고전파와-런던파-비교" class="headerlink" title="고전파와 런던파 비교"></a>고전파와 런던파 비교</h2><p>코전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다</p><p>런던파의 장점</p><ul><li>입자성이 좋다. 테스트가 세밀해서 한번에 한 클래스만 확인한다</li><li>서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다</li><li>테스트가 실패하면 어떤 기능이 실패했는지 확실히 알수 있다</li></ul><h3 id="한-번에-한-클래스만-테스트하기"><a href="#한-번에-한-클래스만-테스트하기" class="headerlink" title="한 번에 한 클래스만 테스트하기"></a>한 번에 한 클래스만 테스트하기</h3><p>좋은 입자성이란 단위 테스트에서 단위를 구성하는 것에 대한 논쟁</p><p>런던파는 클래스를 단위로 간주한다 </p><h3 id="상호-연결된-클래스의-큰-그래프를-단위-테스트하기"><a href="#상호-연결된-클래스의-큰-그래프를-단위-테스트하기" class="headerlink" title="상호 연결된 클래스의 큰 그래프를 단위 테스트하기"></a>상호 연결된 클래스의 큰 그래프를 단위 테스트하기</h3><p>실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.<br>상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다.<br>대개 클래스 그래프가 커진 것은 코드 설계 문제이다</p><h3 id="버그-위치-정확히-찾아내기"><a href="#버그-위치-정확히-찾아내기" class="headerlink" title="버그 위치 정확히 찾아내기"></a>버그 위치 정확히 찾아내기</h3><p>테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다<br>마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 어렵지 않다</p><p>계단식 실패를 통해 방금 고장 낸 코드 조각이 큰가치가 있다는것을 알게 된다 -&gt; 전체 시스템이 그것에 의존한다</p><h3 id="고전파와-런던파-사이의-다른-차이점"><a href="#고전파와-런던파-사이의-다른-차이점" class="headerlink" title="고전파와 런던파 사이의 다른 차이점"></a>고전파와 런던파 사이의 다른 차이점</h3><p>고전파와 런던파 사이에 남아 있는 두가지 차이점</p><ul><li>테스트 주도 개발을 통한 시스템 설계 방식</li><li>과도한 명세 문제</li></ul><p>런던 스타일의 단위 테스트는 하양식 TDD로 이어지며 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트 부터 시작한다</p><p>고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다</p><h2 id="두-분파의-통합-테스트"><a href="#두-분파의-통합-테스트" class="headerlink" title="두 분파의 통합 테스트"></a>두 분파의 통합 테스트</h2><p>런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다</p><p>고전 스타일로 작성된 대부분의 테스트는 런던파에게 통합테스트로 느껴질 것이다</p><h3 id="통합-테스트의-일부인-엔드-투-엔드-테스트"><a href="#통합-테스트의-일부인-엔드-투-엔드-테스트" class="headerlink" title="통합 테스트의 일부인 엔드 투 엔드 테스트"></a>통합 테스트의 일부인 엔드 투 엔드 테스트</h3><p>엔드투 앤드 테스트는 통합 테스트의 일부이다</p><p>엔드투 앤드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과후 빌드 프로세스 후반에 실행하는 것이 좋다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장. 단위 테스트 목표</title>
      <link>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</guid>
      <pubDate>Wed, 03 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1장-단위-테스트-목표&quot;&gt;&lt;a href=&quot;#1장-단위-테스트-목표&quot; class=&quot;headerlink&quot; title=&quot;1장. 단위 테스트 목표&quot;&gt;&lt;/a&gt;1장. 단위 테스트 목표&lt;/h1&gt;&lt;p&gt;단위 테스트를 배우는 것은 테스트 프레임워크나 목 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1장-단위-테스트-목표"><a href="#1장-단위-테스트-목표" class="headerlink" title="1장. 단위 테스트 목표"></a>1장. 단위 테스트 목표</h1><p>단위 테스트를 배우는 것은 테스트 프레임워크나 목 라이브러리등과 같은 기술적인 부분을 익히는 것에 그치지 않는다</p><p>단위 테스트를 매우 많이 작성하더라도 많은 버그와 유지비로 프로젝트 진행이 느려지게 된다</p><h2 id="단위-테스트-현황"><a href="#단위-테스트-현황" class="headerlink" title="단위 테스트 현황"></a>단위 테스트 현황</h2><p>대부분의 프로그래머는 단위 테스트를 실천하고 중요성을 알고 있다</p><p>보통 제품코드와 테스트 코드의 비율은 1:1에서 1:3 정도 된다</p><p>좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제이다</p><h2 id="단위-테스트-목표"><a href="#단위-테스트-목표" class="headerlink" title="단위 테스트 목표"></a>단위 테스트 목표</h2><p>단위 테스트와 코드 설계의 관계</p><ul><li>코드 조각을 단위 테스트하는 것은 훌륭한 리스머스 시험이지만 한 방향으로 작동한다</li></ul><p>단위 테스트의 목표는? -&gt; 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것 이다</p><p>개발속도가 빠르게 감소하는 현상을 소프트웨어 엔트로피라고 한다</p><h3 id="좋은-테스트와-좋지-않은-테스트를-가르는-요인"><a href="#좋은-테스트와-좋지-않은-테스트를-가르는-요인" class="headerlink" title="좋은 테스트와 좋지 않은 테스트를 가르는 요인"></a>좋은 테스트와 좋지 않은 테스트를 가르는 요인</h3><p>테스트의 가치와 유지비용을 모두 고려해야함 비용요소는 다음과 같은 다양한 활동에 필요한 시간에 따라 결정된다</p><ul><li>기반 코드를 리팩터링할 때 테스트도 리팩터링하라</li><li>각 코드 변경 시 테스트를 실행하라</li><li>테스트가 잘못된 경고를 발생시킬 경우 처리하라</li><li>기반 코드가 어떻게 동작하는지 이해라려고 할때 테스트를 읽는 시간에 투자하라</li></ul><p>제품 코드 대 테스트 코드</p><ul><li>코드는 자산이 아니라 책임이다</li><li>테스트도 역시 코드다 다른 코드와 마찬가지로 유지보수가 필요하다</li></ul><h2 id="테스트-스위트-품질-측정을-위한-커버리지-지표"><a href="#테스트-스위트-품질-측정을-위한-커버리지-지표" class="headerlink" title="테스트 스위트 품질 측정을 위한 커버리지 지표"></a>테스트 스위트 품질 측정을 위한 커버리지 지표</h2><ul><li>코드 커버리지</li><li>분기 커버리지</li></ul><p>커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다</p><h3 id="코드-커버리지-지표에-대한-이해"><a href="#코드-커버리지-지표에-대한-이해" class="headerlink" title="코드 커버리지 지표에 대한 이해"></a>코드 커버리지 지표에 대한 이해</h3><p>가장 많이 사용되는 커버리지 지표로 코드 커버리지가 있으며 테스트 커버리지로도 알려져 있다</p><p>코드가 작을수록 커버리지 지표는 더 좋아지는데 이는 원래 라인 수만 처리해서이다</p><p>코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지보수성이 변경되지 않는다</p><h3 id="분기-커버리지-지표에-대한-이해"><a href="#분기-커버리지-지표에-대한-이해" class="headerlink" title="분기 커버리지 지표에 대한 이해"></a>분기 커버리지 지표에 대한 이해</h3><p>분기 커버리지는 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조의 수를 나타낸다</p><h3 id="커버리지-지표에-관한-문제점"><a href="#커버리지-지표에-관한-문제점" class="headerlink" title="커버리지 지표에 관한 문제점"></a>커버리지 지표에 관한 문제점</h3><p>테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유</p><ul><li>테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다</li><li>외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다</li></ul><p>단위 테스트에는 반드시 적잘한 검증이 있어야 된다</p><p>정수 타입으로 변환할수 없는 몇가지 가능한 인수</p><ul><li>널 값</li><li>빈 문자열</li><li>정수가 아님</li><li>너무 긴 문자열</li></ul><h3 id="특정-커버리지-숫자를-목표로-하기"><a href="#특정-커버리지-숫자를-목표로-하기" class="headerlink" title="특정 커버리지 숫자를 목표로 하기"></a>특정 커버리지 숫자를 목표로 하기</h3><p>커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안된다</p><p>커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다</p><h2 id="무엇이-성공적인-테스트-스위트를-만드는가"><a href="#무엇이-성공적인-테스트-스위트를-만드는가" class="headerlink" title="무엇이 성공적인 테스트 스위트를 만드는가?"></a>무엇이 성공적인 테스트 스위트를 만드는가?</h2><p>테스트 스위트의 품질은 어떻게 측정해야 하는가? 믿을만한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는것 뿐이다</p><p>성공적인 테스트 스위트의 특성</p><ul><li>개발 주기에 통합돼 있다<ul><li>자동화된 테스트를 할수 있는 방법은 끊임없이 하는것 뿐</li></ul></li><li>코드베이스에서 가장 중요한 부분만을 대상으로 한다<ul><li>비지니스 로직이 아닌 부분<ul><li>인프라 코드</li><li>데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성</li><li>모든 것을 하나로 묶는 코드</li></ul></li></ul></li><li>최소한의 유지비로 최대의 가치를 끌어낸다<ul><li>가치 있는 테스트 식별하기</li><li>가치 있는 테스트 작성하기</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>13장: 나쁜 코드를 식별 가능하게 만들기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</guid>
      <pubDate>Tue, 02 Jan 2024 05:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;13장-나쁜-코드를-식별-가능하게-만들기&quot;&gt;&lt;a href=&quot;#13장-나쁜-코드를-식별-가능하게-만들기&quot; class=&quot;headerlink&quot; title=&quot;13장: 나쁜 코드를 식별 가능하게 만들기&quot;&gt;&lt;/a&gt;13장: 나쁜 코드를 식별 가능하게
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="13장-나쁜-코드를-식별-가능하게-만들기"><a href="#13장-나쁜-코드를-식별-가능하게-만들기" class="headerlink" title="13장: 나쁜 코드를 식별 가능하게 만들기"></a>13장: 나쁜 코드를 식별 가능하게 만들기</h1><p>나쁜 코드를 딱 봐도 않좋아 보이게 만들어 품질의 수준을 명확히 표시하는 방법 -&gt; 안티 리팩터링</p><h2 id="나쁜-코드에-대처하는-자세"><a href="#나쁜-코드에-대처하는-자세" class="headerlink" title="나쁜 코드에 대처하는 자세"></a>나쁜 코드에 대처하는 자세</h2><p>코드를 원하는 수준으로 리팩터링하지 못할 때가 많다 이런 상황에서 끔찍하지만 않게 약깐의 리팩터링을 수행하기도 한다 하지만 이렇게 하는것은 실수다</p><p>나쁜 코드를 남겨둘때 장점</p><ul><li>다시 찾기가 쉽다</li><li>통제가 지속 가능하지 않다는 신호를 준다</li></ul><h2 id="깨끗한-코드와-레거시-코드로-분리"><a href="#깨끗한-코드와-레거시-코드로-분리" class="headerlink" title="깨끗한 코드와 레거시 코드로 분리"></a>깨끗한 코드와 레거시 코드로 분리</h2><p>잘 만들수 없으면 눈에 띄게 만들어야 된다</p><h3 id="깨진-유리창-이론"><a href="#깨진-유리창-이론" class="headerlink" title="깨진 유리창 이론"></a>깨진 유리창 이론</h3><p>유리창이 하나가 깨지고 나면 곧 더 많은 유리창이 깨진다. 논란의 여지는 있지만 최소한 은유적인 가치는 있다</p><h2 id="나쁜-코드를-찾는-방법"><a href="#나쁜-코드를-찾는-방법" class="headerlink" title="나쁜 코드를 찾는 방법"></a>나쁜 코드를 찾는 방법</h2><h3 id="이-책의-규칙-단순하고-구체적인-코드"><a href="#이-책의-규칙-단순하고-구체적인-코드" class="headerlink" title="이 책의 규칙: 단순하고 구체적인 코드"></a>이 책의 규칙: 단순하고 구체적인 코드</h3><h3 id="코드-스멜-완전하고-추상적인-코드"><a href="#코드-스멜-완전하고-추상적인-코드" class="headerlink" title="코드 스멜: 완전하고 추상적인 코드"></a>코드 스멜: 완전하고 추상적인 코드</h3><h3 id="순환-복잡도-알고리즘-객관적"><a href="#순환-복잡도-알고리즘-객관적" class="headerlink" title="순환 복잡도: 알고리즘(객관적)"></a>순환 복잡도: 알고리즘(객관적)</h3><h3 id="인지-복잡도-알고리즘-주관적"><a href="#인지-복잡도-알고리즘-주관적" class="headerlink" title="인지 복잡도: 알고리즘(주관적)"></a>인지 복잡도: 알고리즘(주관적)</h3><h2 id="코드를-안전하게-나쁜-코드로-보이기-위한-규칙"><a href="#코드를-안전하게-나쁜-코드로-보이기-위한-규칙" class="headerlink" title="코드를 안전하게 나쁜 코드로 보이기 위한 규칙"></a>코드를 안전하게 나쁜 코드로 보이기 위한 규칙</h2><ul><li>올바른 정보를 절대 훼손하지 말 것</li><li>향후 리팩터링을 어렵게 만들지 말 것 </li><li>결과를 한눈에 알 수 있을 것</li></ul><h2 id="나쁜-코드를-나쁘게-보이기-위한-방법"><a href="#나쁜-코드를-나쁘게-보이기-위한-방법" class="headerlink" title="나쁜 코드를 나쁘게 보이기 위한 방법"></a>나쁜 코드를 나쁘게 보이기 위한 방법</h2><p>안전과 가역성은 필수요소</p><h3 id="열거형-사용"><a href="#열거형-사용" class="headerlink" title="열거형 사용"></a>열거형 사용</h3><h3 id="정수형-및-문자열을-타입-코드로-사용"><a href="#정수형-및-문자열을-타입-코드로-사용" class="headerlink" title="정수형 및 문자열을 타입 코드로 사용"></a>정수형 및 문자열을 타입 코드로 사용</h3><h3 id="코드에-매직-넘버-넣기"><a href="#코드에-매직-넘버-넣기" class="headerlink" title="코드에 매직 넘버 넣기"></a>코드에 매직 넘버 넣기</h3><h3 id="코드에-주석-넣기"><a href="#코드에-주석-넣기" class="headerlink" title="코드에 주석 넣기"></a>코드에 주석 넣기</h3><h3 id="코드에-공백-넣기"><a href="#코드에-공백-넣기" class="headerlink" title="코드에 공백 넣기"></a>코드에 공백 넣기</h3><h3 id="이름을-기준으로-항목을-그룹화하기"><a href="#이름을-기준으로-항목을-그룹화하기" class="headerlink" title="이름을 기준으로 항목을 그룹화하기"></a>이름을 기준으로 항목을 그룹화하기</h3><h3 id="이름에-컨텍스트-추가하기"><a href="#이름에-컨텍스트-추가하기" class="headerlink" title="이름에 컨텍스트 추가하기"></a>이름에 컨텍스트 추가하기</h3><h3 id="긴-메서드-만들기"><a href="#긴-메서드-만들기" class="headerlink" title="긴 메서드 만들기"></a>긴 메서드 만들기</h3><h3 id="메서드에-많은-매개변수-넘기기"><a href="#메서드에-많은-매개변수-넘기기" class="headerlink" title="메서드에 많은 매개변수 넘기기"></a>메서드에 많은 매개변수 넘기기</h3><h3 id="getter와-setter-사용하기"><a href="#getter와-setter-사용하기" class="headerlink" title="getter와 setter 사용하기"></a>getter와 setter 사용하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>12장: 최적화 및 일반화 회피</title>
      <link>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/</guid>
      <pubDate>Tue, 02 Jan 2024 00:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;12장-최적화-및-일반화-회피&quot;&gt;&lt;a href=&quot;#12장-최적화-및-일반화-회피&quot; class=&quot;headerlink&quot; title=&quot;12장: 최적화 및 일반화 회피&quot;&gt;&lt;/a&gt;12장: 최적화 및 일반화 회피&lt;/h1&gt;&lt;p&gt;성능 최적화와 일반화는
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="12장-최적화-및-일반화-회피"><a href="#12장-최적화-및-일반화-회피" class="headerlink" title="12장: 최적화 및 일반화 회피"></a>12장: 최적화 및 일반화 회피</h1><p>성능 최적화와 일반화는 프로그래머가 하는 두가지 게임으로 도움이 되기보다 큰 상처를 입히는 경우가 많다</p><p>일반화 해야 되는것은 컨텍스트뿐</p><h2 id="단순성-추구"><a href="#단순성-추구" class="headerlink" title="단순성 추구"></a>단순성 추구</h2><p>단순함을 추구하는것은 소프트웨어 개발의 이상 중 하나</p><p>인간의 인지능력은 제한적이기 때문에 단순함이 필수</p><p>불변속성을 활용하는 최적화</p><p>단순함을 희생할때는 부작용을 최소화하기 위해 예방 조치를 취해야 된다</p><h2 id="일반화의-시기와-방법"><a href="#일반화의-시기와-방법" class="headerlink" title="일반화의 시기와 방법"></a>일반화의 시기와 방법</h2><p>매서드나 클래스를 일반화를 추가하기 전에 그렇게 해야 하는 이유가 있어야 된다</p><h3 id="구현의-최소화로-일반화-지양하기"><a href="#구현의-최소화로-일반화-지양하기" class="headerlink" title="구현의 최소화로 일반화 지양하기"></a>구현의 최소화로 일반화 지양하기</h3><p>하지 않는 일의 양을 최대화 하라</p><p>무언가 만들때는 먼저 컨텍스트, 구현하려는 동작의 범위를 이해해야 한다</p><p>소프트웨어가 발전함에 따라 요구사항이 변경되므로 불필요한 일반화를 구현하고 유지하는데 드는 노력이 쉽게 무효화된다</p><h3 id="안정성이-유사한-것-통합하기"><a href="#안정성이-유사한-것-통합하기" class="headerlink" title="안정성이 유사한 것 통합하기"></a>안정성이 유사한 것 통합하기</h3><p>새로운것과 오래된것을 바로 통합하지 않는것이 좋다 대신 통합 대상이 비슷한 안정성에 도달하면 통합하자</p><h3 id="불필요한-일반화-제거"><a href="#불필요한-일반화-제거" class="headerlink" title="불필요한 일반화 제거"></a>불필요한 일반화 제거</h3><p>함수에 전달된 런터임 인자들을 모니터링해서 매서드 전문화를 적용할수 있다</p><h2 id="최적화-시기와-방법"><a href="#최적화-시기와-방법" class="headerlink" title="최적화 시기와 방법"></a>최적화 시기와 방법</h2><p>자동 성능 테스트를 설정하고 테스트가 실패할 때만 최적화를 하는 것이 좋다</p><h3 id="최적화-전-리팩터링"><a href="#최적화-전-리팩터링" class="headerlink" title="최적화 전 리팩터링"></a>최적화 전 리팩터링</h3><p>첫번째 단계는 코드가 적절하게 리팩터링되었는지 확인하는것이다</p><h3 id="제약-이론에-따른-최적화"><a href="#제약-이론에-따른-최적화" class="headerlink" title="제약 이론에 따른 최적화"></a>제약 이론에 따른 최적화</h3><p>제약이론이 적용됨 - 리소스 풀링 기법</p><h3 id="측정-지표를-사용한-최적화"><a href="#측정-지표를-사용한-최적화" class="headerlink" title="측정 지표를 사용한 최적화"></a>측정 지표를 사용한 최적화</h3><p>코드에서 핫스팟을 식별해야 된다</p><h3 id="좋은-알고리즘과-데이터-구조-선택하기"><a href="#좋은-알고리즘과-데이터-구조-선택하기" class="headerlink" title="좋은 알고리즘과 데이터 구조 선택하기"></a>좋은 알고리즘과 데이터 구조 선택하기</h3><p>데이터 구조를 지역적으로 변환함으로써 이익을 얻을수 있다</p><h3 id="캐시-사용하기"><a href="#캐시-사용하기" class="headerlink" title="캐시 사용하기"></a>캐시 사용하기</h3><p>캐시는 멱등 불변속성과 조합될 때 가장 안전하다</p><h3 id="최적화된-코드-분리하기"><a href="#최적화된-코드-분리하기" class="headerlink" title="최적화된 코드 분리하기"></a>최적화된 코드 분리하기</h3><ul><li>잠금 영역 최소화를 위한 메서드와 클래스 사용</li><li>향후 개발자들에게 알리기 위한 패키지 사용</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장: 코드 구조 따르기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</guid>
      <pubDate>Fri, 29 Dec 2023 00:56:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-코드-구조-따르기&quot;&gt;&lt;a href=&quot;#11장-코드-구조-따르기&quot; class=&quot;headerlink&quot; title=&quot;11장: 코드 구조 따르기&quot;&gt;&lt;/a&gt;11장: 코드 구조 따르기&lt;/h1&gt;&lt;p&gt;소프트웨어는 현실 세계의 한 측면에 대한 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-코드-구조-따르기"><a href="#11장-코드-구조-따르기" class="headerlink" title="11장: 코드 구조 따르기"></a>11장: 코드 구조 따르기</h1><p>소프트웨어는 현실 세계의 한 측면에 대한 모델 입니다</p><h2 id="범위와-출처에-따른-구조-분류"><a href="#범위와-출처에-따른-구조-분류" class="headerlink" title="범위와 출처에 따른 구조 분류"></a>범위와 출처에 따른 구조 분류</h2><p>구조의 분류를 4가지로 나눈다 </p><ul><li>딤간</li><li>팀내</li><li>코드에 있는 경우</li><li>사람에 있는 경우</li></ul><p>매크로 아키텍처는 팀 간 구조에 관한 것<br>마이크로 아키텍처는 팀 내 구조에 관한것</p><p>조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있다 - 콘웨이 법칙</p><h2 id="행위를-코드화하는-세-가지-방법"><a href="#행위를-코드화하는-세-가지-방법" class="headerlink" title="행위를 코드화하는 세 가지 방법"></a>행위를 코드화하는 세 가지 방법</h2><ul><li>제어 흐름</li><li>데이터 구조</li><li>데이터</li></ul><h3 id="데이터에-행위-코드화하기"><a href="#데이터에-행위-코드화하기" class="headerlink" title="데이터에 행위 코드화하기"></a>데이터에 행위 코드화하기</h3><p>코드를 캡슐화해야 하지만 변경점을 노출 하지 않아야 한다</p><h2 id="구조-노출을-위한-코드-추가"><a href="#구조-노출을-위한-코드-추가" class="headerlink" title="구조 노출을 위한 코드 추가"></a>구조 노출을 위한 코드 추가</h2><h2 id="예측-대신-관찰-그리고-경험적-기술-사용"><a href="#예측-대신-관찰-그리고-경험적-기술-사용" class="headerlink" title="예측 대신 관찰, 그리고 경험적 기술 사용"></a>예측 대신 관찰, 그리고 경험적 기술 사용</h2><ul><li>변경되지 않으면 아무것도 하지 말아라</li><li>예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리팩터링 해라</li><li>그렇지 않으면 과거에 발생한 변경 유형을 적용해 리팩터링 해라</li></ul><h2 id="코드를-이해하지-않고도-안전성을-확보하는-방안"><a href="#코드를-이해하지-않고도-안전성을-확보하는-방안" class="headerlink" title="코드를 이해하지 않고도 안전성을 확보하는 방안"></a>코드를 이해하지 않고도 안전성을 확보하는 방안</h2><h3 id="테스트를-통한-안전성-확보"><a href="#테스트를-통한-안전성-확보" class="headerlink" title="테스트를 통한 안전성 확보"></a>테스트를 통한 안전성 확보</h3><h3 id="숙달을-통한-안전성-확보"><a href="#숙달을-통한-안전성-확보" class="headerlink" title="숙달을 통한 안전성 확보"></a>숙달을 통한 안전성 확보</h3><h3 id="도구의-지원을-통한-안전성-확보"><a href="#도구의-지원을-통한-안전성-확보" class="headerlink" title="도구의 지원을 통한 안전성 확보"></a>도구의 지원을 통한 안전성 확보</h3><h3 id="공식-인증을-통한-안전성-확보"><a href="#공식-인증을-통한-안전성-확보" class="headerlink" title="공식 인증을 통한 안전성 확보"></a>공식 인증을 통한 안전성 확보</h3><h3 id="내결함성을-통한-안전성-확보"><a href="#내결함성을-통한-안전성-확보" class="headerlink" title="내결함성을 통한 안전성 확보"></a>내결함성을 통한 안전성 확보</h3><h2 id="활용되지-않은-구조-이용"><a href="#활용되지-않은-구조-이용" class="headerlink" title="활용되지 않은 구조 이용"></a>활용되지 않은 구조 이용</h2><h3 id="추출-및-캡슐화에-공백-활용"><a href="#추출-및-캡슐화에-공백-활용" class="headerlink" title="추출 및 캡슐화에 공백 활용"></a>추출 및 캡슐화에 공백 활용</h3><h3 id="통합에-중복-코드-활용"><a href="#통합에-중복-코드-활용" class="headerlink" title="통합에 중복 코드 활용"></a>통합에 중복 코드 활용</h3><h3 id="캡슐화로-공통-접사-활용"><a href="#캡슐화로-공통-접사-활용" class="headerlink" title="캡슐화로 공통 접사 활용"></a>캡슐화로 공통 접사 활용</h3><h3 id="동적-실행으로-런타임-유형-활용"><a href="#동적-실행으로-런타임-유형-활용" class="headerlink" title="동적 실행으로 런타임 유형 활용"></a>동적 실행으로 런타임 유형 활용</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장: 코드 추가에 대한 두려움 떨쳐내기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</guid>
      <pubDate>Thu, 28 Dec 2023 06:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-코드-추가에-대한-두려움-떨쳐내기&quot;&gt;&lt;a href=&quot;#10장-코드-추가에-대한-두려움-떨쳐내기&quot; class=&quot;headerlink&quot; title=&quot;10장: 코드 추가에 대한 두려움 떨쳐내기&quot;&gt;&lt;/a&gt;10장: 코드 추가에 대한 두려움 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-코드-추가에-대한-두려움-떨쳐내기"><a href="#10장-코드-추가에-대한-두려움-떨쳐내기" class="headerlink" title="10장: 코드 추가에 대한 두려움 떨쳐내기"></a>10장: 코드 추가에 대한 두려움 떨쳐내기</h1><p>코드 추가가 두려운 경우는 비현실적인 목표나 코드가 비용을 추가해서이다</p><h2 id="불확실성-받아들이기-위험-감수"><a href="#불확실성-받아들이기-위험-감수" class="headerlink" title="불확실성 받아들이기: 위험 감수"></a>불확실성 받아들이기: 위험 감수</h2><p>겁을 먹으면 효과적으로 일할 수 없다. 지식을 구축하는 가장 효과적인 방법은 실험이지만 거기에는 요기가 필요하다</p><h2 id="두려움-극복을-위한-스파이크-사용"><a href="#두려움-극복을-위한-스파이크-사용" class="headerlink" title="두려움 극복을 위한 스파이크 사용"></a>두려움 극복을 위한 스파이크 사용</h2><p>스파이크는 자신감과 함께 첫 번째 실제버전을 더 좋게 만드는 데 사용할 수 있는 지식을 제공한다</p><p>이해관계자는 제품이 코드나 기능이 아니라 지식이라는 것을 인지할 필요가 있다</p><h2 id="낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정"><a href="#낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정" class="headerlink" title="낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정"></a>낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정</h2><p>비기능적 요구사항에 개발자 시간의 20%를 할당할것</p><h2 id="불완전성에-대한-두려움-극복을-위한-점진적-개선"><a href="#불완전성에-대한-두려움-극복을-위한-점진적-개선" class="headerlink" title="불완전성에 대한 두려움 극복을 위한 점진적 개선"></a>불완전성에 대한 두려움 극복을 위한 점진적 개선</h2><p>가면 증후군은 스스로 자격이 없는 사람으로 간주하여 누군가 자신을 사기꾼으로 폭로할까 봐 두려워하는 것</p><p>개발자의 삶에 맞춘 최적화</p><h2 id="복사-및-붙여넣기가-속도에-미치는-영향"><a href="#복사-및-붙여넣기가-속도에-미치는-영향" class="headerlink" title="복사 및 붙여넣기가 속도에 미치는 영향"></a>복사 및 붙여넣기가 속도에 미치는 영향</h2><p>코드복제시 고려해야할 사항</p><ul><li>코드를 공유하면 코드가 사용되는 모든 위치에 영향을 미치기 쉽다</li><li>전역적인 동작 변경 속도가 높다는 것은 코드의 여러 다른 위치에 동시에 영향을 줄수 있다</li></ul><p>복사된 코드는 완전히 분리되므로 한곳을 위해 다른 곳을 손상시킬 위험이 없기 때문에 실험과 변경이 더 안전 하다</p><h2 id="확장성을-통한-추가에-의한-변경"><a href="#확장성을-통한-추가에-의한-변경" class="headerlink" title="확장성을 통한 추가에 의한 변경"></a>확장성을 통한 추가에 의한 변경</h2><p>코드를 추가하는 또 다른 방법은 확장성을 이용하는것</p><ul><li>우발적 복잡성 : 도메인에 관련 되지 않은 복잡성</li><li>본질적 복잡성 : 도메인으로 부터 상속된 일부 복잡성</li></ul><h2 id="추가에-의한-변경으로-이전-버전과의-호환성-확보"><a href="#추가에-의한-변경으로-이전-버전과의-호환성-확보" class="headerlink" title="추가에 의한 변경으로 이전 버전과의 호환성 확보"></a>추가에 의한 변경으로 이전 버전과의 호환성 확보</h2><p>어떤 버전이 최신 버전인지 쉽게 알 수 있도록 일관된 명명 체계를 사용하는 것이 좋다</p><h2 id="기능-토글-켜기-x2F-끄기-로-추가에-의한-변경"><a href="#기능-토글-켜기-x2F-끄기-로-추가에-의한-변경" class="headerlink" title="기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경"></a>기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경</h2><p>기능 토글의 이면에 있는 개념 : 최소 요구사항은 컴파일이 되어야 된다</p><h2 id="‘추상화를-통한-분기’로-추가에-의한-변경"><a href="#‘추상화를-통한-분기’로-추가에-의한-변경" class="headerlink" title="‘추상화를 통한 분기’로 추가에 의한 변경"></a>‘추상화를 통한 분기’로 추가에 의한 변경</h2><p>클래스로 타입 코드 대체 패턴을 사용해서 추상화를 통한 분기를 사용한다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장: 코드 삭제의 미학</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</guid>
      <pubDate>Thu, 28 Dec 2023 00:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-코드-삭제의-미학&quot;&gt;&lt;a href=&quot;#9장-코드-삭제의-미학&quot; class=&quot;headerlink&quot; title=&quot;9장: 코드 삭제의 미학&quot;&gt;&lt;/a&gt;9장: 코드 삭제의 미학&lt;/h1&gt;&lt;p&gt;시간이나 노력을 들였기 때문에 어떤 것에 가치를 부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-코드-삭제의-미학"><a href="#9장-코드-삭제의-미학" class="headerlink" title="9장: 코드 삭제의 미학"></a>9장: 코드 삭제의 미학</h1><p>시간이나 노력을 들였기 때문에 어떤 것에 가치를 부여하는 것을 메몰 비용의 오류(sunk-cost fallacy)라고 합니다.</p><p>단 한 가지만 말하라면 바로 적은 것이 더 낫다</p><h2 id="다음-시대는-코드를-지우는-시대일-것이다"><a href="#다음-시대는-코드를-지우는-시대일-것이다" class="headerlink" title="다음 시대는 코드를 지우는 시대일 것이다"></a>다음 시대는 코드를 지우는 시대일 것이다</h2><p>우리는 아직 코드 삭제에 익숙하지 않는다 이것이 다음에 해결해야 할 큰 과제 라고 생각한다</p><h2 id="복잡성을-제거하기-위한-코드-삭제"><a href="#복잡성을-제거하기-위한-코드-삭제" class="headerlink" title="복잡성을 제거하기 위한 코드 삭제"></a>복잡성을 제거하기 위한 코드 삭제</h2><p>기능을 추가하고 테스트를 수행하며 다 많은 코너 케이스(복합 경계 조건)을 처리함에 따라 시간이 지날수록 성장하는 것이 바로 시스템 특징</p><ul><li>도메인 복잡성: 도메인이 기본적으로 가지고 있는것</li><li>부수적 복잡성: 도메인이 요구하지 않았지만 우연히 추가된 모든 복잡성</li></ul><h3 id="경험-부족으로-인한-기술적-무지"><a href="#경험-부족으로-인한-기술적-무지" class="headerlink" title="경험 부족으로 인한 기술적 무지"></a>경험 부족으로 인한 기술적 무지</h3><p>기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상된다</p><p>공동 프로그래밍 : 모든 아이디어가 코드에 적용되기 전에 다른 사람의 두뇌를 거쳐야 한다</p><h3 id="시간-압박으로-인한-기술적-낭비"><a href="#시간-압박으로-인한-기술적-낭비" class="headerlink" title="시간 압박으로 인한 기술적 낭비"></a>시간 압박으로 인한 기술적 낭비</h3><p>부수적 복잡성의 가장 단순한 유형은 기술적 낭비의 가장 일반적인것은 시간 압박에서 시작된다</p><h3 id="환경에-따른-기술적-부채"><a href="#환경에-따른-기술적-부채" class="headerlink" title="환경에 따른 기술적 부채"></a>환경에 따른 기술적 부채</h3><p>기술부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것</p><h3 id="성장에-따른-기술적-장애물"><a href="#성장에-따른-기술적-장애물" class="headerlink" title="성장에 따른 기술적 장애물"></a>성장에 따른 기술적 장애물</h3><p>기술적 장애물(technical drag)dms roqkfdmf ejelrp aksemsms ahems rjt</p><p>사용하지 않으면 기능은 퇴화한다</p><h2 id="친밀도에-따른-코드-분류"><a href="#친밀도에-따른-코드-분류" class="headerlink" title="친밀도에 따른 코드 분류"></a>친밀도에 따른 코드 분류</h2><p>댄 노스는 약 6주가 지나면 코드가 알 수 없는 범주로 빠르게 이동하면서 해당 코드와 친밀도가 떨어지기 시작한다고 사례를 들어 주장함<br>유지 시간의 한계가 몇 개월이 아닌 몇주 단위여야 한다</p><h2 id="레거시-시스템에서의-코드-삭제"><a href="#레거시-시스템에서의-코드-삭제" class="headerlink" title="레거시 시스템에서의 코드 삭제"></a>레거시 시스템에서의 코드 삭제</h2><p>레거시 코드의 일반적인 정의는 수정하기가 겁나는 코드(서커스 팩터 circus factor 의 결과)이다</p><h3 id="스트랭글러-무화과나무-패턴"><a href="#스트랭글러-무화과나무-패턴" class="headerlink" title="스트랭글러 무화과나무 패턴"></a>스트랭글러 무화과나무 패턴</h3><p>숙주는 레거시 시스템</p><h3 id="코드-개선을-위한-스트랭글러-무화과나무-패턴-사용"><a href="#코드-개선을-위한-스트랭글러-무화과나무-패턴-사용" class="headerlink" title="코드 개선을 위한 스트랭글러 무화과나무 패턴 사용"></a>코드 개선을 위한 스트랭글러 무화과나무 패턴 사용</h3><p>호출의 빈도는 일반적으로 그것이 얼마나 중요한지를 나타내는 좋은 지표</p><h2 id="동결된-프로젝트에서-코드-삭제"><a href="#동결된-프로젝트에서-코드-삭제" class="headerlink" title="동결된 프로젝트에서 코드 삭제"></a>동결된 프로젝트에서 코드 삭제</h2><p>코드에는 사용하지 않는 다는 표시가 없어서 변경할때 마다 고려하고 유지 해야 한다</p><h3 id="바람직한-결과를-기본값으로-설정"><a href="#바람직한-결과를-기본값으로-설정" class="headerlink" title="바람직한 결과를 기본값으로 설정"></a>바람직한 결과를 기본값으로 설정</h3><p>유지기간을 정해 놓고 그 기간이 지나면 코드를 삭제한다</p><h3 id="스파이크와-스태빌라이즈-안정화-로-낭비-줄이기"><a href="#스파이크와-스태빌라이즈-안정화-로-낭비-줄이기" class="headerlink" title="스파이크와 스태빌라이즈(안정화)로 낭비 줄이기"></a>스파이크와 스태빌라이즈(안정화)로 낭비 줄이기</h3><p>빠르게 구현하고 코드를 얼마나 사용하는지 측정하고 사용하면 유지하고 사용하지 않으면 삭제한다</p><h2 id="버전-관리에서-브랜치-삭제"><a href="#버전-관리에서-브랜치-삭제" class="headerlink" title="버전 관리에서 브랜치 삭제"></a>버전 관리에서 브랜치 삭제</h2><p>브랜치는 시간이 지나면 축적되는데 이것은 불필요한 복잡성을 추가한다</p><h3 id="브랜치-제한으로-낭비-최소화"><a href="#브랜치-제한으로-낭비-최소화" class="headerlink" title="브랜치 제한으로 낭비 최소화"></a>브랜치 제한으로 낭비 최소화</h3><p>협업 방법인 칸반을 적용할수 있다</p><h2 id="코드-문서-삭제"><a href="#코드-문서-삭제" class="headerlink" title="코드 문서 삭제"></a>코드 문서 삭제</h2><p>문서는 정확히 3가지 조건을 충족해야 함</p><ul><li>관련성</li><li>정확성</li><li>발견 가능성</li></ul><h3 id="지식을-문서화하는-방법을-결정하는-알고리즘"><a href="#지식을-문서화하는-방법을-결정하는-알고리즘" class="headerlink" title="지식을 문서화하는 방법을 결정하는 알고리즘"></a>지식을 문서화하는 방법을 결정하는 알고리즘</h3><p>문서화하는 것이 의미가 있는지 여부 결정</p><ul><li>문서화 대상이 자주 바뀌지 않는지</li><li>드물게 사용하는 경우 문서화</li><li>자동화 할수 있음 자동화</li><li>아니면 외워라</li></ul><h2 id="테스트-코드-삭제"><a href="#테스트-코드-삭제" class="headerlink" title="테스트 코드 삭제"></a>테스트 코드 삭제</h2><h3 id="낙관적-테스트-삭제"><a href="#낙관적-테스트-삭제" class="headerlink" title="낙관적 테스트 삭제"></a>낙관적 테스트 삭제</h3><p>항상 참인 것은 삭제 해라</p><h3 id="비관적-테스트-삭제"><a href="#비관적-테스트-삭제" class="headerlink" title="비관적 테스트 삭제"></a>비관적 테스트 삭제</h3><p>항상 거짓인 것은 삭제 해라</p><h3 id="불안정-테스트-수정-또는-삭제"><a href="#불안정-테스트-수정-또는-삭제" class="headerlink" title="불안정 테스트 수정 또는 삭제"></a>불안정 테스트 수정 또는 삭제</h3><p>성공 실패를 반복하면서 예측할수 없는 테스트(불안정 테스트)는 삭제해라</p><h3 id="복잡한-테스트를-제거하기-위한-코드-리팩터링"><a href="#복잡한-테스트를-제거하기-위한-코드-리팩터링" class="headerlink" title="복잡한 테스트를 제거하기 위한 코드 리팩터링"></a>복잡한 테스트를 제거하기 위한 코드 리팩터링</h3><p>테스트를 리팩터링해야 한다는 것은 테스트 중인 코드에 적절한 아키텍처가 없다는 것</p><h3 id="속도를-높이는-테스트-문화"><a href="#속도를-높이는-테스트-문화" class="headerlink" title="속도를 높이는 테스트 문화"></a>속도를 높이는 테스트 문화</h3><p>느린 테스트와 빠른 테스트를 구분하고 가능한 자주 빠른 테스트를 진행하라</p><h2 id="설정-코드-삭제"><a href="#설정-코드-삭제" class="headerlink" title="설정 코드 삭제"></a>설정 코드 삭제</h2><p>완벽하게 만들 수 없다면 최소한 설정이 가능하게 만들어라</p><h3 id="설정의-예상-수명으로-범위-지정"><a href="#설정의-예상-수명으로-범위-지정" class="headerlink" title="설정의 예상 수명으로 범위 지정"></a>설정의 예상 수명으로 범위 지정</h3><ul><li>실험을 위한 설정 : 베타 테스트 또는 A&#x2F;B 테스트</li><li>과도기 적인 설정 : 릴리즈와 뱊호를 연결하는 것</li><li>영구적인 설정 : 사용량을 증가시키거나 유지보수가 간편해야 하기 때문에 특별하다<h2 id="라이브러리-제거를-위한-코드-삭제"><a href="#라이브러리-제거를-위한-코드-삭제" class="headerlink" title="라이브러리 제거를 위한 코드 삭제"></a>라이브러리 제거를 위한 코드 삭제</h2></li></ul><p>라이브러리를 사용하는것은 양날의 검</p><h3 id="외부-라이브러리에-대한-의존도-제한"><a href="#외부-라이브러리에-대한-의존도-제한" class="headerlink" title="외부 라이브러리에 대한 의존도 제한"></a>외부 라이브러리에 대한 의존도 제한</h3><p>고통스러울수록 더 시도하라</p><h2 id="작동-중인-기능에서-코드-삭제"><a href="#작동-중인-기능에서-코드-삭제" class="headerlink" title="작동 중인 기능에서 코드 삭제"></a>작동 중인 기능에서 코드 삭제</h2><p>코드는 부채이다 코드를 삭제하면 부채를 감소시킬수 있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장: 주석 자제하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</guid>
      <pubDate>Wed, 27 Dec 2023 05:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-주석-자제하기&quot;&gt;&lt;a href=&quot;#8장-주석-자제하기&quot; class=&quot;headerlink&quot; title=&quot;8장: 주석 자제하기&quot;&gt;&lt;/a&gt;8장: 주석 자제하기&lt;/h1&gt;&lt;p&gt;메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-주석-자제하기"><a href="#8장-주석-자제하기" class="headerlink" title="8장: 주석 자제하기"></a>8장: 주석 자제하기</h1><p>메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지 않는 주석을 대상으로 함</p><p>주석을 없에는것이 좋을수 있는 이유</p><ul><li>코드가 명확하고 좋은 타입명과 변수명을 사용하는 경우</li><li>주석은 컴파일러가 확인하지 않으므로 특히 코드가 수정된 후에는 주석이 맞다고 보장할 수 없다</li></ul><p>주석이 스멜을 가진 코드 위에 탈취제처럼 자주 사용된다 주석을 달기보다 코드를 정리해야 된다</p><p>일반적인 문제는 이해할 수 없는 코드를 작성한 작성자가 주석으로 어떻게든 명확하고 분명하게 표현할 수 있다고 생각한다는 것</p><p>코드가 표현할 수 없는 것만 주석으로 처리하십시오</p><h2 id="오래된-주석-제거"><a href="#오래된-주석-제거" class="headerlink" title="오래된 주석 제거"></a>오래된 주석 제거</h2><p>해당 주석은 잘못된 정보를 제공하거나 이해하는데 더 방해를 한다</p><h2 id="주석-처리된-코드-제거"><a href="#주석-처리된-코드-제거" class="headerlink" title="주석 처리된 코드 제거"></a>주석 처리된 코드 제거</h2><p>버전 관리를 하기 때문에 주석으로 코드를 관리 할 필요가 더이상 불필요하다</p><h2 id="불필요한-주석-제거"><a href="#불필요한-주석-제거" class="headerlink" title="불필요한 주석 제거"></a>불필요한 주석 제거</h2><p>코드가 주석만큼 읽기 쉬울때 해당 주석을 불필요한 주석이라고 한다</p><h2 id="메서드의-이름으로-주석-대신하기"><a href="#메서드의-이름으로-주석-대신하기" class="headerlink" title="메서드의 이름으로 주석 대신하기"></a>메서드의 이름으로 주석 대신하기</h2><p>일부 주석은 기능보다는 코드를 문서화한다. 메서드 명으로 해당 주석을 대신한다</p><h3 id="계획을-위한-주석-사용"><a href="#계획을-위한-주석-사용" class="headerlink" title="계획을 위한 주석 사용"></a>계획을 위한 주석 사용</h3><p>주석으로 계획을 세울수도 있지만 구현후에는 불필요한 주석일수 있다</p><h2 id="불변속성을-문서화한-주석-유지"><a href="#불변속성을-문서화한-주석-유지" class="headerlink" title="불변속성을 문서화한 주석 유지"></a>불변속성을 문서화한 주석 유지</h2><ul><li><p>주석을 코드를 바꿀수 있는지?</p></li><li><p>검증하기 위한 자동화된 테스트를 만들 수 있는지?</p></li><li><p>위에 두개를 모두 실행할수 없으면 주석을 유지해야 한다</p></li></ul><h3 id="프로세스의-불변속성"><a href="#프로세스의-불변속성" class="headerlink" title="프로세스의 불변속성"></a>프로세스의 불변속성</h3><p>나무를 심기에 가장 좋은 때는 20년 전이었다. 두 번째로 좋은 때는 바로 지금이다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장: 컴파일러와의 협업</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/</guid>
      <pubDate>Wed, 27 Dec 2023 04:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;7장-컴파일러와의-협업&quot;&gt;&lt;a href=&quot;#7장-컴파일러와의-협업&quot; class=&quot;headerlink&quot; title=&quot;7장: 컴파일러와의 협업&quot;&gt;&lt;/a&gt;7장: 컴파일러와의 협업&lt;/h1&gt;&lt;p&gt;컴파일러에 익숙해지면 컴파일러와 함께 정확성에 대한
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="7장-컴파일러와의-협업"><a href="#7장-컴파일러와의-협업" class="headerlink" title="7장: 컴파일러와의 협업"></a>7장: 컴파일러와의 협업</h1><p>컴파일러에 익숙해지면 컴파일러와 함께 정확성에 대한 책임을 공유함으로써 컴파일러를 팀원으로 받아들이고 컴파일러가 소프트웨어를 제대로 빌드하는데 도움이 되게 해야 된다</p><h2 id="컴파일러에-대해-알아보기"><a href="#컴파일러에-대해-알아보기" class="headerlink" title="컴파일러에 대해 알아보기"></a>컴파일러에 대해 알아보기</h2><p>컴파일러는 의심이 가면 물어보라 라는 일번적인 관용구를 따른다</p><h3 id="약점-정지-문제는-컴파일-시-알-수-있는-것을-제한한다"><a href="#약점-정지-문제는-컴파일-시-알-수-있는-것을-제한한다" class="headerlink" title="약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다"></a>약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다</h3><p>런타임 동안 어떤 일이 일어날지 정확히 말할 수 없는 이유를 정지문제(halting problem)라고 한다</p><p>일반적으로 프로그램은 근본적으로 예측이 불가능하다</p><p>컴파일러는 프로그램이 안전하다고 보장할 수 없는 경우 허용하지 않습니다 이를 보수적 분성(conservative analysis)이라고 한다</p><h3 id="장점-도달성-검증은-메서드의-반환을-보장한다"><a href="#장점-도달성-검증은-메서드의-반환을-보장한다" class="headerlink" title="장점: 도달성 검증은 메서드의 반환을 보장한다"></a>장점: 도달성 검증은 메서드의 반환을 보장한다</h3><p>switch문의 경우 모든 case문이 컴파일러에 의해 도달 가능한지 검사한다 이를 완전 검사(exhaustive check)라고 한다</p><h3 id="장점-확정-할당은-초기화되지-않은-변수에-대한-접근을-막는다"><a href="#장점-확정-할당은-초기화되지-않은-변수에-대한-접근을-막는다" class="headerlink" title="장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다"></a>장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다</h3><p>확정 할당 분석(definite assignment analysis)은 변수가 초기화되지 않은 상태로 사용되는지 검사한다</p><h3 id="장점-접근-제어로-데이터-캡슐화를-지원한다"><a href="#장점-접근-제어로-데이터-캡슐화를-지원한다" class="headerlink" title="장점: 접근 제어로 데이터 캡슐화를 지원한다"></a>장점: 접근 제어로 데이터 캡슐화를 지원한다</h3><p>민감한 메서드가 있을 경우 접근 제어자를 사용하여 외부에서 접근하지 못하게 할 수 있다</p><h3 id="장점-타입-형-검사기는-속성을-보증한다"><a href="#장점-타입-형-검사기는-속성을-보증한다" class="headerlink" title="장점: 타입(형) 검사기는 속성을 보증한다"></a>장점: 타입(형) 검사기는 속성을 보증한다</h3><ul><li>대여타입(Rust)</li><li>다형성 타입 유추(Ocaml, F#)</li><li>타입 클래스(하스켈)</li><li>유니언 타입과 교차 타입(타입스크립트)</li><li>종속 타입(coq 와 Agda)</li></ul><h3 id="약점-null을-역참조하면-애플리케이션이-손상된다"><a href="#약점-null을-역참조하면-애플리케이션이-손상된다" class="headerlink" title="약점: null을 역참조하면 애플리케이션이 손상된다"></a>약점: null을 역참조하면 애플리케이션이 손상된다</h3><p>너무 적게 확인하는 것보다 너무 많이 확인하는 것이 낫다</p><h3 id="약점-산술-오류는-오버플로나-손상을-일으킨다"><a href="#약점-산술-오류는-오버플로나-손상을-일으킨다" class="headerlink" title="약점: 산술 오류는 오버플로나 손상을 일으킨다"></a>약점: 산술 오류는 오버플로나 손상을 일으킨다</h3><p>0으로 나누기 또는 나머지 연산 이를 산술적 오류(arithmetic error)라고 한다</p><h3 id="약점-아웃-오브-바운드-오류는-애플리케이션을-손상시킨다"><a href="#약점-아웃-오브-바운드-오류는-애플리케이션을-손상시킨다" class="headerlink" title="약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다"></a>약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다</h3><p>범위네 있지 않은 인덱스에 접근하려고 하면 아웃-오브-바운드 오류(out-of-bounds error)가 발생한다</p><h3 id="무한루프는-애플리케이션을-지연시킨다"><a href="#무한루프는-애플리케이션을-지연시킨다" class="headerlink" title="무한루프는 애플리케이션을 지연시킨다"></a>무한루프는 애플리케이션을 지연시킨다</h3><p>컴파일러는 해당 값을 찾아 내지 못한다</p><h3 id="약점-교착-상태-및-경쟁-상태로-인해-의도하지-않은-동작이-발생한다"><a href="#약점-교착-상태-및-경쟁-상태로-인해-의도하지-않은-동작이-발생한다" class="headerlink" title="약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다"></a>약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다</h3><p>멀티스레딩에서 비롯됨 변경 가능한 데이터를 공유하는 여러 스레드가 있으면 문제의 홍수가 발생함</p><h2 id="컴파일러-사용"><a href="#컴파일러-사용" class="headerlink" title="컴파일러 사용"></a>컴파일러 사용</h2><p>소프트웨어 개발과 건축을 비유하긴 하는데 우리 분야에서 가장 해로운 비유 프로그래밍은 건축이 아닌 여러 단계의 커뮤니케이션</p><ul><li>컴퓨터와 의사소통(코드를 짤때)</li><li>다른 개발자와 의사소통(코드를 읽을때)</li><li>컴파일러와 의사소통(코드를 컴파일할때)</li></ul><p>데이터 구조는 시간이 정지된 알고리즘이다</p><h3 id="컴파일러-활용"><a href="#컴파일러-활용" class="headerlink" title="컴파일러 활용"></a>컴파일러 활용</h3><ul><li>컴파일러 TODO 리스트로 안정성 확보</li><li>순서 강제화를 이용한 안정성 확보</li><li>캡슐화를 강제를 통한 안정성 확보</li><li>컴파일러로 사용하지 않는 코드 감지</li><li>확정 값을 통한 안정성 확보</li></ul><h3 id="컴파일러와-싸우지-말-것"><a href="#컴파일러와-싸우지-말-것" class="headerlink" title="컴파일러와 싸우지 말 것"></a>컴파일러와 싸우지 말 것</h3><ul><li>타입</li><li>형 변환</li><li>동적 타입</li><li>런타임 타입</li><li>게으름</li><li>기본값</li><li>상속</li><li>처리를 강제하지 않은 예외</li><li>아키텍처</li></ul><h2 id="컴파일러-신뢰하기"><a href="#컴파일러-신뢰하기" class="headerlink" title="컴파일러 신뢰하기"></a>컴파일러 신뢰하기</h2><p>컴파일러에게 해준 만큼 돌려받을수 있다</p><h3 id="컴파일러에게-불변속성-가르치기"><a href="#컴파일러에게-불변속성-가르치기" class="headerlink" title="컴파일러에게 불변속성 가르치기"></a>컴파일러에게 불변속성 가르치기</h3><p>이길수 없으면 같은 편으로 만들어라</p><h3 id="컴파일러의-경고에-주의를-기울일-것"><a href="#컴파일러의-경고에-주의를-기울일-것" class="headerlink" title="컴파일러의 경고에 주의를 기울일 것"></a>컴파일러의 경고에 주의를 기울일 것</h3><p>정보 피로(alarm fatigue)는 경고를 무시하게 만든다</p><h2 id="컴파일러만-신뢰할-것"><a href="#컴파일러만-신뢰할-것" class="headerlink" title="컴파일러만 신뢰할 것"></a>컴파일러만 신뢰할 것</h2><p>만일 당신이 이 방에서 가장 똑똑한 사람이라면 당신은 잘못된 방에 있는 것이다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장: 데이터 보호</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/</guid>
      <pubDate>Wed, 27 Dec 2023 01:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;6장-데이터-보호&quot;&gt;&lt;a href=&quot;#6장-데이터-보호&quot; class=&quot;headerlink&quot; title=&quot;6장: 데이터 보호&quot;&gt;&lt;/a&gt;6장: 데이터 보호&lt;/h1&gt;&lt;p&gt;데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="6장-데이터-보호"><a href="#6장-데이터-보호" class="headerlink" title="6장: 데이터 보호"></a>6장: 데이터 보호</h1><p>데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지역에만 영향을 주게 만드는데 중점</p><h2 id="getter-없이-캡슐화하기"><a href="#getter-없이-캡슐화하기" class="headerlink" title="getter 없이 캡슐화하기"></a>getter 없이 캡슐화하기</h2><h3 id="규칙-getter와-setter를-사용하지-말-것"><a href="#규칙-getter와-setter를-사용하지-말-것" class="headerlink" title="규칙: getter와 setter를 사용하지 말 것"></a>규칙: getter와 setter를 사용하지 말 것</h3><p>부울(Boolean)이 아닌 필드에 setter나 getter를 사용하지 말 것</p><p>필드를 비공개로 하는 것의 가장 큰 장점은 그렇게 하는 것이 푸시 기반(push-base) 아키텍처를 장려하기 때문</p><p>디미터 법칙에서 유래</p><h3 id="규칙-적용하기"><a href="#규칙-적용하기" class="headerlink" title="규칙 적용하기"></a>규칙 적용하기</h3><h3 id="리팩터링-패턴-getter와-setter-제거하기"><a href="#리팩터링-패턴-getter와-setter-제거하기" class="headerlink" title="리팩터링 패턴: getter와 setter 제거하기"></a>리팩터링 패턴: getter와 setter 제거하기</h3><p>기능을 데이터에 더 가깝게 이동하여 getter와 setter를 제거할수 있다</p><h3 id="마지막-getter-삭제"><a href="#마지막-getter-삭제" class="headerlink" title="마지막 getter 삭제"></a>마지막 getter 삭제</h3><h2 id="간단한-데이터-캡슐화하기"><a href="#간단한-데이터-캡슐화하기" class="headerlink" title="간단한 데이터 캡슐화하기"></a>간단한 데이터 캡슐화하기</h2><h3 id="규칙-공통-접사를-사용하지-말-것"><a href="#규칙-공통-접사를-사용하지-말-것" class="headerlink" title="규칙: 공통 접사를 사용하지 말 것"></a>규칙: 공통 접사를 사용하지 말 것</h3><p>코드에 공통 접두사나 접미사가 있는 메서드나 변수가 없어야 된다</p><p>클래스를 사용해서 메서드와 변수를 그룹하하면 공통 접두사나 접미사를 제거할 수 있다</p><p>단일 책임 원칙을 따르는 클래스를 만들어야 한다</p><h3 id="리팩터링-패턴-데이터-캡슐화"><a href="#리팩터링-패턴-데이터-캡슐화" class="headerlink" title="리팩터링 패턴: 데이터 캡슐화"></a>리팩터링 패턴: 데이터 캡슐화</h3><p>변수와 메서드를 클래스로 옴기는 작업</p><h2 id="순서에-존재하는-불변속성-제거하기"><a href="#순서에-존재하는-불변속성-제거하기" class="headerlink" title="순서에 존재하는 불변속성 제거하기"></a>순서에 존재하는 불변속성 제거하기</h2><p>무언가가 다른 것보다 먼저 호출되어야 할때 그것을 순서 불변속성(sequence invariance)이라고 한다</p><h3 id="리팩터링-패턴-순서-강제화"><a href="#리팩터링-패턴-순서-강제화" class="headerlink" title="리팩터링 패턴: 순서 강제화"></a>리팩터링 패턴: 순서 강제화</h3><p>생성자를 먼저 호출하지 않는 것은 불가능 하기 때문에 이불변속성이 제거된다 이 리팩터링을 순서 강제화라고 한다</p><h2 id="열거형을-제거하는-또-다른-방법"><a href="#열거형을-제거하는-또-다른-방법" class="headerlink" title="열거형을 제거하는 또 다른 방법"></a>열거형을 제거하는 또 다른 방법</h2><h3 id="비공개-생성자를-통한-열거"><a href="#비공개-생성자를-통한-열거" class="headerlink" title="비공개 생성자를 통한 열거"></a>비공개 생성자를 통한 열거</h3><h3 id="숫자를-클래스에-다시-매핑하기"><a href="#숫자를-클래스에-다시-매핑하기" class="headerlink" title="숫자를 클래스에 다시 매핑하기"></a>숫자를 클래스에 다시 매핑하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li><li><a href="https://github.com/Neppord/FantasyBattle-Refactoring-Kata">Fantasy Battle Refactoring Kata</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장: 유사한 코드 융합하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/</guid>
      <pubDate>Wed, 27 Dec 2023 00:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;5장-유사한-코드-융합하기&quot;&gt;&lt;a href=&quot;#5장-유사한-코드-융합하기&quot; class=&quot;headerlink&quot; title=&quot;5장: 유사한 코드 융합하기&quot;&gt;&lt;/a&gt;5장: 유사한 코드 융합하기&lt;/h1&gt;&lt;h2 id=&quot;유사한-클래스-통합하기&quot;&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="5장-유사한-코드-융합하기"><a href="#5장-유사한-코드-융합하기" class="headerlink" title="5장: 유사한 코드 융합하기"></a>5장: 유사한 코드 융합하기</h1><h2 id="유사한-클래스-통합하기"><a href="#유사한-클래스-통합하기" class="headerlink" title="유사한 클래스 통합하기"></a>유사한 클래스 통합하기</h2><h3 id="리팩터링-패턴-유사-클래스-통합"><a href="#리팩터링-패턴-유사-클래스-통합" class="headerlink" title="리팩터링 패턴: 유사 클래스 통합"></a>리팩터링 패턴: 유사 클래스 통합</h3><p>일련의 상수 메서드를 공통으로 가진 두개 이상의 클래스에서 이 일련의 상수 메서드가 클래스에 따라 다른 값을 반환 할 때마다<br>이 리팩터링 패턴을 사용해 통합할수 있다</p><h2 id="단순한-조건-통합하기"><a href="#단순한-조건-통합하기" class="headerlink" title="단순한 조건 통합하기"></a>단순한 조건 통합하기</h2><p>단순한 조건은 통합한다 이건 어떠한 판단을 하지 않아도 처리할수 있는 리팩토링이다</p><h3 id="리팩터링-패턴-if-문-결합"><a href="#리팩터링-패턴-if-문-결합" class="headerlink" title="리팩터링 패턴: if 문 결합"></a>리팩터링 패턴: if 문 결합</h3><p>연속적인 if문을 결합해서 통합한다 || 연산자를 사용해서 통합한다</p><h2 id="복잡한-조건-통합하기"><a href="#복잡한-조건-통합하기" class="headerlink" title="복잡한 조건 통합하기"></a>복잡한 조건 통합하기</h2><h3 id="조건을-위한-산술-규칙-사용"><a href="#조건을-위한-산술-규칙-사용" class="headerlink" title="조건을 위한 산술 규칙 사용"></a>조건을 위한 산술 규칙 사용</h3><p>|| 연산자는 + 처럼 동작하고 &amp;&amp; 연산자는 * 처럼 동작한다</p><p>그렇게 생각하면 결합법칙, 교환법칙, 분배법칙을 고려할수 있다</p><h3 id="규칙-순수-조건-사용"><a href="#규칙-순수-조건-사용" class="headerlink" title="규칙: 순수 조건 사용"></a>규칙: 순수 조건 사용</h3><p>조건은 항상 순수 조건이어야 한다 순수라는 말은 조건에 부수적인 동작이 없다는 뜻이다</p><p>명령에서 질의 분리라는 일반적인 스멜에서 비론된다</p><h3 id="조건-산술-적용"><a href="#조건-산술-적용" class="headerlink" title="조건 산술 적용"></a>조건 산술 적용</h3><p>익숙한 산술 법칙을 사용해서 단순화 하고 다시 코드를 변환할수 있다</p><h2 id="클래스-간의-코드-통합"><a href="#클래스-간의-코드-통합" class="headerlink" title="클래스 간의 코드 통합"></a>클래스 간의 코드 통합</h2><h3 id="클래스-관계를-묘사하기-위한-UML-클래스-다이어그램-소개"><a href="#클래스-관계를-묘사하기-위한-UML-클래스-다이어그램-소개" class="headerlink" title="클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개"></a>클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개</h3><p>전체 프로그램에 대한 클래스 다이어그램을 만드는 것은 순식간에 거대해져서 도움이 되지 않는다<br>주로 디자인 패턴이나 소프트웨어 아키텍처의 작은 부분을 설명하는데 사용하기 때문에 중요한 메서드만 포함한다</p><h3 id="리팩터링-패턴-전략-패턴의-도입"><a href="#리팩터링-패턴-전략-패턴의-도입" class="headerlink" title="리팩터링 패턴: 전략 패턴의 도입"></a>리팩터링 패턴: 전략 패턴의 도입</h3><p>많은 패턴이 전략 패턴의 다른 형태이다 전략이 필드를 가지고 있는 경우 이를 상태 패턴이라고 한다</p><h3 id="규칙-구현체가-하나뿐인-인터페이스를-만들지-말-것"><a href="#규칙-구현체가-하나뿐인-인터페이스를-만들지-말-것" class="headerlink" title="규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것"></a>규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것</h3><p>구현 클래스가 하나밖에 없는 인터페이스는 가독성에 도움이 되지 않는다<br>인터페이스는 변형을 전제로 하는데 아무것도 없다면 오히려 가독성을 방해할수 있다</p><p>구현클래스를 수정하는 경우 인터페이스도 수정해야 해서 오버헤드를 발생시킨다</p><h3 id="리팩터링-패턴-구현에서-인터페이스-추출"><a href="#리팩터링-패턴-구현에서-인터페이스-추출" class="headerlink" title="리팩터링 패턴: 구현에서 인터페이스 추출"></a>리팩터링 패턴: 구현에서 인터페이스 추출</h3><p>단순한 리팩터링 인터페이스를 만드는 것을 필요할때 까지 연기할수 있어서 유용하다</p><h2 id="유사-함수-통합하기"><a href="#유사-함수-통합하기" class="headerlink" title="유사 함수 통합하기"></a>유사 함수 통합하기</h2><h2 id="유사한-코드-통합하기"><a href="#유사한-코드-통합하기" class="headerlink" title="유사한 코드 통합하기"></a>유사한 코드 통합하기</h2><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장: 타입 코드 처리하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/</guid>
      <pubDate>Tue, 26 Dec 2023 05:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;4장-타입-코드-처리하기&quot;&gt;&lt;a href=&quot;#4장-타입-코드-처리하기&quot; class=&quot;headerlink&quot; title=&quot;4장: 타입 코드 처리하기&quot;&gt;&lt;/a&gt;4장: 타입 코드 처리하기&lt;/h1&gt;&lt;h2 id=&quot;간단한-if-문-리팩터링&quot;&gt;&lt;a h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="4장-타입-코드-처리하기"><a href="#4장-타입-코드-처리하기" class="headerlink" title="4장: 타입 코드 처리하기"></a>4장: 타입 코드 처리하기</h1><h2 id="간단한-if-문-리팩터링"><a href="#간단한-if-문-리팩터링" class="headerlink" title="간단한 if 문 리팩터링"></a>간단한 if 문 리팩터링</h2><h3 id="규칙-if-문에서-else를-사용하지-말-것"><a href="#규칙-if-문에서-else를-사용하지-말-것" class="headerlink" title="규칙: if 문에서 else를 사용하지 말 것"></a>규칙: if 문에서 else를 사용하지 말 것</h3><p>결정은 어렵다 if문은 검사 로 간주 if-else 를 사용하면 의사결정으로 간주</p><h3 id="규칙-적용"><a href="#규칙-적용" class="headerlink" title="규칙 적용"></a>규칙 적용</h3><p>클래스로 타입 코드 대체 한다</p><h3 id="리팩터링-패턴-클래스로-타입-코드-대체"><a href="#리팩터링-패턴-클래스로-타입-코드-대체" class="headerlink" title="리팩터링 패턴: 클래스로 타입 코드 대체"></a>리팩터링 패턴: 클래스로 타입 코드 대체</h3><p>클래스로 타입 코드를 바꾼다</p><h3 id="클래스로-코드-이관하기"><a href="#클래스로-코드-이관하기" class="headerlink" title="클래스로 코드 이관하기"></a>클래스로 코드 이관하기</h3><p>클래스로 메소드를 이관 시키면 if문을 제거 할수 있다</p><h3 id="리팩터링-패턴-클래스로의-코드-이관"><a href="#리팩터링-패턴-클래스로의-코드-이관" class="headerlink" title="리팩터링 패턴: 클래스로의 코드 이관"></a>리팩터링 패턴: 클래스로의 코드 이관</h3><p>클래스로 타입코드 대체 패턴의 자연스러운 연장선</p><h3 id="불필요한-메서드-인라인화"><a href="#불필요한-메서드-인라인화" class="headerlink" title="불필요한 메서드 인라인화"></a>불필요한 메서드 인라인화</h3><p>함수를 호출하는 곳으로 변경 처리 </p><p>메서드 인라인화 패턴은 매서드 추출과 정확히 반대</p><h3 id="리팩터링-패턴-메서드의-인라인화"><a href="#리팩터링-패턴-메서드의-인라인화" class="headerlink" title="리팩터링 패턴: 메서드의 인라인화"></a>리팩터링 패턴: 메서드의 인라인화</h3><p>메서드 인라인화를 수행할 때는 모든 호출 측을 수정하여 원래 메서드를 제거 해야 한다</p><p>호출 또는 전달 한가지만 할것</p><h2 id="긴-if-문의-리팩터링"><a href="#긴-if-문의-리팩터링" class="headerlink" title="긴 if 문의 리팩터링"></a>긴 if 문의 리팩터링</h2><p>메서드를 클래스로 이관하고 메서드를 전문화 시킨다</p><ul><li>일반성 제거</li><li>리팩터링 패턴: 메서드 전문화<h3 id="규칙-switch를-사용하지-말-것"><a href="#규칙-switch를-사용하지-말-것" class="headerlink" title="규칙: switch를 사용하지 말 것"></a>규칙: switch를 사용하지 말 것</h3></li></ul><p>default 케이스가 없고 모든 case에 반환값이 있는 경우가 아니라면 switch문은 사용하지 말아야 한다</p><h3 id="if-제거하기"><a href="#if-제거하기" class="headerlink" title="if 제거하기"></a>if 제거하기</h3><h2 id="코드-중복-처리"><a href="#코드-중복-처리" class="headerlink" title="코드 중복 처리"></a>코드 중복 처리</h2><h3 id="인터페이스-대신-추상-클래스를-사용할-수는-없을까"><a href="#인터페이스-대신-추상-클래스를-사용할-수는-없을까" class="headerlink" title="인터페이스 대신 추상 클래스를 사용할 수는 없을까?"></a>인터페이스 대신 추상 클래스를 사용할 수는 없을까?</h3><p>사용할수 있다 하지만 몇가지 단점도 있다 인터페이스를 사용하면 개발자가 능동적으로 무엇을 해야 한다 하지만 추상클래스는 그냥 넘어 갈수 있다</p><h3 id="규칙-인터페이스에서만-상속받을-것"><a href="#규칙-인터페이스에서만-상속받을-것" class="headerlink" title="규칙: 인터페이스에서만 상속받을 것"></a>규칙: 인터페이스에서만 상속받을 것</h3><h3 id="클래스에-있는-코드의-중복은-다-무엇일까"><a href="#클래스에-있는-코드의-중복은-다-무엇일까" class="headerlink" title="클래스에 있는 코드의 중복은 다 무엇일까?"></a>클래스에 있는 코드의 중복은 다 무엇일까?</h3><h2 id="복잡한-if-체인-구문-리팩터링"><a href="#복잡한-if-체인-구문-리팩터링" class="headerlink" title="복잡한 if 체인 구문 리팩터링"></a>복잡한 if 체인 구문 리팩터링</h2><h2 id="필요-없는-코드-제거하기"><a href="#필요-없는-코드-제거하기" class="headerlink" title="필요 없는 코드 제거하기"></a>필요 없는 코드 제거하기</h2><h3 id="리팩터링-패턴-삭제-후-컴파일하기"><a href="#리팩터링-패턴-삭제-후-컴파일하기" class="headerlink" title="리팩터링 패턴: 삭제 후 컴파일하기"></a>리팩터링 패턴: 삭제 후 컴파일하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>pyproject.toml</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-pyproject/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-pyproject/</guid>
      <pubDate>Tue, 26 Dec 2023 02:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;pyproject-toml&quot;&gt;&lt;a href=&quot;#pyproject-toml&quot; class=&quot;headerlink&quot; title=&quot;pyproject.toml&quot;&gt;&lt;/a&gt;pyproject.toml&lt;/h1&gt;&lt;p&gt;pyproject.tomlPEP 518 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="pyproject-toml"><a href="#pyproject-toml" class="headerlink" title="pyproject.toml"></a>pyproject.toml</h1><p>pyproject.tomlPEP 518 에 정의되고 PEP 621 및 PEP 660 에서 확장된 새로운 구성 파일입니다.<br>빌드 시스템 요구 사항을 저장하도록 설계되었지만 Python 프로젝트에 대한 모든 도구 구성을 저장할 수도 있어 필요하거나<br>setup.cfg다른 도구 관련 파일을 대체할 수도 있습니다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/carlosperate/awesome-pyproject">Awesome pyproject.toml</a></li><li><a href="https://peps.python.org/pep-0518/">PEP 518 – Specifying Minimum Build System Requirements for Python Projects</a></li><li><a href="https://peps.python.org/pep-0621/">PEP 621 – Storing project metadata in pyproject.toml</a></li><li><a href="https://peps.python.org/pep-0660/">PEP 660 – Editable installs for pyproject.toml based builds (wheel based)</a></li><li><a href="https://packaging.python.org/en/latest/guides/writing-pyproject-toml/">Writing your pyproject.toml</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-pyproject/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장: 긴 코드 조각내기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/</guid>
      <pubDate>Tue, 26 Dec 2023 01:58:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;3장-긴-코드-조각내기&quot;&gt;&lt;a href=&quot;#3장-긴-코드-조각내기&quot; class=&quot;headerlink&quot; title=&quot;3장: 긴 코드 조각내기&quot;&gt;&lt;/a&gt;3장: 긴 코드 조각내기&lt;/h1&gt;&lt;p&gt;DRY(Don’t Repeat Yourself)&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="3장-긴-코드-조각내기"><a href="#3장-긴-코드-조각내기" class="headerlink" title="3장: 긴 코드 조각내기"></a>3장: 긴 코드 조각내기</h1><p>DRY(Don’t Repeat Yourself)</p><p>KISS(Keep it simple, stupid)</p><p>위에 지침을 따라도 코드는 쉽게 지저분해지고 혼란스러울수 있다</p><p>메서드 추출로 가독성을 올린다</p><h2 id="첫-번째-규칙-왜-다섯-줄인가"><a href="#첫-번째-규칙-왜-다섯-줄인가" class="headerlink" title="첫 번째 규칙: 왜 다섯 줄인가?"></a>첫 번째 규칙: 왜 다섯 줄인가?</h2><p>이 지침을 엄수하는것으로 엄청난 개선이다</p><h3 id="규칙-다섯-줄-제한"><a href="#규칙-다섯-줄-제한" class="headerlink" title="규칙: 다섯 줄 제한"></a>규칙: 다섯 줄 제한</h3><p>메서드는 {}를 제외하고 5줄 이상이 되면 안된다</p><p>메서드가 길다는것 자체가 코드 스멜이다</p><p>관심을 가지지 않으면 시간이 지남에 따라 더많은 기능이 추가 되면서 메서드가 커지는 경향</p><h2 id="함수-분해를-위한-리팩터링-패턴-소개"><a href="#함수-분해를-위한-리팩터링-패턴-소개" class="headerlink" title="함수 분해를 위한 리팩터링 패턴 소개"></a>함수 분해를 위한 리팩터링 패턴 소개</h2><p>작게 잘라서 이해하기 쉽게 하나씩 처리</p><h3 id="리팩터링-패턴-메서드-추출"><a href="#리팩터링-패턴-메서드-추출" class="headerlink" title="리팩터링 패턴: 메서드 추출"></a>리팩터링 패턴: 메서드 추출</h3><p>메서드 추출은 한 메서드의 일부를 취해서 자체 메서드로 추출 한다</p><h2 id="추상화-수준을-맞추기-위한-함수-분해"><a href="#추상화-수준을-맞추기-위한-함수-분해" class="headerlink" title="추상화 수준을 맞추기 위한 함수 분해"></a>추상화 수준을 맞추기 위한 함수 분해</h2><h3 id="규칙-호출-또는-전달-한-가지만-할-것"><a href="#규칙-호출-또는-전달-한-가지만-할-것" class="headerlink" title="규칙: 호출 또는 전달, 한 가지만 할 것"></a>규칙: 호출 또는 전달, 한 가지만 할 것</h3><p>함수 내에서는 객체에 있는 메서드를 호출하거나 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안된다</p><p>함수의 내용은 동일한 추상화 수준에 있어야 한다는 그 자체가 스멜일 정도로 강력하다</p><h2 id="좋은-함수-이름의-속성"><a href="#좋은-함수-이름의-속성" class="headerlink" title="좋은 함수 이름의 속성"></a>좋은 함수 이름의 속성</h2><p>좋은 이름이 가져야할 속성</p><ul><li>정직해야 한다. 함수의 의도를 설명해야 한다</li><li>완전해야 한다. 함수가 하는 모든것을 담아야 한다</li><li>도메인에서 일하는 사람이 이해할 수 있어야 한다</li></ul><h2 id="너무-많은-일을-하는-함수-분리하기"><a href="#너무-많은-일을-하는-함수-분리하기" class="headerlink" title="너무 많은 일을 하는 함수 분리하기"></a>너무 많은 일을 하는 함수 분리하기</h2><h3 id="규칙-if-문은-함수의-시작에만-배치"><a href="#규칙-if-문은-함수의-시작에만-배치" class="headerlink" title="규칙: if 문은 함수의 시작에만 배치"></a>규칙: if 문은 함수의 시작에만 배치</h3><p>함수는 한가지 일만 해야 된다는것을 알아야 됨</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-26-five_lines_of_code_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장: 리팩터링 깊게 들여다보기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/</guid>
      <pubDate>Fri, 22 Dec 2023 01:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;2장-리팩터링-깊게-들여다보기&quot;&gt;&lt;a href=&quot;#2장-리팩터링-깊게-들여다보기&quot; class=&quot;headerlink&quot; title=&quot;2장: 리팩터링 깊게 들여다보기&quot;&gt;&lt;/a&gt;2장: 리팩터링 깊게 들여다보기&lt;/h1&gt;&lt;h2 id=&quot;가독성-및-유
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="2장-리팩터링-깊게-들여다보기"><a href="#2장-리팩터링-깊게-들여다보기" class="headerlink" title="2장: 리팩터링 깊게 들여다보기"></a>2장: 리팩터링 깊게 들여다보기</h1><h2 id="가독성-및-유지보수성-향상"><a href="#가독성-및-유지보수성-향상" class="headerlink" title="가독성 및 유지보수성 향상"></a>가독성 및 유지보수성 향상</h2><p>리팩터링</p><ul><li>더 나은 코드를 만드는것 </li><li>코드가 하는 일은 변경하지 않는것</li></ul><h3 id="코드-개선"><a href="#코드-개선" class="headerlink" title="코드 개선"></a>코드 개선</h3><ul><li>가독성 : 의도를 전달하기 위한 코드의 성질</li><li>유지보수성 : 코드를 변경하기 쉽게 만드는 성질<ul><li>함께 변하는건 함께 있어야 된다(localizing ivariants)</li><li>취약성의 근원은 전역 상태(global state)이다</li><li>불변속성(invariants) : 코드에서 상태(조선)를 명시적으로 확인하지 않는 속성(assertion 으로만 확인)</li></ul></li></ul><h3 id="코드가-하는-일을-바꾸지-않고-유지보수하기"><a href="#코드가-하는-일을-바꾸지-않고-유지보수하기" class="headerlink" title="코드가 하는 일을 바꾸지 않고 유지보수하기"></a>코드가 하는 일을 바꾸지 않고 유지보수하기</h3><p>코드는 블랙박스로 생각하고 외부에 영향을 주지 않는 내부의 모든 작업을 변경할수 있다고 생각</p><p>리팩터링을 할 때는 블랙박스의 경계를 고려해야 함</p><p>리팩터링의 세가지 핵심</p><ul><li>의도를 전달함으로써 가독성 향상</li><li>불변속성의 범위제한을 통한 유지보수성 향상</li><li>범위 밖의 코드에 영향을 주지 않고 1항과 2항을 수정</li></ul><h2 id="속도-유연성-및-안정성-확보"><a href="#속도-유연성-및-안정성-확보" class="headerlink" title="속도, 유연성 및 안정성 확보"></a>속도, 유연성 및 안정성 확보</h2><p>리팩터링 패턴에는 구체적이고 지역적인것(변수명 변경) 부터 추상적이고 전역적인 것에 이르기 까지 여러 수준이 있다.</p><h3 id="상속보다는-컴포지션-사용"><a href="#상속보다는-컴포지션-사용" class="headerlink" title="상속보다는 컴포지션 사용"></a>상속보다는 컴포지션 사용</h3><p>유연성 : 컴포지션을 중심으로 만들어진 시스템을 사용하면 다른 방식보다 더 깔끔하게 코드를 결합하고 재사용 할 수 있다</p><h3 id="수정이-아니라-추가로-코드를-변경"><a href="#수정이-아니라-추가로-코드를-변경" class="headerlink" title="수정이 아니라 추가로 코드를 변경"></a>수정이 아니라 추가로 코드를 변경</h3><p>컴포지션의 가장 큰 장점은 추가(addition)로 변경 가능 하다는 것</p><p>개방 폐쇠 원칙- 확장엔 열려있어야 하고 수정엔 닫혀 있어야 한다는 의미</p><ul><li>프로그래밍 속도<ul><li>어떤 코드가 사용되고 어떤 코드가 사용되지 않는지 주의를 기울이고 사용하지 않는 코드는 최대한 빨리 삭제</li></ul></li><li>안정성<ul><li>추가에 의한 변경 방식을 따르면 기존코드를 항상 보존할 수 있다</li></ul></li></ul><h2 id="리팩터링과-일상-업무"><a href="#리팩터링과-일상-업무" class="headerlink" title="리팩터링과 일상 업무"></a>리팩터링과 일상 업무</h2><p>기슬부채</p><ul><li>레거시 시스템을 변경하기 전에 먼저 리팩터링 하자</li><li>코드를 변경한 후에도 리팩터링 하자</li></ul><h3 id="학습-방법으로서의-리팩터링"><a href="#학습-방법으로서의-리팩터링" class="headerlink" title="학습 방법으로서의 리팩터링"></a>학습 방법으로서의 리팩터링</h3><p>리팩터링은 코드를 연구하는 완전히 다른 방법</p><h2 id="소프트웨어-분야에서-‘도메인’-정의하기"><a href="#소프트웨어-분야에서-‘도메인’-정의하기" class="headerlink" title="소프트웨어 분야에서 ‘도메인’ 정의하기"></a>소프트웨어 분야에서 ‘도메인’ 정의하기</h2><p>실제 세계의 구성요소를 소프트웨어의 도메인 이라고 한다</p><p>프로그래밍은 주로 학습과 의사소통에 관한것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-22-five_lines_of_code_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion Samplers</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/</guid>
      <pubDate>Thu, 21 Dec 2023 08:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Stable-Diffusion-Samplers&quot;&gt;&lt;a href=&quot;#Stable-Diffusion-Samplers&quot; class=&quot;headerlink&quot; title=&quot;Stable Diffusion Samplers&quot;&gt;&lt;/a&gt;Stable Diff
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Stable-Diffusion-Samplers"><a href="#Stable-Diffusion-Samplers" class="headerlink" title="Stable Diffusion Samplers"></a>Stable Diffusion Samplers</h1><h2 id="Old-School-ODE-solvers"><a href="#Old-School-ODE-solvers" class="headerlink" title="Old-School ODE solvers"></a>Old-School ODE solvers</h2><p>상미분 방정식(ODE)</p><ul><li>Euler :  가장 간단한 해결 입니다.</li><li>Heun : 오일러의 더 정확하지만 느린 버전입니다.</li><li>LMS(Linear multi-step method) : 오일러와 속도는 동일하지만 (아마도) 더 정확합니다.</li></ul><h2 id="Ancestral-samplers"><a href="#Ancestral-samplers" class="headerlink" title="Ancestral samplers"></a>Ancestral samplers</h2><ul><li>Euler a</li><li>DPM2 a</li><li>DPM++ 2S a</li><li>DPM++ 2S a Karras</li></ul><p>Ancestral samplers는 각 샘플링 단계에서 이미지에 노이즈를 추가합니다. 샘플링 결과에 임의성이 있기 때문에 확률적 샘플러 입니다.</p><p>단점은 이미지가 수렴되지 않는다는 것입니다.</p><h2 id="Karras-noise-schedule"><a href="#Karras-noise-schedule" class="headerlink" title="Karras noise schedule"></a>Karras noise schedule</h2><p>Karras 라는 라벨이 붙은 샘플러는 Karras 기사 에서 권장하는 소음 일정을 사용합니다.<br>주의 깊게 살펴보면 노이즈 단계 크기가 끝 부분에서 더 작아지는 것을 볼 수 있습니다.<br>그들은 이것이 이미지의 품질을 향상시킨다는 것을 발견했습니다.</p><h2 id="DDIM-및-PLMS"><a href="#DDIM-및-PLMS" class="headerlink" title="DDIM 및 PLMS"></a>DDIM 및 PLMS</h2><p>DDIM(Denoising Diffusion Implicit Model) 및 PLMS(Pseudo Linear Multi-Step 방법)는 원래 Stable Diffusion v1 과 함께 제공되는 샘플러였습니다 .<br>DDIM은 확산 모델용으로 설계된 최초의 샘플러 중 하나입니다. PLMS는 DDIM의 더 새롭고 빠른 대안입니다.</p><p>일반적으로 오래된 것으로 간주되어 더 이상 널리 사용되지 않습니다.</p><h2 id="DPM-및-DPM"><a href="#DPM-및-DPM" class="headerlink" title="DPM 및 DPM++"></a>DPM 및 DPM++</h2><p>DPM (확산 확률 모델 솔버) 및 DPM++ 는 2022년에 출시된 확산 모델용으로 설계된 새로운 샘플러입니다. 이들은 유사한 아키텍처의 솔버 제품군을 나타냅니다.</p><p>DPM 과 DPM2는 DPM2가 2차라는 점을 제외하면 유사합니다(더 정확하지만 느림).</p><p>DPM++ 는 DPM보다 개선된 것입니다.</p><p>DPM 적응형은 단계 크기를 적응적으로 조정합니다. 샘플링 단계 수 내에서 완료를 보장하지 않으므로 속도가 느려질 수 있습니다.</p><h2 id="UniPC"><a href="#UniPC" class="headerlink" title="UniPC"></a>UniPC</h2><p>UniPC (Unified Predictor-Corrector)는 2023년에 출시된 새로운 샘플러입니다.<br>ODE 솔버의 예측-수정기 방법에서 영감을 받아 5~10단계로 고품질 이미지 생성을 달성할 수 있습니다.</p><h2 id="k-diffusion"><a href="#k-diffusion" class="headerlink" title="k-diffusion"></a>k-diffusion</h2><p>마지막으로, k-확산 이라는 용어를 듣고 그것이 무엇을 의미하는지 궁금했을 것입니다.<br>이는 단순히 Katherine Crowson의 k-diffusion GitHub 저장소 및 이와 관련된 샘플러를 나타냅니다.</p><p>저장소는 Karras 2022 기사 에서 연구된 샘플러를 구현합니다.</p><p>기본적으로 DDIM, PLMS, UniPC를 제외한 AUTOMATIC1111의 모든 샘플러는 k-diffusion에서 차용한 것입니다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://stable-diffusion-art.com/samplers/">Stable Diffusion Samplers: A Comprehensive Guide</a></li><li><a href="https://github.com/crowsonkb/k-diffusion">k-diffusion</a></li><li><a href="https://arxiv.org/abs/2206.00364">Elucidating the Design Space of Diffusion-Based Generative Models</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-Stable_Diffusion_Samplers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Classifier-Free Guidance : CFG</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/</guid>
      <pubDate>Thu, 21 Dec 2023 02:18:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Classifier-Free-Guidance-CFG&quot;&gt;&lt;a href=&quot;#Classifier-Free-Guidance-CFG&quot; class=&quot;headerlink&quot; title=&quot;Classifier-Free Guidance : CFG&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Classifier-Free-Guidance-CFG"><a href="#Classifier-Free-Guidance-CFG" class="headerlink" title="Classifier-Free Guidance : CFG"></a>Classifier-Free Guidance : CFG</h1><h2 id="Classifier-guidance-분류자-지침"><a href="#Classifier-guidance-분류자-지침" class="headerlink" title="Classifier guidance(분류자 지침)"></a>Classifier guidance(분류자 지침)</h2><p>Classifier guidance은 확산 모델에 이미지 와 라벨을 통합하는 방법입니다.<br>라벨을 사용하여 확산 과정을 안내할 수 있습니다. 예를 들어, “고양이”라는 라벨은 역확산 과정을 조종하여 고양이 사진을 생성합니다.</p><p>classifier guidance scale 은 확산 프로세스가 라벨을 얼마나 밀접하게 따라야 하는지를 제어하기 위한 매개변수입니다.</p><p>높은 classifier guidance를 사용하면 확산 모델에 의해 생성된 이미지가 극단적이거나 모호하지 않은 예시 쪽으로 편향됩니다.<br>모델에게 고양이를 요청하면 모델은 명백히 고양이이고 다른 것은 없는 이미지를 반환합니다.</p><p>classifier guidance scale 지침을 얼마나 밀접하게 준수하는지 제어합니다.<br>위 그림에서 오른쪽 샘플링은 중간 샘플링보다 분류자 안내 척도가 더 높습니다.<br>실제로 이 척도 값은 해당 레이블이 있는 데이터에 대한 드리프트 항의 승수일 뿐입니다.</p><h2 id="Classifier-free-guidance-분류자-없는-지침"><a href="#Classifier-free-guidance-분류자-없는-지침" class="headerlink" title="Classifier-free guidance(분류자 없는 지침)"></a>Classifier-free guidance(분류자 없는 지침)</h2><p>classifier guidance은 기록적인 성능을 달성했지만 해당 지침을 제공하려면 추가 모델이 필요합니다.<br>이로 인해 훈련에 약간의 어려움이 생겼습니다. Classifier-free guidance는 classifier guidance를  classifier 없이  달성하는 방법입니다.<br>지침을 위해 클래스 레이블과 별도의 모델을 사용하는 대신,<br>텍스트-이미지에서 논의한 것과 똑같은 이미지 캡션을 사용하고 조건부 확산 모델을 학습할 것을 제안했습니다.</p><p>classifier-free guidance scale (CFG scale)는 텍스트 프롬프트가 확산 과정을 얼마나 조정하는지 제어하는 값입니다.<br>CFG 스케일이 0으로 설정되면 AI 이미지 생성은 조건이 적용되지 않습니다 (즉, 프롬프트가 무시됩니다).<br>CFG 스케일이 높을수록 확산이 프롬프트 쪽으로 조정됩니다. 이 값은 일반적으로 7.0에서 13.0 사이의 값을 가집니다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a></li><li><a href="https://arxiv.org/abs/2207.12598">Classifier-Free Diffusion Guidance</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-Classifier_Free_Guidance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장: 리팩터링 리팩터링하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/</guid>
      <pubDate>Thu, 21 Dec 2023 01:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 책에서 소개된 규칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다섯중 제한&lt;/li&gt;
&lt;li&gt;호출 또는 전달 한가지만 할것&lt;/li&gt;
&lt;li&gt;if문은 함수의 시작에만 배치&lt;/li&gt;
&lt;li&gt;if문은 else를 사용하지 말것&lt;/li&gt;
&lt;li&gt;switch를 사용하지 말것
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이 책에서 소개된 규칙</p><ul><li>다섯중 제한</li><li>호출 또는 전달 한가지만 할것</li><li>if문은 함수의 시작에만 배치</li><li>if문은 else를 사용하지 말것</li><li>switch를 사용하지 말것</li><li>인터페이스에서만 상속 받을것</li><li>순수 조건 사용</li><li>구현체가 하나뿐인 인터페이스를 만들지 말것</li><li>getter&#x2F;setter를 사용하지 말것</li><li>공통 접사를 사용하지 말것</li></ul><h1 id="1장-리팩터링-리팩터링하기"><a href="#1장-리팩터링-리팩터링하기" class="headerlink" title="1장: 리팩터링 리팩터링하기"></a>1장: 리팩터링 리팩터링하기</h1><p>코드 스멜과 단위테스트를 가지고 리팩터링을 학습하는 방법은 진입 장벽이 너무 높다</p><h2 id="리팩터링이란-무엇인가"><a href="#리팩터링이란-무엇인가" class="headerlink" title="리팩터링이란 무엇인가?"></a>리팩터링이란 무엇인가?</h2><p>기능을 변경하지 않고 코드를 변경하는것</p><p>리팩터링을 해야 하는 이유</p><ul><li>코드를 더 빠르게 만들기 위해</li><li>더 작은 코드를 만들기 위해</li><li>코드를 더 일반적이거나 재사용 가능하게 하기 위해</li><li>코드의 가독성을 높이고 유지보수를 용이하게 하기 위해</li></ul><p>좋은코드 - 사람이 읽기 쉽고 유지보수가 용이하며 의도한 대로 잘 동작하는 코드</p><h2 id="스킬-무엇을-리팩터링할-것인가"><a href="#스킬-무엇을-리팩터링할-것인가" class="headerlink" title="스킬: 무엇을 리팩터링할 것인가?"></a>스킬: 무엇을 리팩터링할 것인가?</h2><p>리팩터링은 코드 스멜과 함꼐 가르친다 하지마 코드스멜은 보는 감각을 키우는데 시간이 걸린다</p><h2 id="문화-리팩터링은-언제-할까"><a href="#문화-리팩터링은-언제-할까" class="headerlink" title="문화: 리팩터링은 언제 할까?"></a>문화: 리팩터링은 언제 할까?</h2><p>리팩터링은 샤워와 같다 - 켄트 백</p><p>탐색 - 명세화 - 구현 - 테스트 - 리팩터링 - 전달</p><h3 id="레거시-시스템에서의-리팩터링"><a href="#레거시-시스템에서의-리팩터링" class="headerlink" title="레거시 시스템에서의 리팩터링"></a>레거시 시스템에서의 리팩터링</h3><p>우선 변경하기 쉽게 만든 후 변경 하라 - 켄트 백</p><h3 id="언제-리팩터링을-하지-말아야-할까"><a href="#언제-리팩터링을-하지-말아야-할까" class="headerlink" title="언제 리팩터링을 하지 말아야 할까?"></a>언제 리팩터링을 하지 말아야 할까?</h3><ul><li>한 번 실행하고 삭제할 코드 - xp 에서 스파이크로 알려진것</li><li>폐기되기 전 유지보수 모드에 있는 코드</li><li>임베디드 시스템이나 게임의 고급 물리엔진과 같인 엄격한 성능 요구사항이 있는 코드</li></ul><h2 id="도구-안전한-리팩터링-방법"><a href="#도구-안전한-리팩터링-방법" class="headerlink" title="도구: (안전한) 리팩터링 방법"></a>도구: (안전한) 리팩터링 방법</h2><ul><li>레시피처럼 상세하고 단계별로 구조화된 리팩터링 패턴</li><li>버전관리</li><li>컴파일러</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-21-five_lines_of_code_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>12장: 데이터 시스템의 미래</title>
      <link>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/</guid>
      <pubDate>Mon, 18 Dec 2023 06:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;파생-데이터&quot;&gt;&lt;a href=&quot;#파생-데이터&quot; class=&quot;headerlink&quot; title=&quot;파생 데이터&quot;&gt;&lt;/a&gt;파생 데이터&lt;/h1&gt;&lt;h2 id=&quot;12장-데이터-시스템의-미래&quot;&gt;&lt;a href=&quot;#12장-데이터-시스템의-미래&quot; class
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="파생-데이터"><a href="#파생-데이터" class="headerlink" title="파생 데이터"></a>파생 데이터</h1><h2 id="12장-데이터-시스템의-미래"><a href="#12장-데이터-시스템의-미래" class="headerlink" title="12장: 데이터 시스템의 미래"></a>12장: 데이터 시스템의 미래</h2><h3 id="데이터-통합"><a href="#데이터-통합" class="headerlink" title="데이터 통합"></a>데이터 통합</h3><p>문제가 주어졌을때 모든 문제를 만족하는 하나의 해결책은 없지만 상황에 따라 적절한 서로 다른 접근법이 많이 있다</p><ul><li>파생 데이터에 특화된 도구의 결합<ul><li>포스트그레스큐엘 같은 디비는 간단한 애플리케이션 만들기에 충분한 전문 색인 기능이 포함되어 있지만 더 복잡한 검색 기능을 지원하기 위해서는 전문적인 정보 탐색 도구가 필요하다</li><li>데이터 통합은 나무가 아닌 숲을 보기 위해 줌아웃해서 조직 전체 데이터플로를 고려할때 명확해진다<ul><li>데이터플로에 대한 추론<ul><li>같은 데이터의 사본을 여러 저장소 시스템에 유지해야 할때 입력가 출력을 분명히 할 필요가 있다</li></ul></li><li>파생 데이터 대 분산 트랜잭션<ul><li>서로 다른 데이터 시스템 간 일관성을 유지하는 고전적인 방법은 원자적 커밋가 2단계 커밋에서 설명한 분산트랜잭션이다</li><li>추상적인 수준으로 보면 파생 데이터와 분산 트랜잭션은 다른 방식으로 유사한 목표를 달성한다</li></ul></li><li>전체 순서화의 제약<ul><li>충분히 작은 시스템에서 이벤트 로그의 순서 전체를 보장하는 것은 가능하다 하지만 규모가 커지고 더 복잡한 작업부하가 발생함에 따라 한계가 드러나기 시작한다</li><li>이벤트의 전체 순서를 결정하는것 - 전체 순서 브로드캐스트</li></ul></li><li>인과성 획득을 위한 이벤트 순서화<ul><li>이벤트 인과성이 미묘한 방식으로 발생하기도 한다</li></ul></li></ul></li></ul></li><li>일괄 처리와 스트림 처리<ul><li>데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것</li><li>입력을 소비 형태로 바꾸고 필터링하고 집계해 모델을 학습하고 평가한 뒤 마지막에는 적절한 출력으로 기록</li><li>일괄 처리자와 스트림은 이 목표를 달성하기 위한 도구</li><li>파생 상태 유지<ul><li>일괄 처리는 함수형 프로그래밍 언어로 코드를 작성하지 않아도 상당히 강력한 함수형 특징을 가진다</li><li>일괄 처리는 결정적이고 출력이 입력에만 의존하며 명시적 출력 외에는 다른 부수 효과가 없는 순수함수를 장려하며 입력을 불변으로 간주하고 출력은 추가 전용으로만 사용된다</li></ul></li><li>애플리케이션 발전을 위한 데이터 재처리<ul><li>파생데이터를 유지할 때 일괄 처리와 스트림 처리 모두 유용한다</li><li>스트림 처리를 사용하면 입력의 변화를 빠르게 파생 뷰에 반영할수 있다</li><li>일괄 처리 시스템을 이용하면 누적된 상당한 양의 과거 데이터를 재처리에 기존 데이터셋에 반영할수 있다</li></ul></li><li>람다 아키텍처<ul><li>입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터셋에 추가하는 방식으로 기록해야 한다는것으로 이벤트 소싱과 유사하다</li><li>일괄 처리는 간단해서 버그가 생길 가능성이 적은 반면 스트림 처리자는 신뢰성이 떨어지고 내결함성을 확보하기 어렵다는 것이다</li></ul></li><li>일괄 처리와 스트림 처리의 통합<ul><li>한 시스템에서 일괄 처리와 스트림 처리를 통합하는 작업이 진행 되고 있다</li></ul></li></ul></li></ul><h3 id="데이터베이스-언번들링"><a href="#데이터베이스-언번들링" class="headerlink" title="데이터베이스 언번들링"></a>데이터베이스 언번들링</h3><p>유닉스와 관계형 데이터베이스는 정보 관리 문제를 각기 매우 다른 유사점과 차이점은 탐구할 가치가 있다.</p><ul><li><p>데이터 저장소 기술 구성하기</p><ul><li>테이터 베이스가 제공하는 다양한 기능<ul><li>색인 생성 하기<ul><li>트랜젝션이 테이블에 쓸 때 마다 꾸준히 색인에 반영</li></ul></li><li>모든 것의 메타데이터베이스<ul><li>전체 조직의 데이터플로가 거대한 데이터베이스</li><li>연합 데이터베이스 : 읽기를 통합</li><li>언번들링 데이터베이스 : 쓰기를 통합</li></ul></li><li>언번들링이 동작하게 만들기<ul><li>신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 시스템을 만든다는 측면 에서 연합과 언번들링은 동전의 양면과 같다</li><li>쓰기 동기화는 읽기 동기화 보다 어렵다</li><li>로그기반통합은 느슨한 결합이다</li></ul></li><li>언번들링 대 통합 시스템<ul><li>언번들링은 단일 소프트웨어로 가능한것 보다 더 넓은 범위의 문제를 해결하기 위한 방법이다</li></ul></li><li>뭐가 빠졌지?<ul><li>미분 데이터플로(differential dataflow)</li></ul></li></ul></li></ul></li><li><p>데이터플로 주변 애플리케이션 설계</p><ul><li>파생 함수로서의 애플리케이션 코드<ul><li>트리거, 스토어드 프로시저, 사용자정의함수</li></ul></li><li>애플리케이션 코드와 상태의 분리<ul><li>웹 어플리케이션이 상태 비저장 서비스로 배포된다 하지만 상태는 데이터베이스에 저장한다</li><li>관찰자 패턴(observer pattern) : 상태를 관찰하는 코드와 상태를 변경하는 코드를 분리하는 방법</li></ul></li><li>데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용</li><li>스트림 처리자와 서비스<ul><li>스트림 연산자로 데이터플로 스스템을 구성하는 것은 마이크로서비스 접근법가 유사한 특징이 상당히 많다</li></ul></li></ul></li><li><p>파생 상태 관찰하기</p><ul><li>쓰기 경로(Write path) : 데이터베이스에 데이터를 쓰는 경로</li><li>읽기 경로(Read path) : 데이터베이스에서 데이터를 읽는 경로</li><li>구체화 뷰 와 캐싱<ul><li>공통 질의 캐시</li></ul></li><li>오프라인 대응 가능한 상태 저장 클라이언트<ul><li>오프라인 우선(offine-first) 애플리케이션</li></ul></li><li>상태 변경을 클라이언트에게 푸시 하기<ul><li>각 장치는 작은 이벤트 스트림을 구독하는 작은 구독자</li></ul></li><li>종단간 이벤트 스트림<ul><li>데이터 시스템을 설계한다면 현재 상태를 단지 질의하는 방식이 아니라 변경 사항을 구독하는 방식을 염두에 뒤야 한다</li></ul></li><li>읽기도 이벤트다<ul><li>지속성 있는 저장소에 읽기 이벤트를 기록하면 인과적 의존성을 추적하기가 더 용이하다</li></ul></li><li>다중 파티션 데이터 처리<ul><li>질의를 스트림으로 간주하면 기성 솔루션의 한계를 넘어서는 대규모 애플리케이션을 구현하는 방안<h3 id="정확성을-목표로"><a href="#정확성을-목표로" class="headerlink" title="정확성을 목표로"></a>정확성을 목표로</h3></li></ul></li></ul></li></ul><p>모두가 신뢰성있고 정확한 애플리케이션을 구축하기를 원한다</p><p>전통적인 트랜잭션 접근법이 사라지고 있지는 않지만 나는 이것이 최후에 방법이라 생각하지 않는다</p><ul><li>데이터베이스에 관한 종단 간 논증<ul><li>불변성이 유용하긴 해도 그 자체가 만능은 아니다</li><li>연산자의 정확히 한 번 실행<ul><li>정확히 한번(또는 결과적으로 한 번)</li><li>연산을 멱등으로 만드는 법</li></ul></li><li>중복 억제</li><li>연산 식별자</li><li>종단 간 논증<ul><li>종단 간 논증(end-to-end argument) : 시스템의 모든 부분이 신뢰성을 보장하는 것은 아니며 신뢰성을 보장하는 것은 시스템의 최종 목표이다</li></ul></li><li>종단 간 사고를 데이터 시스템에 적용하기<ul><li>트랜잭션은 오랜 기간 매우 휼륭한 추상화로 간주됐고 아직도 유용하다고 나는 믿는다</li></ul></li></ul></li><li>제약 조건 강제하기<ul><li>유일성 제약조건은 합의가 필요하다</li><li>로그 기반 메시징의 유일성<ul><li>전체 순서 브로드캐스트(total order broadcast) : 모든 메시지가 동일한 순서로 전달되는 것을 보장</li></ul></li><li>다중 파티션 요청 처리</li></ul></li><li>적시성과 무결성<ul><li>일관성<ul><li>적시성 : 시스템의 상태가 얼마나 최신인지를 나타내는 척도</li><li>무결성 : 시스템의 상태가 얼마나 정확한지를 나타내는 척도</li></ul></li><li>데이터플로 시스템의 정확성<ul><li>ACID 트랜잭션은 대개 적시성 과 무결성을 보장한다</li><li>정확히 한번이나 결과적으로 한 번 시맨틱은 무결성을 보존하는 매커니즘이다</li></ul></li><li>느슨하게 해석되는 제약 조건</li><li>코디네이션 회피 데이터 시스템</li></ul></li><li>믿어라. 하지만 확인하라.<ul><li>소프트웨어 버그가 발생해도 무결성 유지하기</li><li>약속을 맹목적으로 믿지 마라</li><li>검증하는 문화</li><li>감사 기능 설계</li><li>다시 종단 간 논증</li><li>감사 데이터 시스템용 도구</li></ul></li></ul><h3 id="옳은-일-하기"><a href="#옳은-일-하기" class="headerlink" title="옳은 일 하기"></a>옳은 일 하기</h3><p>ACM 소프트웨어 공학 윤리 강령</p><ul><li>예측 분석<ul><li>편견과 차별</li><li>책임과 의무</li><li>피드백 루프</li></ul></li><li>사생활과 추적<ul><li>감시<ul><li>감시 중심 애플리케이션 설계</li></ul></li><li>동의와 선택의 자유</li><li>사생활 데이터 사용</li><li>자산 권력으로서의 데이터</li><li>산업 혁명의 기억</li><li>법률과 자기 규제</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>엔지니어는 우리가 원하는 세상 즉 사람이 사람답게 존중 받는 세상을 위해 일할 책임이 있음을 기억해야 한다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-18-Designing_Data_Intensive_Applications_chapter12/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
