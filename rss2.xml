<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Mon, 22 Jan 2024 01:22:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CHAPTER 2 현실에서의 함수형 사고</title>
      <link>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/</guid>
      <pubDate>Mon, 22 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-2-현실에서의-함수형-사고&quot;&gt;&lt;a href=&quot;#CHAPTER-2-현실에서의-함수형-사고&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 2 현실에서의 함수형 사고&quot;&gt;&lt;/a&gt;CHAPTER 2 현실에서의 함수형 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-2-현실에서의-함수형-사고"><a href="#CHAPTER-2-현실에서의-함수형-사고" class="headerlink" title="CHAPTER 2 현실에서의 함수형 사고"></a>CHAPTER 2 현실에서의 함수형 사고</h1><h2 id="토니-피자에-오신-것을-환영합니다"><a href="#토니-피자에-오신-것을-환영합니다" class="headerlink" title="토니 피자에 오신 것을 환영합니다"></a>토니 피자에 오신 것을 환영합니다</h2><p>계층형 설계(stratifed design)원칙이 어떤것인지 알아 본다</p><p>분산시스템을 이해 하려고 타임라인 다이어그램(timeline diagram)을 사용</p><h2 id="파트-I-액션과-계산-데이터"><a href="#파트-I-액션과-계산-데이터" class="headerlink" title="파트 I: 액션과 계산, 데이터"></a>파트 I: 액션과 계산, 데이터</h2><ul><li>액션: 호출 횟수와 시점에 의존하는 것</li><li>계산: 어떤 것을 결정하거나 계획하는 것은 계산 입니다</li><li>데이터: 유연하기 때문에 저장하거나 네트워크로 전송하는 등 다양하게 쓸 수 있다</li></ul><h2 id="변경-가능성에-따라-코드-나누기"><a href="#변경-가능성에-따라-코드-나누기" class="headerlink" title="변경 가능성에 따라 코드 나누기"></a>변경 가능성에 따라 코드 나누기</h2><p>계층형설계는 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눕니다</p><h2 id="파트-II-일급-추상"><a href="#파트-II-일급-추상" class="headerlink" title="파트 II: 일급 추상"></a>파트 II: 일급 추상</h2><p>타임라인 다이어 그램은 로봇 한대가 피가를 만들기 위한 액션들을 보여 줍니다</p><h2 id="분산-시스템을-타임라인으로-시각화하기"><a href="#분산-시스템을-타임라인으로-시각화하기" class="headerlink" title="분산 시스템을 타임라인으로 시각화하기"></a>분산 시스템을 타임라인으로 시각화하기</h2><p>분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모른다</p><h2 id="각각의-타임라인은-다른-순서로-실행됩니다"><a href="#각각의-타임라인은-다른-순서로-실행됩니다" class="headerlink" title="각각의 타임라인은 다른 순서로 실행됩니다"></a>각각의 타임라인은 다른 순서로 실행됩니다</h2><p>타입라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다</p><h2 id="어려운-경험을-통해-분산-시스템에-대해-배운-것"><a href="#어려운-경험을-통해-분산-시스템에-대해-배운-것" class="headerlink" title="어려운 경험을 통해 분산 시스템에 대해 배운 것"></a>어려운 경험을 통해 분산 시스템에 대해 배운 것</h2><ul><li>기본적으로 타임라인은 서로 순서를 맞추지 않습니다</li><li>액션이 실행되는 시간은 중요하지 않다</li><li>드물지만 타이밍이 어긋나는 경우는 실제 일어난다</li><li>타임라인 다이어그램으로 시스템의 문제를 알 수 있다</li></ul><h2 id="타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기"><a href="#타임라인-커팅-로봇이-서로를-기다릴-수-있게-하기" class="headerlink" title="타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기"></a>타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기</h2><p>커팅(cutting) : 타임라인의 시간을 맞추는 작업</p><p>타임라인 커팅은 고차동작(higher-order operation)으로 구현 </p><h2 id="좋은-경험을-통해-타임라인에-대해-배운-것"><a href="#좋은-경험을-통해-타임라인에-대해-배운-것" class="headerlink" title="좋은 경험을 통해 타임라인에 대해 배운 것"></a>좋은 경험을 통해 타임라인에 대해 배운 것</h2><ul><li>타임라인 커팅으로 서로 다른 작업들을 쉽게 이해 할 수 있다</li><li>타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다</li><li>타임라인 다이어그램은 유연하다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-22-Grokking_Simplicity_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</title>
      <link>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/</guid>
      <pubDate>Fri, 19 Jan 2024 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot;&gt;&lt;a href=&quot;#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 1 쏙쏙 들어오는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다"><a href="#CHAPTER-1-쏙쏙-들어오는-함수형-코딩에-오신-것을-환영합니다" class="headerlink" title="CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다"></a>CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다</h1><h2 id="함수형-프로그래밍은-무엇인가요"><a href="#함수형-프로그래밍은-무엇인가요" class="headerlink" title="함수형 프로그래밍은 무엇인가요?"></a>함수형 프로그래밍은 무엇인가요?</h2><p>함수형 프로그래밍(functional programming)</p><ul><li>수학 함수를 사용하고 부수 효과(side effect)를 피하는것이 특성인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수(pure function)만 사용하는 프로그래밍 패러다임</li></ul><p>부수 효과(side effect)</p><ul><li>함수가 리턴값 이외에 하는 모든 일을 말한다</li></ul><p>순수 함수(pure function)</p><ul><li>인자에만 의존하고 부수 효과가 없는 함수</li><li>수학 함수라 볼수 있다</li></ul><h2 id="실용적인-측면에서-함수형-프로그래밍-정의의-문제점"><a href="#실용적인-측면에서-함수형-프로그래밍-정의의-문제점" class="headerlink" title="실용적인 측면에서 함수형 프로그래밍 정의의 문제점"></a>실용적인 측면에서 함수형 프로그래밍 정의의 문제점</h2><p>함수형 프로그래밍</p><ul><li>수학 함수를 사용하고 부수 효과를 피하는것이 특징인 프로그래밍 패러다임</li><li>부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일</li></ul><h3 id="문제-1-부수-효과는-필요합니다"><a href="#문제-1-부수-효과는-필요합니다" class="headerlink" title="문제 1. 부수 효과는 필요합니다"></a>문제 1. 부수 효과는 필요합니다</h3><p>부수 효과는 소프트웨어를 실행하는 이유이다</p><h2 id="문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다"><a href="#문제-2-함수형-프로그래밍은-부수-효과를-잘-다룰-수-있습니다" class="headerlink" title="문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다"></a>문제 2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있습니다</h2><p>순수 함수만 쓰라는 것처럼 되어 있지만 순수하지 않은 함수도 사용합니다</p><h2 id="문제-3-함수형-프로그래밍은-실용적이다"><a href="#문제-3-함수형-프로그래밍은-실용적이다" class="headerlink" title="문제 3. 함수형 프로그래밍은 실용적이다"></a>문제 3. 함수형 프로그래밍은 실용적이다</h2><p>함수형 프로그래밍이 수학적이라 실제 소프트웨어 개발에서 사용하지 않는 것 처럼 느껴집니다</p><h2 id="함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기"><a href="#함수형-프로그래밍을-학문적-지식이-아닌-기술과-개념으로-보기" class="headerlink" title="함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기"></a>함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기</h2><p>중요한 기술 </p><ul><li>액션 action</li><li>계산 calculation</li><li>데이터 data</li></ul><h2 id="액션과-계산-데이터-구분하기"><a href="#액션과-계산-데이터-구분하기" class="headerlink" title="액션과 계산, 데이터 구분하기"></a>액션과 계산, 데이터 구분하기</h2><p>함수형 프로그래머는 직감적으로 코드를 세 분류로 나눈다</p><ul><li>액션</li><li>계산</li><li>데이터</li></ul><h2 id="함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다"><a href="#함수형-프로그래머는-부를-때-조심해야-하는-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다"></a>함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다</h2><ul><li>액션: 호출하는 시점과 횟수에 의존한다</li><li>액션이 아닌 코드 : 호출하는 시점과 횟수에 의존하지 않는다</li></ul><h2 id="함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다"><a href="#함수형-프로그래머는-실행하는-코드와-그렇지-않은-코드를-구분합니다" class="headerlink" title="함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다"></a>함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다</h2><p>계산 과 데이터는 둘다 부르는 시점이나 횟수가 중요하지 않다</p><ul><li>데이터 : 정적이고 보이는 그대로</li><li>계산 : 동적이고 보이지 않는다</li></ul><p>함수형 프로그래머는 코드를 액션과 계산 데이터로 구분</p><h2 id="함수형-프로그래머는-액션과-계산-데이터를-구분합니다"><a href="#함수형-프로그래머는-액션과-계산-데이터를-구분합니다" class="headerlink" title="함수형 프로그래머는 액션과 계산, 데이터를 구분합니다"></a>함수형 프로그래머는 액션과 계산, 데이터를 구분합니다</h2><h3 id="1단계-사용자가-작업-완료-표시를-함"><a href="#1단계-사용자가-작업-완료-표시를-함" class="headerlink" title="1단계: 사용자가 작업 완료 표시를 함"></a>1단계: 사용자가 작업 완료 표시를 함</h3><p>UI 이벤트인데 실행 횟수에 의존하기 때문에 액션입니다</p><h3 id="2단계-클라이언트가-서버로-메시지를-보냄"><a href="#2단계-클라이언트가-서버로-메시지를-보냄" class="headerlink" title="2단계: 클라이언트가 서버로 메시지를 보냄"></a>2단계: 클라이언트가 서버로 메시지를 보냄</h3><p>메시지를 보내는것도 액션이다<br>메시지 자체는 나중에 서버에서 해석해야 되는 값이기 때문에 데이터다</p><h3 id="3단계-서버가-메시지를-받음"><a href="#3단계-서버가-메시지를-받음" class="headerlink" title="3단계: 서버가 메시지를 받음"></a>3단계: 서버가 메시지를 받음</h3><p>메시지를 받는 횟수에 의존하므로 액션</p><h3 id="4단계-서버가-데이터-베이스를-변경"><a href="#4단계-서버가-데이터-베이스를-변경" class="headerlink" title="4단계: 서버가 데이터 베이스를 변경"></a>4단계: 서버가 데이터 베이스를 변경</h3><p>내부 상태를 바꾸는 것은 액션</p><h3 id="5단계-서버가-누구에서-알림을-보낼지-결정"><a href="#5단계-서버가-누구에서-알림을-보낼지-결정" class="headerlink" title="5단계: 서버가 누구에서 알림을 보낼지 결정"></a>5단계: 서버가 누구에서 알림을 보낼지 결정</h3><p>결정하는 것은 계산이다. 입력값이 같다면 서버는 항상 같은 결정을 내리기 때문</p><h3 id="6단계-서버가-이메일로-알림을-보냄"><a href="#6단계-서버가-이메일로-알림을-보냄" class="headerlink" title="6단계: 서버가 이메일로 알림을 보냄"></a>6단계: 서버가 이메일로 알림을 보냄</h3><p>이메일 보내기는 액션</p><h2 id="함수형-프로그래밍에서는-코드를-세-가지로-분류합니다"><a href="#함수형-프로그래밍에서는-코드를-세-가지로-분류합니다" class="headerlink" title="함수형 프로그래밍에서는 코드를 세 가지로 분류합니다"></a>함수형 프로그래밍에서는 코드를 세 가지로 분류합니다</h2><ul><li>액션<ul><li>호출하는 시점과 횟수에 둘다 의존한다</li></ul></li><li>계산<ul><li>입력값을 출력값으로 만드는 것</li></ul></li><li>데이터<ul><li>이벤트에 대해 기록한 사실<h2 id="액션-계산-데이터를-구분하면-어떤-장점이-있나요"><a href="#액션-계산-데이터를-구분하면-어떤-장점이-있나요" class="headerlink" title="액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?"></a>액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?</h2>요즘 유행하는 분산 시스템에 잘 어울린다</li></ul></li></ul><p>시간에 따라 바뀌는 값을 모델링 할때 동작 방법을 이해하는 것은 중요하지만 쉽지 않다<br>실행시점이나 횟수에 의존하는 코드를 없애면 코드를 더 쉽게 이해할수 있고 심각한 버그를 막을수 있다</p><p>데이터와 계산은 실행 시점이나 횟수에 의존하지 않는다</p><p>액션은 실행시점이나 횟수에 의존하지만 코드 전체에 영향을 주지 않도록 격리시키면 된다</p><h2 id="함수형-사고가-무엇인가요"><a href="#함수형-사고가-무엇인가요" class="headerlink" title="함수형 사고가 무엇인가요?"></a>함수형 사고가 무엇인가요?</h2><p>함수형 사고(functional thinking)</p><ul><li>액션, 계산, 데이터</li><li>일급 추상</li></ul><h2 id="이-책을-읽는-기본-규칙"><a href="#이-책을-읽는-기본-규칙" class="headerlink" title="이 책을 읽는 기본 규칙"></a>이 책을 읽는 기본 규칙</h2><ul><li>특정 언어 기능에 의존하지 않아야 한다</li><li>실용적이라 바로 쓸 수 있어야 한다</li><li>여러분의 현재 가지고 있는 코드와 관계 없이 쓸 수 있어야 된다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://www.yes24.com/Product/Goods/108748841">쏙쏙 들어오는 함수형 코딩(심플한 코드로 복잡한 소프트웨어 길들이기)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-19-Grokking_Simplicity_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장. 단위 테스트 안티 패턴</title>
      <link>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/</guid>
      <pubDate>Thu, 18 Jan 2024 01:39:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-단위-테스트-안티-패턴&quot;&gt;&lt;a href=&quot;#11장-단위-테스트-안티-패턴&quot; class=&quot;headerlink&quot; title=&quot;11장. 단위 테스트 안티 패턴&quot;&gt;&lt;/a&gt;11장. 단위 테스트 안티 패턴&lt;/h1&gt;&lt;h2 id=&quot;비공개-메서드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-단위-테스트-안티-패턴"><a href="#11장-단위-테스트-안티-패턴" class="headerlink" title="11장. 단위 테스트 안티 패턴"></a>11장. 단위 테스트 안티 패턴</h1><h2 id="비공개-메서드-단위-테스트"><a href="#비공개-메서드-단위-테스트" class="headerlink" title="비공개 메서드 단위 테스트"></a>비공개 메서드 단위 테스트</h2><p>전혀 하지 말아야 된다</p><h3 id="비공개-메서드와-테스트-취약성"><a href="#비공개-메서드와-테스트-취약성" class="headerlink" title="비공개 메서드와 테스트 취약성"></a>비공개 메서드와 테스트 취약성</h3><p>단위 테스트를 하려고 비공개 메서드를 노출하는 경우에는 식별할수 있는 동작만 테스트하는 것을 위반한다</p><h3 id="비공개-메서드와-불필요한-커버리지"><a href="#비공개-메서드와-불필요한-커버리지" class="headerlink" title="비공개 메서드와 불필요한 커버리지"></a>비공개 메서드와 불필요한 커버리지</h3><ul><li>죽은 코드다</li><li>추상화가 누락되어 있다</li></ul><h3 id="비공개-메서드-테스트가-타당한-경우"><a href="#비공개-메서드-테스트가-타당한-경우" class="headerlink" title="비공개 메서드 테스트가 타당한 경우"></a>비공개 메서드 테스트가 타당한 경우</h3><p>비공개 메서드를 테스트하는 것 자체는 나쁘지 않다<br>비공개 메서드가 구현 세부사항의 프록시에 해당하므로 나쁜것</p><h2 id="비공개-상태-노출"><a href="#비공개-상태-노출" class="headerlink" title="비공개 상태 노출"></a>비공개 상태 노출</h2><p>안티패턴으로 단위 테스트 목적만으로 비공개 상태를 노출하는것이 있다</p><p>테스트 유의성을 위해 공개 API의 노출 영역을 넓히는 것은 좋지 않은 습관이다</p><h2 id="테스트로-유출된-도메인-지식"><a href="#테스트로-유출된-도메인-지식" class="headerlink" title="테스트로 유출된 도메인 지식"></a>테스트로 유출된 도메인 지식</h2><p>도메인 지식을 테스트로 유출하는 것은 또하나의 흔한 안티 패턴</p><h2 id="코드-오염"><a href="#코드-오염" class="headerlink" title="코드 오염"></a>코드 오염</h2><p>테스트에만 필요한 제품 코드를 추가하는것</p><h2 id="구체-클래스를-목으로-처리하기"><a href="#구체-클래스를-목으로-처리하기" class="headerlink" title="구체 클래스를 목으로 처리하기"></a>구체 클래스를 목으로 처리하기</h2><p>일부 기능을 지키려고 구체 클래스를 목으로 처리해야 하면 이는 단일 책임 원칙을 위한하는 결과다</p><h2 id="시간-처리하기"><a href="#시간-처리하기" class="headerlink" title="시간 처리하기"></a>시간 처리하기</h2><p>시간에 따라 달라지는 기능을 테스트하면 거짓 양성이 발생할 수 있다</p><h3 id="앰비언트-컨텍스트로서의-시간"><a href="#앰비언트-컨텍스트로서의-시간" class="headerlink" title="앰비언트 컨텍스트로서의 시간"></a>앰비언트 컨텍스트로서의 시간</h3><p>로거 기능과 마찬가지로 시간을 엠비언트 컨텍스트로 사용하는것도 안티 패턴이다</p><h3 id="명시적-의존성으로서의-시간"><a href="#명시적-의존성으로서의-시간" class="headerlink" title="명시적 의존성으로서의 시간"></a>명시적 의존성으로서의 시간</h3><p>더나은 방법으로 시간의존성을 명시적으로 주입하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-18-unit_testing_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장. 데이터베이스 테스트</title>
      <link>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/</guid>
      <pubDate>Wed, 17 Jan 2024 01:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-데이터베이스-테스트&quot;&gt;&lt;a href=&quot;#10장-데이터베이스-테스트&quot; class=&quot;headerlink&quot; title=&quot;10장. 데이터베이스 테스트&quot;&gt;&lt;/a&gt;10장. 데이터베이스 테스트&lt;/h1&gt;&lt;p&gt;통합 테스트라는 퍼즐의 마지막 조각은
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-데이터베이스-테스트"><a href="#10장-데이터베이스-테스트" class="headerlink" title="10장. 데이터베이스 테스트"></a>10장. 데이터베이스 테스트</h1><p>통합 테스트라는 퍼즐의 마지막 조각은 프로세스 외부 관리 의존성이다. 가장 일반적인 예는 애플리케이션 데이터베이스다</p><p>실제 데이터베이스를 테스트하면 회귀 방지가 아주 뛰어나지만 설정하기 쉽지 않다</p><h2 id="데이터베이스-테스트를-위한-전제-조건"><a href="#데이터베이스-테스트를-위한-전제-조건" class="headerlink" title="데이터베이스 테스트를 위한 전제 조건"></a>데이터베이스 테스트를 위한 전제 조건</h2><ul><li>형상 관리 시스템에 데이터베이스 유지</li><li>개발자마다 별도의 데이터베이스 인스턴스 사용</li><li>데이터베이스 배포에 마이그레이션 기반 방식 적용</li></ul><h3 id="데이터베이스를-형상-관리-시스템에-유지"><a href="#데이터베이스를-형상-관리-시스템에-유지" class="headerlink" title="데이터베이스를 형상 관리 시스템에 유지"></a>데이터베이스를 형상 관리 시스템에 유지</h3><p>데이터베이스 스키마를 일반 코드로 취급하는것 </p><p>모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다</p><ul><li>변경 내역 부재</li><li>복수의 원천 정보</li></ul><h3 id="참조-데이터도-데이터베이스-스키마다"><a href="#참조-데이터도-데이터베이스-스키마다" class="headerlink" title="참조 데이터도 데이터베이스 스키마다"></a>참조 데이터도 데이터베이스 스키마다</h3><p>참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터다.</p><p>참조 데이터와 일반데이터를 구별할 수 있는 간단한 방법이 있다 애플리케이션이 데이터를 수정할 수 있으면 일반데이터고 그렇지 않으면 참조 데이터다.</p><h3 id="모든-개발자를-위한-별도의-데이터베이스-인스턴스"><a href="#모든-개발자를-위한-별도의-데이터베이스-인스턴스" class="headerlink" title="모든 개발자를 위한 별도의 데이터베이스 인스턴스"></a>모든 개발자를 위한 별도의 데이터베이스 인스턴스</h3><p>공유 데이터베이스를 사용하면 개발 프로세스를 방해 하게 된다</p><ul><li>서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문이다</li><li>하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있다</li></ul><p>테스트 실행 속도를 극대화 하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하라</p><h3 id="상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포"><a href="#상태-기반-데이터베이스-배포와-마이그레이션-기반-데이터베이스-배포" class="headerlink" title="상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포"></a>상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포</h3><p>데이터베이스 배포 방식</p><ul><li>상태기반<ul><li>상태를 형상 관리에 저장함으로써 상태를 명시하고 비교도구가 마이그레이션을 암묵적으로 제어할 수 있게 한다</li></ul></li><li>마이그레이션 기반<ul><li>마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다</li></ul></li></ul><p>결과적으로 상태 기반 방식은 대다수의 프로젝트에서 실용적이지 않다</p><h2 id="데이터베이스-트랜잭션-관리"><a href="#데이터베이스-트랜잭션-관리" class="headerlink" title="데이터베이스 트랜잭션 관리"></a>데이터베이스 트랜잭션 관리</h2><h3 id="제품-코드에서-데이터베이스-트랜잭션-관리하기"><a href="#제품-코드에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="제품 코드에서 데이터베이스 트랜잭션 관리하기"></a>제품 코드에서 데이터베이스 트랜잭션 관리하기</h3><h3 id="통합-테스트에서-데이터베이스-트랜잭션-관리하기"><a href="#통합-테스트에서-데이터베이스-트랜잭션-관리하기" class="headerlink" title="통합 테스트에서 데이터베이스 트랜잭션 관리하기"></a>통합 테스트에서 데이터베이스 트랜잭션 관리하기</h3><p>테스트에서 트랜젝션이나 작업 단위를 재사용하지 말라</p><h2 id="테스트-데이터-생명-주기"><a href="#테스트-데이터-생명-주기" class="headerlink" title="테스트 데이터 생명 주기"></a>테스트 데이터 생명 주기</h2><ul><li>통합 테스트를 순차적으로 실행하라</li><li>테스트 실행 간에 남은 데이터를 제거하라</li></ul><h3 id="병렬-테스트-실행과-순차적-테스트-실행"><a href="#병렬-테스트-실행과-순차적-테스트-실행" class="headerlink" title="병렬 테스트 실행과 순차적 테스트 실행"></a>병렬 테스트 실행과 순차적 테스트 실행</h3><p>컨테이너를 사용해 테스트를 병렬로 실행시킬수 있다</p><p>단점은</p><ul><li>도커 이미지를 유지 보수해야함</li><li>각 테스트마다 컨테이너 인스턴스가 있는지 확인해야 함</li><li>통합 테스트를 일괄 처리하고</li><li>다 사용한 컨테이너는 폐기해야 한다</li></ul><p>통합 테스트의 실행 시간을 최소화 해야 하는 경우가 아니라면 컨테이너를 사용하지 않는 것이 좋다</p><p>데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 더 실용적이다</p><h3 id="테스트-실행-간-데이터-정리"><a href="#테스트-실행-간-데이터-정리" class="headerlink" title="테스트 실행 간 데이터 정리"></a>테스트 실행 간 데이터 정리</h3><ul><li>각 테스트 전에 데이터베이스 백업 복원하기</li><li>테스트 종료 시점에 데이터 정리하기</li><li>데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기</li><li>테스트 시작 시점에 데이터 정리하기</li></ul><h3 id="인메모리-데이터베이스-피하기"><a href="#인메모리-데이터베이스-피하기" class="headerlink" title="인메모리 데이터베이스 피하기"></a>인메모리 데이터베이스 피하기</h3><p>인메모리 데이터베이스의 장점</p><ul><li>테스트 데이터를 제거할 필요가 없음</li><li>작업 속도 향상</li><li>테스트가 실행될 때마다 인스턴스화 가능</li></ul><p>하지만 기능적 일관성이 없기 때문에 사용하지 않는것이 좋다</p><h2 id="테스트-구절에서-코드-재사용하기"><a href="#테스트-구절에서-코드-재사용하기" class="headerlink" title="테스트 구절에서 코드 재사용하기"></a>테스트 구절에서 코드 재사용하기</h2><p>통합 테스트가 너무 빨리 커지면 유지 보수 지표가 나빠질 수 있다</p><h3 id="준비-구절에서-코드-재사용하기"><a href="#준비-구절에서-코드-재사용하기" class="headerlink" title="준비 구절에서 코드 재사용하기"></a>준비 구절에서 코드 재사용하기</h3><p>오브젝트 마더(Object Mother) 패턴</p><p>테스트 데이터 빌더(Test Data Builder) 패턴</p><h3 id="실행-구절에서-코드-재사용하기"><a href="#실행-구절에서-코드-재사용하기" class="headerlink" title="실행 구절에서 코드 재사용하기"></a>실행 구절에서 코드 재사용하기</h3><p>대리자(Delegate) 패턴을 활용해서 실행구절을 줄일수 있따</p><h3 id="검증-구절에서-코드-재사용하기"><a href="#검증-구절에서-코드-재사용하기" class="headerlink" title="검증 구절에서 코드 재사용하기"></a>검증 구절에서 코드 재사용하기</h3><p>플루언트 인터페이스를 사용하면 검증문이 읽기 쉬워진다</p><h3 id="테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가"><a href="#테스트가-데이터베이스-트랜잭션을-너무-많이-생성하는가" class="headerlink" title="테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?"></a>테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?</h3><p>빠른 피드백과 유지 보수성의 절충</p><h2 id="데이터베이스-테스트에-대한-일반적인-질문"><a href="#데이터베이스-테스트에-대한-일반적인-질문" class="headerlink" title="데이터베이스 테스트에 대한 일반적인 질문"></a>데이터베이스 테스트에 대한 일반적인 질문</h2><h3 id="읽기-테스트를-해야-하는가"><a href="#읽기-테스트를-해야-하는가" class="headerlink" title="읽기 테스트를 해야 하는가?"></a>읽기 테스트를 해야 하는가?</h3><p>읽기를 테스트하기로 결정한 경우에는 실제 데이터베이스에서 통합 테스트하라</p><h3 id="리포지터리-테스트를-해야-하는가"><a href="#리포지터리-테스트를-해야-하는가" class="headerlink" title="리포지터리 테스트를 해야 하는가?"></a>리포지터리 테스트를 해야 하는가?</h3><p>리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트의 일부로 취급</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-17-unit_testing_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장. 목 처리에 대한 모범 사례</title>
      <link>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/</guid>
      <pubDate>Tue, 16 Jan 2024 00:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-목-처리에-대한-모범-사례&quot;&gt;&lt;a href=&quot;#9장-목-처리에-대한-모범-사례&quot; class=&quot;headerlink&quot; title=&quot;9장. 목 처리에 대한 모범 사례&quot;&gt;&lt;/a&gt;9장. 목 처리에 대한 모범 사례&lt;/h1&gt;&lt;p&gt;목은 테스트 대
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-목-처리에-대한-모범-사례"><a href="#9장-목-처리에-대한-모범-사례" class="headerlink" title="9장. 목 처리에 대한 모범 사례"></a>9장. 목 처리에 대한 모범 사례</h1><p>목은 테스트 대상 시스템과 의존성 간의 상호 작용을 모방하고 검사하는 데 도움이 되는 테스트 대역이다</p><p>목은 비관리 의존성에만 적용해야 된다</p><h2 id="목의-가치를-극대화하기"><a href="#목의-가치를-극대화하기" class="headerlink" title="목의 가치를 극대화하기"></a>목의 가치를 극대화하기</h2><p>비관리 의존성에만 목을 사용하게끔 제한하는 것이 중요하지만 이는 목의 가치를 극대화 하기 위한 첫 번째 단계일 뿐이다</p><h3 id="시스템-끝에서-상호-작용-검증하기"><a href="#시스템-끝에서-상호-작용-검증하기" class="headerlink" title="시스템 끝에서 상호 작용 검증하기"></a>시스템 끝에서 상호 작용 검증하기</h3><p>시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라.</p><h3 id="목을-스파이로-대체하기"><a href="#목을-스파이로-대체하기" class="headerlink" title="목을 스파이로 대체하기"></a>목을 스파이로 대체하기</h3><p>스파이는 목과 같은 목적을 수행하는 테스트 대역이다<br>스파이는 수동으로 작성하는 반면에 목은 목프레임워크의 도움을 받아 생성한다는 것이 유일한 차이점이다</p><p>시스템 끝에 있는 클래스의 경우 스파이가 목보다 낫다</p><h2 id="목-처리에-대한-모범-사례"><a href="#목-처리에-대한-모범-사례" class="headerlink" title="목 처리에 대한 모범 사례"></a>목 처리에 대한 모범 사례</h2><ul><li>비관리 의존성에만 목 적용하기</li><li>시스템 끝에 있는 의존성에 대해 상호 작용 검증하기</li><li>통합 테스트에서만 목을 사용하고 단위 테스트에서는 하지 않기</li><li>항상 목 호출 수 확인하기</li><li>보유 타입만 목으로 처리하기</li></ul><h3 id="목은-통합-테스트만을-위한-것"><a href="#목은-통합-테스트만을-위한-것" class="headerlink" title="목은 통합 테스트만을 위한 것"></a>목은 통합 테스트만을 위한 것</h3><p>비지니스 로직과 오케이스레이션의 분리에서 비롯된다</p><h3 id="테스트당-목이-하나일-필요는-없음"><a href="#테스트당-목이-하나일-필요는-없음" class="headerlink" title="테스트당 목이 하나일 필요는 없음"></a>테스트당 목이 하나일 필요는 없음</h3><p>단위 테스트의 단위는 코드의 단위가 아니라 동작의 단위이다</p><h3 id="호출-횟수-검증하기"><a href="#호출-횟수-검증하기" class="headerlink" title="호출 횟수 검증하기"></a>호출 횟수 검증하기</h3><p>비관리 의존성과의 통신에 관해서 다음 두가지 모두 확인하는 것이 중요하다</p><ul><li>예상하는 호출이 있는가?</li><li>예상치 못한 호출이 있는가?</li></ul><h3 id="보유-타입만-목으로-처리하기"><a href="#보유-타입만-목으로-처리하기" class="headerlink" title="보유 타입만 목으로 처리하기"></a>보유 타입만 목으로 처리하기</h3><p>보유 타입만 목으로 처리하는것</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-16-unit_testing_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장. 통합 테스트를 하는 이유</title>
      <link>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/</guid>
      <pubDate>Fri, 12 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-통합-테스트를-하는-이유&quot;&gt;&lt;a href=&quot;#8장-통합-테스트를-하는-이유&quot; class=&quot;headerlink&quot; title=&quot;8장. 통합 테스트를 하는 이유&quot;&gt;&lt;/a&gt;8장. 통합 테스트를 하는 이유&lt;/h1&gt;&lt;p&gt;단위 테스트에만 전적으
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-통합-테스트를-하는-이유"><a href="#8장-통합-테스트를-하는-이유" class="headerlink" title="8장. 통합 테스트를 하는 이유"></a>8장. 통합 테스트를 하는 이유</h1><p>단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다</p><p>단위 테스트가 비즈니스 로직을 확인하는데 좋지만 비즈니스 로직을 외부와 단절된 상태로 확인하는 것만으로는 충분하지 않다</p><h2 id="통합-테스트는-무엇인가"><a href="#통합-테스트는-무엇인가" class="headerlink" title="통합 테스트는 무엇인가?"></a>통합 테스트는 무엇인가?</h2><h3 id="통합-테스트의-역할"><a href="#통합-테스트의-역할" class="headerlink" title="통합 테스트의 역할"></a>통합 테스트의 역할</h3><p>단위 테스트는 세가지 요구사항을 충족하는 테스트다</p><ul><li>단일 동작 단위를 검증하고</li><li>빠르게 수행하고</li><li>다른 테스트와 별도로 처리한다</li></ul><p>단위테스트가 아닌 모든 테스트는 통합테스트다</p><h3 id="다시-보는-테스트-피라미드"><a href="#다시-보는-테스트-피라미드" class="headerlink" title="다시 보는 테스트 피라미드"></a>다시 보는 테스트 피라미드</h3><p>유지비 증가 이유</p><ul><li>프로세스 외부 의존성 운영이 필요함</li><li>관련된 협력자가 많아서 테스트가 비대해짐</li></ul><p>단위 테스트로 가능한 많이 비즈니스 시나리오의 예외 상황을 확인하고 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룬다</p><h3 id="통합-테스트와-빠른-실패"><a href="#통합-테스트와-빠른-실패" class="headerlink" title="통합 테스트와 빠른 실패"></a>통합 테스트와 빠른 실패</h3><p>통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라<br>상호작용을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가로 작성하라</p><h2 id="어떤-프로세스-외부-의존성을-직접-테스트해야-하는가"><a href="#어떤-프로세스-외부-의존성을-직접-테스트해야-하는가" class="headerlink" title="어떤 프로세스 외부 의존성을 직접 테스트해야 하는가"></a>어떤 프로세스 외부 의존성을 직접 테스트해야 하는가</h2><h3 id="프로세스-외부-의존성의-두-가지-유형"><a href="#프로세스-외부-의존성의-두-가지-유형" class="headerlink" title="프로세스 외부 의존성의 두 가지 유형"></a>프로세스 외부 의존성의 두 가지 유형</h3><ul><li>관리 의존성<ul><li>테스트에서 제어할 수 있는 의존성</li><li>데이터베이스</li></ul></li><li>비관리 의존성<ul><li>테스트에서 제어할 수 없는 의존성</li><li>SMTP 서버</li></ul></li></ul><p>관리 의존성은 실제 인스턴스를 사용하고 비관리 의존성은 목으로 대체하라</p><h3 id="관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기"><a href="#관리-의존성이면서-비관리-의존성인-프로세스-외부-의존성-다루기" class="headerlink" title="관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기"></a>관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기</h3><p>프로세스 외부 의존성(데이터 베이스)</p><p>데이터 베이스와의 상호작용을 검증하지 말고 데이터베이스의 최종 상태를 확인하라</p><h3 id="통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까"><a href="#통합-테스트에서-실제-데이터베이스를-사용할-수-없으면-어떻게-할까" class="headerlink" title="통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?"></a>통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?</h3><p>통합 테스트에서 관리 의존성을 실제 버전으로 사용할 수 없는 경우도 있다</p><p>그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라</p><h2 id="의존성-추상화를-위한-인터페이스-사용"><a href="#의존성-추상화를-위한-인터페이스-사용" class="headerlink" title="의존성 추상화를 위한 인터페이스 사용"></a>의존성 추상화를 위한 인터페이스 사용</h2><h3 id="인터페이스와-느슨한-결합"><a href="#인터페이스와-느슨한-결합" class="headerlink" title="인터페이스와 느슨한 결합"></a>인터페이스와 느슨한 결합</h3><p>인터페이스를 사용하는 이유</p><ul><li>프로세스 외부 의존성을 추상화해 느슨한 결합을 달성</li><li>기존 코드를 변경하지 않고 새로운 기능을 추가해 개방 폐쇄 원칙을 달성</li></ul><p>위에 2가지 이유 모두 오해</p><p>단일 구현을 위한 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다<br>진정한 추상화는 발견하는것이지 발명하는것이 아니다</p><p>YAGNI 원칙을 위반하는 생각이다<br>YAGNI 원칙은 현재 필요하지 않는 기능에 시간을 드리지 말라는 원칙이다</p><ul><li>기회비용</li><li>프로젝트 코드는 적을수록 좋다</li></ul><h3 id="프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가"><a href="#프로세스-외부-의존성에-인터페이스를-사용하는-이유는-무엇인가" class="headerlink" title="프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?"></a>프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?</h3><p>목을 사용하기 위함</p><p>인터페이스가 없으면 테스트 대역을 만들수 없음</p><h2 id="통합-테스트-모범-사례"><a href="#통합-테스트-모범-사례" class="headerlink" title="통합 테스트 모범 사례"></a>통합 테스트 모범 사례</h2><p>통합 테스트를 최대한 활용하는 데 도움이 되는 몇가지 지침</p><ul><li>도메인 모델 경계 명시하기</li><li>애플리케이션 내 계층 줄이기</li><li>순환 의존성 제거하기</li></ul><h3 id="도메인-모델-경계-명시하기"><a href="#도메인-모델-경계-명시하기" class="headerlink" title="도메인 모델 경계 명시하기"></a>도메인 모델 경계 명시하기</h3><p>항상 도메인 모델을 코드베이스에서 명시적이고 잘알려진 위치에 두도록 하라<br>도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘 보여주고 더 잘 설명할 수 있다</p><h3 id="계층-수-줄이기"><a href="#계층-수-줄이기" class="headerlink" title="계층 수 줄이기"></a>계층 수 줄이기</h3><p>대부분의 프로그래머는 간접 계층을 추가해서 코드를 추상화하고 일반화 하려고 한다</p><p>추상계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기 너무 어려워진다</p><h3 id="순환-의존성-제거하기"><a href="#순환-의존성-제거하기" class="headerlink" title="순환 의존성 제거하기"></a>순환 의존성 제거하기</h3><p>순환 의존성의 대표적인 예는 콜백이다</p><p>순한 의존성은 코드를 읽고 이해할때 알아야 할것들이 너무 많아서 큰 부담이 된다</p><p>순한 의존성은 테스트를 방해 한다</p><h3 id="테스트에서-다중-실행-구절-사용"><a href="#테스트에서-다중-실행-구절-사용" class="headerlink" title="테스트에서 다중 실행 구절 사용"></a>테스트에서 다중 실행 구절 사용</h3><p>통합 테스트에서 두 유스케이스를 모두 확인하려고 할때 아래의 구조가 된다</p><ul><li>준비</li><li>실행</li><li>검증</li><li>실행</li><li>검증</li></ul><p>이러한 방식은 사용자의 상태가 자연스럽게 흐르기 때문에 설득력이 있고 첫 번째 실행은 두 번째 실행의 준비 단계 역활을 할수 있다<br>문제는 이러한 테스트가 초점을 잃고 순식간에 너무 커질수 있다</p><h2 id="로깅-기능을-테스트하는-방법"><a href="#로깅-기능을-테스트하는-방법" class="headerlink" title="로깅 기능을 테스트하는 방법"></a>로깅 기능을 테스트하는 방법</h2><ul><li>로깅을 조금이라도 테스트 해야 하는가?</li><li>만약 그렇다면 어떻게 테스트 해야 하는가?</li><li>로깅이 얼마나 많으면 충분한가?</li><li>로거 인스턴스를 어떻게 전달할까?</li></ul><h3 id="로깅을-테스트해야-하는가"><a href="#로깅을-테스트해야-하는가" class="headerlink" title="로깅을 테스트해야 하는가?"></a>로깅을 테스트해야 하는가?</h3><p>로깅은 횡단 기능으로 코드베이스 어느 부분에서나 필요로 할 수 있다</p><p>로깅의 종류 </p><ul><li>지원 로깅</li><li>진단 로깅</li></ul><h3 id="로깅을-어떻게-테스트해야-하는가"><a href="#로깅을-어떻게-테스트해야-하는가" class="headerlink" title="로깅을 어떻게 테스트해야 하는가?"></a>로깅을 어떻게 테스트해야 하는가?</h3><p>목으로 테스트 하지 마라</p><h3 id="로깅이-얼마나-많으면-충분한가"><a href="#로깅이-얼마나-많으면-충분한가" class="headerlink" title="로깅이 얼마나 많으면 충분한가?"></a>로깅이 얼마나 많으면 충분한가?</h3><ul><li>과도한 로깅은 코드를 혼란스럽게 한다</li><li>핵심은 로그의 신호 대비 잡음 비율이다</li></ul><h3 id="로거-인스턴스를-어떻게-전달하는가"><a href="#로거-인스턴스를-어떻게-전달하는가" class="headerlink" title="로거 인스턴스를 어떻게 전달하는가?"></a>로거 인스턴스를 어떻게 전달하는가?</h3><ul><li>정적 메서드를 사용하는 것</li></ul><p>앰비언트 컨텍스트라고 부른다 이는 안티 패턴이며 다음과 같은 두가지 단점</p><ul><li>의존성이 숨어 있고 변경하기가 어렵다</li><li>테스트가 더 어려워진다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-12-unit_testing_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7장. 가치 있는 단위 테스트를 위한 리팩터링</title>
      <link>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/</guid>
      <pubDate>Thu, 11 Jan 2024 02:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;7장-가치-있는-단위-테스트를-위한-리팩터링&quot;&gt;&lt;a href=&quot;#7장-가치-있는-단위-테스트를-위한-리팩터링&quot; class=&quot;headerlink&quot; title=&quot;7장. 가치 있는 단위 테스트를 위한 리팩터링&quot;&gt;&lt;/a&gt;7장. 가치 있는 단위 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="7장-가치-있는-단위-테스트를-위한-리팩터링"><a href="#7장-가치-있는-단위-테스트를-위한-리팩터링" class="headerlink" title="7장. 가치 있는 단위 테스트를 위한 리팩터링"></a>7장. 가치 있는 단위 테스트를 위한 리팩터링</h1><p>좋은 단위 테스트 스위트의 속성</p><ul><li>개발 주기에 통합돼 있다</li><li>코드베이스 중 가장 중요한 부분만을 대상으로 한다</li><li>최소한의 유지비로 최대의 가치를 끌어낸다<ul><li>가치 있는 테스트</li><li>가치 있는 테스트 작성하기</li></ul></li></ul><h2 id="리팩터링할-코드-식별하기"><a href="#리팩터링할-코드-식별하기" class="headerlink" title="리팩터링할 코드 식별하기"></a>리팩터링할 코드 식별하기</h2><h3 id="코드의-네-가지-유형"><a href="#코드의-네-가지-유형" class="headerlink" title="코드의 네 가지 유형"></a>코드의 네 가지 유형</h3><ul><li>복잡도 또는 도메인 유의성<ul><li>코드 복잡도는 코드 내 의사 결정 지점 수로 정의한다</li><li>도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는지를 나타낸다</li></ul></li><li>클래스 또는 매서드가 가진 협력자 수<ul><li>가변 의존성이거나 프로젝트 외부 의존성 이다</li><li>협력자가 많은 코드는 테스트 비용이 많이 든다</li></ul></li></ul><p>기초가 되는 4가지 유형</p><ul><li>도메인 모델과 알고리즘</li><li>간단한 코드</li><li>컨트롤러</li><li>지나치게 복잡한 코드</li></ul><p>코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 된다</p><p>좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다</p><h3 id="험블-객체-패턴을-사용해-지나치게-복잡한-코드-분할하기"><a href="#험블-객체-패턴을-사용해-지나치게-복잡한-코드-분할하기" class="headerlink" title="험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기"></a>험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기</h3><p>지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야 한다<br>헥사고날과 함수형 아키텍처는 험블 객체 패턴을 사용한다<br>험블객체 패턴을 보는 또 다른 방법은 단일 책임 원칙(SRP)을 지키는 것<br>또 다른 예로 도메인 주도 설계에 나오는 집계 패턴이 있다</p><h2 id="최적의-단위-테스트-커버리지-분석"><a href="#최적의-단위-테스트-커버리지-분석" class="headerlink" title="최적의 단위 테스트 커버리지 분석"></a>최적의 단위 테스트 커버리지 분석</h2><p>비지니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트할수 있다</p><h3 id="전제-조건을-테스트해야-하는가"><a href="#전제-조건을-테스트해야-하는가" class="headerlink" title="전제 조건을 테스트해야 하는가?"></a>전제 조건을 테스트해야 하는가?</h3><p>전제 조건에 도메인 의미가 없으면 테스트는 가치가 없다</p><h2 id="컨트롤러에서-조건부-로직-처리"><a href="#컨트롤러에서-조건부-로직-처리" class="headerlink" title="컨트롤러에서 조건부 로직 처리"></a>컨트롤러에서 조건부 로직 처리</h2><p>비지니스 로직과 오케스트레이션의 분리</p><ul><li>저장소에서 데이터 검색</li><li>비즈니스 로직 실행</li><li>데이터를 다시 저장소에 저장</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-11-unit_testing_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>6장. 단위 테스트 스타일</title>
      <link>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/</guid>
      <pubDate>Wed, 10 Jan 2024 00:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;6장-단위-테스트-스타일&quot;&gt;&lt;a href=&quot;#6장-단위-테스트-스타일&quot; class=&quot;headerlink&quot; title=&quot;6장. 단위 테스트 스타일&quot;&gt;&lt;/a&gt;6장. 단위 테스트 스타일&lt;/h1&gt;&lt;p&gt;단위테스트 스타일&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;출
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="6장-단위-테스트-스타일"><a href="#6장-단위-테스트-스타일" class="headerlink" title="6장. 단위 테스트 스타일"></a>6장. 단위 테스트 스타일</h1><p>단위테스트 스타일</p><ul><li>출력 기반 테스트 -&gt; 가장 품질이 좋음</li><li>상태 기반 테스트 -&gt; 두번째 </li><li>통신 기반 테스트 -&gt; 가장 품질이 낮음</li></ul><h2 id="단위-테스트의-세-가지-스타일"><a href="#단위-테스트의-세-가지-스타일" class="headerlink" title="단위 테스트의 세 가지 스타일"></a>단위 테스트의 세 가지 스타일</h2><ul><li>출력 기반 테스트(output-based testing)</li><li>상태 기반 테스트(state-based testing)</li><li>통신 기반 테스트(communication-based testing)</li></ul><h3 id="출력-기반-테스트-정의"><a href="#출력-기반-테스트-정의" class="headerlink" title="출력 기반 테스트 정의"></a>출력 기반 테스트 정의</h3><p>대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식</p><p>출력 기반 단위 테스트 스타일은 함수형 이라고도 한다</p><h3 id="상태-기반-스타일-정의"><a href="#상태-기반-스타일-정의" class="headerlink" title="상태 기반 스타일 정의"></a>상태 기반 스타일 정의</h3><p>작업이 완료된 후 시스템 상태를 확인하는 것이다<br>이 테스트 스타일에서 상태라는 용어는 SUT나 협력자 중 하나 또는 데이터베이스나 파일시스템등 외부의존성의 상태를 의미 할수 있다 </p><h3 id="통신-기반-스타일-정의"><a href="#통신-기반-스타일-정의" class="headerlink" title="통신 기반 스타일 정의"></a>통신 기반 스타일 정의</h3><p>목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다</p><h2 id="단위-테스트-스타일-비교"><a href="#단위-테스트-스타일-비교" class="headerlink" title="단위 테스트 스타일 비교"></a>단위 테스트 스타일 비교</h2><p>4대 요소랑 비교해보면 재미있을것이다</p><ul><li>회귀방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지보수성</li></ul><h3 id="회귀-방지와-피드백-속도-지표로-스타일-비교하기"><a href="#회귀-방지와-피드백-속도-지표로-스타일-비교하기" class="headerlink" title="회귀 방지와 피드백 속도 지표로 스타일 비교하기"></a>회귀 방지와 피드백 속도 지표로 스타일 비교하기</h3><p>회귀 방지 지표</p><ul><li>테스트 중에 실행되는 코드의 양</li><li>코드 복잡도</li><li>도메인 유의성</li></ul><p> 어떤 스타일도 이 부분 에선 도움이 안된다</p><p>테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다</p><h3 id="리팩터링-내성-지표로-스타일-비교하기"><a href="#리팩터링-내성-지표로-스타일-비교하기" class="headerlink" title="리팩터링 내성 지표로 스타일 비교하기"></a>리팩터링 내성 지표로 스타일 비교하기</h3><p>리팩터링 내성은 리팩터링 중 발생하는 거짓 양성 수에 대한 척도다</p><p>거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다</p><ul><li>출력 기반 테스트가 가장 우수하다</li><li>상태 기반 테스트는 일반적으로 거짓양성이 되기 쉽다</li><li>통신 기반 테스트가 허위 정보에 가장 취약하다</li></ul><h3 id="유지-보수성-지표로-스타일-비교하기"><a href="#유지-보수성-지표로-스타일-비교하기" class="headerlink" title="유지 보수성 지표로 스타일 비교하기"></a>유지 보수성 지표로 스타일 비교하기</h3><ul><li>테스트를 이해라기 얼마나 어려운가(테스트 크기에 대한 함수)?</li><li>테스트를 실행하기 얼마나 어려운가(프로세스 외부 의존성 개수에 대한 함수)?</li></ul><p>출력 기반 테스트가 가장 유지보수에 용의하다</p><p>상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다</p><p>클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적 그렇지 않으면 코드 오염으로 이어진다</p><p>통신 기반 테스트는 유지 보수성 지표에서 출력 기반 테스트와 상태 기반 테스트 보다 점수가 낮다</p><h3 id="스타일-비교하기-결론"><a href="#스타일-비교하기-결론" class="headerlink" title="스타일 비교하기: 결론"></a>스타일 비교하기: 결론</h3><p>출력 기반 테스트가 가장 품질이 좋다</p><h2 id="함수형-아키텍처-이해"><a href="#함수형-아키텍처-이해" class="headerlink" title="함수형 아키텍처 이해"></a>함수형 아키텍처 이해</h2><p>함수형 프로그래밍과 출력 기반 테스트의 연관성을 이해하는데 도움이 될 것이다</p><h3 id="함수형-프로그래밍이란"><a href="#함수형-프로그래밍이란" class="headerlink" title="함수형 프로그래밍이란?"></a>함수형 프로그래밍이란?</h3><p>출력 기반 단위 테스트 스타일은 함수형이라고도 한다<br>기반 제품 코드를 함수형 프로그래밍을 이용해 순수 함수 방식으로 작성해야 하기 때문이다</p><p>함수형 프로그래밍은 수학적 함수를 사용한 프로그래밍이다</p><p>수학적 함수는 호출 횟수에 상관 없이 주어진 입력에 대해 동일한 출력을 생성한다</p><p>숨은 입출력의 유형</p><ul><li>부작용</li><li>예외</li><li>내외부 상태에 대한 참조</li></ul><h3 id="함수형-아키텍처란"><a href="#함수형-아키텍처란" class="headerlink" title="함수형 아키텍처란?"></a>함수형 아키텍처란?</h3><p>함수형 프로그래밍 목표는 부작용을 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것</p><p>비즈니스 로직과 부작용을 분리하는 유형</p><ul><li>결정을 내리는 코드 : 부작용이 없는 코드<ul><li>함수형 코어(불변 코어)</li></ul></li><li>해당 결정에 따라 작동하는 코드 : 결정이 된 부분을 데이터베이스로 변경이나 메시지 버스로 전송된 메시지 같이 가시적인 부분으로 변환하는 부분<ul><li>가변 셀</li></ul></li></ul><p>함수형 코어와 가변 셀의 협력</p><ul><li>가변 셍은 모든 입력을 수집한다</li><li>함수형 코어는 결정을 생성한다</li><li>셀은 결정을 부작용으로 변환한다</li></ul><h3 id="함수형-아키텍처와-육각형-아키텍처-비교"><a href="#함수형-아키텍처와-육각형-아키텍처-비교" class="headerlink" title="함수형 아키텍처와 육각형 아키텍처 비교"></a>함수형 아키텍처와 육각형 아키텍처 비교</h3><p>함수형 아키텍처와 육각형 아키텍처는 비슷한 점이 많다</p><p>함수형 아키텍처는 육각형 아키텍처의 하위 집합이다. 극단적으로 함수형 아키텍처를 육각형 아키텍처로 볼 수도 있다</p><h2 id="함수형-아키텍처와-출력-기반-테스트로-전환"><a href="#함수형-아키텍처와-출력-기반-테스트로-전환" class="headerlink" title="함수형 아키텍처와 출력 기반 테스트로 전환"></a>함수형 아키텍처와 출력 기반 테스트로 전환</h2><ul><li>프로세스 외부 의존성에서 목으로 변경</li><li>목에서 함수형 아키텍처로 변경</li></ul><h2 id="함수형-아키텍처의-단점-이해하기"><a href="#함수형-아키텍처의-단점-이해하기" class="headerlink" title="함수형 아키텍처의 단점 이해하기"></a>함수형 아키텍처의 단점 이해하기</h2><p>항수형 아키텍처와 관련된 비용과 장단점</p><h3 id="함수형-아키텍처-적용-가능성"><a href="#함수형-아키텍처-적용-가능성" class="headerlink" title="함수형 아키텍처 적용 가능성"></a>함수형 아키텍처 적용 가능성</h3><p>함수형 코어의 클래스는 협력자로 작동하면 안되고 작업의 결과인 값으로 작동해야 한다</p><h3 id="성능-단점"><a href="#성능-단점" class="headerlink" title="성능 단점"></a>성능 단점</h3><p>함수형 아키텍처와 전동적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성간의 절충이다</p><h3 id="코드베이스-크기-증가"><a href="#코드베이스-크기-증가" class="headerlink" title="코드베이스 크기 증가"></a>코드베이스 크기 증가</h3><p>함수형 아키텍처는 함수형 코어와 가변 셀 사이를 명확하게 분리해야 한다 그래서 초기에 코딩이 더 필요하다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-10-unit_testing_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>5장. 목과 테스트 취약성</title>
      <link>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/</guid>
      <pubDate>Tue, 09 Jan 2024 00:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;5장-목과-테스트-취약성&quot;&gt;&lt;a href=&quot;#5장-목과-테스트-취약성&quot; class=&quot;headerlink&quot; title=&quot;5장. 목과 테스트 취약성&quot;&gt;&lt;/a&gt;5장. 목과 테스트 취약성&lt;/h1&gt;&lt;p&gt;런던파는 테스트 대상 코드 조각을 서로 분리
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="5장-목과-테스트-취약성"><a href="#5장-목과-테스트-취약성" class="headerlink" title="5장. 목과 테스트 취약성"></a>5장. 목과 테스트 취약성</h1><p>런던파는 테스트 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하고자 한다</p><p>고전파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하자고 한다 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다</p><h2 id="목과-스텁-구분"><a href="#목과-스텁-구분" class="headerlink" title="목과 스텁 구분"></a>목과 스텁 구분</h2><p>테스트 대역의 종류</p><ul><li>목(mock)</li><li>스텁(stub)</li><li>가짜(fakes)</li><li>스파이(spy)</li><li>더미(dummy)</li></ul><h3 id="테스트-대역-유형"><a href="#테스트-대역-유형" class="headerlink" title="테스트 대역 유형"></a>테스트 대역 유형</h3><p>테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다</p><ul><li>목은 외부로 나가는 상호 작용을 모방하고 검사하는데 도움이 된다</li><li>스텁은 내부로 들어오는 상호 작용을 모방하는데 도움이 된다</li></ul><h3 id="도구로서의-목과-테스트-대역으로서의-목"><a href="#도구로서의-목과-테스트-대역으로서의-목" class="headerlink" title="도구로서의 목과 테스트 대역으로서의 목"></a>도구로서의 목과 테스트 대역으로서의 목</h3><p>도구로써 목은 목라이브러리의 클래스도 목으로 참고할 수 있다</p><h3 id="스텁으로-상호-작용을-검증하지-말라"><a href="#스텁으로-상호-작용을-검증하지-말라" class="headerlink" title="스텁으로 상호 작용을 검증하지 말라"></a>스텁으로 상호 작용을 검증하지 말라</h3><p>스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다</p><p>최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세라고 부른다</p><p>목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만 대다수 그렇다</p><h3 id="목과-스텁-함께-쓰기"><a href="#목과-스텁-함께-쓰기" class="headerlink" title="목과 스텁 함께 쓰기"></a>목과 스텁 함께 쓰기</h3><p>때로는 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다</p><h3 id="목과-스텁은-명령과-조회에-어떻게-관련돼-있는가"><a href="#목과-스텁은-명령과-조회에-어떻게-관련돼-있는가" class="headerlink" title="목과 스텁은 명령과 조회에 어떻게 관련돼 있는가"></a>목과 스텁은 명령과 조회에 어떻게 관련돼 있는가</h3><p>목과 스텁의 개념은 명령 조회 분리 원칙과 관련이 있다</p><p>CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하고 이 둘을 혼용해서는 안된다</p><p>명령은 부작용을 일으키고 어떤 값도 반환 하지 않는다</p><h2 id="식별할-수-있는-동작과-구현-세부-사항"><a href="#식별할-수-있는-동작과-구현-세부-사항" class="headerlink" title="식별할 수 있는 동작과 구현 세부 사항"></a>식별할 수 있는 동작과 구현 세부 사항</h2><p>단위 테스트에서 리패터링 내성 지표가 가장 중요하다</p><p>테스트는 어떻게가 아니라 무엇에 중점을 뒤야한다</p><h3 id="식별할-수-있는-동작은-공개-API와-다르다"><a href="#식별할-수-있는-동작은-공개-API와-다르다" class="headerlink" title="식별할 수 있는 동작은 공개 API와 다르다"></a>식별할 수 있는 동작은 공개 API와 다르다</h3><p>모든 제품 코드는 2차원으로 분류 가능</p><ul><li>공개 API 또는 비공개 API</li><li>식별할 수 있는 동작 또는 구현 세부 사항</li></ul><p>각 차원의 범주는 겹치지 않는다</p><p>코드가 시스템의 식별할 수 있는 동작이려면 다음중 하나를 해야 한다</p><ul><li>클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라</li><li>클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라</li></ul><h3 id="잘-설계된-API와-캡슐화"><a href="#잘-설계된-API와-캡슐화" class="headerlink" title="잘 설계된 API와 캡슐화"></a>잘 설계된 API와 캡슐화</h3><p>장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다. 복잡도 때문이다</p><ul><li>구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다</li><li>데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다</li></ul><h3 id="구현-세부-사항-유출-상태의-예"><a href="#구현-세부-사항-유출-상태의-예" class="headerlink" title="구현 세부 사항 유출: 상태의 예"></a>구현 세부 사항 유출: 상태의 예</h3><p>API를 잘 설계하면 단위 테스트도 자동으로 좋아진다</p><p>클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개해야 하며 다른 모든 것은 구현 세부 사항이므로 비공개 API뒤에 숨어 있어야 된다</p><h2 id="목과-테스트-취약성-간의-관계"><a href="#목과-테스트-취약성-간의-관계" class="headerlink" title="목과 테스트 취약성 간의 관계"></a>목과 테스트 취약성 간의 관계</h2><h3 id="육각형-아키텍처-정의"><a href="#육각형-아키텍처-정의" class="headerlink" title="육각형 아키텍처 정의"></a>육각형 아키텍처 정의</h3><p>도메인과 애플리케이션 서비스라는 두 계층으로 나눈다<br>애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형성하며 이 육각형은 애플리케이션을 나타낸다</p><ul><li>도메인 계층과 애플리케이션 서비스 계층 간의 관심사의 분리</li><li>애플리케이션 내부 통신</li><li>애플리케이션 간의 통신</li></ul><h3 id="시스템-내부-통신과-시스템-간-통신"><a href="#시스템-내부-통신과-시스템-간-통신" class="headerlink" title="시스템 내부 통신과 시스템 간 통신"></a>시스템 내부 통신과 시스템 간 통신</h3><p>시스템 내부 통신은 구현 세부 사항이고 시스템 간 통신은 그렇지 않다</p><p>시스템 간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯된다<br>성장의 주요 원칙중 하나라 하위 호환성을 지키는 것이다</p><h2 id="단위-테스트의-고전파와-런던파-재고"><a href="#단위-테스트의-고전파와-런던파-재고" class="headerlink" title="단위 테스트의 고전파와 런던파 재고"></a>단위 테스트의 고전파와 런던파 재고</h2><p>런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다</p><p>고전파는 테스트 간에 공유하는 의존성만 교체하자고 한다</p><h3 id="모든-프로세스-외부-의존성을-목으로-해야-하는-것은-아니다"><a href="#모든-프로세스-외부-의존성을-목으로-해야-하는-것은-아니다" class="headerlink" title="모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다"></a>모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다</h3><ul><li>공유 의존성</li><li>프로세스 외부 의존성</li><li>비공개 의존성</li></ul><p>고전파는 공유 의존성을 피할 것을 권고 한다</p><h3 id="목을-사용한-동작-검증"><a href="#목을-사용한-동작-검증" class="headerlink" title="목을 사용한 동작 검증"></a>목을 사용한 동작 검증</h3><p>종종 목이 동작을 검증한다고 한다 하지만 대부분의 경우는 그렇지 않다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-09-unit_testing_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion 이해를 위한 자료 모음</title>
      <link>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/</guid>
      <pubDate>Mon, 08 Jan 2024 06:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ComfyUI-샘플-모음&quot;&gt;&lt;a href=&quot;#ComfyUI-샘플-모음&quot; class=&quot;headerlink&quot; title=&quot;ComfyUI 샘플 모음&quot;&gt;&lt;/a&gt;ComfyUI 샘플 모음&lt;/h1&gt;&lt;p&gt;ComfyUI를 이해하는데 도움이 되는 샘플 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ComfyUI-샘플-모음"><a href="#ComfyUI-샘플-모음" class="headerlink" title="ComfyUI 샘플 모음"></a>ComfyUI 샘플 모음</h1><p>ComfyUI를 이해하는데 도움이 되는 샘플 모음</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://comfyanonymous.github.io/ComfyUI_examples/">ComfyUI Examples</a></li><li><a href="https://github.com/WASasquatch/was-node-suite-comfyui/wiki/Workflow-Examples">was-node-examples</a></li><li><a href="https://github.com/atlasunified/Templates-ComfyUI-">Templates-ComfyUI-</a></li><li><a href="https://github.com/comfyanonymous/ComfyUI/blob/master/script_examples/websockets_api_example.py">ComfyUI websockets_api_example</a></li><li><a href="https://github.com/comfyanonymous/ComfyUI/blob/master/script_examples/basic_api_example.py">ComfyUI basic_api_example</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-08-comfyui_examples/#disqus_thread</comments>
    </item>
    
    <item>
      <title>4장. 좋은 단위 테스트의 4대 요소</title>
      <link>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/</guid>
      <pubDate>Mon, 08 Jan 2024 00:51:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;4장-좋은-단위-테스트의-4대-요소&quot;&gt;&lt;a href=&quot;#4장-좋은-단위-테스트의-4대-요소&quot; class=&quot;headerlink&quot; title=&quot;4장. 좋은 단위 테스트의 4대 요소&quot;&gt;&lt;/a&gt;4장. 좋은 단위 테스트의 4대 요소&lt;/h1&gt;&lt;p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="4장-좋은-단위-테스트의-4대-요소"><a href="#4장-좋은-단위-테스트의-4대-요소" class="headerlink" title="4장. 좋은 단위 테스트의 4대 요소"></a>4장. 좋은 단위 테스트의 4대 요소</h1><p>좋은 단위 테스트 스위트의 특성</p><ul><li>개발 주기에 통합돼 있다</li><li>코드베이스의 가장 중요한 부분만을 대상으로 한다</li><li>최소한의 유지비로 최대 가치를 끌어낸다<ul><li>가치 있는 테스트 식별</li><li>가치 있는 테스트 작성</li></ul></li></ul><h2 id="좋은-단위-테스트의-4대-요소-자세히-살펴보기"><a href="#좋은-단위-테스트의-4대-요소-자세히-살펴보기" class="headerlink" title="좋은 단위 테스트의 4대 요소 자세히 살펴보기"></a>좋은 단위 테스트의 4대 요소 자세히 살펴보기</h2><ul><li>회귀 방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지 보수성</li></ul><h3 id="첫-번째-요소-회귀-방지"><a href="#첫-번째-요소-회귀-방지" class="headerlink" title="첫 번째 요소: 회귀 방지"></a>첫 번째 요소: 회귀 방지</h3><p>회귀는 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우<br>회귀는 귀찮다. 최악의 상황은 아니다</p><p>회귀 방지 지표에 대한 테스트 점수가 잘 나오는지 평가하려면 다음 사항을 고려해야 한다</p><ul><li>테스트 중에 실행되는 코드의 양</li><li>코드 복잡도</li><li>코드의 도메인 유의성</li></ul><p>일반적으로 코드가 많을수록 테스트에서 회귀가 나타낼 가능성이 높다</p><p>복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드 보다 훨씬 더 중요하다</p><h3 id="두-번째-요소-리팩터링-내성"><a href="#두-번째-요소-리팩터링-내성" class="headerlink" title="두 번째 요소: 리팩터링 내성"></a>두 번째 요소: 리팩터링 내성</h3><p>테스트를 빨간색(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다</p><p>거짓양성(테스트가 실패하는 것처럼 보이지만 실제로는 성공하는 경우)이 발생하면 리팩터링 내성이 떨어진다</p><ul><li>기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다</li><li>코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다</li></ul><h3 id="무엇이-거짓-양성의-원인인가"><a href="#무엇이-거짓-양성의-원인인가" class="headerlink" title="무엇이 거짓 양성의 원인인가?"></a>무엇이 거짓 양성의 원인인가?</h3><p>거짓양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리 하는것 뿐이다</p><p>테스트는 최종 사용자의 관점에서 sut를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다</p><p>테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다</p><h3 id="구현-세부-사항-대신-최종-결과를-목표로-하기"><a href="#구현-세부-사항-대신-최종-결과를-목표로-하기" class="headerlink" title="구현 세부 사항 대신 최종 결과를 목표로 하기"></a>구현 세부 사항 대신 최종 결과를 목표로 하기</h3><p>리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항 과 테스트 간의 결합도를 낮추는 것뿐 이다</p><h2 id="첫-번째-특성과-두-번째-특성-간의-본질적인-관계"><a href="#첫-번째-특성과-두-번째-특성-간의-본질적인-관계" class="headerlink" title="첫 번째 특성과 두 번째 특성 간의 본질적인 관계"></a>첫 번째 특성과 두 번째 특성 간의 본질적인 관계</h2><ul><li>테스트 정확도 극대화</li><li>거짓 양성과 거짓 음성의 중요성</li></ul><h3 id="테스트-정확도-극대화"><a href="#테스트-정확도-극대화" class="headerlink" title="테스트 정확도 극대화"></a>테스트 정확도 극대화</h3><p>정확도 지표</p><ul><li>테스트가 버그 있음을 얼마나 잘 나타내는가</li><li>테스트가 버그 없음을 얼마나 잘 나타내는가</li></ul><h3 id="거짓-양성과-거짓-음성의-중요성-역학-관계"><a href="#거짓-양성과-거짓-음성의-중요성-역학-관계" class="headerlink" title="거짓 양성과 거짓 음성의 중요성: 역학 관계"></a>거짓 양성과 거짓 음성의 중요성: 역학 관계</h3><p>단기적으로 거짓 양성도 거짓 음성만큼 나쁘지 않다 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 큰영향을 미치기 시작한다</p><p>중대형 프로젝트를 하면 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다</p><h2 id="세-번째-요소와-네-번째-요소-빠른-피드백과-유지-보수성"><a href="#세-번째-요소와-네-번째-요소-빠른-피드백과-유지-보수성" class="headerlink" title="세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성"></a>세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성</h2><p>좋은 단위 테스트의 특성 중 남은 두가지 요소</p><ul><li>빠른 피드백</li><li>유지 보수성</li></ul><p>유지 보수성 평가</p><ul><li>테스트가 얼마나 이해하기 어려운가</li><li>테스트가 얼마나 실행하기 어려운가</li></ul><h2 id="이상적인-테스트를-찾아서"><a href="#이상적인-테스트를-찾아서" class="headerlink" title="이상적인 테스트를 찾아서"></a>이상적인 테스트를 찾아서</h2><ul><li>회귀방지</li><li>리팩터링 내성</li><li>빠른 피드백</li><li>유지 보수성</li></ul><p>테스트 코드를 포함한 모든 코드는 책임이다. 최소한으로 필요한 가치로 임계치를 상당히 높게 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라</p><h3 id="이상적인-테스트를-만들-수-있는가"><a href="#이상적인-테스트를-만들-수-있는가" class="headerlink" title="이상적인 테스트를 만들 수 있는가?"></a>이상적인 테스트를 만들 수 있는가?</h3><p>회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이라 이상적인 테스트를 만드는게 불가능하다</p><h3 id="극단적인-사례-1-엔드-투-엔드-테스트"><a href="#극단적인-사례-1-엔드-투-엔드-테스트" class="headerlink" title="극단적인 사례 1: 엔드 투 엔드 테스트"></a>극단적인 사례 1: 엔드 투 엔드 테스트</h3><p>단점 느린 속도</p><h3 id="극단적인-사례-2-간단한-테스트"><a href="#극단적인-사례-2-간단한-테스트" class="headerlink" title="극단적인 사례 2: 간단한 테스트"></a>극단적인 사례 2: 간단한 테스트</h3><p>간단한 테스트는 실수할 여지가 많지 않아 회귀를 나타내지 않을것이다</p><h3 id="극단적인-사례-3-깨지기-쉬운-테스트"><a href="#극단적인-사례-3-깨지기-쉬운-테스트" class="headerlink" title="극단적인 사례 3: 깨지기 쉬운 테스트"></a>극단적인 사례 3: 깨지기 쉬운 테스트</h3><p>거짓 양성이 많은 테스트를 작성하기 매우 쉽다</p><h3 id="이상적인-테스트를-찾아서-결론"><a href="#이상적인-테스트를-찾아서-결론" class="headerlink" title="이상적인 테스트를 찾아서: 결론"></a>이상적인 테스트를 찾아서: 결론</h3><p>한 특성에서 얻는 것이 많을수록 다른 특성에서 더 일게 된다</p><p>테스트 스위트를 탄탄하게 만들려면 테스트 불안정성을 제거하는 것이 최우선 과제다</p><h2 id="대중적인-테스트-자동화-개념-살펴보기"><a href="#대중적인-테스트-자동화-개념-살펴보기" class="headerlink" title="대중적인 테스트 자동화 개념 살펴보기"></a>대중적인 테스트 자동화 개념 살펴보기</h2><h3 id="테스트-피라미드-분해"><a href="#테스트-피라미드-분해" class="headerlink" title="테스트 피라미드 분해"></a>테스트 피라미드 분해</h3><p>테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다</p><h3 id="블랙박스-테스트와-화이트박스-테스트-간의-선택"><a href="#블랙박스-테스트와-화이트박스-테스트-간의-선택" class="headerlink" title="블랙박스 테스트와 화이트박스 테스트 간의 선택"></a>블랙박스 테스트와 화이트박스 테스트 간의 선택</h3><ul><li>블랙 박스 테스트 : 시스템 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다</li><li>화이트 박스 테스트 : 애플리케이션의 내부 작업을 검증하는 테스트 방식이다</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-08-unit_testing_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>3장. 단위 테스트 구조</title>
      <link>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/</guid>
      <pubDate>Fri, 05 Jan 2024 01:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;3장-단위-테스트-구조&quot;&gt;&lt;a href=&quot;#3장-단위-테스트-구조&quot; class=&quot;headerlink&quot; title=&quot;3장. 단위 테스트 구조&quot;&gt;&lt;/a&gt;3장. 단위 테스트 구조&lt;/h1&gt;&lt;h2 id=&quot;단위-테스트를-구성하는-방법&quot;&gt;&lt;a hre
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="3장-단위-테스트-구조"><a href="#3장-단위-테스트-구조" class="headerlink" title="3장. 단위 테스트 구조"></a>3장. 단위 테스트 구조</h1><h2 id="단위-테스트를-구성하는-방법"><a href="#단위-테스트를-구성하는-방법" class="headerlink" title="단위 테스트를 구성하는 방법"></a>단위 테스트를 구성하는 방법</h2><h3 id="AAA-arrange-act-assert-패턴-사용"><a href="#AAA-arrange-act-assert-패턴-사용" class="headerlink" title="AAA(arrange act assert) 패턴 사용"></a>AAA(arrange act assert) 패턴 사용</h3><p>3A 패턴은 테스트를 준비(arrange), 실행(act), 검증(assert) 세 단계로 나누는 것을 의미한다.</p><p>AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는데 도움이 된다</p><p>일관성이 이 패턴의 가장 큰 장점 중 하나다</p><p>Given-When-Then 패턴</p><ul><li>Given: 테스트를 위한 사전 조건을 설정한다</li><li>When: 테스트를 수행한다</li><li>Then: 테스트 결과를 검증한다</li></ul><h3 id="여러-개의-준비-실행-검증-구절-피하기"><a href="#여러-개의-준비-실행-검증-구절-피하기" class="headerlink" title="여러 개의 준비, 실행, 검증 구절 피하기"></a>여러 개의 준비, 실행, 검증 구절 피하기</h3><p>여러 개의 준비 실행 검증 구절은 테스트가 너무 많은 것을 한 번에 검증한다는 의미다</p><p>검증 구절로 구분된 여러 개의 실행 구절을 보면 려러 개의 동작 단위를 검증 하는 테스트를 뜻한다 이건 더 이상 단위 테스트가 아니라 통합 테스트다</p><h3 id="테스트-내-if-문-피하기"><a href="#테스트-내-if-문-피하기" class="headerlink" title="테스트 내 if 문 피하기"></a>테스트 내 if 문 피하기</h3><p>이것도 안티 패턴이다</p><p>이러한 테스트는 반드시 여러 개의 테스트로 분리해야 한다</p><p>테스트에 분기가 있어서 얻는 이점은 없다</p><h3 id="각-구절은-얼마나-커야-하는가"><a href="#각-구절은-얼마나-커야-하는가" class="headerlink" title="각 구절은 얼마나 커야 하는가?"></a>각 구절은 얼마나 커야 하는가?</h3><p>일반적으로 준비 구절이 세 구절 중 가장 크다.<br>실행과 검증을 합친 만큼 클 수도 있다</p><p>그러나 준비 구절이 너무 크면 코드 재사용에 도움이 되는 두가지 패턴으로<br>오브젝트 마더(object mother)와 테스트 데이터 빌더(test data builder)가 있다</p><p>실행 구절은 보통 한 줄이다. 실행 구절이 두줄 이상인 경우는 sut의 공개 API에 문제가 있을수도 있다</p><p>불변 위반(jnvariant violation) 잠재적인 모순으로 부터 코드를 보호 하는 행위를 캡슐화라고 한다</p><h3 id="검증-구절에는-검증문이-얼마나-있어야-하는가"><a href="#검증-구절에는-검증문이-얼마나-있어야-하는가" class="headerlink" title="검증 구절에는 검증문이 얼마나 있어야 하는가"></a>검증 구절에는 검증문이 얼마나 있어야 하는가</h3><p>단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다<br>단일 동작 단위는 여러 결과를 낼 수 있으며 하나의 테스트로 모든 결과를 평가하는것이 좋다</p><h3 id="종료-단계는-어떤가"><a href="#종료-단계는-어떤가" class="headerlink" title="종료 단계는 어떤가"></a>종료 단계는 어떤가</h3><p>준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다</p><p>AAA 패턴에는 이 단계를 포함하지 않는다</p><p>종료는 통합 테스트의 영역이다</p><h3 id="테스트-대상-시스템-구별하기"><a href="#테스트-대상-시스템-구별하기" class="headerlink" title="테스트 대상 시스템 구별하기"></a>테스트 대상 시스템 구별하기</h3><p>SUT(System Under Test) 테스트에서 중요한 역할을 하는데 애플리케이션을 호출하고자 하는 동작에 대한 진입점을 제공한다</p><p>SUT와 의존성과 구분하는 것이 중요하다</p><h3 id="준비-실행-검증-주석-제거하기"><a href="#준비-실행-검증-주석-제거하기" class="headerlink" title="준비, 실행, 검증 주석 제거하기"></a>준비, 실행, 검증 주석 제거하기</h3><p>의존성에서 SUT를 떼어내는 것이 중요하듯이 주석으로 하는것 보다 빈 줄로 구절을 구분한다</p><ul><li>AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라</li><li>그렇지 않으면 구절 주석을 유지하라</li></ul><h2 id="테스트-간-테스트-픽스처-재사용"><a href="#테스트-간-테스트-픽스처-재사용" class="headerlink" title="테스트 간 테스트 픽스처 재사용"></a>테스트 간 테스트 픽스처 재사용</h2><p>테스트 픽처스</p><ul><li>테스트 픽스처는 테스트 실행 대상 객체이다</li><li>NUnit에서 [TestFixture] 특성을 사용하여 테스트가 포함된 클래스를 표시한다</li></ul><p>준비 구절을 생성자로 추출 할때 단점</p><ul><li>테스트 간 결합도가 높아진다</li><li>테스트 가독성이 떨어진다</li></ul><h3 id="테스트-간의-높은-결합도는-안티-패턴이다"><a href="#테스트-간의-높은-결합도는-안티-패턴이다" class="headerlink" title="테스트 간의 높은 결합도는 안티 패턴이다"></a>테스트 간의 높은 결합도는 안티 패턴이다</h3><p>테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다.</p><h3 id="테스트-가독성을-떨어뜨리는-생성자-사용"><a href="#테스트-가독성을-떨어뜨리는-생성자-사용" class="headerlink" title="테스트 가독성을 떨어뜨리는 생성자 사용"></a>테스트 가독성을 떨어뜨리는 생성자 사용</h3><p>준비 코드를 생성자로 추출할 때 테스트 가독성을 떨어뜨린다</p><h3 id="더-나은-테스트-픽스처-재사용법"><a href="#더-나은-테스트-픽스처-재사용법" class="headerlink" title="더 나은 테스트 픽스처 재사용법"></a>더 나은 테스트 픽스처 재사용법</h3><p>테스트 픽스처를 재사용할때 생성자 사용이 최선의 방법은 아니다</p><ul><li>비공개 팩토리 매서드를 두는것도 하나의 방법이다</li><li>기초 클래스 내 공통 초기화 코드를 두는법</li></ul><h2 id="단위-테스트-명명법"><a href="#단위-테스트-명명법" class="headerlink" title="단위 테스트 명명법"></a>단위 테스트 명명법</h2><p>가장 도움 되지 않는 명명법</p><p>[테스트 대상]<em>[시나리오]</em>[예상 결과]</p><ul><li>테스트 대상 메서드 : 테스트 중인 메서드의 이름</li><li>시나리오 : 메서드를 테스트하는 조건</li><li>현재 시나리오에서 테스트 대상 메서드에 기대하는 것</li></ul><p>프로그래머가 아닌 사람들에게 이름을 어떻게 생각하는지 중요하지 않다고 말할 수 있다 테스트는 프로그래머를 위한것이라서 그렇게 생각한다</p><h3 id="단위-테스트-명명-지침"><a href="#단위-테스트-명명-지침" class="headerlink" title="단위 테스트 명명 지침"></a>단위 테스트 명명 지침</h3><ul><li>엄격한 명명 정책을 따르지 않는다</li><li>문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자</li><li>단어를 밑줄 표시(_)로 구분한다</li></ul><h3 id="예제-지침에-따른-테스트-이름-변경"><a href="#예제-지침에-따른-테스트-이름-변경" class="headerlink" title="예제: 지침에 따른 테스트 이름 변경"></a>예제: 지침에 따른 테스트 이름 변경</h3><p>테스트 이름에 SYUT(System Under Test)에 메서드 이름을 포함하지 말라</p><h2 id="매개변수화된-테스트-리팩터링하기"><a href="#매개변수화된-테스트-리팩터링하기" class="headerlink" title="매개변수화된 테스트 리팩터링하기"></a>매개변수화된 테스트 리팩터링하기</h2><p>동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말라</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-05-unit_testing_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2장. 단위 테스트란 무엇인가</title>
      <link>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/</guid>
      <pubDate>Thu, 04 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;2장-단위-테스트란-무엇인가&quot;&gt;&lt;a href=&quot;#2장-단위-테스트란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;2장. 단위 테스트란 무엇인가&quot;&gt;&lt;/a&gt;2장. 단위 테스트란 무엇인가&lt;/h1&gt;&lt;p&gt;고전파(classical sc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="2장-단위-테스트란-무엇인가"><a href="#2장-단위-테스트란-무엇인가" class="headerlink" title="2장. 단위 테스트란 무엇인가"></a>2장. 단위 테스트란 무엇인가</h1><p>고전파(classical school)는 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식</p><p>런던파(London school)는 단위 테스트와 테스트 주도 개발에 실용적으로 접근하는 방식</p><h2 id="‘단위-테스트’의-정의"><a href="#‘단위-테스트’의-정의" class="headerlink" title="‘단위 테스트’의 정의"></a>‘단위 테스트’의 정의</h2><p>단위 테스트의 속성</p><ul><li>작은 코드 조각을 검증하고</li><li>빠르게 수행하고</li><li>격리된 방식으로 처리하는 자동화된 테스트다</li></ul><p>세번째에서 논란의 여지가 있는데 격리된 방식에 차이가 런던파와 고전파의 차이다.</p><h3 id="격리-문제에-대한-런던파의-접근"><a href="#격리-문제에-대한-런던파의-접근" class="headerlink" title="격리 문제에 대한 런던파의 접근"></a>격리 문제에 대한 런던파의 접근</h3><p>테스트 대상 시스템을 협력자에게서 격리하는 것을 말한다. 즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 된다</p><p>장점</p><ul><li>단위 테스트를 의존성과 별개로 수행할수 있다</li><li>테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알수 있다</li><li>객체 그래프를 분할할 수 있다</li></ul><h3 id="격리-문제에-대한-고전파의-접근"><a href="#격리-문제에-대한-고전파의-접근" class="headerlink" title="격리 문제에 대한 고전파의 접근"></a>격리 문제에 대한 고전파의 접근</h3><p>테스트는 서로 격리해서 실행해야 한다</p><ul><li>공유 의존성(shared dependency) : 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성</li><li>비공개 의존성(private dependency) : 공유하지 않은 의존성</li><li>프로세스 외부 의존성(out of process dependency) : 애플리케이션 실행 프로세스 외부에서 실행되는 의존성</li></ul><p>결리 문제에 대한 이러한 해석에는 목과 기타 테스트 대역을 적당히 쓰려는 견해가 있다</p><p>공유의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다<br>테스트 실행 속도를 높이기 의해 공유의존성을 대체한다</p><h2 id="단위-테스트의-런던파와-고전파"><a href="#단위-테스트의-런던파와-고전파" class="headerlink" title="단위 테스트의 런던파와 고전파"></a>단위 테스트의 런던파와 고전파</h2><table><thead><tr><th></th><th>격리주체</th><th>단위의 크기</th><th>테스트 대역 사용 대상</th></tr></thead><tbody><tr><td>런던파</td><td>단위</td><td>단일 클래스</td><td>불변의존성 외 모든 의존성</td></tr><tr><td>고전파</td><td>단위테스트</td><td>단일 클래스 또는 클래스 세트</td><td>공유 의존성</td></tr></tbody></table><h3 id="고전파와-런던파가-의존성을-다루는-방법"><a href="#고전파와-런던파가-의존성을-다루는-방법" class="headerlink" title="고전파와 런던파가 의존성을 다루는 방법"></a>고전파와 런던파가 의존성을 다루는 방법</h3><p>테스트 대역을 어디에서나 흔히 사용할수 있지만 런던파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 하고 있다</p><ul><li>협력자(collaborator) : 공유하거나 변경 가능한 의존성</li><li>의존성 : 일반적인 클래스는 두가지 유형의 의존성으로 동작한다 협력자, 값</li></ul><h2 id="고전파와-런던파-비교"><a href="#고전파와-런던파-비교" class="headerlink" title="고전파와 런던파 비교"></a>고전파와 런던파 비교</h2><p>코전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다</p><p>런던파의 장점</p><ul><li>입자성이 좋다. 테스트가 세밀해서 한번에 한 클래스만 확인한다</li><li>서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다</li><li>테스트가 실패하면 어떤 기능이 실패했는지 확실히 알수 있다</li></ul><h3 id="한-번에-한-클래스만-테스트하기"><a href="#한-번에-한-클래스만-테스트하기" class="headerlink" title="한 번에 한 클래스만 테스트하기"></a>한 번에 한 클래스만 테스트하기</h3><p>좋은 입자성이란 단위 테스트에서 단위를 구성하는 것에 대한 논쟁</p><p>런던파는 클래스를 단위로 간주한다 </p><h3 id="상호-연결된-클래스의-큰-그래프를-단위-테스트하기"><a href="#상호-연결된-클래스의-큰-그래프를-단위-테스트하기" class="headerlink" title="상호 연결된 클래스의 큰 그래프를 단위 테스트하기"></a>상호 연결된 클래스의 큰 그래프를 단위 테스트하기</h3><p>실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.<br>상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다.<br>대개 클래스 그래프가 커진 것은 코드 설계 문제이다</p><h3 id="버그-위치-정확히-찾아내기"><a href="#버그-위치-정확히-찾아내기" class="headerlink" title="버그 위치 정확히 찾아내기"></a>버그 위치 정확히 찾아내기</h3><p>테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다<br>마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 어렵지 않다</p><p>계단식 실패를 통해 방금 고장 낸 코드 조각이 큰가치가 있다는것을 알게 된다 -&gt; 전체 시스템이 그것에 의존한다</p><h3 id="고전파와-런던파-사이의-다른-차이점"><a href="#고전파와-런던파-사이의-다른-차이점" class="headerlink" title="고전파와 런던파 사이의 다른 차이점"></a>고전파와 런던파 사이의 다른 차이점</h3><p>고전파와 런던파 사이에 남아 있는 두가지 차이점</p><ul><li>테스트 주도 개발을 통한 시스템 설계 방식</li><li>과도한 명세 문제</li></ul><p>런던 스타일의 단위 테스트는 하양식 TDD로 이어지며 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트 부터 시작한다</p><p>고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다</p><h2 id="두-분파의-통합-테스트"><a href="#두-분파의-통합-테스트" class="headerlink" title="두 분파의 통합 테스트"></a>두 분파의 통합 테스트</h2><p>런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다</p><p>고전 스타일로 작성된 대부분의 테스트는 런던파에게 통합테스트로 느껴질 것이다</p><h3 id="통합-테스트의-일부인-엔드-투-엔드-테스트"><a href="#통합-테스트의-일부인-엔드-투-엔드-테스트" class="headerlink" title="통합 테스트의 일부인 엔드 투 엔드 테스트"></a>통합 테스트의 일부인 엔드 투 엔드 테스트</h3><p>엔드투 앤드 테스트는 통합 테스트의 일부이다</p><p>엔드투 앤드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과후 빌드 프로세스 후반에 실행하는 것이 좋다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-04-unit_testing_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>1장. 단위 테스트 목표</title>
      <link>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/</guid>
      <pubDate>Wed, 03 Jan 2024 01:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1장-단위-테스트-목표&quot;&gt;&lt;a href=&quot;#1장-단위-테스트-목표&quot; class=&quot;headerlink&quot; title=&quot;1장. 단위 테스트 목표&quot;&gt;&lt;/a&gt;1장. 단위 테스트 목표&lt;/h1&gt;&lt;p&gt;단위 테스트를 배우는 것은 테스트 프레임워크나 목 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1장-단위-테스트-목표"><a href="#1장-단위-테스트-목표" class="headerlink" title="1장. 단위 테스트 목표"></a>1장. 단위 테스트 목표</h1><p>단위 테스트를 배우는 것은 테스트 프레임워크나 목 라이브러리등과 같은 기술적인 부분을 익히는 것에 그치지 않는다</p><p>단위 테스트를 매우 많이 작성하더라도 많은 버그와 유지비로 프로젝트 진행이 느려지게 된다</p><h2 id="단위-테스트-현황"><a href="#단위-테스트-현황" class="headerlink" title="단위 테스트 현황"></a>단위 테스트 현황</h2><p>대부분의 프로그래머는 단위 테스트를 실천하고 중요성을 알고 있다</p><p>보통 제품코드와 테스트 코드의 비율은 1:1에서 1:3 정도 된다</p><p>좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제이다</p><h2 id="단위-테스트-목표"><a href="#단위-테스트-목표" class="headerlink" title="단위 테스트 목표"></a>단위 테스트 목표</h2><p>단위 테스트와 코드 설계의 관계</p><ul><li>코드 조각을 단위 테스트하는 것은 훌륭한 리스머스 시험이지만 한 방향으로 작동한다</li></ul><p>단위 테스트의 목표는? -&gt; 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것 이다</p><p>개발속도가 빠르게 감소하는 현상을 소프트웨어 엔트로피라고 한다</p><h3 id="좋은-테스트와-좋지-않은-테스트를-가르는-요인"><a href="#좋은-테스트와-좋지-않은-테스트를-가르는-요인" class="headerlink" title="좋은 테스트와 좋지 않은 테스트를 가르는 요인"></a>좋은 테스트와 좋지 않은 테스트를 가르는 요인</h3><p>테스트의 가치와 유지비용을 모두 고려해야함 비용요소는 다음과 같은 다양한 활동에 필요한 시간에 따라 결정된다</p><ul><li>기반 코드를 리팩터링할 때 테스트도 리팩터링하라</li><li>각 코드 변경 시 테스트를 실행하라</li><li>테스트가 잘못된 경고를 발생시킬 경우 처리하라</li><li>기반 코드가 어떻게 동작하는지 이해라려고 할때 테스트를 읽는 시간에 투자하라</li></ul><p>제품 코드 대 테스트 코드</p><ul><li>코드는 자산이 아니라 책임이다</li><li>테스트도 역시 코드다 다른 코드와 마찬가지로 유지보수가 필요하다</li></ul><h2 id="테스트-스위트-품질-측정을-위한-커버리지-지표"><a href="#테스트-스위트-품질-측정을-위한-커버리지-지표" class="headerlink" title="테스트 스위트 품질 측정을 위한 커버리지 지표"></a>테스트 스위트 품질 측정을 위한 커버리지 지표</h2><ul><li>코드 커버리지</li><li>분기 커버리지</li></ul><p>커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다</p><h3 id="코드-커버리지-지표에-대한-이해"><a href="#코드-커버리지-지표에-대한-이해" class="headerlink" title="코드 커버리지 지표에 대한 이해"></a>코드 커버리지 지표에 대한 이해</h3><p>가장 많이 사용되는 커버리지 지표로 코드 커버리지가 있으며 테스트 커버리지로도 알려져 있다</p><p>코드가 작을수록 커버리지 지표는 더 좋아지는데 이는 원래 라인 수만 처리해서이다</p><p>코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지보수성이 변경되지 않는다</p><h3 id="분기-커버리지-지표에-대한-이해"><a href="#분기-커버리지-지표에-대한-이해" class="headerlink" title="분기 커버리지 지표에 대한 이해"></a>분기 커버리지 지표에 대한 이해</h3><p>분기 커버리지는 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조의 수를 나타낸다</p><h3 id="커버리지-지표에-관한-문제점"><a href="#커버리지-지표에-관한-문제점" class="headerlink" title="커버리지 지표에 관한 문제점"></a>커버리지 지표에 관한 문제점</h3><p>테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유</p><ul><li>테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다</li><li>외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다</li></ul><p>단위 테스트에는 반드시 적잘한 검증이 있어야 된다</p><p>정수 타입으로 변환할수 없는 몇가지 가능한 인수</p><ul><li>널 값</li><li>빈 문자열</li><li>정수가 아님</li><li>너무 긴 문자열</li></ul><h3 id="특정-커버리지-숫자를-목표로-하기"><a href="#특정-커버리지-숫자를-목표로-하기" class="headerlink" title="특정 커버리지 숫자를 목표로 하기"></a>특정 커버리지 숫자를 목표로 하기</h3><p>커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안된다</p><p>커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다</p><h2 id="무엇이-성공적인-테스트-스위트를-만드는가"><a href="#무엇이-성공적인-테스트-스위트를-만드는가" class="headerlink" title="무엇이 성공적인 테스트 스위트를 만드는가?"></a>무엇이 성공적인 테스트 스위트를 만드는가?</h2><p>테스트 스위트의 품질은 어떻게 측정해야 하는가? 믿을만한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는것 뿐이다</p><p>성공적인 테스트 스위트의 특성</p><ul><li>개발 주기에 통합돼 있다<ul><li>자동화된 테스트를 할수 있는 방법은 끊임없이 하는것 뿐</li></ul></li><li>코드베이스에서 가장 중요한 부분만을 대상으로 한다<ul><li>비지니스 로직이 아닌 부분<ul><li>인프라 코드</li><li>데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성</li><li>모든 것을 하나로 묶는 코드</li></ul></li></ul></li><li>최소한의 유지비로 최대의 가치를 끌어낸다<ul><li>가치 있는 테스트 식별하기</li><li>가치 있는 테스트 작성하기</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="http://www.acornpub.co.kr/book/unit-testing">단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-03-unit_testing_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>13장: 나쁜 코드를 식별 가능하게 만들기</title>
      <link>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/</guid>
      <pubDate>Tue, 02 Jan 2024 05:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;13장-나쁜-코드를-식별-가능하게-만들기&quot;&gt;&lt;a href=&quot;#13장-나쁜-코드를-식별-가능하게-만들기&quot; class=&quot;headerlink&quot; title=&quot;13장: 나쁜 코드를 식별 가능하게 만들기&quot;&gt;&lt;/a&gt;13장: 나쁜 코드를 식별 가능하게
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="13장-나쁜-코드를-식별-가능하게-만들기"><a href="#13장-나쁜-코드를-식별-가능하게-만들기" class="headerlink" title="13장: 나쁜 코드를 식별 가능하게 만들기"></a>13장: 나쁜 코드를 식별 가능하게 만들기</h1><p>나쁜 코드를 딱 봐도 않좋아 보이게 만들어 품질의 수준을 명확히 표시하는 방법 -&gt; 안티 리팩터링</p><h2 id="나쁜-코드에-대처하는-자세"><a href="#나쁜-코드에-대처하는-자세" class="headerlink" title="나쁜 코드에 대처하는 자세"></a>나쁜 코드에 대처하는 자세</h2><p>코드를 원하는 수준으로 리팩터링하지 못할 때가 많다 이런 상황에서 끔찍하지만 않게 약깐의 리팩터링을 수행하기도 한다 하지만 이렇게 하는것은 실수다</p><p>나쁜 코드를 남겨둘때 장점</p><ul><li>다시 찾기가 쉽다</li><li>통제가 지속 가능하지 않다는 신호를 준다</li></ul><h2 id="깨끗한-코드와-레거시-코드로-분리"><a href="#깨끗한-코드와-레거시-코드로-분리" class="headerlink" title="깨끗한 코드와 레거시 코드로 분리"></a>깨끗한 코드와 레거시 코드로 분리</h2><p>잘 만들수 없으면 눈에 띄게 만들어야 된다</p><h3 id="깨진-유리창-이론"><a href="#깨진-유리창-이론" class="headerlink" title="깨진 유리창 이론"></a>깨진 유리창 이론</h3><p>유리창이 하나가 깨지고 나면 곧 더 많은 유리창이 깨진다. 논란의 여지는 있지만 최소한 은유적인 가치는 있다</p><h2 id="나쁜-코드를-찾는-방법"><a href="#나쁜-코드를-찾는-방법" class="headerlink" title="나쁜 코드를 찾는 방법"></a>나쁜 코드를 찾는 방법</h2><h3 id="이-책의-규칙-단순하고-구체적인-코드"><a href="#이-책의-규칙-단순하고-구체적인-코드" class="headerlink" title="이 책의 규칙: 단순하고 구체적인 코드"></a>이 책의 규칙: 단순하고 구체적인 코드</h3><h3 id="코드-스멜-완전하고-추상적인-코드"><a href="#코드-스멜-완전하고-추상적인-코드" class="headerlink" title="코드 스멜: 완전하고 추상적인 코드"></a>코드 스멜: 완전하고 추상적인 코드</h3><h3 id="순환-복잡도-알고리즘-객관적"><a href="#순환-복잡도-알고리즘-객관적" class="headerlink" title="순환 복잡도: 알고리즘(객관적)"></a>순환 복잡도: 알고리즘(객관적)</h3><h3 id="인지-복잡도-알고리즘-주관적"><a href="#인지-복잡도-알고리즘-주관적" class="headerlink" title="인지 복잡도: 알고리즘(주관적)"></a>인지 복잡도: 알고리즘(주관적)</h3><h2 id="코드를-안전하게-나쁜-코드로-보이기-위한-규칙"><a href="#코드를-안전하게-나쁜-코드로-보이기-위한-규칙" class="headerlink" title="코드를 안전하게 나쁜 코드로 보이기 위한 규칙"></a>코드를 안전하게 나쁜 코드로 보이기 위한 규칙</h2><ul><li>올바른 정보를 절대 훼손하지 말 것</li><li>향후 리팩터링을 어렵게 만들지 말 것 </li><li>결과를 한눈에 알 수 있을 것</li></ul><h2 id="나쁜-코드를-나쁘게-보이기-위한-방법"><a href="#나쁜-코드를-나쁘게-보이기-위한-방법" class="headerlink" title="나쁜 코드를 나쁘게 보이기 위한 방법"></a>나쁜 코드를 나쁘게 보이기 위한 방법</h2><p>안전과 가역성은 필수요소</p><h3 id="열거형-사용"><a href="#열거형-사용" class="headerlink" title="열거형 사용"></a>열거형 사용</h3><h3 id="정수형-및-문자열을-타입-코드로-사용"><a href="#정수형-및-문자열을-타입-코드로-사용" class="headerlink" title="정수형 및 문자열을 타입 코드로 사용"></a>정수형 및 문자열을 타입 코드로 사용</h3><h3 id="코드에-매직-넘버-넣기"><a href="#코드에-매직-넘버-넣기" class="headerlink" title="코드에 매직 넘버 넣기"></a>코드에 매직 넘버 넣기</h3><h3 id="코드에-주석-넣기"><a href="#코드에-주석-넣기" class="headerlink" title="코드에 주석 넣기"></a>코드에 주석 넣기</h3><h3 id="코드에-공백-넣기"><a href="#코드에-공백-넣기" class="headerlink" title="코드에 공백 넣기"></a>코드에 공백 넣기</h3><h3 id="이름을-기준으로-항목을-그룹화하기"><a href="#이름을-기준으로-항목을-그룹화하기" class="headerlink" title="이름을 기준으로 항목을 그룹화하기"></a>이름을 기준으로 항목을 그룹화하기</h3><h3 id="이름에-컨텍스트-추가하기"><a href="#이름에-컨텍스트-추가하기" class="headerlink" title="이름에 컨텍스트 추가하기"></a>이름에 컨텍스트 추가하기</h3><h3 id="긴-메서드-만들기"><a href="#긴-메서드-만들기" class="headerlink" title="긴 메서드 만들기"></a>긴 메서드 만들기</h3><h3 id="메서드에-많은-매개변수-넘기기"><a href="#메서드에-많은-매개변수-넘기기" class="headerlink" title="메서드에 많은 매개변수 넘기기"></a>메서드에 많은 매개변수 넘기기</h3><h3 id="getter와-setter-사용하기"><a href="#getter와-setter-사용하기" class="headerlink" title="getter와 setter 사용하기"></a>getter와 setter 사용하기</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>12장: 최적화 및 일반화 회피</title>
      <link>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/</link>
      <guid>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/</guid>
      <pubDate>Tue, 02 Jan 2024 00:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;12장-최적화-및-일반화-회피&quot;&gt;&lt;a href=&quot;#12장-최적화-및-일반화-회피&quot; class=&quot;headerlink&quot; title=&quot;12장: 최적화 및 일반화 회피&quot;&gt;&lt;/a&gt;12장: 최적화 및 일반화 회피&lt;/h1&gt;&lt;p&gt;성능 최적화와 일반화는
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="12장-최적화-및-일반화-회피"><a href="#12장-최적화-및-일반화-회피" class="headerlink" title="12장: 최적화 및 일반화 회피"></a>12장: 최적화 및 일반화 회피</h1><p>성능 최적화와 일반화는 프로그래머가 하는 두가지 게임으로 도움이 되기보다 큰 상처를 입히는 경우가 많다</p><p>일반화 해야 되는것은 컨텍스트뿐</p><h2 id="단순성-추구"><a href="#단순성-추구" class="headerlink" title="단순성 추구"></a>단순성 추구</h2><p>단순함을 추구하는것은 소프트웨어 개발의 이상 중 하나</p><p>인간의 인지능력은 제한적이기 때문에 단순함이 필수</p><p>불변속성을 활용하는 최적화</p><p>단순함을 희생할때는 부작용을 최소화하기 위해 예방 조치를 취해야 된다</p><h2 id="일반화의-시기와-방법"><a href="#일반화의-시기와-방법" class="headerlink" title="일반화의 시기와 방법"></a>일반화의 시기와 방법</h2><p>매서드나 클래스를 일반화를 추가하기 전에 그렇게 해야 하는 이유가 있어야 된다</p><h3 id="구현의-최소화로-일반화-지양하기"><a href="#구현의-최소화로-일반화-지양하기" class="headerlink" title="구현의 최소화로 일반화 지양하기"></a>구현의 최소화로 일반화 지양하기</h3><p>하지 않는 일의 양을 최대화 하라</p><p>무언가 만들때는 먼저 컨텍스트, 구현하려는 동작의 범위를 이해해야 한다</p><p>소프트웨어가 발전함에 따라 요구사항이 변경되므로 불필요한 일반화를 구현하고 유지하는데 드는 노력이 쉽게 무효화된다</p><h3 id="안정성이-유사한-것-통합하기"><a href="#안정성이-유사한-것-통합하기" class="headerlink" title="안정성이 유사한 것 통합하기"></a>안정성이 유사한 것 통합하기</h3><p>새로운것과 오래된것을 바로 통합하지 않는것이 좋다 대신 통합 대상이 비슷한 안정성에 도달하면 통합하자</p><h3 id="불필요한-일반화-제거"><a href="#불필요한-일반화-제거" class="headerlink" title="불필요한 일반화 제거"></a>불필요한 일반화 제거</h3><p>함수에 전달된 런터임 인자들을 모니터링해서 매서드 전문화를 적용할수 있다</p><h2 id="최적화-시기와-방법"><a href="#최적화-시기와-방법" class="headerlink" title="최적화 시기와 방법"></a>최적화 시기와 방법</h2><p>자동 성능 테스트를 설정하고 테스트가 실패할 때만 최적화를 하는 것이 좋다</p><h3 id="최적화-전-리팩터링"><a href="#최적화-전-리팩터링" class="headerlink" title="최적화 전 리팩터링"></a>최적화 전 리팩터링</h3><p>첫번째 단계는 코드가 적절하게 리팩터링되었는지 확인하는것이다</p><h3 id="제약-이론에-따른-최적화"><a href="#제약-이론에-따른-최적화" class="headerlink" title="제약 이론에 따른 최적화"></a>제약 이론에 따른 최적화</h3><p>제약이론이 적용됨 - 리소스 풀링 기법</p><h3 id="측정-지표를-사용한-최적화"><a href="#측정-지표를-사용한-최적화" class="headerlink" title="측정 지표를 사용한 최적화"></a>측정 지표를 사용한 최적화</h3><p>코드에서 핫스팟을 식별해야 된다</p><h3 id="좋은-알고리즘과-데이터-구조-선택하기"><a href="#좋은-알고리즘과-데이터-구조-선택하기" class="headerlink" title="좋은 알고리즘과 데이터 구조 선택하기"></a>좋은 알고리즘과 데이터 구조 선택하기</h3><p>데이터 구조를 지역적으로 변환함으로써 이익을 얻을수 있다</p><h3 id="캐시-사용하기"><a href="#캐시-사용하기" class="headerlink" title="캐시 사용하기"></a>캐시 사용하기</h3><p>캐시는 멱등 불변속성과 조합될 때 가장 안전하다</p><h3 id="최적화된-코드-분리하기"><a href="#최적화된-코드-분리하기" class="headerlink" title="최적화된 코드 분리하기"></a>최적화된 코드 분리하기</h3><ul><li>잠금 영역 최소화를 위한 메서드와 클래스 사용</li><li>향후 개발자들에게 알리기 위한 패키지 사용</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2024/01/2024-01-02-five_lines_of_code_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11장: 코드 구조 따르기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/</guid>
      <pubDate>Fri, 29 Dec 2023 00:56:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;11장-코드-구조-따르기&quot;&gt;&lt;a href=&quot;#11장-코드-구조-따르기&quot; class=&quot;headerlink&quot; title=&quot;11장: 코드 구조 따르기&quot;&gt;&lt;/a&gt;11장: 코드 구조 따르기&lt;/h1&gt;&lt;p&gt;소프트웨어는 현실 세계의 한 측면에 대한 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="11장-코드-구조-따르기"><a href="#11장-코드-구조-따르기" class="headerlink" title="11장: 코드 구조 따르기"></a>11장: 코드 구조 따르기</h1><p>소프트웨어는 현실 세계의 한 측면에 대한 모델 입니다</p><h2 id="범위와-출처에-따른-구조-분류"><a href="#범위와-출처에-따른-구조-분류" class="headerlink" title="범위와 출처에 따른 구조 분류"></a>범위와 출처에 따른 구조 분류</h2><p>구조의 분류를 4가지로 나눈다 </p><ul><li>딤간</li><li>팀내</li><li>코드에 있는 경우</li><li>사람에 있는 경우</li></ul><p>매크로 아키텍처는 팀 간 구조에 관한 것<br>마이크로 아키텍처는 팀 내 구조에 관한것</p><p>조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있다 - 콘웨이 법칙</p><h2 id="행위를-코드화하는-세-가지-방법"><a href="#행위를-코드화하는-세-가지-방법" class="headerlink" title="행위를 코드화하는 세 가지 방법"></a>행위를 코드화하는 세 가지 방법</h2><ul><li>제어 흐름</li><li>데이터 구조</li><li>데이터</li></ul><h3 id="데이터에-행위-코드화하기"><a href="#데이터에-행위-코드화하기" class="headerlink" title="데이터에 행위 코드화하기"></a>데이터에 행위 코드화하기</h3><p>코드를 캡슐화해야 하지만 변경점을 노출 하지 않아야 한다</p><h2 id="구조-노출을-위한-코드-추가"><a href="#구조-노출을-위한-코드-추가" class="headerlink" title="구조 노출을 위한 코드 추가"></a>구조 노출을 위한 코드 추가</h2><h2 id="예측-대신-관찰-그리고-경험적-기술-사용"><a href="#예측-대신-관찰-그리고-경험적-기술-사용" class="headerlink" title="예측 대신 관찰, 그리고 경험적 기술 사용"></a>예측 대신 관찰, 그리고 경험적 기술 사용</h2><ul><li>변경되지 않으면 아무것도 하지 말아라</li><li>예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리팩터링 해라</li><li>그렇지 않으면 과거에 발생한 변경 유형을 적용해 리팩터링 해라</li></ul><h2 id="코드를-이해하지-않고도-안전성을-확보하는-방안"><a href="#코드를-이해하지-않고도-안전성을-확보하는-방안" class="headerlink" title="코드를 이해하지 않고도 안전성을 확보하는 방안"></a>코드를 이해하지 않고도 안전성을 확보하는 방안</h2><h3 id="테스트를-통한-안전성-확보"><a href="#테스트를-통한-안전성-확보" class="headerlink" title="테스트를 통한 안전성 확보"></a>테스트를 통한 안전성 확보</h3><h3 id="숙달을-통한-안전성-확보"><a href="#숙달을-통한-안전성-확보" class="headerlink" title="숙달을 통한 안전성 확보"></a>숙달을 통한 안전성 확보</h3><h3 id="도구의-지원을-통한-안전성-확보"><a href="#도구의-지원을-통한-안전성-확보" class="headerlink" title="도구의 지원을 통한 안전성 확보"></a>도구의 지원을 통한 안전성 확보</h3><h3 id="공식-인증을-통한-안전성-확보"><a href="#공식-인증을-통한-안전성-확보" class="headerlink" title="공식 인증을 통한 안전성 확보"></a>공식 인증을 통한 안전성 확보</h3><h3 id="내결함성을-통한-안전성-확보"><a href="#내결함성을-통한-안전성-확보" class="headerlink" title="내결함성을 통한 안전성 확보"></a>내결함성을 통한 안전성 확보</h3><h2 id="활용되지-않은-구조-이용"><a href="#활용되지-않은-구조-이용" class="headerlink" title="활용되지 않은 구조 이용"></a>활용되지 않은 구조 이용</h2><h3 id="추출-및-캡슐화에-공백-활용"><a href="#추출-및-캡슐화에-공백-활용" class="headerlink" title="추출 및 캡슐화에 공백 활용"></a>추출 및 캡슐화에 공백 활용</h3><h3 id="통합에-중복-코드-활용"><a href="#통합에-중복-코드-활용" class="headerlink" title="통합에 중복 코드 활용"></a>통합에 중복 코드 활용</h3><h3 id="캡슐화로-공통-접사-활용"><a href="#캡슐화로-공통-접사-활용" class="headerlink" title="캡슐화로 공통 접사 활용"></a>캡슐화로 공통 접사 활용</h3><h3 id="동적-실행으로-런타임-유형-활용"><a href="#동적-실행으로-런타임-유형-활용" class="headerlink" title="동적 실행으로 런타임 유형 활용"></a>동적 실행으로 런타임 유형 활용</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-29-five_lines_of_code_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10장: 코드 추가에 대한 두려움 떨쳐내기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/</guid>
      <pubDate>Thu, 28 Dec 2023 06:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;10장-코드-추가에-대한-두려움-떨쳐내기&quot;&gt;&lt;a href=&quot;#10장-코드-추가에-대한-두려움-떨쳐내기&quot; class=&quot;headerlink&quot; title=&quot;10장: 코드 추가에 대한 두려움 떨쳐내기&quot;&gt;&lt;/a&gt;10장: 코드 추가에 대한 두려움 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="10장-코드-추가에-대한-두려움-떨쳐내기"><a href="#10장-코드-추가에-대한-두려움-떨쳐내기" class="headerlink" title="10장: 코드 추가에 대한 두려움 떨쳐내기"></a>10장: 코드 추가에 대한 두려움 떨쳐내기</h1><p>코드 추가가 두려운 경우는 비현실적인 목표나 코드가 비용을 추가해서이다</p><h2 id="불확실성-받아들이기-위험-감수"><a href="#불확실성-받아들이기-위험-감수" class="headerlink" title="불확실성 받아들이기: 위험 감수"></a>불확실성 받아들이기: 위험 감수</h2><p>겁을 먹으면 효과적으로 일할 수 없다. 지식을 구축하는 가장 효과적인 방법은 실험이지만 거기에는 요기가 필요하다</p><h2 id="두려움-극복을-위한-스파이크-사용"><a href="#두려움-극복을-위한-스파이크-사용" class="headerlink" title="두려움 극복을 위한 스파이크 사용"></a>두려움 극복을 위한 스파이크 사용</h2><p>스파이크는 자신감과 함께 첫 번째 실제버전을 더 좋게 만드는 데 사용할 수 있는 지식을 제공한다</p><p>이해관계자는 제품이 코드나 기능이 아니라 지식이라는 것을 인지할 필요가 있다</p><h2 id="낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정"><a href="#낭비나-위험에-대한-두려움-극복을-위한-사용-시간-비율-지정" class="headerlink" title="낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정"></a>낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정</h2><p>비기능적 요구사항에 개발자 시간의 20%를 할당할것</p><h2 id="불완전성에-대한-두려움-극복을-위한-점진적-개선"><a href="#불완전성에-대한-두려움-극복을-위한-점진적-개선" class="headerlink" title="불완전성에 대한 두려움 극복을 위한 점진적 개선"></a>불완전성에 대한 두려움 극복을 위한 점진적 개선</h2><p>가면 증후군은 스스로 자격이 없는 사람으로 간주하여 누군가 자신을 사기꾼으로 폭로할까 봐 두려워하는 것</p><p>개발자의 삶에 맞춘 최적화</p><h2 id="복사-및-붙여넣기가-속도에-미치는-영향"><a href="#복사-및-붙여넣기가-속도에-미치는-영향" class="headerlink" title="복사 및 붙여넣기가 속도에 미치는 영향"></a>복사 및 붙여넣기가 속도에 미치는 영향</h2><p>코드복제시 고려해야할 사항</p><ul><li>코드를 공유하면 코드가 사용되는 모든 위치에 영향을 미치기 쉽다</li><li>전역적인 동작 변경 속도가 높다는 것은 코드의 여러 다른 위치에 동시에 영향을 줄수 있다</li></ul><p>복사된 코드는 완전히 분리되므로 한곳을 위해 다른 곳을 손상시킬 위험이 없기 때문에 실험과 변경이 더 안전 하다</p><h2 id="확장성을-통한-추가에-의한-변경"><a href="#확장성을-통한-추가에-의한-변경" class="headerlink" title="확장성을 통한 추가에 의한 변경"></a>확장성을 통한 추가에 의한 변경</h2><p>코드를 추가하는 또 다른 방법은 확장성을 이용하는것</p><ul><li>우발적 복잡성 : 도메인에 관련 되지 않은 복잡성</li><li>본질적 복잡성 : 도메인으로 부터 상속된 일부 복잡성</li></ul><h2 id="추가에-의한-변경으로-이전-버전과의-호환성-확보"><a href="#추가에-의한-변경으로-이전-버전과의-호환성-확보" class="headerlink" title="추가에 의한 변경으로 이전 버전과의 호환성 확보"></a>추가에 의한 변경으로 이전 버전과의 호환성 확보</h2><p>어떤 버전이 최신 버전인지 쉽게 알 수 있도록 일관된 명명 체계를 사용하는 것이 좋다</p><h2 id="기능-토글-켜기-x2F-끄기-로-추가에-의한-변경"><a href="#기능-토글-켜기-x2F-끄기-로-추가에-의한-변경" class="headerlink" title="기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경"></a>기능 토글(켜기&#x2F;끄기)로 추가에 의한 변경</h2><p>기능 토글의 이면에 있는 개념 : 최소 요구사항은 컴파일이 되어야 된다</p><h2 id="‘추상화를-통한-분기’로-추가에-의한-변경"><a href="#‘추상화를-통한-분기’로-추가에-의한-변경" class="headerlink" title="‘추상화를 통한 분기’로 추가에 의한 변경"></a>‘추상화를 통한 분기’로 추가에 의한 변경</h2><p>클래스로 타입 코드 대체 패턴을 사용해서 추상화를 통한 분기를 사용한다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9장: 코드 삭제의 미학</title>
      <link>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/</guid>
      <pubDate>Thu, 28 Dec 2023 00:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;9장-코드-삭제의-미학&quot;&gt;&lt;a href=&quot;#9장-코드-삭제의-미학&quot; class=&quot;headerlink&quot; title=&quot;9장: 코드 삭제의 미학&quot;&gt;&lt;/a&gt;9장: 코드 삭제의 미학&lt;/h1&gt;&lt;p&gt;시간이나 노력을 들였기 때문에 어떤 것에 가치를 부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="9장-코드-삭제의-미학"><a href="#9장-코드-삭제의-미학" class="headerlink" title="9장: 코드 삭제의 미학"></a>9장: 코드 삭제의 미학</h1><p>시간이나 노력을 들였기 때문에 어떤 것에 가치를 부여하는 것을 메몰 비용의 오류(sunk-cost fallacy)라고 합니다.</p><p>단 한 가지만 말하라면 바로 적은 것이 더 낫다</p><h2 id="다음-시대는-코드를-지우는-시대일-것이다"><a href="#다음-시대는-코드를-지우는-시대일-것이다" class="headerlink" title="다음 시대는 코드를 지우는 시대일 것이다"></a>다음 시대는 코드를 지우는 시대일 것이다</h2><p>우리는 아직 코드 삭제에 익숙하지 않는다 이것이 다음에 해결해야 할 큰 과제 라고 생각한다</p><h2 id="복잡성을-제거하기-위한-코드-삭제"><a href="#복잡성을-제거하기-위한-코드-삭제" class="headerlink" title="복잡성을 제거하기 위한 코드 삭제"></a>복잡성을 제거하기 위한 코드 삭제</h2><p>기능을 추가하고 테스트를 수행하며 다 많은 코너 케이스(복합 경계 조건)을 처리함에 따라 시간이 지날수록 성장하는 것이 바로 시스템 특징</p><ul><li>도메인 복잡성: 도메인이 기본적으로 가지고 있는것</li><li>부수적 복잡성: 도메인이 요구하지 않았지만 우연히 추가된 모든 복잡성</li></ul><h3 id="경험-부족으로-인한-기술적-무지"><a href="#경험-부족으로-인한-기술적-무지" class="headerlink" title="경험 부족으로 인한 기술적 무지"></a>경험 부족으로 인한 기술적 무지</h3><p>기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상된다</p><p>공동 프로그래밍 : 모든 아이디어가 코드에 적용되기 전에 다른 사람의 두뇌를 거쳐야 한다</p><h3 id="시간-압박으로-인한-기술적-낭비"><a href="#시간-압박으로-인한-기술적-낭비" class="headerlink" title="시간 압박으로 인한 기술적 낭비"></a>시간 압박으로 인한 기술적 낭비</h3><p>부수적 복잡성의 가장 단순한 유형은 기술적 낭비의 가장 일반적인것은 시간 압박에서 시작된다</p><h3 id="환경에-따른-기술적-부채"><a href="#환경에-따른-기술적-부채" class="headerlink" title="환경에 따른 기술적 부채"></a>환경에 따른 기술적 부채</h3><p>기술부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것</p><h3 id="성장에-따른-기술적-장애물"><a href="#성장에-따른-기술적-장애물" class="headerlink" title="성장에 따른 기술적 장애물"></a>성장에 따른 기술적 장애물</h3><p>기술적 장애물(technical drag)dms roqkfdmf ejelrp aksemsms ahems rjt</p><p>사용하지 않으면 기능은 퇴화한다</p><h2 id="친밀도에-따른-코드-분류"><a href="#친밀도에-따른-코드-분류" class="headerlink" title="친밀도에 따른 코드 분류"></a>친밀도에 따른 코드 분류</h2><p>댄 노스는 약 6주가 지나면 코드가 알 수 없는 범주로 빠르게 이동하면서 해당 코드와 친밀도가 떨어지기 시작한다고 사례를 들어 주장함<br>유지 시간의 한계가 몇 개월이 아닌 몇주 단위여야 한다</p><h2 id="레거시-시스템에서의-코드-삭제"><a href="#레거시-시스템에서의-코드-삭제" class="headerlink" title="레거시 시스템에서의 코드 삭제"></a>레거시 시스템에서의 코드 삭제</h2><p>레거시 코드의 일반적인 정의는 수정하기가 겁나는 코드(서커스 팩터 circus factor 의 결과)이다</p><h3 id="스트랭글러-무화과나무-패턴"><a href="#스트랭글러-무화과나무-패턴" class="headerlink" title="스트랭글러 무화과나무 패턴"></a>스트랭글러 무화과나무 패턴</h3><p>숙주는 레거시 시스템</p><h3 id="코드-개선을-위한-스트랭글러-무화과나무-패턴-사용"><a href="#코드-개선을-위한-스트랭글러-무화과나무-패턴-사용" class="headerlink" title="코드 개선을 위한 스트랭글러 무화과나무 패턴 사용"></a>코드 개선을 위한 스트랭글러 무화과나무 패턴 사용</h3><p>호출의 빈도는 일반적으로 그것이 얼마나 중요한지를 나타내는 좋은 지표</p><h2 id="동결된-프로젝트에서-코드-삭제"><a href="#동결된-프로젝트에서-코드-삭제" class="headerlink" title="동결된 프로젝트에서 코드 삭제"></a>동결된 프로젝트에서 코드 삭제</h2><p>코드에는 사용하지 않는 다는 표시가 없어서 변경할때 마다 고려하고 유지 해야 한다</p><h3 id="바람직한-결과를-기본값으로-설정"><a href="#바람직한-결과를-기본값으로-설정" class="headerlink" title="바람직한 결과를 기본값으로 설정"></a>바람직한 결과를 기본값으로 설정</h3><p>유지기간을 정해 놓고 그 기간이 지나면 코드를 삭제한다</p><h3 id="스파이크와-스태빌라이즈-안정화-로-낭비-줄이기"><a href="#스파이크와-스태빌라이즈-안정화-로-낭비-줄이기" class="headerlink" title="스파이크와 스태빌라이즈(안정화)로 낭비 줄이기"></a>스파이크와 스태빌라이즈(안정화)로 낭비 줄이기</h3><p>빠르게 구현하고 코드를 얼마나 사용하는지 측정하고 사용하면 유지하고 사용하지 않으면 삭제한다</p><h2 id="버전-관리에서-브랜치-삭제"><a href="#버전-관리에서-브랜치-삭제" class="headerlink" title="버전 관리에서 브랜치 삭제"></a>버전 관리에서 브랜치 삭제</h2><p>브랜치는 시간이 지나면 축적되는데 이것은 불필요한 복잡성을 추가한다</p><h3 id="브랜치-제한으로-낭비-최소화"><a href="#브랜치-제한으로-낭비-최소화" class="headerlink" title="브랜치 제한으로 낭비 최소화"></a>브랜치 제한으로 낭비 최소화</h3><p>협업 방법인 칸반을 적용할수 있다</p><h2 id="코드-문서-삭제"><a href="#코드-문서-삭제" class="headerlink" title="코드 문서 삭제"></a>코드 문서 삭제</h2><p>문서는 정확히 3가지 조건을 충족해야 함</p><ul><li>관련성</li><li>정확성</li><li>발견 가능성</li></ul><h3 id="지식을-문서화하는-방법을-결정하는-알고리즘"><a href="#지식을-문서화하는-방법을-결정하는-알고리즘" class="headerlink" title="지식을 문서화하는 방법을 결정하는 알고리즘"></a>지식을 문서화하는 방법을 결정하는 알고리즘</h3><p>문서화하는 것이 의미가 있는지 여부 결정</p><ul><li>문서화 대상이 자주 바뀌지 않는지</li><li>드물게 사용하는 경우 문서화</li><li>자동화 할수 있음 자동화</li><li>아니면 외워라</li></ul><h2 id="테스트-코드-삭제"><a href="#테스트-코드-삭제" class="headerlink" title="테스트 코드 삭제"></a>테스트 코드 삭제</h2><h3 id="낙관적-테스트-삭제"><a href="#낙관적-테스트-삭제" class="headerlink" title="낙관적 테스트 삭제"></a>낙관적 테스트 삭제</h3><p>항상 참인 것은 삭제 해라</p><h3 id="비관적-테스트-삭제"><a href="#비관적-테스트-삭제" class="headerlink" title="비관적 테스트 삭제"></a>비관적 테스트 삭제</h3><p>항상 거짓인 것은 삭제 해라</p><h3 id="불안정-테스트-수정-또는-삭제"><a href="#불안정-테스트-수정-또는-삭제" class="headerlink" title="불안정 테스트 수정 또는 삭제"></a>불안정 테스트 수정 또는 삭제</h3><p>성공 실패를 반복하면서 예측할수 없는 테스트(불안정 테스트)는 삭제해라</p><h3 id="복잡한-테스트를-제거하기-위한-코드-리팩터링"><a href="#복잡한-테스트를-제거하기-위한-코드-리팩터링" class="headerlink" title="복잡한 테스트를 제거하기 위한 코드 리팩터링"></a>복잡한 테스트를 제거하기 위한 코드 리팩터링</h3><p>테스트를 리팩터링해야 한다는 것은 테스트 중인 코드에 적절한 아키텍처가 없다는 것</p><h3 id="속도를-높이는-테스트-문화"><a href="#속도를-높이는-테스트-문화" class="headerlink" title="속도를 높이는 테스트 문화"></a>속도를 높이는 테스트 문화</h3><p>느린 테스트와 빠른 테스트를 구분하고 가능한 자주 빠른 테스트를 진행하라</p><h2 id="설정-코드-삭제"><a href="#설정-코드-삭제" class="headerlink" title="설정 코드 삭제"></a>설정 코드 삭제</h2><p>완벽하게 만들 수 없다면 최소한 설정이 가능하게 만들어라</p><h3 id="설정의-예상-수명으로-범위-지정"><a href="#설정의-예상-수명으로-범위-지정" class="headerlink" title="설정의 예상 수명으로 범위 지정"></a>설정의 예상 수명으로 범위 지정</h3><ul><li>실험을 위한 설정 : 베타 테스트 또는 A&#x2F;B 테스트</li><li>과도기 적인 설정 : 릴리즈와 뱊호를 연결하는 것</li><li>영구적인 설정 : 사용량을 증가시키거나 유지보수가 간편해야 하기 때문에 특별하다<h2 id="라이브러리-제거를-위한-코드-삭제"><a href="#라이브러리-제거를-위한-코드-삭제" class="headerlink" title="라이브러리 제거를 위한 코드 삭제"></a>라이브러리 제거를 위한 코드 삭제</h2></li></ul><p>라이브러리를 사용하는것은 양날의 검</p><h3 id="외부-라이브러리에-대한-의존도-제한"><a href="#외부-라이브러리에-대한-의존도-제한" class="headerlink" title="외부 라이브러리에 대한 의존도 제한"></a>외부 라이브러리에 대한 의존도 제한</h3><p>고통스러울수록 더 시도하라</p><h2 id="작동-중인-기능에서-코드-삭제"><a href="#작동-중인-기능에서-코드-삭제" class="headerlink" title="작동 중인 기능에서 코드 삭제"></a>작동 중인 기능에서 코드 삭제</h2><p>코드는 부채이다 코드를 삭제하면 부채를 감소시킬수 있다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-28-five_lines_of_code_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8장: 주석 자제하기</title>
      <link>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</link>
      <guid>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/</guid>
      <pubDate>Wed, 27 Dec 2023 05:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;8장-주석-자제하기&quot;&gt;&lt;a href=&quot;#8장-주석-자제하기&quot; class=&quot;headerlink&quot; title=&quot;8장: 주석 자제하기&quot;&gt;&lt;/a&gt;8장: 주석 자제하기&lt;/h1&gt;&lt;p&gt;메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="8장-주석-자제하기"><a href="#8장-주석-자제하기" class="headerlink" title="8장: 주석 자제하기"></a>8장: 주석 자제하기</h1><p>메서드 내부에 있으면서 javadoc과 같은 외부도구에서 사용하지 않는 주석을 대상으로 함</p><p>주석을 없에는것이 좋을수 있는 이유</p><ul><li>코드가 명확하고 좋은 타입명과 변수명을 사용하는 경우</li><li>주석은 컴파일러가 확인하지 않으므로 특히 코드가 수정된 후에는 주석이 맞다고 보장할 수 없다</li></ul><p>주석이 스멜을 가진 코드 위에 탈취제처럼 자주 사용된다 주석을 달기보다 코드를 정리해야 된다</p><p>일반적인 문제는 이해할 수 없는 코드를 작성한 작성자가 주석으로 어떻게든 명확하고 분명하게 표현할 수 있다고 생각한다는 것</p><p>코드가 표현할 수 없는 것만 주석으로 처리하십시오</p><h2 id="오래된-주석-제거"><a href="#오래된-주석-제거" class="headerlink" title="오래된 주석 제거"></a>오래된 주석 제거</h2><p>해당 주석은 잘못된 정보를 제공하거나 이해하는데 더 방해를 한다</p><h2 id="주석-처리된-코드-제거"><a href="#주석-처리된-코드-제거" class="headerlink" title="주석 처리된 코드 제거"></a>주석 처리된 코드 제거</h2><p>버전 관리를 하기 때문에 주석으로 코드를 관리 할 필요가 더이상 불필요하다</p><h2 id="불필요한-주석-제거"><a href="#불필요한-주석-제거" class="headerlink" title="불필요한 주석 제거"></a>불필요한 주석 제거</h2><p>코드가 주석만큼 읽기 쉬울때 해당 주석을 불필요한 주석이라고 한다</p><h2 id="메서드의-이름으로-주석-대신하기"><a href="#메서드의-이름으로-주석-대신하기" class="headerlink" title="메서드의 이름으로 주석 대신하기"></a>메서드의 이름으로 주석 대신하기</h2><p>일부 주석은 기능보다는 코드를 문서화한다. 메서드 명으로 해당 주석을 대신한다</p><h3 id="계획을-위한-주석-사용"><a href="#계획을-위한-주석-사용" class="headerlink" title="계획을 위한 주석 사용"></a>계획을 위한 주석 사용</h3><p>주석으로 계획을 세울수도 있지만 구현후에는 불필요한 주석일수 있다</p><h2 id="불변속성을-문서화한-주석-유지"><a href="#불변속성을-문서화한-주석-유지" class="headerlink" title="불변속성을 문서화한 주석 유지"></a>불변속성을 문서화한 주석 유지</h2><ul><li><p>주석을 코드를 바꿀수 있는지?</p></li><li><p>검증하기 위한 자동화된 테스트를 만들 수 있는지?</p></li><li><p>위에 두개를 모두 실행할수 없으면 주석을 유지해야 한다</p></li></ul><h3 id="프로세스의-불변속성"><a href="#프로세스의-불변속성" class="headerlink" title="프로세스의 불변속성"></a>프로세스의 불변속성</h3><p>나무를 심기에 가장 좋은 때는 20년 전이었다. 두 번째로 좋은 때는 바로 지금이다</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/five-lines/">파이브 라인스 오브 코드</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/12/2023-12-27-five_lines_of_code_8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
