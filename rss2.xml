<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>폭간의 기술블로그</title>
    <link>https://sejoung.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잘정리하자</description>
    <pubDate>Fri, 01 Dec 2023 08:00:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>09장: 일관성과 합의</title>
      <link>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/</guid>
      <pubDate>Tue, 28 Nov 2023 01:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;h2 id=&quot;09장-일관성과-합의&quot;&gt;&lt;a href=&quot;#09장-일관성과-합의&quot; class=&quot;header
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><h2 id="09장-일관성과-합의"><a href="#09장-일관성과-합의" class="headerlink" title="09장: 일관성과 합의"></a>09장: 일관성과 합의</h2><p>결함의 가장 간단한 해결방법은 서비스가 실패하도록 두고 사용자에게 오류메시지를 보내는것</p><p>내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는것</p><p>분산시스템에 가장 중용한 추상화 중 하나는 합의</p><p>스플릿 브래인(split brain) : 두 노드가 자신이 리더라고 생각하는 상황</p><h3 id="일관성-보장"><a href="#일관성-보장" class="headerlink" title="일관성 보장"></a>일관성 보장</h3><p>복제 데이터베이스는 대부분 최소한 최종적 일관성(Eventual Consistency)을 제공한다</p><p>이것은 매우 약한 보장 언제 복제본이 수렴될지에 대해선 모른다</p><p>트랜젝션 격리는 주로 동시에 실행되는 트랜젝션 때문에 발생하는 경쟁조건을 회피하는것에 관한것</p><p>분산 일관성은 대게 지연과 결함이 있더라도 복제본 상태를 코디네이션 하는것</p><h3 id="선형성"><a href="#선형성" class="headerlink" title="선형성"></a>선형성</h3><p>선형성을 뒷바침 하는 아이디어</p><ul><li>원자적 일관성(atomic consistency)</li><li>강한 일관성(strong consistency)</li><li>즉각 일관성(immediate consistency)</li><li>외부 일관성(external consistency)</li></ul><p>선형성은 최신성 보장(recency guarantee)이다</p><ul><li>시스템에 선형성을 부여하는 것은 무엇인가?<ul><li>읽기가 새로운 값을 반환한 적이 있은 후에는 모든 후속 읽기도 반드시 새로운 값을 반환 해야 된다</li><li>선형성 대 직렬성<ul><li>직렬성 : 트랜잭션들의 격리 속성(트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해 준다)</li><li>선형성 : 레지스터에 실행되는 읽기 쓰기에 대한 최신성 보장이다</li></ul></li></ul></li><li>선형성에 기대기<ul><li>어떤 환경에서 선형성이 유용할까?<ul><li>잠금과 리더 선출<ul><li>아파치 주키퍼</li><li>etcd</li></ul></li><li>제약 조건과 유일성 보장<ul><li>엄격한 유일성 제약조건은 선형성이 필요하다</li></ul></li><li>채널 간 타이밍 의존성<ul><li>웹서버와 이미지 크기 변경 모듈 사이에 다른 통신 채널, 파일저장소와 메시지 큐 때문에 발생하는 문제</li></ul></li></ul></li></ul></li><li>선형성 시스템 구현하기<ul><li>복제 방법<ul><li>단일 리더 복제(선형적이 될 가능성이 있음)</li><li>합의 알고리즘(선형적)</li><li>다중 리더 복제(비선형적)</li><li>리더 없는 복제(아마도 비선형적)</li></ul></li><li>선형성과 정족수<ul><li>엄격한 정족수를 사용한 읽기는 선형적인 것처럼 보인다 하지만 네트워크 지연의 변동이 심하면 경쟁조건이 생길수 있다</li></ul></li></ul></li><li>선형성의 비용<ul><li>복제 방법중 선형성을 제공하는 것도 있고 그렇지 않은 것도 있다</li><li>단일 리더를 사용하는 데이터 베이스는 선형성을 제공하지만 리더가 장애가 나면 선형성을 제공하지 못한다</li><li>CAP 정리<ul><li>일관성(Consistency) : 모든 클라이언트가 같은 순간의 데이터를 보는 것</li><li>가용성(Availability) : 모든 클라이언트의 요청에 항상 응답을 주는 것</li><li>분단 내성(Partition tolerance) : 네트워크 장애가 일어나도 시스템이 정상적으로 동작하는 것</li></ul></li><li>선형성과 네트워크 지연<ul><li>실제로 선형적인 시스템은 놀랄 만큼 드물다</li><li>cpu의 램조차 선형적이지 않다</li><li>선형성을 제거한 이유는 내결함성이 아니라 성능이다</li></ul></li></ul></li></ul><h3 id="순서화-보장"><a href="#순서화-보장" class="headerlink" title="순서화 보장"></a>순서화 보장</h3><p>선형성을 보장할때 순서하가 중요한 근본적 아이디어일 수도 있다는것</p><ul><li>순서화와 인과성<ul><li>순서화가 인과성을 보존하는데 도움을 준다</li><li>질문과 답변사이의 인과적 의존성이 있다</li><li>트랜젝션은 일관된 스냅숏에서 읽는다고 했다 여기서 일관성은 인과성에 일관적이란 의미</li><li>시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다</li><li>인과적 순서가 전체 순서는 아니다<ul><li>수학적 집합은 항성 전체 순서를 정할수 있는건 아니다</li><li>부분적으로 순서가 정해진다(partially ordered)</li><li>선형성 : 시스템에서 연산의 전체순서를 정할수 있다</li><li>인과성 : 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻</li></ul></li><li>선형성은 인과적 일관성보다 강하다<ul><li>선형성은 인과성을 내포한다</li></ul></li><li>인과적 의존성 담기<ul><li>인과성이 유지하기 위해서 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다</li></ul></li></ul></li><li>일련번호 순서화<ul><li>일련번호나 타임스탬프를 써서 이벤트의 순서를 정할수 있다</li><li>일련번호나 타임스템프느는 크기가 작고 전체 순서를 제공한다</li><li>인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다</li><li>비인과적 일련번호 생성기<ul><li>각 노드가 자신만에 독립적인 일련번호 집합을 생성할수 있다</li><li>각 연산에 일 기준 시계에서 얻은 타임스템프를 붙일수 있다</li><li>일련번호 블록을 미리 할당할수 있다</li><li>생성한 일련번호가 인과성에 일관적이지 않다</li></ul></li><li>램포트 타임스템프<ul><li>인과성에 일관적인 일련번호 생성</li><li>모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킨다</li><li>항상 전체순서화를 강제화</li></ul></li></ul></li><li>전체 순서 브로드캐스트<ul><li>cpu에서 실행된 순서가 바로 전체 순서다</li><li>전체 순서 브로드캐스트(total order broadcast)</li><li>원자적 브로드캐스트(atmoic broadcast)</li><li>만족해야할 안전성 속성<ul><li>신뢰성 있는 전달(reliable delivery)</li><li>전체 순서가 정해진 전달(totally ordered delivery)</li></ul></li><li>전체 순서 브로드캐스트 사용하기<ul><li>상태 기계 복제(state machine replication) : 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다</li><li>직렬성 트랜적션을 구현하는데도 쓸수 있다</li><li>메시지가 전달하는 시점에 그 순서가 고정됨</li><li>로그를 만드는 방법 중 하나</li></ul></li><li>전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기<ul><li>전체 순서 브로드캐스트는 비동기식이다</li><li>순차적 일관성(sequential consistency) : 모든 클라이언트가 같은 순서로 메시지를 보는 것</li><li>타임라인 일관성(timeline consistency) : 모든 클라이언트가 같은 순서로 메시지를 보는 것</li></ul></li><li>선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기<ul><li>선형성 레지스터와 전체순서 브로드캐스트는 둘 다 합의와 동등하다고 증명할수 있다</li></ul></li></ul></li></ul><h3 id="분산-트랜잭션과-합의"><a href="#분산-트랜잭션과-합의" class="headerlink" title="분산 트랜잭션과 합의"></a>분산 트랜잭션과 합의</h3><p>여러 노드들이 뭔가에 동의하게 만드는것</p><p>리더선출, 원자적커밋</p><ul><li>원자적 커밋과 2단계 커밋(2PC)<ul><li>원자성은 주데이터와 보조색인이 일관성을 유지하도록 보장한다</li><li>단일 노드에서 분산 원자적 커밋으로<ul><li>단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현됨</li><li>커밋된 트랜잭션 효과는 나중에 다른 보상 트랜잭션(compensation transaction)을 실행해 취소할수 있다</li></ul></li><li>2단계 커밋 소개<ul><li>XA 트랜잭션</li><li>트랜잭션의 참여자(participant)</li><li>트랜잭션 코디네이터(coordinator)</li></ul></li><li>약속에 관한 시스템<ul><li>2PC는 약속에 관한 시스템(promise system)이다</li></ul></li><li>코디네이터 장애<ul><li>코디네이터가 장애가 나면 참여자들은 영원히 대기 상태에 빠진다</li></ul></li><li>3단계 커밋<ul><li>2PC는 코디네이터가 복구하기를 기다리느라 멈출 수 있다는 사실때문에 블로킹 원자적 커밋 프로토콜</li><li>2PC 대안으로 3PC가 있다</li><li>3PC는 원자성을 보장하지못한다</li></ul></li></ul></li><li>현실의 분산 트랜잭션<ul><li>데이터베이스 내부 분산 트랜잭션</li><li>이종 분산 트랜잭션</li><li>정확히 한 번 메시지 처리<ul><li>결과적으로(effectively), 정확히 한번(exactly once) 처리 되도록 보장할수 있다</li></ul></li><li>XA 트랜잭션<ul><li>X&#x2F;Open XA(Extended Architecture) 이종 기술에 걸친 2단계 커밋을 구현하는 표준</li></ul></li><li>의심스러운 상태에 있는 동안 잠금을 유지하는 문제<ul><li>데이터베이스는 트랜잭션이 커밋하거나 어보트할 떄까지 이런 잠금을 해제할 수 없다</li></ul></li><li>코디네이트 장애에서 복구하기<ul><li>고아가된(orphand) 트랜잭션 해결방법은 수동 커밋 롤백 선택</li><li>경험적 결정(hueristic decision) : 코디네이터가 장애가 나면 참여자들이 트랜잭션을 커밋하거나 어보트할 수 있다</li><li>경험적은 2PC 약속 체계를 위반하기 때문에 아마도 원자성을 깰 수 있다</li></ul></li><li>분산트랜잭션 제약<ul><li>코디네이터가 복제되지 않고 단일 장비에서 실행되면 단일 장애점(single point of failure)이 된다</li><li>코디네이터 서버가 어플리케이션의 일부가 되면 상태 비저장 서버가 아니다</li><li>XA가 최소 공통 분모가 되어야 된다</li><li>분산 트랜잭션은 장애를 증폭시키는 경향이 있다</li></ul></li></ul></li><li>내결함성을 지닌 합의<ul><li>합의 알고리즘<ul><li>군일한 동의</li><li>무결성</li><li>유효성</li><li>종료</li></ul></li><li>합의 알고리즘과 전체 순서 브로드캐스트<ul><li>뷰스탬프 복제(viewstamped replication), 팍소스(paxos), 라프트(raft)</li><li>순차열(sequence)에 대해 결정해서 전체 순서 알고리즘을 만든다</li><li>전체 순서 브로드캐스트는 합의를 여러번 반복하는것과 동일</li></ul></li><li>단일 리더 복제와 합의<ul><li>리더를 선출 할려면 먼저 리더가 필요?</li></ul></li><li>에포크 번호 붙이기와 정족수<ul><li>에포크 번호(epoch number)</li><li>투표 번호(ballot number)</li><li>뷰 번호(view number)</li><li>팀 번호(team number)</li></ul></li><li>합의의 제약<ul><li>장애 노드 감지를 위해 일반적으로 타임아웃에 의존</li></ul></li></ul></li><li>멤버십과 코디네이션 서비스<ul><li>분산 키-값 저장소, 코디네이션과 설정 서비스</li><li>선형성 원자적 연산</li><li>연산의 전체 순서화</li><li>장애 감지</li><li>변경 알림</li><li>작업을 노드에 할당하기<ul><li>노드들을 코디네이션 하는 작업의 일부를 외부 서이스에 위탁</li></ul></li><li>서비스 찾기<ul><li>서비스 디스커버리</li></ul></li><li>맴버십 서비스<ul><li>주키퍼와 유사 프로젝트들은 맴버쉽 서비스(membership service)</li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>합의의 문제점</p><ul><li>선형성 레지스터</li><li>원자적 트랜잭션 커밋</li><li>전체 순서 브로드캐스트</li><li>잠금과 임차권</li><li>맴버십&#x2F;코디네이션 서비스</li><li>유일성 제약조건</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-28-Designing_Data_Intensive_Applications_chapter9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>08장: 분산 시스템의 골칫거리</title>
      <link>https://sejoung.github.io/2023/11/2023-11-27-Designing_Data_Intensive_Applications_chapter8/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-27-Designing_Data_Intensive_Applications_chapter8/</guid>
      <pubDate>Mon, 27 Nov 2023 01:28:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;h2 id=&quot;08장-분산-시스템의-골칫거리&quot;&gt;&lt;a href=&quot;#08장-분산-시스템의-골칫거리&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><h2 id="08장-분산-시스템의-골칫거리"><a href="#08장-분산-시스템의-골칫거리" class="headerlink" title="08장: 분산 시스템의 골칫거리"></a>08장: 분산 시스템의 골칫거리</h2><p>엔지니어로서의 우리의 임무는 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축하는것</p><h3 id="결함과-부분-장애"><a href="#결함과-부분-장애" class="headerlink" title="결함과 부분 장애"></a>결함과 부분 장애</h3><p>하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다(결정적이다)</p><p>부분 장애(partial failure) : 분산시스템에서는 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는것도 무리가 아니다(비결정적)</p><ul><li>클라우드 컴퓨팅과 슈퍼컴퓨팅<ul><li>고성능 컴퓨팅(high performance computing, HPC) : 슈퍼컴퓨터는 하나의 컴퓨터로서 매우 빠른 연산을 수행하는데 초점을 맞춘다</li><li>클라우드 컴퓨팅(cloud computing) : 여러 컴퓨터를 연결하여 하나의 컴퓨터처럼 동작하게 하는데 초점을 맞춘다</li><li>결함처리는 소프트웨어 설계의 일부</li></ul></li></ul><h3 id="신뢰성-없는-네트워크"><a href="#신뢰성-없는-네트워크" class="headerlink" title="신뢰성 없는 네트워크"></a>신뢰성 없는 네트워크</h3><p>이더넷은 비동기 패킷 네트워크(asynchronous packet network)이다.<br>이더넷은 패킷을 전송하는데 있어서 신뢰성을 보장하지 않는다.<br>패킷이 손상되거나 유실되더라도 이더넷은 재전송을 보장하지 않는다.<br>이러한 문제를 다루는 흔한 방법은 타임아웃이다</p><ul><li>현실의 네트워크 결함<ul><li>네트워크 분단(네트워크 결함)</li><li>반드시 네트워크 결함을 견뎌내도록 처리할 필요 없다</li><li>카오스 몽키</li></ul></li><li>결함 감지<ul><li>많은 시스템은 결함이 있는 노드를 자동으로 감지할 수 있어야 된다</li></ul></li><li>타임아웃과 기약 없는 지연<ul><li>비동기 네트워크는 기약없는 지연(unbounded delay)을 가진다</li><li>네트워크 혼잡과 큐대기<ul><li>패킷 지연의 변동성은 큐대기 때문인 경우가 많다</li><li>트레픽이 많거나 자원을 많이 사용하는 누군가가 있으면 실험적으로 타임아웃을 설정할수 밖에 없다</li></ul></li></ul></li><li>동기 네트워크 대 비동기 네트워크<ul><li>전화 네트워크에서 통화를 할때는 회선이 만들어진다 (동기 네트워크)<ul><li>네트워크 지연을 예측 가능하게 만들 수는 없을까?<ul><li>왜 데이터센터 네트워크와 인터넷은 패킷 교환을 활용할까?<ul><li>버스트 트레픽(bursty traffic)에 최적화</li></ul></li></ul></li></ul></li><li>현제 배포된 기술로는 네트워크의 지연과 신뢰성에 대해 어떠한 보장도 할수 없다</li><li>타임아웃에는 올바른 값이 없으며 실험을 통해 결정해야 된다</li></ul></li></ul><h3 id="신뢰성-없는-시계"><a href="#신뢰성-없는-시계" class="headerlink" title="신뢰성 없는 시계"></a>신뢰성 없는 시계</h3><p>시계와 시간은 중요하다 다양한 방식으로 시계에 의존한다</p><p>지속시간 : 시간의 흐름을 측정하는 것<br>시점 : 특정 시간을 가리키는 것</p><ul><li>단조 시계 대 일 기준 시계<ul><li>단조 시계(monotonic clock) : 시간이 항상 증가하는 시계<ul><li>타임아웃이나 서비스 응답 시간 같은 지속 시간을 재는데 적합</li><li>분산 시스템에서 경과 시간을 재는데 단조시계를 사용하는것은 일반적으로 괜찮다</li></ul></li><li>일기준 시계(time-of-day clock)<ul><li>에포크(epoch) : 시간의 기준점 1970년 1월 1일 0시 0분 0초</li><li>NTP로 동기회</li></ul></li></ul></li><li>시계 동기화와 정확도<ul><li>단조시계는 동기화가 필요 없지만 일 기준 시계는 NTP로 동기화 해야 유용하다</li><li>드리프트(drift) 현상이 생긴다(더 빠르거나 느리게 실행된다)</li></ul></li><li>동기화된 시계에 의존하기<ul><li>하루는 정확히 86,400초가 아닐수도 있고 일 기준 시계가 시간이 거꾸로 갈 수도 있으며 노드의 시간이 다른 노드의 시간과 차이가 많이 날수도 있다</li><li>모든 장비의 시계 차이를 모니터링 해야 된다</li><li>이벤트 순서화용 타임스템프<ul><li>타임스템프로 이벤트 순서를 올바르게 정할수 없다</li><li>최종 쓰기 승리(last write wins) 전략을 사용하면 데이터가 유실 될수도 있다</li></ul></li><li>시계 읽기는 신뢰구간이 있다<ul><li>불확실성 경계는 시간 출처를 기반으로 계산할수 있다</li><li>예외 스페너에 있는 구글 트루 타임 API</li></ul></li><li>전역 스냅숏용 동기화된 시계<ul><li>동기화된 일 기준 시계의 타입스템프를 트랜잭션 ID로 쓸수 있을까? 동기화를 충분히 잘하면 가능<ul><li>스패너는 이런 방법으로 데이터센터에 결쳐서 스냅숏 격리를 구현한다</li><li>트랜잭션의 인과성을 반영하는것을 보장하기 위해 읽기 쓰기 트랜잭션을 커밋하기 전에 의도적으로 신뢰 구간의 길이만큼 기다린다</li></ul></li></ul></li></ul></li><li>프로세스 중단<ul><li>리더 선점 이슈 해결을 위해 동기화된 시계에 의존하는건 좋지 않다</li><li>스레드가 오랫동안 멈출수 있다</li><li>분산 시스템의 노드는 어느 시점에 실행이 상당한 시간 동안 멈출 수 있다고 가정해야 한다</li><li>응답 시간 보장<ul><li>어떤 시스템은 명시된 시간안에 응답하는데 실패하면 심각한 손상을 유발할 수 있는 환경에서 실행된다<ul><li>데드라인이 명시됨 엄격한 실시간 시스템(hard real-time system)</li></ul></li></ul></li><li>가비지 컬렉션의 영향을 제한하기<ul><li>GC 중단을 노드가 잠시 동안 계획적으로 중단되는 것으로 간주하고 노드가 GC하는 동안 클라이언트의 요청을 다른 노드들이 처리하게 하는 방법</li><li>수명이 짧은 객체만 GC를 사용하고 수명이 긴 객체의 전체 GC가 필요하면 주기적으로 재시작하는 방법</li></ul></li></ul></li></ul><h3 id="지식-진실-그리고-거짓말"><a href="#지식-진실-그리고-거짓말" class="headerlink" title="지식, 진실, 그리고 거짓말"></a>지식, 진실, 그리고 거짓말</h3><p>분산 시스템에서 네트워크 문제와 노드 자체의 문제를 확실히 구분하기 어렵다</p><ul><li>진실은 다수결로 결정된다<ul><li>정족수(quorum) : 다수결을 결정하는데 필요한 최소한의 노드 수 </li><li>다수결을 사용하면 노드의 문제를 구분할 수 있다</li><li>리더와 잠금(leader and lock) : 리더가 잠금을 획득하고 다수결로 결정된다</li><li>펜싱 토큰(fencing token): 잠금 서비스가 증가시키는 값 오래된 토큰의 사용을 거부</li></ul></li><li>비잔틴 결함<ul><li>펜싱토큰은 부주의에 의한 오류를 감지</li><li>시스템 보장을 무너뜨릶려면 가짜 펜싱 토큰을 포함한 메시지를 보내면 된다</li><li>비잔틴 결함(byzantine fault) : 잘못된 메시지를 보내는 노드를 포함한 비잔틴 장군 문제</li><li>비잔틴 내결함성(byzantine fault tolerance) : 비잔틴 결함을 감지하고 복구하는 시스템</li><li>약한 형태의 거짓말로 보호해주는 메커니즘을 소프트웨어에 추가하는게 가치가 있을수가 있다</li></ul></li><li>시스템 모델과 현실<ul><li>타이밍 가정에 대해서는 세가지 시스템 모델이 흔히 사용된다<ul><li>동기식 모델</li><li>부분 동기식 모델</li><li>비동기식 모델</li></ul></li><li>노드장애 고려<ul><li>죽으면 중단하는(crash-stop) 결함 : 노드가 죽으면 아무것도 하지 않는다</li><li>죽으면 복구하는(crash-recovery) 결함 : 노드가 죽으면 재시작한다</li><li>비잔틴(임의적인) 결함 : 노드가 임의적인 행동을 할 수 있다</li></ul></li><li>현실에서는 죽으면 복구하는 결함을 지닌 부분 동기식 모델이 일반적으로 가장 유용한 모델이다</li><li>알고리즘의 정확성<ul><li>정확하다는 알고리즘 속성에 만족하는지를 확인한다</li></ul></li><li>안정성과 할동성<ul><li>상황을 분명히 하기 위해 안정성과 활동성을 정의한다</li><li>안정성은 비공식적으로 나쁜 일은 일어나지 않는다</li><li>활동성은 비공식적으로 좋은 일은 결국일어난다</li></ul></li><li>시스템 모델을 현실 세계에 대응 시키기<ul><li>시스템 모델은 현실 세계를 단순화 하기 위한 도구이다(추상화)</li><li>알고리즘이 올바르다고 증명됐더라도 현실 시스템에서 구현도 언제나 올바르게 동작한다는 뜻은 아니다</li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul><li>부분실패가 생길수 있다</li><li>결함을 견뎌내려면 그것을 감지하는게 첫걸음</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-27-Designing_Data_Intensive_Applications_chapter8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>07장: 트랜잭션</title>
      <link>https://sejoung.github.io/2023/11/2023-11-23-Designing_Data_Intensive_Applications_chapter7/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-23-Designing_Data_Intensive_Applications_chapter7/</guid>
      <pubDate>Thu, 23 Nov 2023 01:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;h2 id=&quot;07장-트랜잭션&quot;&gt;&lt;a href=&quot;#07장-트랜잭션&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><h2 id="07장-트랜잭션"><a href="#07장-트랜잭션" class="headerlink" title="07장: 트랜잭션"></a>07장: 트랜잭션</h2><p>트렌젝션은 데이터베이스의 여러문제를 단순화하는 메커니즘으로 채택돼 왔다<br>트랜젝션은 애플리케이션에서 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.<br>데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든것이다</p><p>트랜잭션 격리 수준(isolation level)</p><ul><li>READ UNCOMMITTED : 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다.</li><li>READ COMMITTED : 커밋된 데이터만 읽을 수 있다.</li><li>snapshot isolation : 트랜잭션 시작 시점의 데이터를 읽을 수 있다.<ul><li>MVCC(Multi Version Concurrency Control) : 트랜잭션 시작 시점의 데이터를 읽을 수 있다.</li></ul></li><li>serializable : 트랜잭션을 순차적으로 실행한다.</li></ul><h3 id="애매모호한-트랜잭션의-개념"><a href="#애매모호한-트랜잭션의-개념" class="headerlink" title="애매모호한 트랜잭션의 개념"></a>애매모호한 트랜잭션의 개념</h3><p>현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜젝션을 지원한다</p><ul><li>ACID의 의미<ul><li>원자성(atomicity) : 트랜잭션은 성공하거나 실패하거나 둘 중 하나다.<ul><li>원자성은 동시성과 관련이 없다</li><li>abortablility : 트랜잭션을 중단하고 처음부터 다시 시작할 수 있는가?</li></ul></li><li>일관성(consistency) : 트랜잭션은 일관성 있는 상태를 유지한다. 트랜잭션 실행 전후에도 데이터베이스는 일관성 있는 상태를 유지해야 한다.<ul><li>복제일관성(replication consistency)</li><li>최종일관성(eventual consistency)</li><li>일관성 해싱(consistency hashing)</li><li>선형일관성(linearizability)</li><li>데이터베이스가 좋은 상태에 있어야 된다</li></ul></li><li>격리성(isolation) : 트랜잭션은 다른 트랜잭션의 연산에 끼어들 수 없다. 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.<ul><li>동시에 실행되는 트랜잭션은 서로 격리된다</li><li>직렬성(serializability)</li></ul></li><li>지속성(durability) : 트랜잭션을 성공적으로 완료했으면 그 결과가 항상 기록되어야 한다. 시스템에 문제가 발생하더라도 트랜잭션의 결과는 보존되어야 한다.</li><li>BASE(Basically Available, Soft state, Eventual consistency) : 일관성을 희생하고 유연성을 확보하는 방법이다. 데이터베이스가 항상 일관된 상태를 유지하지 않아도 되기 때문에 데이터베이스에 장애가 발생하더라도 가용성을 높일 수 있다.</li></ul></li><li>단일 객체 연산과 다중 객체 연산<ul><li>단일 객체 연산 : 트랜잭션은 하나의 객체만 변경한다.<ul><li>경량 트렌젝션(lightweight transaction) : 단일 객체 연산을 지원하는 트랜잭션</li></ul></li><li>다중 객체 연산 : 트랜잭션은 여러 객체를 변경한다.<ul><li>다중객체 트랜잭션의 필요성<ul><li>외래키 사용</li><li>비정규화된 정보를 갱신</li><li>색인 갱신</li></ul></li><li>오류와 어보트 처리<ul><li>오류가 생기면 어보트되고 안전하게 재시도할 수 있어야 된다</li></ul></li></ul></li></ul></li></ul><h3 id="완화된-격리-수준"><a href="#완화된-격리-수준" class="headerlink" title="완화된 격리 수준"></a>완화된 격리 수준</h3><p>트랜잭션 격리를 제공하여 동시성 문제를 감추려고 함</p><p>직렬성 격리(serializable isolation) : 트랜잭션을 순차적으로 실행하는 것처럼 보이게 하는 격리 수준</p><ul><li>커밋 후 읽기(Read Committed) : 트랜잭션이 커밋한 데이터만 읽을 수 있다.<ul><li>더티 읽기(dirty read) 방지</li><li>더티 쓰기(dirty write) 방지</li><li>여러 데이터 베이스의 기본설정</li></ul></li><li>스냅숏 격리와 반복 읽기 <ul><li>비반복 읽기(nonrepeatable read),읽기 스큐(read skew) : 트랜잭션 안에서 같은 쿼리를 두 번 실행했을 때 결과가 다른 현상</li><li>스냅숏 격리(snapshot isolation) : 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다</li><li>읽는 쪽에서 쓰는 쪽을 차단하지 않고 쓰는쪽에서 읽는 쪽을 차단하지 않는다</li><li>MVCC(Multi Version Concurrency Control) : 트랜잭션 시작 시점의 데이터를 읽을 수 있다.</li><li>일관된 스냅숏을 보는 가시성 규칙<ul><li>읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜젝션이 이미 커밋 상태</li><li>읽기 대상 객체가 삭제된것으로 표시되지 않음, 삭제 되었지만 읽기 트랜젝션이 시작된 시점에 커밋 되지 않음</li></ul></li><li>색인과 스냅숏 격리<ul><li>색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼수 없는 버전을 걸러내게 한다</li><li>가비지 컬렉션이 어떤 트랜잭션에게도 더이상 보이지 않은 오래된 객체 버전을 삭제할때 대응되는 색인도 삭제</li></ul></li><li>반복읽기와 혼란스러운 이름<ul><li>반복읽기(repeatable read) : 트랜잭션 안에서 같은 쿼리를 두 번 실행했을 때 결과가 같다</li><li>오라클에서는 직렬성(serializable)라고 부른다</li><li>sql 표준에서는 스냅숏 격리(snapshot isolation)개념이 없어서 다른이름으로 부른다</li></ul></li></ul></li><li>갱신 손실 방지<ul><li>갱신 손실(loss of updates) : 두 트랜잭션이 동일한 객체를 갱신할 때 마지막에 커밋한 트랜잭션만 반영되고 첫번째 트랜잭션의 갱신 결과는 사라지는 현상</li><li>갱신 손실 방지<ul><li>원자적 쓰기 연산</li><li>명시적 잠금</li><li>갱신 손실 자동 감지</li><li>compare-and-set</li><li>충돌해소와 복제<ul><li>최종 쓰기 승리(last write wins) : 갱신 손실이 발생하면 마지막에 갱신한 트랜잭션의 결과를 사용한다.</li></ul></li></ul></li></ul></li><li>쓰기 스큐와 팬텀<ul><li>쓰기 스큐(write skew) : 트랜잭션 안에서 두 객체를 갱신할 때 다른 트랜잭션이 그 사이에 객체를 갱신했을 때 발생하는 현상</li><li>팬텀(phantom) : 트랜잭션 안에서 같은 쿼리를 두 번 실행했을 때 결과 집합이 달라지는 현상<ul><li>충돌 구체화(materializing conflict)</li></ul></li></ul></li></ul><h3 id="직렬성"><a href="#직렬성" class="headerlink" title="직렬성"></a>직렬성</h3><p>가장 강력한 격리수준이지만 동시성 제어를 위해 가장 비싼 방법이다</p><ul><li>실제적인 직렬 실행<ul><li>동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것</li><li>직렬로 단일 스레드에서 실행</li><li>트랜잭션을 스토어드 프로시저 안에 캡슐화 하기<ul><li>스토어드 프로시저의 장단점<ul><li>벤더 마다 제각각 sp용 언어가 따로 있다</li><li>코드관리가 어렵다, 디버깅이 어렵다</li><li>데이터베이스 서버는 애플리케이션 서버보다 훨씬 성능에 민감하다(공유자원문제)</li></ul></li></ul></li><li>파티셔닝<ul><li>여러 cpu 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할수 있다</li><li>트랜젝션은 단일 파티션내에서만 데이터를 읽고 쓰도록 데이터셋을 파티션 할수 있으면 각각 트렌젝션 스레드를 가질수 있다</li></ul></li></ul></li><li>2단계 잠금(2PL)<ul><li>two-phase locking</li><li>쓰기 트렌젝션 뿐만 아니라 읽기 트랜잭션도 막는다</li><li>교착상태(deadlock) : 두 트랜잭션이 서로 상대방이 가지고 있는 잠금을 요구하면서 서로 기다리는 상황</li><li>성능이 약하다</li><li>팬덤을 막아야 된다(서술잠금)</li><li>색인범위잠금(index-range locking) 다음키 잠금(next-key locking)</li></ul></li><li>직렬성 스냅숏 격리(SSI)<ul><li>직렬성 스냅숏 격리(serializable snapshot isolation)</li><li>비관적 동시성 제어(pessimistic concurrency control) : 트랜잭션을 실행하기 전에 미리 잠금을 획득하는 방법</li><li>낙관적 동시성 제어(optimistic concurrency control) : 트랜잭션을 실행하는 도중에는 다른 트랜잭션과 충돌하지 않는다고 가정하고 트랜잭션을 실행한 다음에 충돌이 없었는지 확인하는 방법</li><li>오래된 MVCC 읽기 감지</li><li>과거의 읽기에 영향을 미치는 쓰기 감지</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-23-Designing_Data_Intensive_Applications_chapter7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>06장: 파티셔닝</title>
      <link>https://sejoung.github.io/2023/11/2023-11-21-Designing_Data_Intensive_Applications_chapter6/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-21-Designing_Data_Intensive_Applications_chapter6/</guid>
      <pubDate>Tue, 21 Nov 2023 08:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;h2 id=&quot;06장-파티셔닝&quot;&gt;&lt;a href=&quot;#06장-파티셔닝&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><h2 id="06장-파티셔닝"><a href="#06장-파티셔닝" class="headerlink" title="06장: 파티셔닝"></a>06장: 파티셔닝</h2><p>데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다 이작업을 샤딩이라고도 한다</p><p>파티션을 나눌때 보통 각 데이터 단위가 하나의 파티션에 속한다</p><p>파티셔닝의 주된 이유 : 확장성</p><h3 id="파티셔닝과-복제"><a href="#파티셔닝과-복제" class="headerlink" title="파티셔닝과 복제"></a>파티셔닝과 복제</h3><p>보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.<br>각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장</p><p>한 노드에 여러 파티션을 저장할수도 있다.</p><h3 id="키-값-데이터-파티셔닝"><a href="#키-값-데이터-파티셔닝" class="headerlink" title="키-값 데이터 파티셔닝"></a>키-값 데이터 파티셔닝</h3><p>파티셔닝의 목적의 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.<br>파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 한다.<br>쏠림이 있으면 효과가 매우 떨어진다<br>불균형하게 부하가 높은 파티션을 핫스팟이라고 한다</p><p>핫스팟을 피하는 가장 단순한 방법은 레코드를 할당할 노드를 무작위로 선택하는것<br>하지만 단점이 있는데 어떤 레코드를 읽으려고 할때 해당 레코드가 어느 노드에 저장됐는지 알수없으므로 코든 노드에서 병렬적으로 질의를 실행해야 한다</p><ul><li><p>키 범위 기준 파티셔닝</p><ul><li>각파티션에 연속된 범위의 키를 할당하는것</li><li>키 범위 크기가 모두 동일할 필요는 없다</li><li>데이터를 고르게 분산 시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다</li><li>키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다</li></ul></li><li><p>키의 해시값 기준 파티셔닝</p><ul><li>쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는데 해시 함수를 사용한다</li><li>좋은 해시함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다</li><li>파티셔닝용 해시함수는 암호적으로 강력할 필요는 없다</li><li>키를 파티션 사이에 균일하게 분산시키는데 좋다 파티션 경계는 크기가 동일하도록 나눌수도 있고 무작위에 가깝게 선택할 수도 있다 이런 기법을 일관성 해싱이라고 부른다</li><li>카산드라는 두 가지 파티셔닝 전략 사이에 타협한다 복합 기본키를 지정</li></ul></li><li><p>쏠린 작업부하와 핫스팟 완화</p><ul><li>유명인 문제</li><li>간단한 해결책은 각키의 시작이나 끝에 임의의 숫자를 붙이는것 10진수 2개만 붙혀도 100개의 다른 키로 균등하게 분산<ul><li>요청수가 몰리는 소수의 키에만 적용</li><li>어떤 키가 쪼개졌는지 추적할 방법도 있어야 된다</li></ul></li></ul></li></ul><h3 id="파티셔닝과-보조-색인"><a href="#파티셔닝과-보조-색인" class="headerlink" title="파티셔닝과 보조 색인"></a>파티셔닝과 보조 색인</h3><p>지금까지의 설명한 파티셔닝 방식은 키-값 데이터 모델에 의존한다<br>보조색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는 두가지 방법이 있다.</p><ul><li>문서 기준 보조 색인 파티셔닝<ul><li>문서 ID 라고 부르는 고유 ID가 있고 해데이터베이스를 문서 ID 기준으로 파티셔닝 한다</li><li>보조 색인을 만들어서 문서ID를 값으로 하는 색인을 따로 만든다</li><li>지역 색인(local index)라고도 부른다</li><li>지역 색인을 하기 위해서 모든 파티션에 질의를 보내서 얻은 결과를 모아야 된다<ul><li>스캐터&#x2F;게더(scatter&#x2F;gather)라고 부른다</li></ul></li></ul></li><li>용어 기준 보조 색인 파티셔닝<ul><li>모든 파티션의 데이터를 담당하는 전역 색인을 만들수도 있다</li><li>용어기준으로 파티셔닝됐다(term-partitioned)라고 부른다</li><li>읽기가 효율적이다</li><li>전역 색인은 느리고 복잡하다</li><li>비동기적으로 갱신됀다</li></ul></li></ul><h3 id="파티션-재균형화"><a href="#파티션-재균형화" class="headerlink" title="파티션 재균형화"></a>파티션 재균형화</h3><p>시간이 지나면 데이터 베이스에 변화가 생긴다<br>변화가 생기면 데이터와 요청이 한노드에서 다른노드로 옴겨져야 한다<br>이과정을 재균형화(rebalancing)라고 한다</p><p>재균형화의 기대값</p><ul><li><p>부하가 클러스터내에 있는 노드에 균등하게 분배된다</p></li><li><p>재균형화 도중에도 데이터 베이스는 읽기 쓰기 요청을 받아들여야 한다</p></li><li><p>재균형화가 빨리 실행되고 네트워크와 디스크 I&#x2F;O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옴겨지면 안된다</p></li><li><p>재균형화 전략</p><ul><li>쓰면 안되는 방법 : 해시값에 모드 N 연산을 실행(% 연산)</li><li>파티션 갯수 고정<ul><li>전체 데이터셋의 크기 변동이 심하다면 적절한 파티션 개수를 정하기 어렵다</li></ul></li><li>동적 파티셔닝<ul><li>파티션의 크기가 넘어가면 파티션을 쪼개서 각각에 원래 파티션의 데이터 절반정도가 포함되게 한다 반대의 경우 합칠수도 있다</li><li>파티션 갯수가 전체 데이터 용량에 맞춰 조정된다는 이점</li><li>빈데이터 베이스는 파티션 경계를 어디로 정해야 되는지 정보가 없어서 하나의 파티션이라는 함정이 있다<ul><li>이문제를 해결하기 위해 사전분활(pre-splitting)이라는 방법을 사용한다</li></ul></li></ul></li><li>노드 비례 파티셔닝<ul><li>노드당 할당되는 파티션 개수를 고정한다</li><li>노드가 추가되면 고정된 갯수의 파티션을 무작위로 선택해 분할하고 각 분할 파티션의 절반은 그대로 두고 다른 절반은 새노드에 할당한다</li><li>파티션의 경계를 무작위로 선택하려면 해시 기반 파티셔닝을 사용해야 한다</li></ul></li></ul></li><li><p>운영: 자동 재균형화와 수동 재균형화</p><ul><li>자동실행? 수동실행?</li><li>완전 자동 재균형화<ul><li>유지보수에 손이 덜가서 편할수 있다</li><li>예측이 어렵다</li></ul></li><li>완전수동 재균형화</li></ul></li></ul><h3 id="요청-라우팅"><a href="#요청-라우팅" class="headerlink" title="요청 라우팅"></a>요청 라우팅</h3><p>서비스 찾기(service discovery) : 클라이언트가 요청을 보낼때 어떤 노드에 보낼지 알아야 한다</p><p>몽고 디비 : 설정서버(config server), 몽고스(mongos)</p><ul><li>병렬 질의 실행<ul><li>대규모 병렬 처리(massively parallel processing, MPP)</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>주요 파티셔닝 기법</p><ul><li>키 법위 파티셔닝</li><li>해시 파티셔닝</li><li>문서 기준 파티셔닝</li><li>용어 기준 파티셔닝</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-21-Designing_Data_Intensive_Applications_chapter6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>우분투 NVIDIA 드라이버 설치(ubuntu-drivers 사용)</title>
      <link>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_nvidia_driver_install/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_nvidia_driver_install/</guid>
      <pubDate>Tue, 21 Nov 2023 01:57:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;우분투-NVIDIA-드라이버-설치-ubuntu-drivers-사용&quot;&gt;&lt;a href=&quot;#우분투-NVIDIA-드라이버-설치-ubuntu-drivers-사용&quot; class=&quot;headerlink&quot; title=&quot;우분투 NVIDIA 드라이버 설치(u
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="우분투-NVIDIA-드라이버-설치-ubuntu-drivers-사용"><a href="#우분투-NVIDIA-드라이버-설치-ubuntu-drivers-사용" class="headerlink" title="우분투 NVIDIA 드라이버 설치(ubuntu-drivers 사용)"></a>우분투 NVIDIA 드라이버 설치(ubuntu-drivers 사용)</h1><p>ubuntu-drivers를 사용하여 NVIDIA 드라이버를 설치하는 방법을 알아보자.</p><h2 id="드라이버-버전-확인"><a href="#드라이버-버전-확인" class="headerlink" title="드라이버 버전 확인"></a>드라이버 버전 확인</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/driver/nvidia/version</span><br></pre></td></tr></table></figure><h2 id="드라이버-확인"><a href="#드라이버-확인" class="headerlink" title="드라이버 확인"></a>드라이버 확인</h2><h3 id="데스크탑"><a href="#데스크탑" class="headerlink" title="데스크탑"></a>데스크탑</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers list</span><br></pre></td></tr></table></figure><h3 id="서버"><a href="#서버" class="headerlink" title="서버"></a>서버</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers list --gpgpu</span><br></pre></td></tr></table></figure><h2 id="일반-용도-예-데스크탑-및-게임-용-드라이버-설치"><a href="#일반-용도-예-데스크탑-및-게임-용-드라이버-설치" class="headerlink" title="일반 용도(예: 데스크탑 및 게임)용 드라이버 설치"></a>일반 용도(예: 데스크탑 및 게임)용 드라이버 설치</h2><p>가장 적합한 드라이버를 설치한다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers install</span><br></pre></td></tr></table></figure><p>특정 버전설치 설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers install nvidia:525</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="GPGPU-용도-예-서버-용-드라이버-설치"><a href="#GPGPU-용도-예-서버-용-드라이버-설치" class="headerlink" title="GPGPU 용도(예: 서버)용 드라이버 설치"></a>GPGPU 용도(예: 서버)용 드라이버 설치</h2><p>가장 적합한 드라이버를 설치한다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers install --gpgpu</span><br></pre></td></tr></table></figure><p>특정 버전설치 설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers install --gpgpu nvidia:525-server</span><br><span class="line"></span><br><span class="line">sudo apt install nvidia-utils-525-server</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="삭제"><a href="#삭제" class="headerlink" title="삭제"></a>삭제</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt --purge remove &#x27;*nvidia*$&#123;DRIVER_BRANCH&#125;*&#x27;</span><br><span class="line"></span><br><span class="line">sudo apt autoremove</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://ubuntu.com/server/docs/nvidia-drivers-installation">NVIDIA 드라이버 설치</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_nvidia_driver_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>update-alternatives (기본값 심볼릭 링크 관리)</title>
      <link>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_update-alternatives/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_update-alternatives/</guid>
      <pubDate>Tue, 21 Nov 2023 01:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;update-alternatives-기본값-심볼릭-링크-관리&quot;&gt;&lt;a href=&quot;#update-alternatives-기본값-심볼릭-링크-관리&quot; class=&quot;headerlink&quot; title=&quot;update-alternatives (기본값 심
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="update-alternatives-기본값-심볼릭-링크-관리"><a href="#update-alternatives-기본값-심볼릭-링크-관리" class="headerlink" title="update-alternatives (기본값 심볼릭 링크 관리)"></a>update-alternatives (기본값 심볼릭 링크 관리)</h1><p>우분투를 사용할때 여러버전의 자바와 파이썬을 사용해야 할때가 있다.<br>이럴때 update-alternatives를 사용하면 편리하다.</p><h2 id="조회-방법"><a href="#조회-방법" class="headerlink" title="조회 방법"></a>조회 방법</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update-alternatives --config python</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="등록-방법"><a href="#등록-방법" class="headerlink" title="등록 방법"></a>등록 방법</h2><p>등록 방법은 아래와 같다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.11 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="설정-방법"><a href="#설정-방법" class="headerlink" title="설정 방법"></a>설정 방법</h2><p>설정 방법은 아래와 같다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update-alternatives --set python /usr/bin/python3.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="삭제-방법"><a href="#삭제-방법" class="headerlink" title="삭제 방법"></a>삭제 방법</h2><p>삭제 방법은 아래와 같다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update-alternatives --remove python /usr/bin/python3.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://manpages.ubuntu.com/manpages/trusty/man8/update-alternatives.8.html">update-alternatives man</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-21-ubuntu_update-alternatives/#disqus_thread</comments>
    </item>
    
    <item>
      <title>github 여러 계정 관리(ssh)</title>
      <link>https://sejoung.github.io/2023/11/2023-12-05-git_multiple_accounts/</link>
      <guid>https://sejoung.github.io/2023/11/2023-12-05-git_multiple_accounts/</guid>
      <pubDate>Tue, 21 Nov 2023 01:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;github-여러-계정-관리-ssh&quot;&gt;&lt;a href=&quot;#github-여러-계정-관리-ssh&quot; class=&quot;headerlink&quot; title=&quot;github 여러 계정 관리(ssh)&quot;&gt;&lt;/a&gt;github 여러 계정 관리(ssh)&lt;/h1&gt;&lt;h2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="github-여러-계정-관리-ssh"><a href="#github-여러-계정-관리-ssh" class="headerlink" title="github 여러 계정 관리(ssh)"></a>github 여러 계정 관리(ssh)</h1><h2 id="ssh-키-생성"><a href="#ssh-키-생성" class="headerlink" title="ssh 키 생성"></a>ssh 키 생성</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;sejoung@gmail.com&quot; -f &quot;id_ed25519_sejoung&quot;</span><br><span class="line"></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;beni@realdraw.ai&quot; -f &quot;id_ed25519_beni&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ssh-키-등록"><a href="#ssh-키-등록" class="headerlink" title="ssh 키 등록"></a>ssh 키 등록</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519_sejoung</span><br><span class="line"></span><br><span class="line">ssh-add ~/.ssh/id_ed25519_beni</span><br></pre></td></tr></table></figure><p>등록된 ssh 키 등록 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><h2 id="키등록"><a href="#키등록" class="headerlink" title="키등록"></a>키등록</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_ed25519_sejoung.pub</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_ed25519_beni.pub</span><br></pre></td></tr></table></figure><h2 id="ssh-config-설정"><a href="#ssh-config-설정" class="headerlink" title="ssh config 설정"></a>ssh config 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User sejoung</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_sejoung</span><br><span class="line"></span><br><span class="line">Host github.com-beni</span><br><span class="line">  HostName github.com</span><br><span class="line">  User beni</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_beni  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="설정-후-테스트"><a href="#설정-후-테스트" class="headerlink" title="설정 후 테스트"></a>설정 후 테스트</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">ssh -T git@github.com-beni</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.github.com/ko/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">새 SSH 키 생성 및 ssh-agent에 추가</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-12-05-git_multiple_accounts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>05장: 복제</title>
      <link>https://sejoung.github.io/2023/11/2023-11-16-Designing_Data_Intensive_Applications_chapter5/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-16-Designing_Data_Intensive_Applications_chapter5/</guid>
      <pubDate>Thu, 16 Nov 2023 08:01:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;분산-데이터&quot;&gt;&lt;a href=&quot;#분산-데이터&quot; class=&quot;headerlink&quot; title=&quot;분산 데이터&quot;&gt;&lt;/a&gt;분산 데이터&lt;/h1&gt;&lt;p&gt;기술이 성공하기 위해서 홍보보다 현실이 우선돼야 한다. 자연을 속일 수는 없기 때문이다 - Ric
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="분산-데이터"><a href="#분산-데이터" class="headerlink" title="분산 데이터"></a>분산 데이터</h1><p>기술이 성공하기 위해서 홍보보다 현실이 우선돼야 한다. 자연을 속일 수는 없기 때문이다 - Richard Feynman</p><p>여러 장비 간 분산된 데이터베이스를 필요로 하는 이유</p><ul><li><p>확장성</p></li><li><p>내결함성&#x2F;고가용성</p></li><li><p>지연시간</p></li><li><p>고부하로 확장</p><ul><li>수직확장, 용량확장, 공유메모리 아키텍처</li><li>비공유 아키텍처<ul><li>수평확장</li></ul></li><li>복제 대 파티셔닝<ul><li>여러 노드에 데이터 분산 방법<ul><li>복제</li><li>파티셔닝</li></ul></li></ul></li></ul></li><li><p>참고 문헌</p></li></ul><h2 id="05장-복제"><a href="#05장-복제" class="headerlink" title="05장: 복제"></a>05장: 복제</h2><p>잘못될 수 있는 것과 잘못될 수 없는 겂 사이의 주된 차이점은 잘못될 수 없는 겂이 잘못됐을 때는 잘못을 파악하거나 고치는 것은 거의 불가능하다 - 더글라스 애덤스</p><p>복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다</p><ul><li>지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다</li><li>시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다</li><li>읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다</li></ul><p>노드간 변경을 위한 인기 있는 알고리즘</p><ul><li>단일 리더</li><li>다중 리더</li><li>리더 없는</li></ul><h3 id="리더와-팔로워"><a href="#리더와-팔로워" class="headerlink" title="리더와 팔로워"></a>리더와 팔로워</h3><p>데이터베이스의 복사본을 저장하는 각 노드를 복제서버 라고 한다</p><ul><li>동기식 대 비동기식 복제<ul><li>동기식 복제<ul><li>팔로워와 리더가 일관성이 있다</li><li>하지만 비현실적</li></ul></li><li>비동기식 복제<ul><li>보통의 리더기반 복제는 완전히 비동기식으로 구성된다</li></ul></li></ul></li><li>새로운 팔로워 설정<ul><li>새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장?<ul><li>스냅샷을 일정 시점에 가지고 옴</li><li>스냅숏을 새로운 팔로워 노드에 복사</li><li>팔로워는 리더에서 연결해서 스냅숏 이후에 데이터를 동기화</li></ul></li></ul></li><li>노드 중단 처리<ul><li>팔로워 장애: 따라잡기 복구<ul><li>팔로워가 장애 후에 복구 되면 리더에서 새로운 데이터를 다시 동기화함</li></ul></li><li>리더 장애: 장애 복구<ul><li>장애복구(failover)<ul><li>리더가 장애인지 판단</li><li>새로운 리더를 선택</li><li>새로운 리더 사용을 위해 시스템을 재설정</li></ul></li><li>장애 복구 과정의 문제<ul><li>비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신 하지 못할수 있다</li><li>쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 네용에 맞추 조정돼한한다면 특히 위험</li><li>특정 결함 시나리오 두 노드가 모두 자신이 리더라고 믿을 수 있다 - 스플릿 브레인</li><li>리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마일까?</li></ul></li></ul></li></ul></li><li>복제 로그 구현<ul><li>구문기반 복제<ul><li>SQL 구분을 파싱해서 실행</li><li>구문을 기록할때 결정적 함수 호출을 고정 값을 반환하게끔 대체</li></ul></li><li>쓰기 전 로그 배송<ul><li>리더가 로그를 쓰기 전에 팔로워에게 로그를 보냄</li><li>로그가 제일 저수준의 데이터를 기술한다는 점</li></ul></li><li>논리적(로우 기반) 로그 복제<ul><li>복제와 저장소 엔진을 위해 다른 로그 포멧형식을 사용하는 것</li><li>change data capture(CDC)라고도 함</li></ul></li><li>트리거 기반 복제<ul><li>트리거나 스토어드 프로시저를 사용</li></ul></li></ul></li></ul><h3 id="복제-지연-문제"><a href="#복제-지연-문제" class="headerlink" title="복제 지연 문제"></a>복제 지연 문제</h3><p>읽기 확장 아키텍처에서 간단히 팔로워를 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴수 있다</p><p>최종적 일관성</p><ul><li>자신이 쓴 내용 읽기<ul><li>쓰기 후 읽기 일관성(자신의 쓰기 읽기 일관성)</li><li>크로스 디바이스</li></ul></li><li>단조 읽기<ul><li>시간이 거꾸러 흐르는 현상 - 단조 읽기는 이런 종류 이상이 발생하지 않음을 보장한다</li><li>강한 일관성 보다는 덜한 보장이지만 최종일관성보다는 더 강한 보장이다</li></ul></li><li>일관된 순서로 읽기<ul><li>복제 지연이 일어 날수 있다</li><li>일관된 순서로 일기</li></ul></li><li>복제 지연을 위한 해결책<ul><li>트렌젝션이 있는 이유 - 올바른 작성수행을 항상 보장하기 위해</li></ul></li><li>다중 리더 복제<ul><li>마스터&#x2F;마스터 복제, 엑티브&#x2F;엑티브 복제</li><li>다중 리더 복제의 사용 사례<ul><li>다중 데이터 센터 운영</li><li>성능, 데이터센터 중단 내성, 네트워크 문제 내성</li><li>오프라인 작업하는 클라이언트</li><li>실시간 협업 편집</li></ul></li><li>쓰기 충돌 다루기<ul><li>다중 리더 복제는 쓰기 충돌이 일어난다</li><li>동기 대 비동기 충돌 감지<ul><li>쓰기 완료전에 쓰기 차단</li><li>충돌 회피</li><li>일관된 상태 수렴</li><li>사용자 정의 충돌 해소 로직<ul><li>쓰기 수행중<ul><li>충돌 핸들러를 호출</li></ul></li><li>읽기 수행 중<ul><li>충돌을 감지하면 모든 충돌 쓰기를 저장한다 그리고 어플리케이션에 여러 데이터를 리턴하고 어플리케이션에서 충돌이 해소 되면 저장</li></ul></li></ul></li><li>충돌은 무엇인가?</li></ul></li></ul></li><li>다중 리더 복제 토폴로지<ul><li>전체 연결</li><li>원형 토플로지<ul><li>single point of failure</li></ul></li><li>별모양 토폴로지<ul><li>single point of failure</li></ul></li></ul></li></ul></li><li>리더 없는 복제<ul><li>노드가 다운됐을 때 데이터베이스에 쓰기<ul><li>읽기 복구와 안티 엔트로피</li><li>읽기와 쓰기를 위한 정족수</li></ul></li><li>정족수 일관성의 한계<ul><li>최신성 모니터링<ul><li>최신 결과를 반환하는지 모니터링</li></ul></li></ul></li><li>느슨한 정족수와 암시된 핸드오프<ul><li>느슨한 정족수</li><li>암시된 핸드오프</li><li>다중 데이터센터 운영</li></ul></li><li>동시 쓰기 감지<ul><li>최종 쓰기 승리(동시쓰기 버리기)</li><li>이전 발생 관계와 동시성</li><li>이전 발생 관계 파악</li><li>동시에 쓴 값 병합</li><li>버전 벡터</li></ul></li></ul></li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>고가용성</li><li>연결이 끊긴 작업</li><li>지연 시간</li><li>확장성</li></ul><p>복제</p><ul><li>단일 리더 복제</li><li>다중 리더 복제</li><li>리더 없는 복제</li></ul><p>일관성 모델</p><ul><li>쓰기 후 읽기 일관성</li><li>단조 일기</li><li>일관된 순서로 일기</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-16-Designing_Data_Intensive_Applications_chapter5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>cuDNN 설치</title>
      <link>https://sejoung.github.io/2023/11/2023-11-14-cudnn_install/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-14-cudnn_install/</guid>
      <pubDate>Tue, 14 Nov 2023 04:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;cuDNN-설치&quot;&gt;&lt;a href=&quot;#cuDNN-설치&quot; class=&quot;headerlink&quot; title=&quot;cuDNN 설치&quot;&gt;&lt;/a&gt;cuDNN 설치&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.nvidia.com/cuda-dow
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="cuDNN-설치"><a href="#cuDNN-설치" class="headerlink" title="cuDNN 설치"></a>cuDNN 설치</h1><p><a href="https://developer.nvidia.com/cuda-downloads">CUDA Toolkit 12.3 Downloads</a> 링크에 따라 설치 하면 됨</p><p>나는 runfile(local)로 설치함</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.3.0/local_installers/cuda_12.3.0_545.23.06_linux.run</span><br><span class="line">sudo sh cuda_12.3.0_545.23.06_linux.run</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>여기서 드라이브는 이미 설치했으니 툴킷만 설치하면 됨 </p><p>아래의 명령어로 설치 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tar -xvf cudnn-linux-x86_64-8.9.6.50_cuda12-archive.tar.xz</span><br><span class="line"></span><br><span class="line">sudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/include</span><br><span class="line"></span><br><span class="line">sudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64</span><br><span class="line"></span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn*</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="검증-툴"><a href="#검증-툴" class="headerlink" title="검증 툴"></a>검증 툴</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> git clone https://github.com/sejoung/cudnn_samples_v8.git</span><br><span class="line"> </span><br><span class="line"> cd cudnn_samples_v8/mnistCUDNN</span><br><span class="line"></span><br><span class="line">make all TARGET_ARCH=x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="freeImage-에러시에-아래-절차-수행"><a href="#freeImage-에러시에-아래-절차-수행" class="headerlink" title="freeImage 에러시에 아래 절차 수행"></a>freeImage 에러시에 아래 절차 수행</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libfreeimage3 libfreeimage-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cuda-12-버전-오류"><a href="#cuda-12-버전-오류" class="headerlink" title="cuda 12 버전 오류"></a>cuda 12 버전 오류</h3><p>make all TARGET_ARCH&#x3D;x86_64 실행시에 아래와 같은 오류가 발생함 <a href="https://forums.developer.nvidia.com/t/nvcc-fatal-unsupported-gpu-architecture-compute-35/247815">Nvcc fatal : Unsupported gpu architecture ‘compute_35’</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc fatal   : Unsupported gpu architecture &#x27;compute_35&#x27;</span><br></pre></td></tr></table></figure><p>그래서 makefile 해당 부분 61로 수정 <a href="https://github.com/sejoung/cudnn_samples_v8.git">cudnn_samples_v8</a> 수정해 놓은 github</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.nvidia.com/deploy/cuda-compatibility/">CUDA Compatibility</a></li><li><a href="https://developer.nvidia.com/cuda-gpus">Your GPU Compute Capability</a></li><li><a href="https://developer.nvidia.com/cuda-downloads">CUDA Toolkit 12.3 Downloads</a></li><li><a href="https://www.wikiwand.com/en/CUDA">CUDA</a></li><li><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">Installation Guide</a></li><li><a href="https://forums.developer.nvidia.com/t/nvcc-fatal-unsupported-gpu-architecture-compute-35/247815">Nvcc fatal : Unsupported gpu architecture ‘compute_35’</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-14-cudnn_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>04장: 부호화와 발전</title>
      <link>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/</guid>
      <pubDate>Tue, 14 Nov 2023 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-시스템의-기초&quot;&gt;&lt;a href=&quot;#데이터-시스템의-기초&quot; class=&quot;headerlink&quot; title=&quot;데이터 시스템의 기초&quot;&gt;&lt;/a&gt;데이터 시스템의 기초&lt;/h1&gt;&lt;h2 id=&quot;04장-부호화와-발전&quot;&gt;&lt;a href=&quot;#04장-부호
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-시스템의-기초"><a href="#데이터-시스템의-기초" class="headerlink" title="데이터 시스템의 기초"></a>데이터 시스템의 기초</h1><h2 id="04장-부호화와-발전"><a href="#04장-부호화와-발전" class="headerlink" title="04장: 부호화와 발전"></a>04장: 부호화와 발전</h2><p>만물은 변한다 그대로 있는 것은 아무것도 없다 - 헤라클레이토스</p><p>시스템이 계속 원활하게 실행되게 하려면 양방향 호환성을 유지해야 된다</p><ul><li>하위호환성 (backwards compatibility) 새로운 코드는 예전 코드가 기록한 데이터를 읽을수 있어야 된다</li><li>상위호환성 (forward compatibility) 예전 코드는 새로운 코드가 기록한 데이터를 읽을수 있어야 된다</li></ul><h3 id="데이터-부호화-형식"><a href="#데이터-부호화-형식" class="headerlink" title="데이터 부호화 형식"></a>데이터 부호화 형식</h3><p>프로그램은 보통 두가지 형태로 표현된 데이터를 사용<br>    - 메모리에 자료구조<br>    - 파일에 쓰거나 바이트 형태</p><p>마샬링 언마샬링</p><ul><li><p>언어별 형식</p><ul><li>부호화는 보통 특정 프로그램밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다</li><li>동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다</li><li>테이터 버전 관리는 보통 부호화 라이브러리에서 나중에 생각하게 된다</li><li>효율성도 나중에 생각하게 된다</li></ul></li><li><p>JSON과 XML, 이진 변형</p><ul><li>문제? <ul><li>JSON과 XML은 텍스트 형식이라서 사람이 읽을수 있고 기계가 읽을수 있어서 인기가 많다</li><li>JSON과 XML은 표준 라이브러리가 있어서 다른 언어에서도 읽고 쓸수 있다</li><li>JSON과 XML은 텍스트 형식이라서 크기가 크고 이진 형식보다 느리다</li><li>JSON과 XML은 모두 스키마를 지원한다</li><li>CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이션이 해야 한다</li></ul></li><li>이진 부호화<ul><li>좀더 간편하고 파싱이 빠른 형식</li></ul></li></ul></li><li><p>스리프트와 프로토콜 버퍼</p><ul><li>이진 부호화 라이브러리</li><li>프로토 버퍼는 구글</li><li>스리프트는 페이스북</li><li>필드태그와 스키마 발전<ul><li>스키마 발전</li><li>테그번호로 상위호환 하위호환을 유지</li></ul></li><li>데이터타입과 스키마 발전<ul><li>불가능하진 않지만 값이 정확하지 않거나 짤릴 위험이 있다</li></ul></li></ul></li><li><p>아브로</p><ul><li>하둡의 하위호환 프로젝트</li><li>스키마를 사용</li><li>스키마는 JSON으로 정의</li><li>쓰기 스키마 - 데이터를 쓸때 사용</li><li>읽기 스키마 - 데이터를 읽을때 사용</li><li>두개의 스키마가 동일하지 않아도 되며 호환가능하면 된다</li><li>스키마 발전 규칙<ul><li>호환성을 유지하기 위해서 기본값이 있는 필드만 추가하거나 삭제할수 있다</li><li>필드에서 널을 허용하려면 유니온 타입을 사용해야 된다</li></ul></li><li>동적 생성 스키마</li><li>코드 생성과 동적 타입언어</li></ul></li><li><p>스키마의 장점</p><ul><li>유효성 검사를 지원</li><li>문서화</li><li>코드 생성</li><li>데이터베이스 스키마를 유지하면 스키마 변경이 적용되지 전에 상위 호환성과 하위 호환성을 확인할 수 있다</li></ul></li></ul><h3 id="데이터플로-모드"><a href="#데이터플로-모드" class="headerlink" title="데이터플로 모드"></a>데이터플로 모드</h3><ul><li>데이터베이스를 통한 데이터플로<ul><li>다양한 시점에 기록된 다양한 값<ul><li>데이터가 코드보다 더 오래 산다</li><li>마이그레이션은 값비싼 작업이다</li></ul></li><li>보관 저장서<ul><li>데이터베이스 스냅샷</li></ul></li></ul></li><li>서비스를 통한 데이터플로: REST와 RPC<ul><li>서비스 지향 설계</li><li>마이크로서이스 설계</li><li>웹서비스<ul><li>REST<ul><li>HTTP 프로토콜</li></ul></li><li>SOAP<ul><li>XML, WSDL, XSD</li></ul></li></ul></li><li>RCP 문제<ul><li>서비스가 다운되면 클라이언트도 다운된다</li><li>서비스가 다운되면 클라이언트가 다운되지 않더라도 서비스를 사용할수 없다</li></ul></li><li>RCP의 현재 방향<ul><li>서비스 디스커버리</li></ul></li><li>데이터 부호화와 RPC의 발전<ul><li>클라인언트와 서버를 독립적으로 변경하고 배포할수 있어야 된다 </li><li>요청은 하위호환성만 필요</li><li>응답은 상위 호환성만 필요</li></ul></li></ul></li><li>메시지 전달 데이터플로<ul><li>비동기 메시지 전달 시스템<ul><li>메시지 브로커<ul><li>상용에서 오픈소스로 바뀜</li></ul></li><li>메시지 큐</li></ul></li><li>분산 액터 프레임워크<ul><li>엑터 모델<ul><li>엑터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다</li><li>스레드를 직접 처리하는 대신 액터에 캡슐화 된다</li><li>보통 하나의 액터는 하나의 클라이언트나 엔티티를 나타낸다</li><li>액터는 로컬 상태를 가질수 있도 비동기 메시지의 송수신으로 다른 액터와 통신한다</li><li>액터는 메시지 전달을 보장하지 않는다</li><li>각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없고 각 액터는 프레임워클와 독립적으로 실행할 수 있다</li></ul></li></ul></li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>데이터 구조를 네트워크나 디스크 상의 바이트열로 변환하는 다양한 방법을 살펴봤다</p><p>순회식 업그레이드 하위호환성 상위 호환성</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-14-Designing_Data_Intensive_Applications_chapter4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>03장: 저장소와 검색</title>
      <link>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/</guid>
      <pubDate>Thu, 09 Nov 2023 01:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-시스템의-기초&quot;&gt;&lt;a href=&quot;#데이터-시스템의-기초&quot; class=&quot;headerlink&quot; title=&quot;데이터 시스템의 기초&quot;&gt;&lt;/a&gt;데이터 시스템의 기초&lt;/h1&gt;&lt;h2 id=&quot;03장-저장소와-검색&quot;&gt;&lt;a href=&quot;#03장-저장
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-시스템의-기초"><a href="#데이터-시스템의-기초" class="headerlink" title="데이터 시스템의 기초"></a>데이터 시스템의 기초</h1><h2 id="03장-저장소와-검색"><a href="#03장-저장소와-검색" class="headerlink" title="03장: 저장소와 검색"></a>03장: 저장소와 검색</h2><p>데이터베이스의 두가지 작업 - 데이터를 저장하고 데이터를 조회하는 것</p><p>로그 구조 계열 저장소 엔진, 페이지 지향 계열 저장소 엔진</p><h3 id="데이터베이스를-강력하게-만드는-데이터-구조"><a href="#데이터베이스를-강력하게-만드는-데이터-구조" class="headerlink" title="데이터베이스를 강력하게 만드는 데이터 구조"></a>데이터베이스를 강력하게 만드는 데이터 구조</h3><p>데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서 필요한 데이터 구조는 색인 이다</p><p>색인의 일반적인 개념은 부가적인 메타테이터를 유지하는 것이다.</p><p>색인은 기본데이터(primary data)에서 파생된 추가적인 구조다.</p><p>많은 데이터베이스에서는 색인의 추가 삭제만 허용</p><p>어떤 종류에 색인이라도 대개 쓰기 속도를 느리게 만든다 데이터를 쓸때 마다 색인도 갱신 해줘야 되기 때문이다. - 저장소 시스템의 중요한 트레이트 오프</p><ul><li><p>해시 색인</p><ul><li>키값 저장소 - 해시맵(해시 테이블)</li><li>키를 데이터 파일의 바이트 오프셋에 매칭 하여 저장</li><li>문제<ul><li>파일형식</li><li>레코드 삭제</li><li>고장 복구</li><li>부분적으로 레코드 쓰기</li><li>동시성 제어</li></ul></li></ul></li><li><p>SS테이블과 LSM 트리</p><ul><li>키로 정렬된 형식을 정렬된 문자열 테이블(sorted string table, SSTable)이라고 한다.<ul><li>장점<ul><li>새그먼트 병합은 파일이 사용가능한 메모리보다 크더라도 간단하고 효율적이다</li><li>파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다</li><li>읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다</li></ul></li><li>SS 테이블 생성과 유지<ul><li>쓰기가 들어오면 인메모리 균형 트리 데이터 구조(멤테이블)에 추가한다</li><li>멤테이블이 일정 크기에 도달하면 디스크에 SSTable 파일로 기록한다</li><li>읽기 요청이 들어오면 먼저 멤테이블에서 키를 찾고 디스크 상의 가장 최신 세그먼트를 찾는다</li><li>가끔 세그먼트 파일을 합치고 덥어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다 이과정은 백그라운드에서 수행</li></ul></li><li>SS테이블에서 LSM 트리 만들기<ul><li>로그 구조화 병합 트리(Log-Structured Merge-Tree, LSM 트리) 패트릭 오닐등이 발표</li></ul></li><li>성능 최적화<ul><li>데이터베이스에 존재하지 않는 키를 찾는 경우 느려짐<ul><li>블룸 필터 - 키가 존재하는지 여부를 빠르게 확인</li></ul></li><li>SSTable 압축하고 병합하는 순서와 시기를 결정<ul><li>크기 계층</li><li>레벨 컴팩션</li></ul></li></ul></li></ul></li></ul></li><li><p>B 트리</p><ul><li>가장 널리 알려진 색인 구조</li><li>4kb 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다</li><li>한 페이지는 B 트리의 루트로 지정된다</li><li>색인에서 키를 찾으려면 루트에서 시작한다</li><li>신뢰할수 있는 B 트리 만들기<ul><li>기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓴다</li><li>즉 페이지를 덮어쓰더라도 페이지를 가리키는 값은 변하지 않는다</li><li>데이터를 복구 하기 위해 쓰기전 로그 (redo log)</li></ul></li><li>최적화<ul><li>일부 데이터베이스는 쓰기 복사 방식을 사용한다</li><li>페이지에 전체 키를 저장하는 게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다</li><li>일반적으로 페이지는 디스크 상 어디에나 위치 할수 있다 트리가 커지면 순서를 유지하기 힘들다 - LSM 트리는 병합하는 과정에서 큰 세그먼트를 다시 한번 쓰기 때문에 순서를 유기하기 쉽다</li><li>트리에 포인터를 추가한다</li><li>프랙탈 트리</li></ul></li></ul></li><li><p>B 트리와 LSM 트리 비교</p><ul><li>LSM 트리는 쓰기 성능이 뛰어나다</li><li>B 트리는 읽기 성능이 뛰어나다</li><li>LSM 트리의 장점<ul><li>쓰기 증폭이 더 낮다<ul><li>데이터를 덮어 쓰는게 아니라 순차적으로 쓰기 때문이다</li></ul></li><li>압축률이 좋다</li></ul></li><li>LSM 트리의 단점<ul><li>컴팩션 과정이 따로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다</li><li>높은 쓰기 처리량에서 발생</li></ul></li></ul></li><li><p>기타 색인 구조</p><ul><li>키-값 색인의 대표적인 예는 관계형 모델의 기본키 색인</li><li>보조색인을 사용하는 방식도 매우 일반적</li><li>클러스터 색인(clustered index) - 색인 안에 색인된 로우를 저장</li><li>커버링 색인(covering index)</li><li>포괄열이 있는 색인(index with included columns)</li><li>다중 칼럼 색인<ul><li>결합 색인(concatenated index)</li></ul></li><li>전문 검색과 퍼지 색인<ul><li>유한 상태 오토마론(finite state automaton, FSA) 트라이(trie)</li><li>레벨슈타인 오토마론(Levenshtein automaton)</li></ul></li><li>모든걸 메모리에 보관<ul><li>인메모리 데이터베이스</li></ul></li></ul></li></ul><h3 id="트랜잭션-처리나-분석"><a href="#트랜잭션-처리나-분석" class="headerlink" title="트랜잭션 처리나 분석?"></a>트랜잭션 처리나 분석?</h3><p>커머셜 트랜잭션 - 초창기 비즈니스 데이터 처리<br>온라인 트랜잭션 처리 - OLTP(Online Transaction Processing)<br>온라인 분석 처리 - OLAP(Online Analytical Processing)</p><ul><li><p>데이터 웨어하우징</p><ul><li>ETL(Extract-Transform-Load) - 데이터를 추출하고 변환한 다음 데이터 웨어하우스에 적재</li></ul></li><li><p>분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마</p><ul><li>별 모양 스키마 - 중앙의 큰 테이블을 기준으로 여러 개의 작은 차원 테이블이 연결된 형태</li><li>눈 꽃송이 모양 스키마 - 여러 차원 테이블이 서로 연결된 형태</li></ul></li></ul><h3 id="칼럼-지향-저장소"><a href="#칼럼-지향-저장소" class="headerlink" title="칼럼 지향 저장소"></a>칼럼 지향 저장소</h3><p>모든 값을 하나의 로우에 함께 저장하지 않는대신 각 칼럼별로 모든 값을 함께 저장한다</p><ul><li><p>칼럼 압축</p><ul><li>압축에 용이하다</li><li>비트맵 부호화</li><li>메모리 대역폭과 벡터화 처리<ul><li>벡터화 처리 - 하나의 명령으로 여러 개의 데이터를 한꺼번에 처리하는 것</li></ul></li></ul></li><li><p>칼럼 저장소의 순서 정렬</p><ul><li>각 칼럼은 독립적으로 정렬할수 없다</li><li>데이터는 한번에 전체 로우를 정렬해야 한다</li><li>다양한 순서 정렬<ul><li>C-store</li></ul></li></ul></li><li><p>칼럼 지향 저장소에 쓰기</p><ul><li>B 트리와 같은 제자리 갱신이 불가능 하다</li><li>집계 : 데이터 큐브와 구체화뷰<ul><li>데이터 큐브 - 다차원의 데이터를 집계한 것</li></ul></li></ul></li><li><p>집계: 데이터 큐브와 구체화 뷰</p></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul><li>OLAP - 데이터 웨어하우스에 저장된 데이터를 집계하고 분석하는 일</li><li>OLTP - 비즈니스 데이터 처리</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-09-Designing_Data_Intensive_Applications_chapter3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>02장: 데이터 모델과 질의 언어</title>
      <link>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/</guid>
      <pubDate>Mon, 06 Nov 2023 04:48:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-시스템의-기초&quot;&gt;&lt;a href=&quot;#데이터-시스템의-기초&quot; class=&quot;headerlink&quot; title=&quot;데이터 시스템의 기초&quot;&gt;&lt;/a&gt;데이터 시스템의 기초&lt;/h1&gt;&lt;h2 id=&quot;02장-데이터-모델과-질의-언어&quot;&gt;&lt;a href=&quot;#
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-시스템의-기초"><a href="#데이터-시스템의-기초" class="headerlink" title="데이터 시스템의 기초"></a>데이터 시스템의 기초</h1><h2 id="02장-데이터-모델과-질의-언어"><a href="#02장-데이터-모델과-질의-언어" class="headerlink" title="02장: 데이터 모델과 질의 언어"></a>02장: 데이터 모델과 질의 언어</h2><p>대부분의 애플리케이션은 하나의 데이터 모델 위에 다른 데이터 모델을 계층을 둬서 만듬</p><h3 id="관계형-모델과-문서-모델"><a href="#관계형-모델과-문서-모델" class="headerlink" title="관계형 모델과 문서 모델"></a>관계형 모델과 문서 모델</h3><p>가장 잘알려진 데이터 모델은 1970년 에드가 코드가 제안한 관계형 모델을 기반으로 한 SQL </p><p>데이터는 관계로(테이블) 구성되고 각 관계는 튜플(로우) 모음</p><ul><li><p>NoSQL의 탄생 : 관계형 모델의 우위를 뒤집으려는 가장 최신 시도</p><ul><li>가까운 미래에는 관계형 데이터 베이스와 비관계형 데이터스토어와 함께 사용될 것이다. - 이미 사용중</li></ul></li><li><p>객체 관계형 불일치</p><ul><li>임피던스 불일치</li></ul></li><li><p>다대일과 다대다 관계</p><ul><li>쓰기 오버해드 불일치</li><li>중복된 데이터를 정규화 하려면 다대일 관계</li></ul></li><li><p>문서 데이터베이스는 역사를 반복하고 있나?</p><ul><li>관계형 모델<ul><li>모든 데이터를 배치하는것</li></ul></li><li>네트워크 모델<ul><li>코다실 모델 : 코다실이라고 부르는 위원회에서 표준화됨</li><li>레코드간의 연결은 외래 키 보다 포인터와 더 비슷하다</li><li>레코드에 접근하는 유일한 방법은 최상위 레코드에서 부터 연속된 연결 경로를 따르는 방법 - 접근경로</li></ul></li><li>문서 데이터베이스와의 비교<ul><li>한 가지 측면에서 계층 모델로 되돌아갔다</li><li>별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다</li></ul></li></ul></li><li><p>관계형 데이터베이스와 오늘날의 문서 데이터베이스</p><ul><li>내결함성과 동시성처리를 포함 고려해야할 차이점이 많이 있다.</li><li>애플리케이션 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는게 좋다</li><li>사딩은 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킴</li><li>애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다</li><li>문서 데이터 베이스는 암묵적인 스키마가 있지만 강요하지 않는다</li></ul></li></ul><h3 id="데이터를-위한-질의-언어"><a href="#데이터를-위한-질의-언어" class="headerlink" title="데이터를 위한 질의 언어"></a>데이터를 위한 질의 언어</h3><p>SQL은 선언형 질의 언어</p><p>IMS와 코다실은 명령형 코드</p><ul><li>웹에서의 선언형 질의<ul><li>CSS selector</li><li>DOM</li></ul></li><li>맵리듀스 질의<ul><li>map 과 reduce 함수를 기반<ul><li>map 함수는 각 입력 데이터를 독립적으로 처리</li><li>reduce 함수는 map 함수의 출력을 하나로 합침</li></ul></li></ul></li></ul><h3 id="그래프형-데이터-모델"><a href="#그래프형-데이터-모델" class="headerlink" title="그래프형 데이터 모델"></a>그래프형 데이터 모델</h3><p>다대다 관계가 일반적일때는 그래프로 데이터를 모델링하기 시작하는 편이 더 좋다</p><p>정점 vertex : 노드나 엔티티<br>간선 edge : 관계나 호(arc)</p><p>페이지 랭크</p><ul><li>속성 그래프(neo4j)<ul><li>고유한 식별자</li><li>유출(outgoing) 간선 집합</li><li>유입(incoming) 간선 집합</li><li>속성 컬렉션(키-값 쌍)</li></ul></li><li>사이퍼 질의 언어<ul><li>속성 그래프를 위한 선언형 질의 언어</li></ul></li><li>SQL의 그래프 질의<ul><li>재귀 공통 테이블 식(recursive common table expression, CTE) with recursive</li><li>SQL은 복잡하다</li></ul></li><li>트리플 저장소와 스파클(Datomic)<ul><li>속성 그래프랑 거의 비슷</li><li>주어, 서술어, 목적어 (subject, predicate, object) 를 트리플(triple) 이라고 부름</li><li>시멘틱웹</li><li>RDF 데이터 모델</li><li>스파클(SPARQL) 질의 언어는 RDF 데이터 모델을 사용한 트리플</li></ul></li><li>초석: 데이터로그<ul><li>스파클이나 사이퍼보다 훨씬 오래된 언어로 1980년대 학계에서 연구됨</li><li>트리플을 작성하는 대신 서술어로 작성한다</li></ul></li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>애플리케이션의 요구사항에 가장 적합한 모델을 찾고 싶은 욕구를 충분히 자극</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-06-Designing_Data_Intensive_Applications_chapter2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</title>
      <link>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/</link>
      <guid>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/</guid>
      <pubDate>Thu, 02 Nov 2023 12:33:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-시스템의-기초&quot;&gt;&lt;a href=&quot;#데이터-시스템의-기초&quot; class=&quot;headerlink&quot; title=&quot;데이터 시스템의 기초&quot;&gt;&lt;/a&gt;데이터 시스템의 기초&lt;/h1&gt;&lt;h2 id=&quot;01장-신뢰할-수-있고-확장-가능하며-유지보수하기-쉬
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-시스템의-기초"><a href="#데이터-시스템의-기초" class="headerlink" title="데이터 시스템의 기초"></a>데이터 시스템의 기초</h1><h2 id="01장-신뢰할-수-있고-확장-가능하며-유지보수하기-쉬운-애플리케이션"><a href="#01장-신뢰할-수-있고-확장-가능하며-유지보수하기-쉬운-애플리케이션" class="headerlink" title="01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"></a>01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</h2><p>오늘날 소프트웨어는 계산 중심 과는 다르게 데이터 중심적이다</p><ul><li>데이터 베이스</li><li>캐시</li><li>검색 색인</li><li>스트림 처리</li><li>일괄 처리</li></ul><p>소프트웨어 시스템의 관심사</p><ul><li>신뢰성</li><li>확장성</li><li>유지보수성</li></ul><h3 id="신뢰성"><a href="#신뢰성" class="headerlink" title="신뢰성"></a>신뢰성</h3><ul><li>애플리케이션은 사용자가 기대한 기능을 수행한다</li><li>시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할수 있다</li><li>시스템 성능은 예상된 부하와 데이터 망에서 필수적인 사용 사례를 충분히 만족한다</li><li>시스템은 허가되지 않은 접근과 오남용을 방지한다</li></ul><p>잘못될수 있는 일을 결함이라고 부른다 결함을 예측하고 대처할수 있는 시스템을 내결함성 또는 탄력성을 지녔다고 말한다<br>고의적으로 결함을 유도함 -&gt; 카오스 몽키</p><ul><li>하드웨어 결함</li><li>소프트웨어 오류</li><li>인적 오류</li></ul><p>신뢰성은 얼마나 중요할까? </p><h3 id="확장성"><a href="#확장성" class="headerlink" title="확장성"></a>확장성</h3><p>확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어</p><ul><li>부하 기술하기</li><li>성능 기술하기<ul><li>처리량, 응답시간</li></ul></li><li>부하 대응 접근 방식<ul><li>스케일업, 스케일 아웃</li><li>비공유 아키텍처</li></ul></li></ul><h3 id="유지보수성"><a href="#유지보수성" class="headerlink" title="유지보수성"></a>유지보수성</h3><ul><li>운용성: 운영의 편리함 만들기</li><li>단순성: 복잡도 관리<ul><li>우발적 복잡도를 줄인다</li></ul></li><li>발전성: 변화를 쉽게 만들기<ul><li>조직 프로세스 애자일</li></ul></li></ul><p>요구사항에는 기능적 요구사항과 비기능적요구사항</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://wikibook.co.kr/data-intensive-applications-ebook/">데이터 중심 애플리케이션 설계</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/11/2023-11-02-Designing_Data_Intensive_Applications_chapter1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stable Diffusion 이해를 위한 자료 모음</title>
      <link>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/</guid>
      <pubDate>Tue, 31 Oct 2023 01:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Stable-Diffusion-이해를-위한-자료-모음&quot;&gt;&lt;a href=&quot;#Stable-Diffusion-이해를-위한-자료-모음&quot; class=&quot;headerlink&quot; title=&quot;Stable Diffusion 이해를 위한 자료 모음&quot;&gt;&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Stable-Diffusion-이해를-위한-자료-모음"><a href="#Stable-Diffusion-이해를-위한-자료-모음" class="headerlink" title="Stable Diffusion 이해를 위한 자료 모음"></a>Stable Diffusion 이해를 위한 자료 모음</h1><h2 id="Diffusion-Model"><a href="#Diffusion-Model" class="headerlink" title="Diffusion Model"></a>Diffusion Model</h2><p><a href="https://arxiv.org/abs/1503.03585">https://arxiv.org/abs/1503.03585</a></p><p>2015년 발표</p><p><code>Diffusion(확산)은 액체나 기체에 다른 물질이 섞이고, 그것이 조금씩 번져가다가 마지막에는 일률적인 농도로 바뀌는 현상이다.</code> 위키피디아</p><p><img src="https://mblogthumb-phinf.pstatic.net/20131015_167/todaudrhkwkd_13817975412967wfk3_JPEG/1.jpg?type=w2" alt="확산"></p><p>물리의 확산 현상에 영감을 받아 모델을 설계</p><p>가우시안 노이즈</p><p>마르코프 체인(특정 상태의 확률은 오직 과거의 기인한다)</p><p><img src="https://velog.velcdn.com/images/fermi99/post/364897c1-5d8f-4951-ab7e-128bfe699b95/image.png" alt="디퓨전모델"></p><h2 id="Denoising-Diffusion-Probabilistic-Models-DDPM"><a href="#Denoising-Diffusion-Probabilistic-Models-DDPM" class="headerlink" title="Denoising Diffusion Probabilistic Models (DDPM)"></a>Denoising Diffusion Probabilistic Models (DDPM)</h2><p><a href="https://arxiv.org/abs/2006.11239">https://arxiv.org/abs/2006.11239</a></p><p>유넷을 활용 → 정답 상태를 유추</p><p>정답만 유추 하기 때문에 좀더 간단해짐 → 노이즈 성분을 예측하니깐 조금 더 품질이 좋아짐</p><p>해결 컨셉은 노이즈화 할때의 수식을 조금 다르게 수정</p><p><code>문제점 : 너무 느리다 스텝이 1000 사용해야 됨(GAN 은 1번)</code></p><h2 id="Denoising-Diffusion-Implicit-Models-DDIM"><a href="#Denoising-Diffusion-Implicit-Models-DDIM" class="headerlink" title="Denoising Diffusion Implicit Models (DDIM)"></a>Denoising Diffusion Implicit Models (DDIM)</h2><p><a href="https://arxiv.org/abs/2010.02502">https://arxiv.org/abs/2010.02502</a></p><p>아이디어 느리니깐 스템을 10, 20, 50 ,100 1000 으로 사용해도 크게 나빠지지 않는다.</p><p><img src="https://user-images.githubusercontent.com/79881119/233402047-07361544-87f3-4d51-8d6f-718fab06dcfc.png" alt="DDIM"></p><h2 id="VariationalAutoEncoder-VAE"><a href="#VariationalAutoEncoder-VAE" class="headerlink" title="VariationalAutoEncoder (VAE)"></a>VariationalAutoEncoder (VAE)</h2><ul><li>supervised learning : 데이터와 라벨이 페어<ul><li>classification</li><li>object detection</li><li>semantic segmentation</li><li>image captioning</li></ul></li><li>unsupervised learning : 데이터만 존재<ul><li>clustering</li><li>dimensionality reduction</li><li>feature learning</li><li>density estimation</li></ul></li></ul><p>이미지를 넣어서 차원이 작은 벡터를 나오면 이것으로 이미지를 만든다 </p><p>explicit density estimation : 확률밀도함수를 직접적으로 구하는 방법</p><p>implicit density estimation :  확률밀도함수를 직접적으로 구하지 않고, 확률밀도함수를 구하는 것을 목적으로 하지 않는 방법</p><p>작은 차원에 피처만으로 이미지를 만들수 있다</p><p>최대 가능도를 써서 트레이닝을 시킨다 </p><p>문제는 계산을 할수가 없다 실제 값을 아는게 아니라 샘플링만 가능</p><p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*_5GpdejeOvt61ew4aPtT_g.png"></p><p><img src="https://github.com/CompVis/latent-diffusion/raw/main/assets/modelfigure.png" alt="LDM"></p><ul><li>denoising 과정에서 autoencoder를 사용</li><li>denoising이 pixel space 가 아닌 latent space 에서 일어남(픽셀단위가 아니라 인코딩된 잠재공간 내에서 노이즈를 추가 제거)</li><li>cross-attention layers를(transformer 아키텍처?) 도입함으로 다른 도메인 conditioning 을 같이 사용할수 있게됨 -&gt;</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/CompVis/latent-diffusion">Latent Diffusion Models</a></li><li><a href="https://github.com/CompVis/stable-diffusion">Stable Diffusion</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/diffusion-model-basic/">Diffusion Model 설명 – 기초부터 응용까지</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/stable-diffusion/">Stable Diffusion : High-Resolution Image Synthesis with Latent Diffusion Models</a></li><li><a href="https://www.youtube.com/watch?v=AVvlDmhHgC4">GAN: Generative Adversarial Networks (꼼꼼한 딥러닝 논문 리뷰와 코드 실습)</a></li><li><a href="https://www.youtube.com/watch?v=sSxdQq9CCx0">머신러닝&#x2F;딥러닝 강의 - 004 UNet 네트워크 구현하기</a></li><li><a href="https://www.youtube.com/watch?reload=9&v=n_FDGMr4MxE">U-Net: Convolutional Networks for Biomedical Image Segmentation (MICCAI 2015)</a></li><li><a href="https://www.youtube.com/watch?v=7fBQDaJkcSU">Stable Diffusion 논문 리뷰</a></li><li><a href="https://laion.ai/">laion.ai</a></li><li><a href="https://stability.ai/">stability.ai</a></li><li><a href="https://www.youtube.com/watch?v=e2rFsn93o0U">불과 1년 만의 쾌거, 생성 모델 특집 - Diffusion Model 이 이루어낸 모든 것을 AI 전문가로부터 들어봅니다!</a></li><li><a href="https://www.youtube.com/watch?v=WQuwkTKvUfg">요즘 핫한 생성모델 stable diffusion 찍먹해보기</a></li><li><a href="https://www.youtube.com/watch?v=nthpXARTduk">guided diffusion에서 StableDiffusion, 그리고 Plug&amp;Play와 DiffStyle까지</a></li><li><a href="https://dacon.io/codeshare/4652">가우시안 노이즈(Gaussian Noise)</a></li><li><a href="https://www.youtube.com/watch?v=uFoGaIVHfoE">Diffusion Model 수학이 포함된 tutorial</a></li><li><a href="https://drive.google.com/file/d/1u8EWfDvaJQGKKC4akQDy50kP-qF_MT09/view?pli=1">Diffusion Model 수학이 포함된 tutorial 발표자료</a></li><li><a href="https://jang-inspiration.com/ddpm-2">[논문리뷰] DDPM: Denoising Diffusion Probabilistic Model</a></li><li><a href="https://velog.io/@hanlyang0522/DDPM-Denoising-Diffusion-Probabilistic-Models-%EB%85%BC%EB%AC%B8-%EB%A6%AC%EB%B7%B0">DDPM: Denoising Diffusion Probabilistic Models 논문 리뷰</a></li><li><a href="https://junia3.github.io/blog/ddim">DDIM(Denoising Diffusion Implicit Models) 이해하기</a></li><li><a href="https://www.youtube.com/watch?v=zcEe78I_4TU">[DLD 2022] Denoising Diffusion Implicit Models</a></li><li><a href="https://arxiv.org/abs/2010.02502">Denoising Diffusion Implicit Models</a></li><li><a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Models</a></li><li><a href="https://arxiv.org/abs/1503.03585">Deep Unsupervised Learning using Nonequilibrium Thermodynamics</a></li><li><a href="https://pebpung.github.io/autoencoder/2021/09/11/Auto-Encoder-1.html">오토인코더(AutoEncoder)</a></li><li><a href="https://www.youtube.com/watch?v=54hyK1J4wTc">[#32.Lec] AutoEncoder and Variational AutoEncoder - 딥러닝 홀로서기</a></li><li><a href="https://bookdown.org/mathemedicine/Stat_book/probability-vs-likelihood.html">Chapter 2 확률(Probability) vs 가능도(Likelihood)</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-31-Stable_Diffusion_link/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Diffusion Models 이란</title>
      <link>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/</guid>
      <pubDate>Mon, 30 Oct 2023 08:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Diffusion-Models-이란&quot;&gt;&lt;a href=&quot;#Diffusion-Models-이란&quot; class=&quot;headerlink&quot; title=&quot;Diffusion Models 이란?&quot;&gt;&lt;/a&gt;Diffusion Models 이란?&lt;/h1&gt;&lt;p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Diffusion-Models-이란"><a href="#Diffusion-Models-이란" class="headerlink" title="Diffusion Models 이란?"></a>Diffusion Models 이란?</h1><p><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">diffusion-models</a> 이글을 번역한 내용 입니다</p><p>지금까지 세 가지 유형의 생성 모델, 즉 GAN, VAE 및 흐름 기반(FLOW-based) 모델에 대해 작성했습니다.<br>이 모델들은 고품질 샘플을 생성하는 데 큰 성공을 거두었지만 각각 몇 가지 한계가 있습니다.<br>GAN 모델은 적대적 훈련 특성으로 인해 잠재적으로 불안정한 훈련과 생성의 다양성이 떨어지는 것으로 알려져 있습니다.<br>VAE는 대리 손실에 의존합니다.<br>FLOW 모델은 가역적 변환을 구축하기 위해 특수 아키텍처를 사용해야 합니다.</p><p>확산 모델(Diffusion models)은 비평형 열역학(non-equilibrium thermodynamics)에서 영감을 얻었습니다.<br>확산 단계의 마르코프 체인(Markov chain)을 정의하여 데이터에 무작위 노이즈를 천천히 추가한 다음,<br>확산 과정을 역으로 학습하여 노이즈에서 원하는 데이터 샘플을 구성하는 방법을 학습합니다.<br>확산 모델은 VAE 또는 흐름 모델과 달리 고정된 절차로 학습되며 잠재 변수는 높은 차원(원본 데이터와 동일)을 갖습니다.</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/generative-overview.png" alt="그림 1. 다양한 유형의 생성 모델 개요."></p><h2 id="확산-모델이란"><a href="#확산-모델이란" class="headerlink" title="확산 모델이란?"></a>확산 모델이란?</h2><p>Several diffusion-based generative models have been proposed with similar ideas underneath, including diffusion probabilistic models <a href="https://arxiv.org/abs/1503.03585">(Sohl-Dickstein et al., 2015)</a>,<br>noise-conditioned score network <a href="https://arxiv.org/abs/1907.05600">(NCSN; Yang &amp; Ermon, 2019)</a>,<br>and denoising diffusion probabilistic models <a href="https://arxiv.org/abs/2006.11239">(DDPM; Ho et al. 2020)</a>.</p><h3 id="순방향-확산-프로세스-Forward-diffusion-process"><a href="#순방향-확산-프로세스-Forward-diffusion-process" class="headerlink" title="순방향 확산 프로세스 (Forward diffusion process)"></a>순방향 확산 프로세스 (Forward diffusion process)</h3><p>실제 데이터 분포에서 샘플링된 데이터 포인트가 주어지면<br>샘플에 소량의 가우시안(Gaussian) 노이즈를 추가하는 순방향 확산 프로세스를 정의해 보겠습니다.<br>T 단계, 시끄러운 샘플 시퀀스 생성  x…x 단계 크기는 분산 일정에 의해 제어됩니다.<br>데이터 샘플 점차적으로 단계적으로 구별되는 특징을 잃습니다. 더 커집니다. 결국 언제 등방성 가우스 분포와 동일합니다.</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/DDPM.png" alt="그림 2. 노이즈를 천천히 추가(제거)하여 샘플을 생성하는 순방향(역방향) 확산 과정의 마르코프 체인. (이미지 출처: Ho et al. 2020, 몇 가지 추가 주석 포함)"></p><h3 id="확률적-경사-Langevin-역학과의-연결"><a href="#확률적-경사-Langevin-역학과의-연결" class="headerlink" title="확률적 경사 Langevin 역학과의 연결"></a>확률적 경사 Langevin 역학과의 연결</h3><p>Langevin 역학은 분자 시스템을 통계적으로 모델링하기 위해 개발된 물리학의 개념입니다.<br>확률적 경사하강법과 결합된 Stochastic Gradient Langevin 역학 <a href="https://www.stats.ox.ac.uk/~teh/research/compstats/WelTeh2011a.pdf">Bayesian Learning via Stochastic Gradient Langevin Dynamics</a><br>은 확률 밀도에서 샘플을 생성할 수 있습니다.</p><h3 id="역확산-과정-Reverse-diffusion-process"><a href="#역확산-과정-Reverse-diffusion-process" class="headerlink" title="역확산 과정(Reverse diffusion process)"></a>역확산 과정(Reverse diffusion process)</h3><p>위의 과정을 반대로 하고 샘플을 추출할 수 있다면 가우스 노이즈 입력에서 실제 샘플을 다시 생성할 수 있습니다. 안타깝게도 쉽게 추정할 수는 없습니다.<br>전체 데이터 세트를 사용해야 하므로 모델을 학습해야 하기 때문입니다. 역확산 프로세스를 실행하기 위해 이러한 조건부 확률을 근사화합니다 .</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/diffusion-example.png" alt="그림 3. 2D 스위스롤 데이터 모델링을 위한 확산 모델 훈련의 예. (이미지 출처: Sohl-Dickstein 외, 2015 )"></p><h2 id="확산-모델-샘플링-속도-향상"><a href="#확산-모델-샘플링-속도-향상" class="headerlink" title="확산 모델 샘플링 속도 향상"></a>확산 모델 샘플링 속도 향상</h2><p>역확산 과정의 마르코프 체인을 따라 DDPM에서 샘플을 생성하는 것은 다음과 같이 매우 느립니다.<br>최대 1단계 또는 수천 단계일 수 있습니다. Song et al. 의 한 데이터 포인트 . 2020 :<br>“예를 들어 DDPM에서 32 × 32 크기의 이미지 50,000개를 샘플링하는 데 약 20시간이 걸리지만 Nvidia 2080 Ti GPU의 GAN에서는 1분도 채 걸리지 않습니다.”</p><p>간단한 방법 중 하나는 샘플링 업데이트를 매번 수행하여 점진적인 샘플링 일정( Nichol &amp; Dhariwal, 2021 )을 실행하는 것입니다.</p><p>DDPM과 비교하여 DDIM은 다음을 수행할 수 있습니다.</p><ul><li>훨씬 적은 수의 단계를 사용하여 고품질 샘플을 생성합니다.</li><li>생성 프로세스는 결정론적이므로 “일관성” 속성을 갖습니다. 즉, 동일한 잠재 변수에 대해 조건화된 여러 샘플이 유사한 상위 수준 특징을 가져야 함을 의미합니다.</li><li>일관성으로 인해 DDIM은 잠재 변수에서 의미상 의미 있는 보간을 수행할 수 있습니다.</li></ul><p>잠재 확산 모델(LDM ; Rombach &amp; Blattmann, et al. 2022 )은 픽셀 공간 대신 잠재 공간에서 확산 프로세스를 실행하므로 훈련 비용이 낮아지고 추론 속도가 빨라집니다.<br>이미지의 대부분의 비트가 지각적 세부 사항에 기여하고 공격적인 압축 후에도 의미론적 및 개념적 구성이 여전히 남아 있다는 관찰에 의해 동기가 부여되었습니다.<br>LDM은 먼저 자동 인코더로 픽셀 수준 중복성을 제거한 다음 학습된 잠재성에 대한 확산 프로세스를 통해 의미론적 개념을 조작&#x2F;생성하여 생성 모델링 학습을 통해 지각 압축과<br>의미론적 압축을 느슨하게 분해합니다.</p><p>지각적 압축 프로세스는 오토인코더 모델에 의존합니다. 인코더 입력 이미지를 압축하는 데 사용됩니다.<br>더 작은 2D 잠재 벡터로 여기서 다운샘플링 속도는. 그런 다음 디코더  잠재 벡터로부터 이미지를 재구성합니다.<br>이 논문에서는 잠재 공간에서 임의로 높은 분산을 방지하기 위해 오토인코더 훈련에서 두 가지 유형의 정규화를 탐구했습니다.</p><ul><li>KL-reg: 학습된 잠재성에 대한 표준 정규 분포에 대한 작은 KL 페널티로, VAE 와 유사합니다 .</li><li>VQ-reg: VQVAE 와 같이 디코더 내에서 벡터 양자화 계층을 사용 하지만 양자화 계층은 디코더에 의해 흡수됩니다.</li></ul><p>확산 및 노이즈 제거 프로세스는 잠재 벡터에서 발생합니다.<br>잡음 제거 모델은 이미지 생성을 위한 유연한 조건화 정보(예: 클래스 레이블, 의미 지도, 이미지의 흐릿한 변형)를<br>처리하기 위해 교차 주의 메커니즘이 강화된 시간 조건화된 U-Net입니다.<br>이 디자인은 교차 주의 메커니즘을 사용하여 다양한 양식의 표현을 모델에 융합하는 것과 동일합니다.<br>각 유형의 조건화 정보는 도메인별 인코더와 쌍을 이룹니다. 조건 입력을 투영하기 위해 교차 주의 구성 요소에 매핑될 수 있는 중간 표현으로,</p><p><img src="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/latent-diffusion-arch.png" alt="그림 9. 잠재 확산 모델의 구조. (이미지 출처: Rombach &amp; Blattmann, et al. 2022 )"></p><h2 id="Conditioned-Generation"><a href="#Conditioned-Generation" class="headerlink" title="Conditioned Generation"></a>Conditioned Generation</h2><p>ImageNet 데이터세트와 같은 조건부 정보가 있는 이미지에 대해 생성 모델을 훈련하는 동안 클래스 레이블이나 설명 텍스트를 기준으로 조건부 샘플을 생성하는 것이 일반적입니다.</p><h3 id="Classifier-Guided-Diffusion"><a href="#Classifier-Guided-Diffusion" class="headerlink" title="Classifier Guided Diffusion"></a>Classifier Guided Diffusion</h3><p>클래스 정보를 확산 프로세스에 명시적으로 통합하기 위해 Dhariwal &amp; Nichol(2021)은 분류기를 교육했습니다.<br>시끄러운 이미지에 그리고 그라디언트를 사용하세요 컨디셔닝 정보에 대한 확산 샘플링 프로세스를 안내합니다.<br>(예: 대상 클래스 레이블) 노이즈 예측을 변경합니다. 그것을 기억해 공동 분포에 대한 점수 함수를 작성할 수 있습니다.  다음과 같이,</p><p>따라서 새로운 분류기 안내 예측기는 다음과 같은 형식을 취합니다.</p><p>분류자 지침의 강도를 제어하기 위해 가중치를 추가할 수 있습니다.</p><p>결과적으로 제거된 확산 모델 ( ADM )과 추가 분류자 지침이 있는 모델( ADM-G )은 SOTA 생성 모델(예: BigGAN)보다 더 나은 결과를 얻을 수 있습니다.</p><p>또한 U-Net 아키텍처를 일부 수정하여 <a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a>은 확산 모델을 사용하는 GAN보다 더 나은 성능을 보여주었습니다.<br>아키텍처 수정에는 더 큰 모델 깊이&#x2F;너비, 더 많은 주의 헤드, 다중 해상도 주의, 업&#x2F;다운샘플링을 위한 BigGAN 잔여 블록, 잔여 연결 재조정이 포함됩니다.</p><h3 id="Classifier-Free-Guidance"><a href="#Classifier-Free-Guidance" class="headerlink" title="Classifier-Free Guidance"></a>Classifier-Free Guidance</h3><p>독립적인 분류기가 없는 경우 , 조건부 확산 모델과 무조건 확산 모델의 점수를 통합하여 조건부 확산 단계를 실행하는 것이 여전히 가능합니다( Ho &amp; Salimans, 2021 ).<br>무조건적 노이즈 제거 확산 모델을 보자 점수 추정기를 통해 매개변수화됨 그리고 조건부 모델<br>매개변수화를 통해. 이 두 모델은 단일 신경망을 통해 학습할 수 있습니다. 정확히 말하면 조건부 확산 모델  쌍을 이루는 데이터에 대해 학습됩니다.<br>여기서 조건화 정보는 모델이 무조건 이미지를 생성하는 방법을 알 수 있도록 주기적으로 무작위로 삭제됩니다.</p><p>암시적 분류기의 기울기는 조건부 및 무조건 점수 추정기로 표현될 수 있습니다. 분류자가 안내하는 수정된 점수에 연결되면 점수는 별도의 분류자에 대한 종속성을 포함하지 않습니다.</p><p>그들의 실험에서는 분류기가 없는 지침이 FID(합성 이미지와 생성된 이미지 구별)와 IS(품질과 다양성) 사이에서 좋은 균형을 이룰 수 있음을 보여주었습니다.</p><p>안내 확산 모델인 GLIDE( Nichol, Dhariwal &amp; Ramesh, et al. 2022 )는 안내 전략, CLIP 안내 및 분류자 없는 안내를 모두 탐색한 결과 후자가 더 선호되는 것으로 나타났습니다.<br>그들은 CLIP 지침이 더 잘 일치하는 이미지 생성을 최적화하는 대신 CLIP 모델에 대한 적대적인 예를 사용하여 모델을 활용하기 때문이라고 가정했습니다.</p><h2 id="Scale-up-Generation-Resolution-and-Quality"><a href="#Scale-up-Generation-Resolution-and-Quality" class="headerlink" title="Scale up Generation Resolution and Quality"></a>Scale up Generation Resolution and Quality</h2><p>고해상도에서 고품질 이미지를 생성하기 위해 Ho et al. (2021)은 증가하는 해상도에서 다중 확산 모델의 파이프라인을 사용할 것을 제안했습니다.<br>파이프라인 모델 간의 노이즈 조절 증대는 최종 이미지 품질에 매우 중요하며, 이는 조절 입력에 강력한 데이터 증대를 적용하는 것입니다.</p><p>각 초해상도 모델의 컨디셔닝 노이즈는 파이프라인 설정의 복합 오류를 줄이는 데 도움이 됩니다.<br>U-net은 고해상도 이미지 생성을 위한 확산 모델링에서 일반적인 모델 아키텍처 선택입니다.</p><p>![그림 11. 증가하는 해상도에서 다중 확산 모델의 계단식 파이프라인. (이미지 출처: Ho et al. 2021 ])](<a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/cascaded-diffusion.png">https://lilianweng.github.io/posts/2021-07-11-diffusion-models/cascaded-diffusion.png</a>)</p><p>그들은 가장 효과적인 노이즈가 낮은 해상도에서 가우스 노이즈를 적용하고 고해상도에서 가우시안 블러를 적용하는 것임을 발견했습니다.<br>또한 그들은 훈련 과정에 약간의 수정이 필요한 두 가지 형태의 컨디셔닝 강화도 탐구했습니다. 컨디셔닝 노이즈는 훈련에만 적용되고 추론에는 적용되지 않습니다.</p><ul><li>Truncated Conditioning Augment는 단계 초기에 확산 프로세스를 중지합니다. 저해상도용.</li><li>잘리지 않은 조건화 확대는 0단계까지 전체 저해상도 역 프로세스를 실행하지만 다음과 같이 손상됩니다.</li><li>그런 다음 부패한 동물에게 먹이를 줍니다. 초해상도 모델에 들어갑니다.</li></ul><p>2단계 확산 모델 unCLIP ( Ramesh et al. 2022 )은 CLIP 텍스트 인코더를 많이 활용하여 고품질의 텍스트 안내 이미지를 생성합니다. 사전 훈련된 CLIP 모델이 주어지면<br>확산 모델에 대한 쌍을 이루는 훈련 데이터,, 어디  이미지이고 해당 캡션을 사용하면 CLIP 텍스트 및 이미지 임베딩을 계산할 수 있습니다.<br>그리고, 각각. unCLIP은 두 가지 모델을 병렬로 학습합니다.</p><ul><li>이전 모델 :CLIP 이미지 임베딩을 출력합니다. 주어진 텍스트</li><li>디코더 : 이미지를 생성합니다 주어진 CLIP 이미지 임베딩 선택적으로 원본 텍스트 . 이 두 모델은 조건부 생성을 가능하게 합니다.</li></ul><p>unCLIP은 2단계 이미지 생성 프로세스를 따릅니다.</p><ul><li>텍스트가 주어짐 CLIP 모델은 먼저 텍스트 임베딩을 생성하는 데 사용됩니다. CLIP 잠재 공간을 사용하면 텍스트를 통해 제로샷 이미지 조작이 가능해집니다.</li><li>확산 또는 자기회귀 사전 이 CLIP 텍스트 임베딩을 처리하여 이미지를 먼저 구성한 다음 확산 디코더를 구성합니다. 사전 조건에 따라 이미지를 생성합니다.<br>이 디코더는 이미지 입력에 따라 이미지 변형을 생성하여 스타일과 의미를 보존할 수도 있습니다.</li></ul><p>CLIP 모델 대신 Imagen ( Saharia et al. 2022 )은 사전 훈련된 대형 LM(즉, 고정된 T5-XXL 텍스트 인코더)을 사용하여 이미지 생성을 위한 텍스트를 인코딩합니다.<br>모델 크기가 클수록 이미지 품질이 향상되고 텍스트-이미지 정렬이 향상되는 일반적인 경향이 있습니다.<br>그들은 T5-XXL과 CLIP 텍스트 인코더가 MS-COCO에서 유사한 성능을 달성하지만 인간 평가에서는 DrawBench(11개 범주를 다루는 프롬프트 모음)에서 T5-XXL을 선호한다는 것을 발견했습니다.</p><p>분류자 없는 지침을 적용하면 증가합니다. 이미지-텍스트 정렬은 향상되지만 이미지 충실도는 저하될 수 있습니다. 그들은 훈련-테스트 불일치, 즉 훈련 데이터 때문에 발생한다는 것을 발견했습니다.<br>범위 내에서 유지됩니다., 테스트 데이터도 그래야 합니다. 두 가지 임계값 전략이 도입되었습니다</p><ul><li>정적 임계값: 클립 에 대한 예측</li><li>동적 임계값: 각 샘플링 단계에서 다음을 계산합니다. 특정 백분위수 절대 픽셀 값으로; 만약에 예측을 다음으로 자릅니다. 그리고 다음으로 나눈다</li></ul><p>Imagen은 U- net을 효율적으로 만들기 위해 U-net의 여러 디자인을 수정합니다 .</p><ul><li>낮은 해상도에 더 많은 잔여 잠금(residual locks)을 추가하여 모델 매개변수를 고해상도 블록에서 저해상도로 전환합니다.</li><li>건너뛰기 연결 크기 조정</li><li>순방향 전달 속도를 향상시키기 위해 다운샘플링(컨볼루션 전에 이동) 및 업샘플링 작업(컨볼루션 후 이동)의 순서를 반대로 바꿉니다.</li></ul><p>그들은 잡음 조절 증대, 동적 임계값 지정 및 효율적인 U-Net이 이미지 품질에 중요하지만 텍스트 인코더 크기 조정이 U-Net 크기보다 더 중요하다는 것을 발견했습니다.</p><h2 id="빠른-요약"><a href="#빠른-요약" class="headerlink" title="빠른 요약"></a>빠른 요약</h2><ul><li><p>장점 : 다루기 쉽고 유연성은 생성 모델링에서 두 가지 상충되는 목표입니다.<br>다루기 쉬운 모델은 분석적으로 평가하고 데이터를 저렴하게 맞출 수 있지만(예: Gaussian 또는 Laplace를 통해) 풍부한 데이터세트의 구조를 쉽게 설명할 수는 없습니다.<br>유연한 모델은 데이터의 임의 구조에 적합할 수 있지만 이러한 모델의 평가, 훈련 또는 샘플링에는 일반적으로 비용이 많이 듭니다. 확산 모델은 분석적으로 다루기 쉽고 유연합니다.</p></li><li><p>단점 : 확산 모델은 샘플을 생성하기 위해 긴 Markov 확산 단계 체인을 사용하므로 시간과 계산 측면에서 상당히 비쌀 수 있습니다.<br>프로세스를 훨씬 빠르게 만들기 위해 새로운 방법이 제안되었지만 샘플링은 여전히 GAN보다 느립니다.</p></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">diffusion-models</a></li><li><a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EB%A5%B4%EC%BD%94%ED%94%84_%EC%97%B0%EC%87%84">마르코프 연쇄</a></li><li><a href="https://www.puzzledata.com/blog190423/">마르코프 체인에 관하여</a></li><li><a href="https://arxiv.org/abs/1503.03585">Deep Unsupervised Learning using Nonequilibrium Thermodynamics</a></li><li><a href="https://arxiv.org/abs/1907.05600">Generative Modeling by Estimating Gradients of the Data Distribution</a></li><li><a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Models</a></li><li><a href="https://lilianweng.github.io/posts/2018-08-12-vae/#reparameterization-trick">Reparameterization Trick</a></li><li><a href="https://www.stats.ox.ac.uk/~teh/research/compstats/WelTeh2011a.pdf">Bayesian Learning via Stochastic Gradient Langevin Dynamics</a></li><li><a href="https://arxiv.org/abs/2105.05233">Diffusion Models Beat GANs on Image Synthesis</a></li><li><a href="https://process-mining.tistory.com/182">Diffusion model 설명 (Diffusion model이란? Diffusion model 증명)</a></li><li><a href="https://ffighting.net/deep-learning-paper-review/diffusion-model/diffusion-model-basic/">Diffusion Model 설명 – 기초부터 응용까지</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-30-What_are_Diffusion_Models/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FirebaseError Installations: Could not process request. Application offline.</title>
      <link>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/</guid>
      <pubDate>Thu, 26 Oct 2023 08:24:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;FirebaseError-Installations-Could-not-process-request-Application-offline&quot;&gt;&lt;a href=&quot;#FirebaseError-Installations-Could-not-process-r
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="FirebaseError-Installations-Could-not-process-request-Application-offline"><a href="#FirebaseError-Installations-Could-not-process-request-Application-offline" class="headerlink" title="FirebaseError Installations: Could not process request. Application offline."></a>FirebaseError Installations: Could not process request. Application offline.</h1><p>갑자기 특정 페이지에서 에러가나면서 랜더링이 되지 않은 이슈가 있었다 콘솔 로그를 보니 아래에 에러메시지가 나오고 있었다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirebaseError Installations: Could not process request. Application offline.</span><br></pre></td></tr></table></figure><p>플러그인 문제인줄 알고 모든 플러그인 삭제 및 캐쉬 삭제 후에도 동일한 이슈가 발생하였다.</p><p>구글링을 해보니 아래와 같은 이슈가 있었다.</p><ul><li><a href="https://github.com/firebase/firebase-js-sdk/issues/4922">FirebaseError Installations: Could not process request. Application offline.</a></li></ul><p>해결은 되지 않았지만 한명이 와이파이를 온오프 해보라는 메시지가 있었다 그것으로 해결이 되었다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/firebase/firebase-js-sdk/issues/4922">FirebaseError Installations: Could not process request. Application offline.</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-26-FirebaseError/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stable-diffusion-webui docker 설치</title>
      <link>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/</guid>
      <pubDate>Thu, 26 Oct 2023 01:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;stable-diffusion-webui-docker-설치&quot;&gt;&lt;a href=&quot;#stable-diffusion-webui-docker-설치&quot; class=&quot;headerlink&quot; title=&quot;stable-diffusion-webui docke
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="stable-diffusion-webui-docker-설치"><a href="#stable-diffusion-webui-docker-설치" class="headerlink" title="stable-diffusion-webui docker 설치"></a>stable-diffusion-webui docker 설치</h1><p>먼저 docker를 설치해야 한다.</p><h2 id="docker-설치"><a href="#docker-설치" class="headerlink" title="docker 설치"></a>docker 설치</h2><p>도커의 자동 설치 스크립트 사용</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -qO- http://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>우분투 직접 설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line">sudo ln -sf /usr/bin/docker.io /usr/local/bin/docker</span><br></pre></td></tr></table></figure><p>도커 권한 부여</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker group 추가</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker group에 현재의 사용자 추가</span></span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker-compose 설치"></a>docker-compose 설치</h2><p><a href="https://github.com/docker/compose/releases">docker compose releases</a> 여기에서 최신버전을 확인후에 설치한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/$&#123;최신버전&#125;/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>권한추가</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="NVIDIA-Container-Toolkit-설치"><a href="#NVIDIA-Container-Toolkit-설치" class="headerlink" title="NVIDIA Container Toolkit 설치"></a>NVIDIA Container Toolkit 설치</h2><p>그리고 엔비디아의 NVIDIA Container Toolkit을 설치해야 한다.</p><p>저장소 등록 및 업데이트</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | \</span><br><span class="line">    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list \</span><br><span class="line">  &amp;&amp; \</span><br><span class="line">    sudo apt-get update</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nvidia-container-toolkit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="stable-diffusion-webui-docker-설치-1"><a href="#stable-diffusion-webui-docker-설치-1" class="headerlink" title="stable-diffusion-webui-docker 설치"></a>stable-diffusion-webui-docker 설치</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/AbdBarho/stable-diffusion-webui-docker.git</span><br><span class="line"></span><br><span class="line">cd stable-diffusion-webui-docker</span><br><span class="line"></span><br><span class="line">docker compose --profile download up --build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wait</span> until its <span class="keyword">done</span>, <span class="keyword">then</span>:</span></span><br><span class="line">docker compose --profile [ui] up --build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">where</span> [ui] is one of: invoke | auto | auto-cpu | comfy | comfy-cpu</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위에 도커 컴포즈 파일에서는 같은 포트를 사용해서 기동하도록 되어 있다 여러개를 동시해 실행하고 싶으면 포트를 변경해야 한다.<br>아래 처럼 실행 가능하다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WEBUI_PORT=7861 docker compose --profile comfy up --build</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html">Installing the NVIDIA Container Toolkit</a></li><li><a href="https://github.com/docker/compose/releases">docker compose releases</a></li><li><a href="https://github.com/AbdBarho/stable-diffusion-webui-docker">stable-diffusion-webui-docker</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-26-stable_diffusion_webui_docker_install/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Please make sure you have the correct access rights and the repository exists</title>
      <link>https://sejoung.github.io/2023/10/2023-10-24-git_error/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-24-git_error/</guid>
      <pubDate>Tue, 24 Oct 2023 03:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러&quot;&gt;&lt;a href=&quot;#Please-make-sure-you-have-the-correct-ac
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러"><a href="#Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-에러" class="headerlink" title="Please make sure you have the correct access rights and the repository exists 에러"></a>Please make sure you have the correct access rights and the repository exists 에러</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ERROR: Repository not found.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l -E md5</span><br></pre></td></tr></table></figure><p>위에 명령어를 실행했을때 아래의 메시지가 나오면</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The agent has no identities.</span><br></pre></td></tr></table></figure><p>아래의 명령어로 등록을 하면 좋다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://stackoverflow.com/questions/25927914/git-error-please-make-sure-you-have-the-correct-access-rights-and-the-reposito">stackoverflow git error</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-24-git_error/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PEP 405 – Python Virtual Environments</title>
      <link>https://sejoung.github.io/2023/10/2023-10-23-python_venv/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-23-python_venv/</guid>
      <pubDate>Mon, 23 Oct 2023 02:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Python-Virtual-Environments&quot;&gt;&lt;a href=&quot;#Python-Virtual-Environments&quot; class=&quot;headerlink&quot; title=&quot;Python Virtual Environments&quot;&gt;&lt;/a&gt;Pytho
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Python-Virtual-Environments"><a href="#Python-Virtual-Environments" class="headerlink" title="Python Virtual Environments"></a>Python Virtual Environments</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>이 PEP는 자체 사이트 디렉토리가 있는 경량 “가상 환경”을 위한 메커니즘을 Python에 추가하고 선택적으로 시스템 사이트 디렉토리에서 격리할 것을 제안합니다.<br>각 가상 환경에는 고유한 Python 바이너리(다양한 Python 버전으로 환경 생성 가능)가 있으며 사이트 디렉터리에 독립적으로 설치된 Python 패키지 세트가 있을 수 있지만<br>기본 설치된 Python과 표준 라이브러리를 공유합니다.</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Python 가상 환경의 유용성은 주로 Ian Bicking의 virtualenv와 같은 기존 타사 가상 환경 도구의 인기로 인해 이미 잘 확립되었습니다.<br>가상 환경은 종속성 관리 및 격리, 시스템 관리자 액세스 없이 Python 패키지를 쉽게 설치 및 사용하고<br>여러 Python 버전에 걸쳐 Python 소프트웨어를 자동으로 테스트하는 등의 용도로 이미 널리 사용되고 있습니다.</p><p>기존 가상 환경 도구는 Python 자체의 동작으로 인한 지원 부족으로 어려움을 겪습니다.<br>Python 바이너리를 가상 환경에 복사하지 않는 virtualenv 와 같은 도구는 시스템 사이트 디렉터리로부터 안정적인 격리를 제공할 수 없습니다.<br>sitePython 바이너리를 복사하는 Virtualenv는 시작할 때마다 섬세한 부트 스트랩 댄스를 수행하기 위해 Python 모듈의 대부분을 복제하고 끊임없이 변화하는<br>표준 라이브러리 모듈 세트를 가상 환경에 수동으로 심볼릭 링크&#x2F;복사해야 합니다.<br>(Virtualenv는 격리를 제공하기 위해 바이너리를 복사해야 합니다.)</p><p>PYTHONHOME가상 환경을 위한 Python의 유일한 기존 내장 솔루션인 환경 변수는 전체 표준 라이브러리를 모든 환경에 복사&#x2F;심볼링 연결해야 합니다.<br>전체 표준 라이브러리를 복사하는 것은 간단한 솔루션이 아니며 심볼릭 링크에 대한 크로스 플랫폼 지원은 일관성이 없습니다<br>(심지어 이를 지원하는 Windows 플랫폼에서도 이를 생성하려면 관리자 권한이 필요한 경우가 많습니다).</p><p>Python과 통합되고 기존 타사 도구에 대한 수년간의 경험을 활용하는 가상 환경 메커니즘은 유지 관리를 줄이고 안정성을 높이며 모든 Python 사용자가 더 쉽게 사용할 수 있습니다.</p><h2 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h2><p>Python 바이너리가 실행되면 접두사(에 저장됨 sys.prefix)를 결정하려고 시도한 다음 표준 라이브러리 및 기타 주요 파일을 찾는 데 사용되며<br>모듈은 site사이트 패키지 디렉터리의 위치를 결정합니다.<br>현재 접두사는 먼저 표준 라이브러리의 존재를 나타내는 PYTHONHOME마커 파일(os.py바이너리)</p><p>이 PEP는 이 검색에 새로운 첫 번째 단계를 추가할 것을 제안합니다.<br>파일 pyvenv.cfg이 Python 실행 파일 옆에 있거나 그 위의 한 디렉터리에서<br>발견되면(실행 파일이 심볼릭 링크인 경우 역참조되지 않음) 이 파일에서 형식의 줄을 검색합니다.<br>키가 발견 되면 이는 Python 바이너리가 가상 환경에 속하고 키의 값이 이 가상 환경을 만드는 데 사용된 Python 실행 파일이 포함된 디렉터리임을 의미합니다. key &#x3D; valuehomehome</p><p>home이 경우 접두사 찾기 는 기본 설치의 접두사를 찾는 효과적인 Python 바이너리 위치로 키 값을 사용하여 정상적으로 계속됩니다.<br>sys.base_prefix은 이 값으로 설정되고 는 가 sys.prefix포함된 디렉터리로 설정됩니다 pyvenv.cfg.<br>(pyvenv.cfg가 발견되지 않거나 키를 포함하지 않는 경우 home접두사 찾기는 정상적으로 계속되며 와 sys.prefix같습니다 sys.base_prefix.)</p><p>또한 sys.base_exec_prefix가 추가되고 와 관련하여 유사하게 처리됩니다 sys.exec_prefix.<br>(sys.exec_prefix와 동일 sys.prefix하지만 플랫폼별 파일의 경우 기본적으로 와 동일한 값을 갖습니다 sys.prefix.)</p><p>및 표준 라이브러리 모듈은 표준 라이브러리와 헤더 파일이 &#x2F; 를 기준으로 검색되는 반면 사이트 패키지 디렉터리(“purelib” 및 “platlib”)<br>site는 여전히 &#x2F; 를 기준으로 검색되도록 수정됩니다 .sysconfigsys.base_prefixsys.base_exec_prefixsysconfigsys.prefixsys.exec_prefix</p><p>pyvenv.cfg따라서 가장 간단한 형태의 Python 가상 환경은 파일 및 사이트 패키지 디렉터리 와 함께 제공되는 Python 바이너리의 복사본 또는 심볼릭 링크로만 구성됩니다 .</p><h3 id="시스템-사이트-패키지로부터-격리"><a href="#시스템-사이트-패키지로부터-격리" class="headerlink" title="시스템 사이트 패키지로부터 격리"></a>시스템 사이트 패키지로부터 격리</h3><p>기본적으로 가상 환경은 시스템 수준 사이트 패키지 디렉터리와 완전히 격리됩니다.</p><p>파일에 값이 대소문자를 구분하지 않는 pyvenv.cfg키가 포함되어 있는 경우 모듈은 가상 환경 사이트 디렉터리 뒤에 시스템 사이트 디렉터리도 추가합니다.<br>따라서 시스템에 설치된 패키지는 계속 가져올 수 있지만 가상 환경에 설치된 동일한 이름의 패키지가 우선적으로 적용됩니다.include-system-site-packagestruesitesys.path</p><p>PEP 370 사용자 수준 사이트 패키지는 venv 목적을 위한 시스템 사이트 패키지의 일부로 간주됩니다.<br>격리된 venv에서는 사용할 수 없지만 venv에서는 사용할 수 있습니다 .include-system-site-packages &#x3D; true</p><h3 id="가상-환경-만들기"><a href="#가상-환경-만들기" class="headerlink" title="가상 환경 만들기"></a>가상 환경 만들기</h3><p>venv또한 이 PEP 에서는 가상 환경 생성을 구현하는 표준 라이브러리에 새 모듈을 추가할 것을 제안합니다.<br>이 모듈은 다음 플래그를 사용하여 실행할 수 있습니다 -m</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><p>이를 더욱 편리하게 하기 위해 설치된 스크립트 pyvenv도 제공됩니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyvenv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><p>이 명령을 실행하면 대상 디렉터리가 생성되고(아직 존재하지 않는 상위 디렉터리 생성) 해당 디렉터리 pyvenv.cfg에 home명령이 실행된 Python 설치를 가리키는 키가 포함된 파일이 배치됩니다.<br>또한 실행 파일 의 복사본(또는 심볼릭 링크) 과 표준 라이브러리 모듈 의 스크립트가 포함된 하위 디렉터리 bin&#x2F;(또는 Windows의 경우) 를 생성합니다<br>(PyPI에서 새 venv로 패키지를 쉽게 설치할 수 있도록 함).<br>그리고 (처음에는 비어 있는) (또는 Windows의 경우) 하위 디렉터리를 만듭니다</p><p>대상 디렉터리가 이미 존재하는 경우 옵션이 제공되지 않는 한 오류가 발생하며, –clear이 경우 대상 디렉터리가 삭제되고 가상 환경 생성이 평소대로 진행됩니다.</p><p>생성된 파일에는 기본적으로 옵션과 함께 실행되는 경우 로 설정된 키 pyvenv.cfg도 포함됩니다</p><p>에 여러 경로를 지정할 수 있으며 pyvenv, 이 경우 제공된 각 경로에 지정된 옵션에 따라 동일한 가상 환경이 생성됩니다.</p><p>이 모듈은 또한 venv의 또는 디렉터리 venv에 POSIX 및 Windows 시스템용 “셸 활성화 스크립트”를 배치합니다. 이러한 스크립트는 단순히 가상 환경의 (또는 )<br>디렉터리를 사용자의 셸 PATH 앞에 추가합니다. 이는 가상 환경을 사용하는 데 반드시 필요한 것은 아니지만<br>(venv의 Python 바이너리 또는 스크립트에 대한 명시적 경로를 사용할 수도 있으므로) 편리합니다.</p><p>pysetup다른 Python 패키지 관리자가 일반 Python 설치에 설치하는 것과 동일한 방식으로 가상 환경에 패키지를<br>설치할 수 있도록 허용 하고 적절한 경우 sysconfig대신 사용할 수 있는 특수한 가상 환경을 피하기 위해 내부 가상 환경 레이아웃은 다음을 모방 합니다.<br>각 플랫폼의 Python 설치 자체 레이아웃. 따라서 POSIX 시스템의 일반적인 가상 환경 레이아웃은 다음과 같습니다.</p><p>가상 환경에 설치된 타사 패키지의 Python 모듈은 디렉터리에 배치되고 site-packages해당 실행 파일은 bin&#x2F;또는 에 배치됩니다 Scripts.</p><h3 id="Sysconfig-설치-구성표-및-사용자-사이트"><a href="#Sysconfig-설치-구성표-및-사용자-사이트" class="headerlink" title="Sysconfig 설치 구성표 및 사용자 사이트"></a>Sysconfig 설치 구성표 및 사용자 사이트</h3><p>이 접근 방식은 venvs에 대한 새로운 sysconfig 설치 체계를 도입하지 않도록 명시적으로 선택합니다.<br>오히려 수정을 통해 sys.prefix위치 기반이 되는 기존 설치 구성표가 sys.prefix가상 환경에서 작동하도록 보장합니다.<br>경로가 에 상대적이지 않은 다른 설치 구성표(예: 사용자 사이트 구성표)에 대한 설치는 sys.prefixvenv의 영향을 전혀 받지 않습니다.</p><p>가상 특정 sysconfig 체계를 기반으로 Python 가상 환경의 대체 구현을 만드는 것이 가능할 수 있지만 가상 환경 내에서 작동하는지 여부를 인식하려면 더 많은 코드가 필요하므로 덜 강력합니다.</p><h3 id="복사본과-심볼릭-링크"><a href="#복사본과-심볼릭-링크" class="headerlink" title="복사본과 심볼릭 링크"></a>복사본과 심볼릭 링크</h3><p>이 PEP의 기술은 일반적으로 복사되거나 심볼릭 링크된 Python 바이너리(및 Windows에서 필요한 기타 DLL)와 동일하게 작동합니다.<br>기본 Python 설치로 업그레이드하는 경우 venv에 복사된 Python 실행 파일이 설치된 표준 라이브러리와 동기화되지 않아 수동 업그레이드가 필요할 수 있으므로 가능한 경우<br>Symlinking을 사용하는 것이 좋습니다.</p><p>심볼릭 링크에는 몇 가지 크로스 플랫폼 문제가 있습니다.</p><ul><li>모든 Windows 버전이 심볼릭 링크를 지원하는 것은 아니며, 지원하는 경우에도 심볼릭 링크를 생성하려면 관리자 권한이 필요한 경우가 많습니다.</li><li>Python의 OS X 프레임워크 빌드에서 sys.executable은 실제 Python 바이너리를 실행하는 스텁일 뿐입니다.<br>이 스텁을 심볼릭 링크하는 것은 작동하지 않습니다. 복사해야 합니다.<br>(다행히도 스텁도 작고 Python으로의 버그 수정 업그레이드로 변경되지 않으므로 복사하는 것은 문제가 되지 않습니다.)</li></ul><p>따라서 이 PEP는 Windows 및 OS X 프레임워크 빌드를 제외한 모든 플랫폼에서 바이너리를 심볼릭 링크하도록 제안합니다. –symlink<br>적절한 권한이 있는 경우 이를 지원하는 Windows 버전에서 심볼릭 링크를 강제로 사용하도록 하는 옵션을 사용할 수 있습니다.<br>(이 옵션은 OS X 프레임워크 빌드에 영향을 미치지 않습니다. 왜냐하면 심볼릭 링크는 그곳에서 작동할 수 없고 이점도 없기 때문입니다.)</p><p>Windows에서 가 –symlink사용되지 않는 경우 이는 기본 Python 설치가 업그레이드되면 venv의 Python 바이너리 및 DLL이 업데이트되어야 함을 의미합니다.<br>그렇지 않으면 업그레이드된 표준 라이브러리와 불일치 문제가 발생할 수 있습니다. pyvenv 스크립트는 –upgrade기존 venv에서 이 업그레이드를 쉽게 수행하기 위한 옵션을 허용합니다.</p><h3 id="Include-files"><a href="#Include-files" class="headerlink" title="Include files"></a>Include files</h3><p>현재 virtualenv 핸들에는 다음과 같은 방식으로 파일이 포함됩니다.</p><p>설치된 Python의 포함 파일이 에 있는 POSIX 시스템 에서 ${base_prefix}&#x2F;include&#x2F;pythonX.Xvirtualenv ${venv}&#x2F;include&#x2F;는.<br>Python의 포함 파일이 있고 심볼릭 링크를 안정적으로 사용할 수 없는 Windows에서는 virtualenv 가.<br>이렇게 하면 virtualenv 내에 빌드되고 설치된 확장 모듈이 항상</p><p>이 솔루션은 확장 모듈이 자체 헤더 파일을 설치할 때 이상적이지 않습니다.<br>해당 헤더 파일의 기본 설치 위치가 쓰기 불가능한 시스템 디렉터리에 대한 심볼릭 링크일 수 있기 때문입니다.<br>한 설치 프로그램인 pip는 헤더 파일을 비표준 위치에 설치하여 명시적으로 이 문제를 해결합니다 ${venv}&#x2F;include&#x2F;site&#x2F;pythonX.X&#x2F;. Python에는<br>현재 사이트별 포함 디렉터리에 대한 표준 추상화가 없기 때문입니다.</p><p>이 PEP는 약간 다른 접근 방식을 제안하지만 본질적으로 동일한 효과와 동일한 장단점을 갖습니다.<br>포함 파일을 venv에 심볼릭 링크하거나 복사하는 대신 헤더 파일이 base_prefix항상 prefix.<br>(우리는 또한 include&#x2F;venv 내에 디렉토리를 생성하므로 설치 프로그램은 env 내에 설치된 포함 파일을 저장할 위치를 갖습니다.)</p><p>distutils&#x2F;packaging 및 확장에 따라 pyvenv의 포함 파일을 더 잘 처리하는 것은 자체 미래 PEP를 받을 자격이 있는 영역입니다.<br>지금은 virtualenv의 동작이 실제로 적어도 “충분히 좋은” 것으로 입증되었다고 제안합니다.</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>위에 설명된 상위 수준 방법은 타사 가상 환경 생성자가 필요에 따라 환경 생성을 사용자 정의할 수 있는 메커니즘을 제공하는 간단한 API를 사용합니다.</p><p>모듈 에는 인스턴스화 시 다음 키워드 인수를 허용하는 클래스가 venv포함되어 있습니다 .EnvBuilder</p><ul><li>system_site_packages- 시스템 Python 사이트 패키지를 환경에서 사용할 수 있어야 함을 나타내는 부울 값입니다. 기본값은 False.</li><li>clear- true인 경우 예외를 발생시키는 대신 기존 대상 디렉터리를 삭제하는 부울 값입니다. 기본값은 False.</li><li>symlinkspythonw.exe- 복사하는 대신 Python 바이너리(및 필요한 DLL 또는 기타 바이너리(예: ))를 심볼릭 링크할지 여부를 나타내는 부울 값입니다 . 기본값은 False.</li></ul><p>인스턴스화된 env-builder에는 create가상 환경을 포함할 대상 디렉터리의 경로(현재 디렉터리에 대한 절대 또는 상대 경로)를 필수 인수로 사용하는 메서드가 있습니다.<br>이 create메서드는 지정된 디렉터리에 환경을 생성하거나 적절한 예외를 발생시킵니다.</p><p>모듈 은 편의를 위해 venv모듈 수준 기능도 제공합니다 .create</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">env_dir,</span></span><br><span class="line"><span class="params">           system_site_packages=<span class="literal">False</span>, clear=<span class="literal">False</span>, use_symlinks=<span class="literal">False</span></span>):</span><br><span class="line">    builder = EnvBuilder(</span><br><span class="line">        system_site_packages=system_site_packages,</span><br><span class="line">        clear=clear,</span><br><span class="line">        use_symlinks=use_symlinks)</span><br><span class="line">    builder.create(env_dir)</span><br></pre></td></tr></table></figure><p>타사 가상 환경 도구 작성자는 제공된 EnvBuilder클래스를 기본 클래스로 자유롭게 사용할 수 있습니다.</p><p>create클래스 의 메소드는 사용자 EnvBuilder정의에 사용할 수 있는 후크를 보여줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, env_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create a virtualized Python environment in a directory.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param env_dir: The target directory to create an environment in.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    env_dir = os.path.abspath(env_dir)</span><br><span class="line">    context = self.create_directories(env_dir)</span><br><span class="line">    self.create_configuration(context)</span><br><span class="line">    self.setup_python(context)</span><br><span class="line">    self.post_setup(context)</span><br></pre></td></tr></table></figure><p>create_directories, create_configuration, setup_python및 각 메소드는 post_setup재정의될 수 있습니다. 이러한 메소드의 기능은 다음과 같습니다.</p><ul><li><p>create_directories- 환경 디렉터리와 필요한 모든 디렉터리를 생성하고 컨텍스트 개체를 반환합니다. 이는 다른 메소드에서 사용하기 위한 속성(예: 경로)의 홀더일 뿐입니다.</p></li><li><p>create_configuration- pyvenv.cfg환경에 구성 파일을 생성합니다.</p></li><li><p>setup_python- 환경에 Python 실행 파일(및 Windows에서는 DLL)의 복사본을 생성합니다.</p></li><li><p>post_setup- 패키지를 사전 설치하거나 가상 환경에 스크립트를 설치하기 위해 타사 서브클래스에서 재정의할 수 있는(기본적으로 무작동) 후크 방법입니다.</p></li></ul><p>또한 가상 환경에 사용자 정의 스크립트를 설치하는 데 도움이 되도록 하위 클래스 EnvBuilder에서 호출할 수 있는 유틸리티 메서드를 제공합니다.<br>post_setup이 메서드는 개체(위 참조)와 디렉터리 경로를 install_scripts인수로 받아들입니다.<br>context디렉터리에는 하위 디렉터리 “common”, “posix”, “nt”가 포함되어야 하며 각 디렉터리에는 환경의 bin 디렉터리로 향하는 스크립트가 포함되어 있습니다.<br>“common”의 내용과 해당 디렉터리는 os.name자리 표시자의 일부 텍스트 교체를 수행한 후 복사됩니다.</p><ul><li>__VENV_DIR__환경 디렉터리의 절대 경로로 대체됩니다.</li><li>__VENV_NAME__환경 이름(환경 디렉터리의 최종 경로 세그먼트)으로 대체됩니다.</li><li>__VENV_BIN_NAME__은 bin 디렉토리의 이름(또는 bin) 으로 대체됩니다 Scripts.</li><li>__VENV_PYTHON__환경 실행 파일의 절대 경로로 대체됩니다.</li></ul><p>참조 구현의 서브 클래스 DistributeEnvBuilder는 가상 환경에 Distribute를 사전 설치하기 위해 실제로 사용자 정의 후크를 사용하는 방법을 보여줍니다.<br>Python 코어에 실제로 추가될 것이라고 는 예상되지 않지만 DistributeEnvBuilder참조 구현을 테스트 및 탐색 목적에 더 즉각적으로 유용하게 만듭니다.</p><h2 id="Backwards-Compatibility"><a href="#Backwards-Compatibility" class="headerlink" title="Backwards Compatibility"></a>Backwards Compatibility</h2><h3 id="sys-prefix-의미를-나누다"><a href="#sys-prefix-의미를-나누다" class="headerlink" title="sys.prefix 의미를 나누다"></a>sys.prefix 의미를 나누다</h3><p>이 라인에 따른 모든 가상 환경 도구(사이트 패키지를 분리하려고 시도하면서 가상 환경에 심볼릭 링크할 필요 없이 기본 Python의 표준 라이브러리를 계속 사용함)는<br>두 가지 다른 의미 사이의 분할을 제안합니다. )는 현재 둘 다 sys.prefix”표준 라이브러리는 어디에 있습니까?”라는 질문에 대한 답변으로 요약되어 있습니다.<br>및 “타사 모듈을 설치해야 하는 사이트 패키지 위치는 어디에 있습니까?”</p><p>sys이 분할은 전자 접두사 또는 후자 접두사에 대한 새 속성을 도입하여 처리할 수 있습니다.<br>어느 옵션이든 sys.prefix. (이러한 소프트웨어는 이러한 질문에 대답하기 위해 직접 사용하는 것보다 site및 모듈 의 API를 사용하는 것이 바람직합니다.<br>이 경우 이전 버전과의 호환성 문제는 없지만 실제로는 때때로 사용됩니다.)</p><p>sys.prefix 에 대한 문서 에서는 이를 “플랫폼 독립적인 Python 파일이 설치된 사이트별 디렉터리 접두사를 제공하는 문자열”이라고 설명하고,<br>에 있는 표준 라이브러리 및 헤더 파일을 구체적으로 언급합니다 sys.prefix. 에 대해서는 언급하지 않습니다 site-packages.</p><p>sys.prefix이 문서화된 정의를 유지한다는 것은 기본 시스템 설치(표준 라이브러리와 헤더 파일이 있는 위치)를 가리키는 것을 그대로 두고 의 접두사를 가리키도록 에 새 값 sys(예: )을<br>도입하는 것을 의미합니다 . 이렇게 하면 문서화된 의미 체계가 유지되지만 타사 코드에서 적절한 API를 사용 하여 사이트 패키지 디렉터리를 찾는 경우<br>격리가 중단될 위험이 있습니다.</p><p>가장 주목할만한 사례는 아마도 API를 주로 사용 하지만 파일을 유용하게 배치할 수 있는 비행 전 확인을 위해 사이트 디렉터리 목록을 작성하는 데 직접 사용하는<br>setuptools 및 해당 포크 배포 일 것입니다.</p><p>sys.prefix그렇지 않으면 Google 코드 검색 은 사이트 패키지 경로를 구축하는 데 사용하는 패키지와 이를 사용하여 코드 실행 추적에서 표준 라이브러리를 제거하는 데<br>사용하는 패키지 간의 사용법이 대략 균일하게 혼합된 것처럼 보이는 것을 나타냅니다 .</p><p>의 문서화된 정의를 수정해야 하지만 sys.prefix이 PEP는 sys.prefix가상 환경(이 site-packages발견된 위치) 을 가리키고 sys.base_prefix표준 라이브러리 및<br>Python 헤더 파일을 가리키도록 소개하는 것을 선호합니다. 이 선택의 근거:</p><ul><li>가상 환경을 더 많이 격리하는 편이 더 좋습니다.</li><li>Virtualenv는 이미 sys.prefix가상 환경을 가리키도록 수정되었으며 실제로는 문제가 되지 않았습니다.</li><li>setuptools&#x2F;distribute에는 수정이 필요하지 않습니다.</li></ul><h3 id="다른-Python-구현에-미치는-영향"><a href="#다른-Python-구현에-미치는-영향" class="headerlink" title="다른 Python 구현에 미치는 영향"></a>다른 Python 구현에 미치는 영향</h3><p>이 PEP 변경 사항의 대부분은 다른 Python 구현과 공유되는 표준 라이브러리에서 발생하며 문제가 발생하지 않습니다.</p><p>다른 Python 구현에서는 파일 찾기 및 구문 분석(있는 경우)을 sys.prefix포함하여 인터프리터 부트스트랩의 새로운 찾기 동작을 복제해야 합니다 .pyvenv.cfg</p><h2 id="Reference-Implementation"><a href="#Reference-Implementation" class="headerlink" title="Reference Implementation"></a>Reference Implementation</h2><p>참조 구현은 CPython Mercurial 저장소의 복제본 에서 찾을 수 있습니다. 테스트하려면 빌드하고 실행하여 가상 환경을 만듭니다.bin&#x2F;pyvenv &#x2F;path&#x2F;to&#x2F;new&#x2F;venv</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://peps.python.org/pep-0405/">PEP 405 – Python Virtual Environments</a></li><li><a href="https://docs.python.org/ko/3/library/venv.html">venv</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-23-python_venv/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stable-diffusion-webui 우분투에 설치</title>
      <link>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/</link>
      <guid>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/</guid>
      <pubDate>Wed, 18 Oct 2023 04:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;stable-diffusion-webui-우분투에-설치&quot;&gt;&lt;a href=&quot;#stable-diffusion-webui-우분투에-설치&quot; class=&quot;headerlink&quot; title=&quot;stable-diffusion-webui 우분투에 설치&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="stable-diffusion-webui-우분투에-설치"><a href="#stable-diffusion-webui-우분투에-설치" class="headerlink" title="stable-diffusion-webui 우분투에 설치"></a>stable-diffusion-webui 우분투에 설치</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install git python3.10-venv -y</span><br><span class="line">git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui &amp;&amp; cd stable-diffusion-webui</span><br><span class="line">python3.10 -m venv venv</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="시작-방법"><a href="#시작-방법" class="headerlink" title="시작 방법"></a>시작 방법</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webui.sh</span><br></pre></td></tr></table></figure><h2 id="외부에서-접속가능하게-설정"><a href="#외부에서-접속가능하게-설정" class="headerlink" title="외부에서 접속가능하게 설정"></a>외부에서 접속가능하게 설정</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./webui.sh --listen</span><br></pre></td></tr></table></figure><h2 id="팁"><a href="#팁" class="headerlink" title="팁"></a>팁</h2><p>아래 처럼 모델 다운로드시에는 꼭 lfs로 해야 된다</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://huggingface.co/lllyasviel/ControlNet-v1-1</span><br></pre></td></tr></table></figure><p>플러그인 설치는 외부로 오픈된 상태에서는 설정이 되지 않는다</p><h2 id="오류"><a href="#오류" class="headerlink" title="오류"></a>오류</h2><p>아래 오류에서 저는 모델 이 잘못됨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2023-10-18 13:56:20,737 - ControlNet - INFO - Loading model: control_v11e_sd15_ip2p [e3b0c442]</span><br><span class="line">*** Error running process: /repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/modules/scripts.py&quot;, line 619, in process</span><br><span class="line">        script.process(p, *script_args)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 977, in process</span><br><span class="line">        self.controlnet_hack(p)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 966, in controlnet_hack</span><br><span class="line">        self.controlnet_main_entry(p)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 688, in controlnet_main_entry</span><br><span class="line">        model_net = Script.load_control_model(p, unet, unit.model)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 321, in load_control_model</span><br><span class="line">        model_net = Script.build_control_model(p, unet, model)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/controlnet.py&quot;, line 349, in build_control_model</span><br><span class="line">        state_dict = load_state_dict(model_path)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/extensions/sd-webui-controlnet/scripts/utils.py&quot;, line 20, in load_state_dict</span><br><span class="line">        state_dict = unsafe_torch_load(ckpt_path, map_location=torch.device(location))</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/venv/lib/python3.10/site-packages/torch/serialization.py&quot;, line 815, in load</span><br><span class="line">        return _legacy_load(opened_file, map_location, pickle_module, **pickle_load_args)</span><br><span class="line">      File &quot;/repositories/stable-diffusion-webui/venv/lib/python3.10/site-packages/torch/serialization.py&quot;, line 1033, in _legacy_load</span><br><span class="line">        magic_number = pickle_module.load(f, **pickle_load_args)</span><br><span class="line">    _pickle.UnpicklingError: invalid load key, &#x27;v&#x27;.</span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr><ul><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui#installation-and-running">installation-and-running</a></li><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/88">Can this be made avalable network-wide, not just on localhost? #88</a></li><li><a href="https://github.com/Mikubill/sd-webui-controlnet/issues/1617">Could not set ControlNet value: invalid literal for int() with base 10: ‘initial’</a></li></ul>]]></content:encoded>
      
      <comments>https://sejoung.github.io/2023/10/2023-10-18-stable_diffusion_webui_install/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
