<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="spring framework The IoC Container"><meta name="keywords" content="spring framework,core,The IoC Container"><meta name="author" content="sejoung"><meta name="copyright" content="sejoung"><title>spring framework The IoC Container | 폭간의 기술블로그</title><link rel="shortcut icon" href="../../../my-favicon.ico"><link rel="stylesheet" href="../../../css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="https://www.googletagmanager.com/gtag/js?id=G-NVRTGLD8RZ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NVRTGLD8RZ');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Framework"><span class="toc-number">1.</span> <span class="toc-text">Spring Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependencies"><span class="toc-number">1.1.</span> <span class="toc-text">Dependencies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dependency-Injection"><span class="toc-number">1.1.1.</span> <span class="toc-text">Dependency Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%83%9D%EC%84%B1%EC%9E%90-%EA%B8%B0%EB%B0%98-%EC%A2%85%EC%86%8D%EC%84%B1-%EC%82%BD%EC%9E%85"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">생성자 기반 종속성 삽입</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9D%B8%EC%88%98-%ED%95%B4%EC%84%9D"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">생성자 인수 해석</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9D%B8%EC%88%98-%EC%9C%A0%ED%98%95-%EC%9D%BC%EC%B9%98"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">생성자 인수 유형 일치</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9D%B8%EC%88%98-%EC%9D%B8%EB%8D%B1%EC%8A%A4"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">생성자 인수 인덱스</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9D%B8%EC%88%98-%EC%9D%B4%EB%A6%84"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">생성자 인수 이름</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%84%B8%ED%84%B0-%EA%B8%B0%EB%B0%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">세터 기반 의존성 주입</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%A2%85%EC%86%8D%EC%84%B1-%ED%95%B4%EA%B2%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"><span class="toc-number">1.1.1.1.6.</span> <span class="toc-text">종속성 해결 프로세스</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%82%BD%EC%9E%85%EC%9D%98-%EC%98%88"><span class="toc-number">1.1.1.1.7.</span> <span class="toc-text">의존성 삽입의 예</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A2%85%EC%86%8D%EC%84%B1-%EB%B0%8F-%EA%B5%AC%EC%84%B1-%EC%84%B8%EB%B6%80-%EC%A0%95%EB%B3%B4"><span class="toc-number">1.1.2.</span> <span class="toc-text">종속성 및 구성 세부 정보</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Straight-Values-Primitives-Strings-and-so-on"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Straight Values (Primitives, Strings, and so on)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#idref%EC%9A%94%EC%86%8C"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">idref요소</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EB%8B%A4%EB%A5%B8-%EC%BD%A9%EC%97%90-%EB%8C%80%ED%95%9C-%EC%96%B8%EA%B8%89-%EA%B3%B5%EB%8F%99-%EC%9E%91%EC%97%85%EC%9E%90"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">다른 콩에 대한 언급 (공동 작업자)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EB%82%B4%EB%B6%80-%EC%BD%A9"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">내부 콩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%BB%AC%EB%A0%89%EC%85%98"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%BB%AC%EB%A0%89%EC%85%98-%EB%B3%91%ED%95%A9"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">컬렉션 병합</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EC%BB%AC%EB%A0%89%EC%85%98-%EB%B3%91%ED%95%A9%EC%9D%98-%EC%A0%9C%ED%95%9C-%EC%82%AC%ED%95%AD"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">컬렉션 병합의 제한 사항</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EA%B0%95%EB%A0%A5%ED%95%9C-%ED%98%95%EC%8B%9D%EC%9D%98-%EC%BB%AC%EB%A0%89%EC%85%98"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">강력한 형식의 컬렉션</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Null-%EB%B0%8F-%EB%B9%88-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B0%92"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">Null 및 빈 문자열 값</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#p-namespace%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-XML-%EB%B0%94%EB%A1%9C-%EA%B0%80%EA%B8%B0"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">p-namespace를 사용한 XML 바로 가기</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-namespace%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-XML-%EB%B0%94%EB%A1%9C-%EA%B0%80%EA%B8%B0"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">c-namespace를 사용한 XML 바로 가기</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EB%B3%B5%ED%95%A9-%EC%86%8D%EC%84%B1-%EC%9D%B4%EB%A6%84"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">복합 속성 이름</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#depends-on-%EC%82%AC%EC%9A%A9"><span class="toc-number">1.1.3.</span> <span class="toc-text">depends-on 사용</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B2%8C%EC%9C%BC%EB%A5%B8-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%90%9C-%EB%B9%88"><span class="toc-number">1.1.4.</span> <span class="toc-text">게으른 초기화 된 빈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowiring-Collaborators"><span class="toc-number">1.1.5.</span> <span class="toc-text">Autowiring Collaborators</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%9E%90%EB%8F%99-%EB%B0%B0%EC%84%A0%EC%9D%98-%ED%95%9C%EA%B3%84%EC%99%80-%EB%8B%A8%EC%A0%90"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">자동 배선의 한계와 단점</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%9E%90%EB%8F%99-%EC%99%80%EC%9D%B4%EC%96%B4-%EB%A7%81%EC%97%90%EC%84%9C-Bean-%EC%A0%9C%EC%99%B8"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">자동 와이어 링에서 Bean 제외</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B0%A9%EB%B2%95-%EC%A3%BC%EC%9E%85"><span class="toc-number">1.1.6.</span> <span class="toc-text">방법 주입</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%A1%B0%ED%9A%8C-%EB%B0%A9%EB%B2%95-%EC%82%BD%EC%9E%85"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">조회 방법 삽입</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%9E%84%EC%9D%98-%EB%B0%A9%EC%8B%9D-%EB%8C%80%EC%B2%B4"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">임의 방식 대체</span></a></li></ol></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EC%A1%B0"><span class="toc-number"></span> <span class="toc-text">참조</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/4936005?s=400&amp;u=a679b941fe377418e7e4efcf916c6a636d7178ee&amp;v=4"></div><div class="author-info__name text-center">sejoung</div><div class="author-info__description text-center">잘정리하자</div><div class="follow-button"><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/sejoung">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../archives"><span class="pull-left">Articles</span><span class="pull-right">733</span></a><a class="author-info-articles__tags article-meta" href="../../../tags"><span class="pull-left">Tags</span><span class="pull-right">793</span></a><a class="author-info-articles__categories article-meta" href="../../../categories"><span class="pull-left">Categories</span><span class="pull-right">74</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.naver.com/sanaes">naverblog</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.linkedin.com/in/sanaes/">linkedin</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.slideshare.net/sejoung">slideshare</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../index.html">폭간의 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">spring framework The IoC Container</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="../../../categories/java/">java</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2019/05/2019-05-17-spring-framework-Dependencies/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>일반적인 엔터프라이즈 애플리케이션은 단일 객체 (또는 Spring 용어로는 빈)로 구성되지 않습니다.<br>가장 단순한 응용 프로그램이라 할지라도 최종 사용자가 일관된 응용 프로그램으로 보는 것을 표현하기 위해 함께 작동하는 몇 가지 개체가 있습니다.<br>이 다음 섹션에서는 독립 실행 형 Bean 정의의 정의에서 목표 달성을 위해 객체가 협업하는 완전히 실현 된 애플리케이션으로 이동하는 방법에 대해 설명합니다.</p>
<h4 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h4><p>DI (Dependency Injection)는 생성자 인수, 팩토리 메서드에 대한 인수 또는 구성 후 개체 인스턴스에 설정된 속성을 통해서만 개체가 종속성 (즉, 작업하는 다른 개체)을 정의하는 프로세스입니다.<br>팩토리 메서드에서 반환됩니다.<br>그런 다음 컨테이너는 bean을 작성할 때 이러한 종속성을 주입합니다.<br>이 프로세스는 기본적으로 클래스 또는 서비스 로케이터 패턴의 직접 작성을 사용하여 자체 의존성의 인스턴스화 또는 위치를 제어하는 ​​빈 자체의 역전 (따라서 제어의역전을 이룸)입니다.</p>
<p>코드는 DI 원칙을 사용하여보다 명확하며 객체가 종속성을 제공받을 때 디커플링이 더 효과적입니다.<br>개체는 종속성을 찾지 않으며 종속성의 위치 나 클래스를 알지 못합니다.<br>따라서 종속성이 인터페이스 또는 추상 기본 클래스에있을 때 클래스 테스트가 쉬워 져 단위 테스트에서 스텁 또는 모의 구현을 사용할 수 있습니다.</p>
<p>DI는 크게 두 가지 변종으로 나뉩니다.<br>생성자 기반 종속성 주입 과 Setter 기반 종속성 주입 입니다.</p>
<h5 id="생성자-기반-종속성-삽입"><a href="#생성자-기반-종속성-삽입" class="headerlink" title="생성자 기반 종속성 삽입"></a>생성자 기반 종속성 삽입</h5><p>생성자 기반 DI는 컨테이너가 여러 종속 변수를 나타내는 여러 개의 인수로 생성자를 호출함으로써 수행됩니다.<br>static Bean을 생성하기위한 특정 인수를 가진 팩토리 메소드를 호출하는 것은 거의 동일하며,이 논의는 생성자와 static 팩토리 메소드 에 대한 인수를 유사하게 취급합니다.<br>다음 예제는 생성자 삽입으로 만 종속성 주입 될 수있는 클래스를 보여줍니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>이 클래스에는 특별한 것이 없다는 것을 주목하십시오.<br>이것은 컨테이너 고유 인터페이스, 기본 클래스 또는 주석에 대한 종속성이없는 POJO입니다.</p>
<h6 id="생성자-인수-해석"><a href="#생성자-인수-해석" class="headerlink" title="생성자 인수 해석"></a>생성자 인수 해석</h6><p>생성자 인수 분석은 인수의 유형을 사용하여 수행됩니다.<br>bean 정의의 생성자 인수에 잠재적 인 모호성이 없으면 bean 정의에서 생성자 인수가 정의되는 순서는 bean이 인스턴스화 될 때 해당 인수가 적절한 생성자에 제공되는 순서입니다.<br>다음 클래스를 고려하십시오.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThingOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>그 가정 ThingTwo및 ThingThree클래스가 상속으로 관련이없는, 잠재적 모호성은 존재하지 않는다.<br>따라서 다음 구성이 제대로 작동하므로 생성자 인수 인덱스 나 유형을 명시 적으로 <constructor-arg> 요소 에 지정할 필요가 없습니다 .</constructor-arg></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>다른 bean이 참조 될 때, 그 타입은 알려지고 일치가 발생할 수있다 (앞의 예에서와 같이).<br><value>true</value>Spring이 값의 타입을 결정할 수 없기 때문에 간단한 타입이 사용될 때, 도움없이 타입별로 일치시킬 수 없습니다.<br>다음 클래스를 고려하십시오.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="생성자-인수-유형-일치"><a href="#생성자-인수-유형-일치" class="headerlink" title="생성자 인수 유형 일치"></a>생성자 인수 유형 일치</h6><p>앞의 시나리오에서 컨테이너는 type특성 을 사용하여 생성자 인수의 형식을 명시 적으로 지정하면 단순 형식과 일치하는 형식을 사용할 수 있습니다.<br>다음 예제와 같이</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="생성자-인수-인덱스"><a href="#생성자-인수-인덱스" class="headerlink" title="생성자 인수 인덱스"></a>생성자 인수 인덱스</h6><p>index다음 예제와 같이이 속성을 사용하여 생성자 인수의 인덱스를 명시 적으로 지정할 수 있습니다 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>여러 간단한 값의 모호성을 해결할뿐만 아니라 인덱스를 지정하면 생성자가 동일한 유형의 인수가 두 개인 모호성이 해결됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">인덱스는 0부터 시작합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="생성자-인수-이름"><a href="#생성자-인수-이름" class="headerlink" title="생성자 인수 이름"></a>생성자 인수 이름</h6><p>다음 예제와 같이 값 모호성 제거에 생성자 매개 변수 이름을 사용할 수도 있습니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>이 기능을 사용하려면 Spring에서 생성자의 매개 변수 이름을 찾을 수 있도록 디버그 플래그를 활성화 한 상태로 코드를 컴파일해야합니다.<br>디버그 플래그로 코드를 컴파일 할 수 없거나 컴파일하지 않으려면 @ConstructorProperties JDK 어노테이션을 사용 하여 생성자 인수의 이름을 명시 적으로 지정할 수 있습니다.<br>샘플 클래스는 다음과 같이 보일 것입니다 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="세터-기반-의존성-주입"><a href="#세터-기반-의존성-주입" class="headerlink" title="세터 기반 의존성 주입"></a>세터 기반 의존성 주입</h6><p>Setter 기반 DI는 static 빈을 인스턴스화하기 위해 인수가없는 생성자 또는 인수가없는 팩토리 메소드를 호출 한 후 bean에서 setter 메소드를 호출하는 컨테이너에 의해 수행됩니다 .</p>
<p>다음 예제에서는 순수한 setter 주입을 사용하여 종속성 주입 만 할 수있는 클래스를 보여줍니다.<br>이 클래스는 일반적인 자바입니다.<br>이것은 컨테이너 고유의 인터페이스, 기본 클래스 또는 주석에 의존하지 않는 POJO입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ApplicationContext가 관리하는 빈에 대한 지원 생성자 기반 및 setter 기반의 DI.<br>또한 생성자 방식을 통해 일부 종속성이 이미 주입 된 후에도 setter 기반 DI를 지원합니다.<br>종속성을 a 형식으로 구성합니다.<br>이 형식은 인스턴스 BeanDefinition와 함께 사용하여 PropertyEditor속성을 한 형식에서 다른 형식으로 변환합니다.<br>그러나, 대부분의 Spring 사용자가 아니라 XML의와 (즉 프로그램입니다) 직접 이러한 클래스와 함께 작동하지 않습니다 bean 정의, 주석 구성 요소 (즉, 주석 클래스 @Component, @Controller등), 또는 @Bean방법 Java 기반의 @Configuration클래스.<br>이 소스는 내부적으로 인스턴스로 변환되어 BeanDefinition전체 Spring IoC 컨테이너 인스턴스를 로드하는 데 사용된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">생성자 기반 또는 세터 기반 DI?</span><br><span class="line"></span><br><span class="line">생성자 기반 및 설정자 기반 DI를 혼합 할 수 있으므로 필수 종속성 및 설정자 메서드에 대한 생성자 또는 선택적 종속성에 대한 구성 메서드를 사용하는 것이 좋습니다. </span><br><span class="line">setter 메소드 에서 @Required 어노테이션을 사용하면 속성을 필수 종속성으로 만들 수 있습니다. </span><br><span class="line">그러나 인수를 프로그래밍 방식으로 검증하는 생성자 주입이 바람직합니다.</span><br><span class="line"></span><br><span class="line">Spring 팀은 일반적으로 애플리케이션 구성 요소를 불변 객체로 구현하고 필요한 종속성을 보장 할 수 없으므로 생성자 삽입을 옹호합니다 null. </span><br><span class="line">또한 생성자가 주입 한 구성 요소는 완전히 초기화 된 상태에서 항상 클라이언트 (호출) 코드로 반환됩니다. </span><br><span class="line">부수적으로, 많은 수의 생성자 인수는 나쁜 코드의 냄새이며, 클래스가 너무 많은 책임을 가지고 있으며 적절한 관심을 분리하기 위해 리팩토링되어야 함을 의미합니다.</span><br><span class="line"></span><br><span class="line">세터 주입은 주로 클래스 내에서 적절한 기본값을 할당 할 수있는 선택적 종속성에 대해서만 사용해야합니다. </span><br><span class="line">그렇지 않으면 코드가 종속성을 사용하는 모든 곳에서 null이 아닌 검사를 수행해야합니다. </span><br><span class="line">setter 주입의 한 가지 이점은 setter 메소드가 해당 클래스의 객체를 재구성하거나 나중에 다시 주입 할 수있게 만드는 것입니다. </span><br><span class="line">따라서 JMX MBeans 를 통한 관리 는 세터 주입에 대한 매력적인 사용 사례입니다.</span><br><span class="line"></span><br><span class="line">특정 클래스에 가장 적합한 DI 스타일을 사용하십시오. </span><br><span class="line">때로는 소스가없는 제 3 자 클래스를 다룰 때 선택이 이루어집니다. </span><br><span class="line">예를 들어 제 3 자 클래스가 모든 setter 메소드를 노출하지 않으면 생성자 주입이 유일하게 사용 가능한 DI 형식 일 수 있습니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="종속성-해결-프로세스"><a href="#종속성-해결-프로세스" class="headerlink" title="종속성 해결 프로세스"></a>종속성 해결 프로세스</h6><p>컨테이너는 다음과 같이 Bean 의존성 분석을 수행합니다.</p>
<ul>
<li><p>이 ApplicationContext클래스는 모든 bean을 설명하는 구성 메타 데이터로 작성되고 초기화됩니다.<br>구성 메타 데이터는 XML, Java 코드 또는 주석으로 지정할 수 있습니다.</p>
</li>
<li><p>각 bean에 대해 종속성은 속성, 생성자 인수 또는 static-factory 메소드에 대한 인수 형식으로 표현됩니다 (일반 생성자 대신 사용하는 경우).<br>이러한 종속성은 bean이 실제로 작성 될 때 bean에 제공됩니다.</p>
</li>
<li><p>각 특성 또는 생성자 인수는 설정할 값의 실제 정의이거나 컨테이너의 다른 Bean에 대한 참조입니다.</p>
</li>
<li><p>값인 각 특성 또는 생성자 인수는 지정된 형식에서 해당 특성 또는 생성자 인수의 실제 유형으로 변환됩니다.<br>기본적으로 봄과 같은 모든 내장 타입의 문자열로 제공되는 값을 변환 할 수 있습니다 int, long, String, boolean등, 그리고.</p>
</li>
</ul>
<p>Spring 컨테이너는 컨테이너가 생성 될 때 각 bean의 설정을 검증한다.<br>그러나 bean 특성 자체는 bean이 실제로 작성 될 때까지 설정되지 않습니다.<br>컨테이너가 생성 될 때 싱글 랭크이며 미리 인스턴스화되도록 설정된 (기본값) 빈이 만들어집니다.<br>범위는 Bean Scopes에 정의되어 있습니다.<br>그렇지 않으면 Bean은 요청 될 때만 작성됩니다.<br>빈의 생성은 잠재적으로 빈의 그래프가 생성되도록합니다.<br>빈의 의존성과 의존성의 종속성 (등등)이 생성되고 할당되기 때문입니다.<br>이러한 종속성들 사이의 해상도 불일치는 늦게 나타납니다.<br>즉, 영향을받는 빈을 처음 만들 때 나타납니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">순환 의존성</span><br><span class="line"></span><br><span class="line">우세하게 생성자 주입을 사용하면 해결할 수없는 순환 종속성 시나리오를 만들 수 있습니다.</span><br><span class="line"></span><br><span class="line">예 : 클래스 A는 생성자 삽입을 통해 클래스 B의 인스턴스를 요구하고 클래스 B는 생성자 주입을 통해 클래스 A의 인스턴스를 필요로합니다. </span><br><span class="line">클래스 A와 B가 서로 주입되도록 Bean을 구성하면 Spring IoC 컨테이너는 런타임에이 순환 참조를 감지하고 a를 던집니다 BeanCurrentlyInCreationException.</span><br><span class="line"></span><br><span class="line">한 가지 가능한 해결책은 생성자가 아닌 설정자가 구성하도록 일부 클래스의 소스 코드를 편집하는 것입니다. </span><br><span class="line">또는 생성자 주입을 피하고 setter 주입 만 사용하십시오. </span><br><span class="line">즉, 권장되지는 않지만 setter 주입을 사용하여 순환 종속성을 구성 할 수 있습니다.</span><br><span class="line"></span><br><span class="line">원형 의존성이없는 전형적인 경우와 달리, 빈 A와 빈 B 사이의 순환 종속성은 완전히 초기화되기 전에 빈 중 하나가 다른 인스턴스에 주입되도록합니다 (고전적인 닭고기 및 계란 시나리오).</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>일반적으로 Spring이 올바른 일을 할 수 있다고 믿을 수 있습니다.<br>컨테이너가 로드 될 때 존재하지 않는 bean에 대한 참조 및 순환 종속성과 같은 구성 문제점을 감지합니다.<br>Spring은 속성을 설정하고 빈이 실제로 생성 될 때 가능한 한 늦게 의존성을 해결합니다.<br>이것은 올바르게로드 된 Spring 컨테이너가 나중에 해당 객체 또는 그 의존성 중 하나를 생성하는 데 문제가있는 경우 객체를 요청할 때 예외를 생성 할 수 있음을 의미합니다.<br>예를 들어, bean은 누락되었거나 유효하지 않은 결과로 예외를 throw합니다.<br>재산. 잠재적으로 일부 구성 문제의 가시성이 지연되는 이유는 다음과 같습니다.<br>ApplicationContext구현은 기본적으로 싱글 톤 빈을 미리 인스턴스화합니다.<br>이 bean이 실제로 필요하기 전에 이들을 작성하기 위해 사전에 시간과 메모리를 필요로하며 ApplicationContext 나중에 작성하지 않고 작성 될 때 구성 문제점을 발견하게 됩니다.<br>싱글 톤 Bean이 미리 인스턴스화되기보다는 느리게 초기화되도록이 기본 동작을 무시할 수 있습니다.</p>
<p>순환 종속성이없는 경우, 하나 이상의 협업 bean이 종속 bean에 주입 될 때, 각 협업 bean은 종속 bean에 주입되기 전에 완전히 구성됩니다.<br>즉, bean A가 bean B에 의존성을 가지면 Spring IoC 컨테이너는 bean A에 setter 메소드를 호출하기 전에 bean B를 완전히 구성합니다.<br>즉, bean은 인스턴스화됩니다 (사전에 인스턴스화 된 singleton이 아닌 경우) ), 그 종속성이 설정되고, 관련 라이프 사이클 메소드 (예 : 구성된 init 메소드 또는 InitializingBean 콜백 메소드 )가 호출됩니다.</p>
<h6 id="의존성-삽입의-예"><a href="#의존성-삽입의-예" class="headerlink" title="의존성 삽입의 예"></a>의존성 삽입의 예</h6><p>다음 예제에서는 setter 기반 DI에 XML 기반 구성 메타 데이터를 사용합니다.<br>Spring XML 설정 파일의 작은 부분은 다음과 같이 몇 가지 bean 정의를 지정한다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>다음 예제는 해당 ExampleBean 클래스를 보여줍니다 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntegerProperty</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>앞의 예제에서 setter는 XML 파일에 지정된 속성과 일치하도록 선언됩니다. </p>
<p>다음 예제에서는 생성자 기반 DI를 사용합니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>다음 예제는 해당 ExampleBean 클래스를 보여줍니다 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = anotherBean;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = yetAnotherBean;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Bean 정의에 지정된 생성자 인수는의 ExampleBean 생성자에 대한 인수로 사용됩니다 .</p>
<p>이제 생성자를 사용하는 대신 Spring이 static 객체의 인스턴스를 반환하는 팩토리 메소드를 호출하도록 지시받는이 예제의 변형을 고려해보십시오 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>다음 예제는 해당 ExampleBean 클래스 를 보여줍니다 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a private constructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ExampleBean</span><span class="params">(...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></span><br><span class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></span><br><span class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title function_">createInstance</span> <span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExampleBean</span> <span class="variable">eb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleBean</span> (...);</span><br><span class="line">        <span class="comment">// some other operations...</span></span><br><span class="line">        <span class="keyword">return</span> eb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static팩토리 메소드 에 대한 인수 <constructor-arg>는 실제로 생성자가 사용 된 것과 완전히 동일한 요소 에 의해 제공 됩니다.<br>팩토리 메소드가 리턴하는 클래스의 유형은 팩토리 메소드를 포함하는 클래스와 동일한 유형 일 필요는 없습니다 static(이 예에서는 동일 함).<br>인스턴스 (비 정적) 팩토리 메소드는 본질적으로 동일한 방식으로 사용할 수 있습니다 (factory-bean속성 대신 속성을 사용 class하는 것과는 별도).<br>따라서 여기서는 자세히 설명하지 않습니다.</constructor-arg></p>
<h4 id="종속성-및-구성-세부-정보"><a href="#종속성-및-구성-세부-정보" class="headerlink" title="종속성 및 구성 세부 정보"></a>종속성 및 구성 세부 정보</h4><p>이전 섹션 에서 언급했듯이 bean 속성 및 생성자 인수를 다른 관리 Bean (공동 작업자)에 대한 참조 또는 인라인으로 정의 된 값으로 정의 할 수 있습니다.<br>Spring의 XML 기반 구성 메타 데이터는 이 목적을 위해 요소 내부 <property>및 <constructor-arg>요소 내의 하위 요소 유형을 지원합니다.</constructor-arg></property></p>
<h5 id="Straight-Values-Primitives-Strings-and-so-on"><a href="#Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="Straight Values (Primitives, Strings, and so on)"></a>Straight Values (Primitives, Strings, and so on)</h5><p>요소 의 value속성은 <property>속성 또는 생성자 인수를 사람이 읽을 수있는 문자열 표현으로 지정합니다.<br>Spring의 변환 서비스 는이 값을 a String에서 실제 유형의 등록 정보 또는 인수 로 변환하는 데 사용됩니다.<br>다음 예제에서는 설정되는 다양한 값을 보여줍니다.</property></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>다음 예제에서는 보다 간결한 XML 구성을 위해 p- 네임 스페이스 를 사용합니다 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:driverClassName</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:username</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:password</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>위의 XML은보다 간결합니다.<br>그러나 Bean 정의를 만들 때 자동 속성 완성을 지원 하는 IDE (예 : IntelliJ IDEA 또는 Spring Tool Suite )를 사용하지 않는 한 오타가 디자인 시간이 아닌 런타임에 발견 됩니다.<br>이러한 IDE 지원을 적극 권장합니다.</p>
<p>다음과 같이 java.util.Properties 인스턴스를 구성 할 수도 있습니다 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mappings&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring 컨테이너는 JavaBeans 메커니즘 을 사용하여 <value>요소 내부의 텍스트를 java.util.Properties인스턴스 로 변환합니다 PropertyEditor.<br>이것은 멋진 지름길이며, Spring 팀이 속성 스타일 <value>보다 중첩 된 요소 의 사용을 선호하는 몇 가지 장소 중 하나 value입니다.</value></value></p>
<h6 id="idref요소"><a href="#idref요소" class="headerlink" title="idref요소"></a>idref요소</h6><p>이 idref요소는 id컨테이너에있는 다른 bean 의 (문자열 값 - 참조가 아닌) a <constructor-arg>또는 <property> 요소 에 전달하는 실수 방지 방법 일뿐 입니다.<br>다음 예제에서는 이를 사용하는 방법을 보여줍니다.</property></constructor-arg></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theClientBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>앞의 Bean 정의 스 니펫은 다음 스 니펫과 정확히 동일합니다 (런타임시).</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>첫 번째 형식은 두 번째 형식보다 바람직합니다.<br>idref태그를 사용하면 참조 된 명명 된 Bean이 실제로 존재하는 배포 시간에 컨테이너에서 유효성을 검사 할 수 있기 때문 입니다.<br>두 번째 변형에서, bean 의 targetName프로퍼티에 전달 된 값에 대한 검증은 수행되지 않는다 client.<br>오타는 client빈이 실제로 인스턴스화 될 때만 발견 될 수 있습니다 (치명적인 결과가 발생할 가능성이 높음).<br>IF client 는 빈입니다 프로토 타입 빈 컨테이너가 배포 된 후,이 오타 및 결과 예외은 오랫동안 발견 할 수있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">local온 속성 idref은 정기적 이상의 값을 제공하지 않기 때문에 요소는 더 이상, 4.0 콩 XSD에서 지원되지 않습니다 bean더 이상 참조. </span><br><span class="line">4.0 스키마로 업그레이드 할 때 기존 idref local참조를 변경하십시오 idref bean.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><idref>엘리먼트가 값을 갖게 되는 일반적인 장소 (최소한 스프링 2.0 이전 버전 에서)는 ProxyFactoryBean빈 정의 에서 AOP 인터셉터 의 설정에있다.<br><idref>인터셉터 이름을 지정할 때 요소를 사용 하면 인터셉터 ID의 철자가 잘못 쓰는 것을 방지 할 수 있습니다.</idref></idref></p>
<h6 id="다른-콩에-대한-언급-공동-작업자"><a href="#다른-콩에-대한-언급-공동-작업자" class="headerlink" title="다른 콩에 대한 언급 (공동 작업자)"></a>다른 콩에 대한 언급 (공동 작업자)</h6><p>ref요소는 내부 최종 요소 <constructor-arg>또는 <property> 정의 소자.<br>여기에서는 bean의 지정된 프라퍼티 값을 컨테이너가 관리하는 다른 bean (collaborator)에 대한 참조로 설정한다.<br>참조 된 bean은 특성이 설정 될 bean의 종속성이며 필요에 따라 특성이 설정되기 전에 필요에 따라 초기화됩니다.<br>공동 작업자가 싱글 톤 bean 인 경우 컨테이너에 의해 이미 초기화되었을 수 있습니다.<br>모든 참조는 궁극적으로 다른 객체에 대한 참조입니다. 범위 지정 및 검증하는 것은 당신이를 통해 다른 개체의 ID 또는 이름을 지정 여부에 따라 bean, local,또는 parent속성.</property></constructor-arg></p>
<p>태그 의 bean속성을 통해 대상 bean을 지정하는 <ref>것이 가장 일반적인 양식이며 동일한 XML 파일에 있는지 여부에 관계없이 동일한 컨테이너 또는 상위 컨테이너에있는 모든 bean에 대한 참조를 작성할 수 있습니다.<br>bean속성 의 값은 id대상 bean 의 속성과 같을 수도 있고 대상 bean의 name속성에있는 값 중 하나와 같을 수도 있습니다.<br>다음 예제에서는 ref요소 를 사용하는 방법을 보여줍니다 .</ref></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;someBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>parent속성을 통해 대상 bean을 지정하면 현재 컨테이너의 상위 컨테이너에있는 bean에 대한 참조가 작성됩니다.<br>parent 속성 의 값은 id대상 bean 의 속성 또는 대상 bean의 name속성에있는 값 중 하나 와 같을 수 있습니다 .<br>대상 bean은 현재 bean의 상위 컨테이너에 있어야합니다.<br>이 Bean 참조 변종은 주로 컨테이너의 계층 구조가 있고 상위 Bean과 동일한 이름을 가진 프록시를 사용하여 상위 컨테이너의 기존 Bean을 래핑하려는 경우에 사용해야합니다.<br>다음 목록은 parent속성 을 사용하는 방법을 보여줍니다 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- in the parent context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.SimpleAccountService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> &lt;!<span class="attr">--</span> <span class="attr">bean</span> <span class="attr">name</span> <span class="attr">is</span> <span class="attr">the</span> <span class="attr">same</span> <span class="attr">as</span> <span class="attr">the</span> <span class="attr">parent</span> <span class="attr">bean</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">&quot;accountService&quot;</span>/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local온 속성 ref은 정기적 이상의 값을 제공하지 않기 때문에 요소는 더 이상, </span><br><span class="line">4.0 콩 XSD에서 지원되지 않습니다 bean더 이상 참조. 4.0 스키마로 업그레이드 할 때 기존 ref local참조를 변경하십시오 ref bean.</span><br></pre></td></tr></table></figure>
<h5 id="내부-콩"><a href="#내부-콩" class="headerlink" title="내부 콩"></a>내부 콩</h5><p><bean>내부 소자 <property>또는 <constructor-arg>다음의 예와 같이, 요소, 내부 빈을 정의한다 :</constructor-arg></property></bean></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Fiona Apple&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>내부 bean 정의에는 정의 된 ID 또는 이름이 필요하지 않습니다.<br>지정된 경우 컨테이너는 식별자와 같은 값을 사용하지 않습니다.<br>scope내부 bean은 항상 익명이며 항상 외부 bean으로 작성되기 때문에 컨테이너는 작성시 플래그를 무시합니다.<br>독립적으로 내부 bean에 액세스하거나 내부 bean을 포함하는 bean 이외의 협업 bean에 주입 할 수 없습니다.</p>
<p>예를 들어 싱글 톤 빈에 포함 된 요청 범위의 내부 빈에 대해 사용자 정의 범위에서 파괴 콜백을 수신 할 수 있습니다.<br>내부 bean 인스턴스의 생성은 포함하는 Bean에 연결되지만 destroy 콜백은 요청 범위의 수명주기에 참여하게합니다.<br>이것은 일반적인 시나리오는 아닙니다.<br>내부 빈은 일반적으로 포함 빈의 범위를 단순히 공유합니다.</p>
<h5 id="컬렉션"><a href="#컬렉션" class="headerlink" title="컬렉션"></a>컬렉션</h5><p><list>, <set>, <map>, 및 <props>요소가 자바의 특성과 인수 설정 Collection유형을 List, Set, Map,와 Properties, 각각 나타낸다.<br>다음 예제에서는이를 사용하는 방법을 보여줍니다.</props></map></set></list></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;moreComplexObject&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;development&quot;</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;an entry&quot;</span> <span class="attr">value</span>=<span class="string">&quot;just some string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;a ref&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;myDataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someSet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>맵 키 또는 값 또는 설정 값의 값은 다음 요소 중 하나 일 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>

<h6 id="컬렉션-병합"><a href="#컬렉션-병합" class="headerlink" title="컬렉션 병합"></a>컬렉션 병합</h6><p>Spring 컨테이너는 또한 병합 컬렉션을 지원한다.<br>응용 프로그램 개발자는 부모를 정의 할 수 있습니다 <list>, <map>, <set>또는 <props>요소와 자식이 <list>, <map>, <set>또는 <props>요소는 상속과 부모 컬렉션 값을 대체합니다.<br>즉, 하위 컬렉션의 값은 상위 컬렉션에 지정된 값을 재정의하는 하위 컬렉션 요소를 사용하여 상위 및 하위 컬렉션의 요소를 병합 한 결과입니다.</props></set></map></list></props></set></map></list></p>
<p>병합에 대한이 절에서는 부모 - 자식 빈 메커니즘에 대해 설명합니다.<br>부모 bean bean 정의에 익숙하지 않은 독자는 계속하기 전에 관련 섹션 을 읽을 수 있습니다 .</p>
<p>다음 예제에서는 컬렉션 병합을 보여줍니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sales&quot;</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bean 정의 의 프로퍼티 요소에 merge&#x3D;true속성 의 사용을 주목하라.<br>때 콩이 해결하고 컨테이너에 의해 인스턴스화, 결과 인스턴스는이 아이의 병합의 결과가 포함되어 수집 부모와 수집을 수집.<br>다음 목록은 결과를 보여줍니다.<props>adminEmails child child adminEmails Properties adminEmails adminEmails</props></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">administrator=administrator@example.com </span><br><span class="line">sales=sales@example.com </span><br><span class="line">support=support@example.co.uk</span><br></pre></td></tr></table></figure>
<p>하위 Properties컬렉션의 값 집합은 부모의 모든 속성 요소를 상속 <props>하며 하위 값의 값 support은 상위 컬렉션 의 값보다 우선합니다.</props></p>
<p>이 병합 동작은 유사하게 적용 <list>, <map>및 <set> 수집 유형.<br><list>요소 의 특정 경우 ,] List렉션 유형 과 연관된 시맨틱 (즉, ordered 값 콜렉션의 개념 )이 유지 보수됩니다.<br>부모의 값은 모든 자식 목록의 값 앞에옵니다. Set 및 Map 의 경우  Properties수집 유형, 어떤 순서는 존재하지 않는다.<br>따라서, 어떠한 순서 의미 연관된 기초 콜렉션 유형 효과없는 Map, Set그리고 Properties용기 내부에서 사용하는 구현의 유형.</list></set></map></list></p>
<h6 id="컬렉션-병합의-제한-사항"><a href="#컬렉션-병합의-제한-사항" class="headerlink" title="컬렉션 병합의 제한 사항"></a>컬렉션 병합의 제한 사항</h6><p>다른 컬렉션 유형 (예 : a Map및 a List)을 병합 할 수 없습니다.<br>그렇게하려고 시도하면 적절한 조치 Exception가 취해집니다.<br>merge 속성은 낮은, 상속, 자녀의 정의에 지정해야합니다.<br>merge 상위 콜렉션 정의에 속성을 지정하는 것은 불필요하며 원하는 병합을 초래하지 않습니다.</p>
<h6 id="강력한-형식의-컬렉션"><a href="#강력한-형식의-컬렉션" class="headerlink" title="강력한 형식의 컬렉션"></a>강력한 형식의 컬렉션</h6><p>Java 5에서 제네릭 형식을 도입하면 강력하게 형식화 된 컬렉션을 사용할 수 있습니다.<br>즉, Collection(예를 들어) String요소 만 포함 할 수 있는 형식 을 선언 할 수 있습니다.<br>Spring에 의존성 삽입 (strong-type-in) Collection을 bean에 삽입하면, Spring의 타입 변환 지원을 이용하여 강력한 타입의 Collection 인스턴스 의 요소가.<br>ini 에 추가되기 전에 적절한 유형으로 변환됩니다 Collection. 다음 Java 클래스 및 Bean 정의는이를 수행하는 방법을 보여줍니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;something&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.SomeClass&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accounts&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9.99&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.75&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;six&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.99&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>빈 의 accounts특성이 something주입을 위해 준비되면 강하게 유형화 된 요소 유형에 대한 제네릭 정보는 Map&lt;String, Float&gt;리플렉션을 통해 사용할 수 있습니다.<br>따라서 Spring의 타입 변환 인프라는 다양한 값 요소를 유형으로 인식 Float하고 문자열 값 ( 9.99, 2.75, 및 3.99)을 실제 Float유형 으로 변환 합니다.</p>
<h5 id="Null-및-빈-문자열-값"><a href="#Null-및-빈-문자열-값" class="headerlink" title="Null 및 빈 문자열 값"></a>Null 및 빈 문자열 값</h5><p>Spring은 프로퍼티 등의 빈 인자를 빈 것으로 취급한다 Strings.<br>다음 XML 기반 구성 메타 데이터 조각은 email속성을 빈 String값 (“”)으로 설정합니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>앞의 예제는 다음 Java 코드와 동일합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exampleBean.setEmail(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><null>소자 핸들 null값. 다음 목록은 예제를 보여줍니다.</null></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>앞의 구성은 다음 Java 코드와 동일합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="p-namespace를-사용한-XML-바로-가기"><a href="#p-namespace를-사용한-XML-바로-가기" class="headerlink" title="p-namespace를 사용한 XML 바로 가기"></a>p-namespace를 사용한 XML 바로 가기</h5><p>p-namespace를 사용하면 bean중첩 된 <property>요소 대신 요소의 속성 을 사용하여 빈을 공동 작업하는 속성 값을 설명하거나 둘 다를 설명 할 수 있습니다.</property></p>
<p>Spring은 XML 스키마 정의를 기반으로하는 네임 스페이스로 확장 가능한 구성 형식 을 지원합니다.<br>beans이 장에서 설명 하는 구성 형식은 XML 스키마 문서에 정의되어 있습니다.<br>그러나 p-namespace는 XSD 파일에 정의되어 있지 않으며 Spring의 핵심에만 존재합니다.</p>
<p>다음 예제에서는 두 개의 XML 코드 조각을 보여줍니다 (첫 번째 코드는 표준 XML 형식을 사용하고 두 번째 코드는 p-namespace를 사용함).</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;someone@somewhere.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;p-namespace&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:email</span>=<span class="string">&quot;someone@somewhere.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>이 예는 emailbean 정의에서 호출 된 p-namespace의 속성을 보여줍니다.<br>이것은 Spring에게 프라퍼티 선언을 포함하도록 지시한다.<br>앞서 언급했듯이 p-namespace에는 스키마 정의가 없으므로 속성 이름에 속성 이름을 설정할 수 있습니다.</p>
<p>이 다음 예제는 다른 bean에 대한 참조를 갖는 두 개의 bean 정의를 추가로 포함합니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John Doe&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spouse&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-modern&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:name</span>=<span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:spouse-ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;jane&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jane Doe&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>이 예제는 p-namespace를 사용하는 속성 값뿐만 아니라 속성 형식을 선언하는 특수 형식을 사용합니다.<br>첫 번째 bean 정의가 bean <property name="spouse" ref="jane">에서 bean john으로 참조를 만드는 데 사용되는 반면,<br>jane두 번째 bean 정의는 p:spouse-ref&#x3D;”jane”똑같은 일을하는 속성으로 사용 됩니다.<br>이 경우 spouse는 프로퍼티 이름이며, -ref파트는 이것이 곧은 값이 아니라 다른 빈에 대한 참조임을 나타냅니다.</property></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p- 네임 스페이스는 표준 XML 형식만큼 유연하지 않습니다. </span><br><span class="line">예를 들어, 속성 참조를 선언하는 형식은 끝나는 속성과 충돌 Ref하지만 표준 XML 형식은 끝나지 않습니다. </span><br><span class="line">세 가지 방법을 동시에 사용하는 XML 문서를 생성하지 않으려면 사용자의 접근 방식을 신중하게 선택하고 이를 팀 구성원에게 알리는 것이 좋습니다.</span><br></pre></td></tr></table></figure>

<h5 id="c-namespace를-사용한-XML-바로-가기"><a href="#c-namespace를-사용한-XML-바로-가기" class="headerlink" title="c-namespace를 사용한 XML 바로 가기"></a>c-namespace를 사용한 XML 바로 가기</h5><p>p-namespace를 가진 XML Shortcut과 유사하게, Spring 3.1에서 소개 된 c-namespace는 중첩 된 constructor-arg요소 보다는 생성자의 인자를 설정하기위한 인라인 속성을 허용 합니다.</p>
<p>다음 예제에서는 c:네임 스페이스를 사용하여 from Constructor 기반 Dependency Injection 과 동일한 작업을 수행합니다 .</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- traditional declaration with optional argument names --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;thingTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;thingThree&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanThree&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;something@somewhere.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- c-namespace declaration with argument names --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span> <span class="attr">c:thingTwo-ref</span>=<span class="string">&quot;beanTwo&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">c:thingThree-ref</span>=<span class="string">&quot;beanThree&quot;</span> <span class="attr">c:email</span>=<span class="string">&quot;something@somewhere.com&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>c:네임 스페이스는 같은 규칙을 사용 p:하나 (뒤에 -ref자신의 이름으로 생성자 인수를 설정하기위한 빈 참조)입니다.<br>마찬가지로 XSD 스키마 (Spring 코어 내부에 있음)에 정의되어 있지 않더라도 XML 파일에서 선언해야합니다.</p>
<p>드문 경우로 생성자 인수 이름을 사용할 수없는 경우 (일반적으로 바이트 코드가 디버깅 정보없이 컴파일 된 경우) 다음과 같이 대체 색인을 인수로 사용할 수 있습니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span> <span class="attr">c:_0-ref</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;beanThree&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_2</span>=<span class="string">&quot;something@somewhere.com&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XML 문법 때문에 _XML 속성 이름은 숫자로 시작될 수 없으므로 (일부 IDE에서 허용되지만) 맨 앞의 존재를 필요로합니다. </span><br><span class="line">대응하는 인덱스 표기법은 &lt;constructor-arg&gt;엘리먼트에 대해서도 이용 가능 하지만 일반적으로 평범한 선언 순서가 보통 충분하기 때문에 일반적으로 사용되지 않는다.</span><br></pre></td></tr></table></figure>

<p>실제로는 생성자 확인 메커니즘 이 인수 매칭에 매우 효율적이므로 꼭 필요하지 않으면 구성을 통해 이름 표기법을 사용하는 것이 좋습니다.</p>
<h5 id="복합-속성-이름"><a href="#복합-속성-이름" class="headerlink" title="복합 속성 이름"></a>복합 속성 이름</h5><p>Bean 특성을 설정할 때 최종 특성 이름을 제외한 경로의 모든 구성 요소가 아닌 한 복합 또는 중첩 된 특성 이름을 사용할 수 있습니다 null. 다음 bean 정의를 고려하십시오.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;something&quot;</span> <span class="attr">class</span>=<span class="string">&quot;things.ThingOne&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fred.bob.sammy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>something빈은 보유 fred갖는 속성 bob갖는 속성, sammy 속성 및 그 마지막 sammy속성의 값으로 설정되고있다 123. 이것이 가능하기 위해서는, fred재산 something과 bob재산 fred이 아니어야 null빈 후에는 구성된다.<br>그렇지 않으면 a NullPointerException가 발생합니다.</p>
<h4 id="depends-on-사용"><a href="#depends-on-사용" class="headerlink" title="depends-on 사용"></a>depends-on 사용</h4><p>빈이 다른 bean의 종속성이라면, 보통 한 bean이 다른 bean의 특성으로 설정됨을 의미합니다.<br>일반적으로 XML 기반 구성 메타 데이터 의 <ref> 요소 로 이를 수행합니다 .<br>그러나 때로 콩 간의 의존성은 덜 직접적입니다.<br>예를 들어 데이터베이스 드라이버 등록과 같이 클래스의 정적 초기화 프로그램을 트리거해야하는 경우를들 수 있습니다.<br>depends-on이 요소를 사용하여 bean이 초기화되기 전에 명시 적으로 하나 이상의 빈을 강제 할 수 속성을 초기화 할 수 있습니다.<br>다음 예제는 depends-on속성을 사용하여 단일 bean에 대한 종속성을 표현합니다.</ref></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>여러 bean에 대한 종속성을 표현하려면, depends-on속성 값으로 쉼표, 공백 및 세미콜론이 유효한 구분 기호 인 bean 이름 목록을 제공 하십시오.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이 depends-on속성은 초기화 시간 종속성과 싱글 톤 bean 의 경우 에만 해당 파괴 시간 종속성을 모두 지정할 수 있습니다. </span><br><span class="line">depends-on주어진 빈과 의 관계 를 정의하는 의존 빈은 주어진 빈 자체가 파괴되기 전에 먼저 파괴된다. </span><br><span class="line">따라서 depends-on종료 순서를 제어 할 수도 있습니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="게으른-초기화-된-빈"><a href="#게으른-초기화-된-빈" class="headerlink" title="게으른 초기화 된 빈"></a>게으른 초기화 된 빈</h4><p>기본적으로 ApplicationContext구현 은 초기화 프로세스의 일부로 모든 싱글 톤 Bean을 열심히 만들고 구성합니다.<br>일반적으로 구성 또는 주변 환경의 오류가 즉시 발견되기 때문에이 사전 인스턴스화가 바람직합니다.<br>이는 수 시간 또는 며칠 후가 아니라 즉시 발견됩니다.<br>이 동작이 바람직하지 않은 경우, bean 정의를 lazy-initialized로 표시하여 싱글 톤 bean의 사전 인스턴스화를 방지 할 수 있습니다.<br>lazy-initialized Bean은 Bean이 시작될 때가 아니라 Bean 인스턴스가 처음 요청 될 때 Bean 인스턴스를 생성하도록 IoC 컨테이너에 지시한다.</p>
<p>XML에서이 동작은 다음 예제와 같이 요소 의 lazy-init특성에 의해 제어됩니다 <bean>.</bean></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>앞의 설정이 an ApplicationContext에 의해 소비 될 때 , lazybean은 ApplicationContext시작될 때 열심히 pre-instantiated되지 않지만,<br>not.lazybean은 열성적으로 pre-instantiated된다.</p>
<p>그러나 지연 초기화 된 bean이 지연 초기화되지 않은 singleton bean의 종속성 일 때,<br>시작시에 lazy 초기화 된 bean을 ApplicationContext생성합니다.<br>왜냐하면 싱글 톤의 종속성을 만족시켜야하기 때문입니다.<br>lazy-initialised bean은 lazy-initialized가 아닌 다른 곳에서 singleton bean으로 주입된다.</p>
<p>다음 예는 요소 의 default-lazy-init속성을 사용하여 컨테이너 수준에서 지연 초기화를 제어 할 수도 있습니다 <beans>.</beans></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Autowiring-Collaborators"><a href="#Autowiring-Collaborators" class="headerlink" title="Autowiring Collaborators"></a>Autowiring Collaborators</h4><p>Spring 컨테이너는 협력 빈들 사이의 관계를 자동 연결 (autowire) 할 수있다.<br>Spring이 bean의 내용을 검사하여 공동 작업자 (다른 bean)를 자동으로 해결하도록 할 수있다 ApplicationContext.<br>Autowiring에는 다음과 같은 장점이 있습니다.</p>
<ul>
<li><p>Autowiring은 프로퍼티 나 생성자의 인자를 지정할 필요성을 크게 줄여줍니다.<br>(이 장의 다른 곳에서 논의 된 bean 템플릿과 같은 다른 메커니즘 도이 점에서 중요합니다.)</p>
</li>
<li><p>Autowiring은 객체가 진화하면서 구성을 업데이트 할 수 있습니다.<br>예를 들어 클래스에 종속성을 추가해야하는 경우 구성을 수정할 필요없이 해당 종속성을 자동으로 충족시킬 수 있습니다.<br>따라서 autowiring은 코드베이스가보다 안정적 일 때 명시 적 배선으로 전환하는 옵션을 무효화하지 않고 개발 중에 특히 유용 할 수 있습니다.</p>
</li>
</ul>
<p>XML 기반의 설정 메타 데이터 ( Dependency Injection 참조 )를 사용할 autowire때, <bean>엘리먼트 의 속성을 사용하여 Bean 정의에 autowire 모드를 지정할 수 있다.<br>autowiring 기능에는 네 가지 모드가 있습니다.<br>빈마다 autowiring을 지정하면 자동 줄 바꿈을 선택할 수 있습니다.<br>다음 표에서는 네 가지 autowiring 모드에 대해 설명합니다.</bean></p>
<p>자동 배선 모드</p>
<ul>
<li><p>no : (기본값) autowiring 없음.<br>빈 참조는 ref요소 로 정의해야합니다 .<br>공동 작업자를 명시 적으로 지정하면 제어력과 명확성이 높아지기 때문에 대규모 배포에서는 기본 설정을 변경하지 않는 것이 좋습니다.<br>어느 정도까지는 시스템의 구조를 문서화합니다.</p>
</li>
<li><p>byName : 속성 이름에 의한 자동 연결.<br>Spring은 autowired 할 필요가있는 프라퍼티와 같은 이름의 bean을 찾는다.<br>예를 들어 bean 정의가 이름으로 autowire로 설정되고 master속성 이 포함되어있는 경우 (즉, setMaster(..)메소드 가있는 경우 )<br>Spring은 명명 된 bean 정의를 찾고 master이를 사용하여 속성을 설정합니다.</p>
</li>
<li><p>byType : 속성 유형의 하나의 bean이 컨테이너에 존재하는 경우 속성을 자동 종료 할 수있게합니다.<br>둘 이상이 존재하면 치명적인 예외가 발생합니다. 이는 byType해당 bean에 대해 자동 와이어 링을 사용할 수 없음을 나타냅니다 .<br>일치하는 bean이 없으면 아무 것도 _ 생하지 않습니다 (특성이 설정되지 않음).</p>
</li>
<li><p>constructor : byTypeconstructor 인수 와 비슷하지만 적용됩니다. 컨테이너에 생성자 인수 유형의 Bean이 정확히 하나도 없으면 심각한 오류가 발생합니다.</p>
</li>
</ul>
<p>함께 byType또는 constructor를 autowiring 모드, 당신은 배열 및 입력 컬렉션을 연결할 수 있습니다.<br>이 경우 예상되는 유형과 일치하는 컨테이너 내의 모든 autowire 후보가 종속성을 충족시키기 위해 제공됩니다.<br>Map예상되는 키 유형이이면 강력한 유형의 인스턴스를 자동 배선 할 수 있습니다 String.<br>autowired Map 인스턴스의 값은 예상되는 유형과 일치하는 모든 bean 인스턴스로 구성되며 Map인스턴스의 키에는 해당 bean 이름이 포함됩니다.</p>
<h5 id="자동-배선의-한계와-단점"><a href="#자동-배선의-한계와-단점" class="headerlink" title="자동 배선의 한계와 단점"></a>자동 배선의 한계와 단점</h5><p>자동 와이어 링은 프로젝트 전체에서 일관되게 사용될 때 가장 잘 작동합니다.<br>autowiring이 일반적으로 사용되지 않는다면 개발자가 하나 또는 두 개의 bean 정의만을 연결하는 것을 혼란스럽게 할 수 있습니다.</p>
<p>autowiring의 한계와 단점을 고려하십시오.</p>
<ul>
<li><p>명시 적 종속성 property및 constructor-arg설정은 항상 autowiring보다 우선합니다.<br>프리미티브 Strings,, 및 Classes(및 이러한 간단한 속성의 배열)과 같은 간단한 속성을 autowire 수 없습니다.<br>이 제한은 디자인에 의한 것입니다.</p>
</li>
<li><p>자동 배선은 명시 적 배선보다 정확하지 않습니다.<br>이전 표에서 언급했듯이, Spring은 예기치 않은 결과를 초래할 수도있는 애매한 경우에 추측을 피하기 위해주의를 기울였습니다.<br>Spring 관리 객체 간의 관계는 더 이상 명시 적으로 문서화되지 않습니다.</p>
</li>
<li><p>Spring 컨테이너에서 문서를 생성 할 수있는 도구에서는 와이어 링 정보를 사용할 수 없습니다.</p>
</li>
<li><p>컨테이너 내의 여러 bean 정의는 autowired 될 setter 메소드 또는 생성자 인수에 의해 지정된 유형과 일치 할 수 있습니다.<br>배열, 컬렉션 또는 Map인스턴스의 경우 반드시 문제는 아닙니다.<br>그러나 단일 값을 예상하는 종속성의 경우이 모호성은 임의로 해결되지 않습니다.<br>고유 한 Bean 정의가 없으면 예외가 발생합니다.</p>
</li>
</ul>
<p>후자의 시나리오에는 몇 가지 옵션이 있습니다.</p>
<ul>
<li><p>명백한 배선을 위해 자동 배선을 포기합니다.</p>
</li>
<li><p>그 설정하여 빈 정의를 autowiring에 피 autowire-candidate에 속성을 false에서 설명한대로 다음 섹션 .</p>
</li>
<li><p>요소 의 primary속성을 로 설정하여 단일 bean 정의를 기본 후보로 지정하십시오 .<bean>true</bean></p>
</li>
<li><p>Annotation 기반 컨테이너 구성에 설명 된대로 주석 기반 구성에서 사용 가능한보다 세부적인 컨트롤을 구현하십시오 .</p>
</li>
</ul>
<h5 id="자동-와이어-링에서-Bean-제외"><a href="#자동-와이어-링에서-Bean-제외" class="headerlink" title="자동 와이어 링에서 Bean 제외"></a>자동 와이어 링에서 Bean 제외</h5><p>Bean별로, 자동 와이어 링에서 Bean을 제외 할 수 있습니다.<br>Spring의 XML 포맷에서, 엘리먼트 의 autowire-candidate애트리뷰트를로 설정한다.<br>컨테이너는 autowiring 기반 구조 (예 :와 같은 어노테이션 스타일 설정 포함)에서 특정 bean 정의를 사용할 수 없도록 만듭니다 .<bean>false@Autowired</bean></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">이 autowire-candidate속성은 유형 기반 자동 와이어 링에만 영향을 주도록 설계되었습니다. </span><br><span class="line">지정된 bean이 autowire 후보로 표시되지 않아도 해결되는 이름 별 명시 적 참조에는 영향을주지 않습니다. </span><br><span class="line">결과적으로, 이름에 따른 autowiring은 이름이 일치하는 경우에도 bean을 주입합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>또한 bean 이름에 대한 패턴 일치를 기반으로 autowire 후보를 제한 할 수 있습니다.<br>최상위 <beans>요소는 default-autowire-candidates속성 내에 하나 이상의 패턴을 허용 합니다.<br>예를 들어, autowire 후보 상태를 이름이로 끝나는 bean으로 제한하려면 Repository값을 제공하십시오 *Repository.<br>여러 패턴을 제공하려면 쉼표로 구분 된 목록으로 정의하십시오. autowire-candidate속성의 명시 적 값 true또는 false빈 정의의에 대한 값은 항상 우선합니다.<br>이러한 bean의 경우 패턴 일치 규칙이 적용되지 않습니다.</beans></p>
<p>이 기술은 autowiring을 통해 다른 bean에 삽입하고 싶지 않은 bean에 유용합니다.<br>autowiring을 사용하여 제외 된 bean 자체를 구성 할 수 없다는 것을 의미하지는 않습니다.<br>오히려 빈 자체는 다른 빈을 autowiring하기위한 후보가 아닙니다.</p>
<h4 id="방법-주입"><a href="#방법-주입" class="headerlink" title="방법 주입"></a>방법 주입</h4><p>대부분의 응용 프로그램 시나리오에서 컨테이너의 대부분의 bean은 singleton 입니다.<br>싱글 톤 빈이 다른 싱글 톤 빈과 협업해야하거나 비 - 싱글 톤 빈이 다른 비 싱글 톤 빈과 협업해야하는 경우 일반적으로 한 빈을 다른 빈의 프로퍼티로 정의하여 종속성을 처리합니다.<br>빈 수명주기가 다른 경우 문제가 발생합니다.<br>단일 톤 bean A가 비 A (프로토 타입) bean B를 A의 각 메소드 호출에서 사용할 필요가 있다고 가정하십시오.<br>컨테이너는 singleton bean A를 한 번만 작성하므로 등록 정보를 설정할 수있는 기회가 한 번만 있습니다.<br>컨테이너는 필요할 때마다 bean A에 bean B의 새 인스턴스를 제공 할 수 없습니다.</p>
<p>해결책은 통제의 반전을 막는 것입니다.<br>인터페이스 를 구현하여 bean A가 컨테이너 를 인식하게 할 수 있으며 ApplicationContextAware, bean A가 필요할 때마다 컨테이너에 대한 getBean(“B”)호출을 (일반적으로 새로운) bean B 인스턴스에 요청 함으로써 컨테이너를 호출 할 수 있습니다.<br>다음 예제에서는이 접근 방식을 보여줍니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></span><br><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring-API imports</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Map commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// notice the Spring API dependency!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applicationContext.getBean(<span class="string">&quot;command&quot;</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>비즈니스 코드가 스프링 프레임 워크를 인식하고 결합하기 때문에 앞의 내용은 바람직하지 않습니다.<br>Spring IoC 컨테이너의 다소 고급 기능인 메소드 삽입 (Method Injection)을 통해이 유스 케이스를 깔끔하게 처리 할 수있다.</p>
<p>이 블로그 엔트리 에서 Method Injection에 대한 동기를 더 읽을 수 있습니다 .</p>
<h5 id="조회-방법-삽입"><a href="#조회-방법-삽입" class="headerlink" title="조회 방법 삽입"></a>조회 방법 삽입</h5><p>조회 메소드 삽입은 컨테이너가 컨테이너 관리 빈의 메소드를 대체하고 컨테이너의 다른 명명 된 빈에 대한 조회 결과를 리턴하는 기능입니다.<br>룩업은 전형적으로 이전 섹션 에서 설명한 시나리오에서와 같이 프로토 타입 빈을 포함합니다.<br>Spring Framework는 CGLIB 라이브러리의 바이트 코드 생성을 사용하여 메소드를 재정의하는 서브 클래스를 동적으로 생성함으로써이 메소드 삽입을 구현합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">이 동적 서브 클래 싱이 작동하기 위해서는 Spring 빈 컨테이너 서브 클래스가 될 수없는 클래스 final와 재정의 될 메소드가 될 수 없다 final.</span><br><span class="line"></span><br><span class="line">abstract메소드가 있는 클래스를 유닛 테스트 하려면 클래스를 직접 서브 클래스 화하고 abstract메소드 의 스텁 구현을 제공해야 합니다.</span><br><span class="line"></span><br><span class="line">구체적인 방법은 구성 요소 스캐닝에도 필요하며, 구체적인 클래스를 선택해야합니다.</span><br><span class="line"></span><br><span class="line">또 다른 중요한 제한점은 팩토리 메소드에서는 조회 메소드가 작동하지 않으며, </span><br><span class="line">특히 @Bean구성 클래스의 메소드에서는 작동하지 않는다는 것입니다 .</span><br><span class="line">이 경우 컨테이너는 인스턴스 작성을 담당하지 않으므로 런타임에서 생성 된 서브 클래스를 작성할 수 없기 때문입니다 파리.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommandManager이전 코드 스 니펫 의 클래스 의 경우 Spring 컨테이너는 createCommand() 메서드 구현을 동적으로 재정의합니다.<br>CommandManager재 작업의 예와 같이 클래스는 Spring에 대한 의존성을 가지고 있지 않습니다</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>삽입 할 메소드 ( CommandManager이 경우) 가 들어있는 클라이언트 클래스 에서 주입 할 메소드에는 다음 형식의 서명이 필요합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>
<p>메소드가있는 abstract경우, 동적으로 생성 된 서브 클래스는 메소드를 구현합니다.<br>그렇지 않으면 동적으로 생성 된 하위 클래스가 원래 클래스에 정의 된 구체적인 메서드를 재정의합니다.<br>다음 예제를 고려하십시오.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myCommand&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;commandManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createCommand&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>식별 된 bean은 bean 의 새 인스턴스가 필요할 때마다 commandManager자체 createCommand()메소드 를 호출합니다 myCommand.<br>myCommand실제로 필요한 경우 빈을 프로토 타입으로 전개하는 데주의해야 합니다.<br>그것이 싱글 톤 (singleton) 이라면 myCommand 매번 동일한 빈 인스턴스 가 반환됩니다.</p>
<p>또는 주석 기반 구성 요소 모델 내 @Lookup에서 다음 예제와 같이 주석을 통해 조회 방법을 선언 할 수 있습니다 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup(&quot;myCommand&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>또는 관용적으로 보면, 조회 메소드의 선언 된 리턴 유형에 대해 해결되는 대상 bean에 의존 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>일반적으로 추상 주석 클래스가 기본적으로 무시되는 Spring의 컴포넌트 검색 규칙과 호환되도록 이러한 주석 첨부 조회 메소드를 구체적인 스텁 구현으로 선언해야합니다.<br>이 제한은 명시 적으로 등록되거나 명시 적으로 가져온 Bean 클래스에는 적용되지 않습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">다르게 범위가 지정된 대상 빈을 액세스하는 또 다른 방법은 ObjectFactory/ Provider주입 지점입니다. </span><br><span class="line">Scoped Bean을 종속성으로 참조하십시오.</span><br><span class="line"></span><br><span class="line">또한 ServiceLocatorFactoryBean( org.springframework.beans.factory.config패키지 안에) 유용 할 수 있습니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="임의-방식-대체"><a href="#임의-방식-대체" class="headerlink" title="임의 방식 대체"></a>임의 방식 대체</h5><p>룩업 메소드 삽입보다 덜 유용한 메소드 주입은 관리 빈의 임의의 메소드를 다른 메소드 구현으로 대체하는 기능입니다.<br>실제로이 기능이 필요할 때까지이 섹션의 나머지 부분은 건너 뛰어도됩니다.</p>
<p>XML 기반 구성 메타 데이터를 사용하면 replaced-method요소를 사용하여 배치 된 bean에 대해 기존 메소드 구현을 다른 것으로 대체 할 수 있습니다.<br>다음 클래스를 살펴 보겠습니다.<br>이 클래스에는 computeValue재정의 할 메소드 가 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValueCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">computeValue</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.beans.factory.support.MethodReplacer 인터페이스 를 구현하는 클래스 는 다음 예제와 같이 새 메서드 정의를 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * meant to be used to override the existing computeValue(String)</span></span><br><span class="line"><span class="comment"> * implementation in MyValueCalculator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title class_">MethodReplacer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>원래 클래스를 전개하고 메소드 대체를 지정하는 bean 정의는 다음 예제와 유사합니다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myValueCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">&quot;computeValue&quot;</span> <span class="attr">replacer</span>=<span class="string">&quot;replacementComputeValue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;replacementComputeValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><arg-type>요소 내의 하나 이상의 요소를 사용하여 <replaced-method> 재정의 할 메소드의 메소드 서명을 나타낼 수 있습니다.<br>인수에 대한 서명은 메소드가 오버로드되어 있고 클래스 내에 여러 변형이있는 경우에만 필요합니다.<br>편의상 인수의 유형 문자열은 완전한 유형의 이름의 부분 문자열 일 수 있습니다.<br>예를 들어, 모두 다음과 일치합니다 java.lang.String.</replaced-method></arg-type></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">String</span><br><span class="line">Str</span><br></pre></td></tr></table></figure>
<p>인수의 수는 각 가능한 선택을 구별하기에 충분하기 때문에이 바로 가기는 인수 유형과 일치하는 가장 짧은 문자열 만 입력하게하여 많은 입력을 절약 할 수 있습니다.</p>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">spring-framework-reference The IoC Container</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://spring.io/blog/2004/08/06/method-injection/">method-injection&#x2F;</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../tags/spring-framework/">spring framework</a><a class="post-meta__tags" href="../../../tags/core/">core</a><a class="post-meta__tags" href="../../../tags/The-IoC-Container/">The IoC Container</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../2019-05-20-cleancode_Concurrency/"><i class="fa fa-chevron-left">  </i><span>클린코드(Concurrency)</span></a></div><div class="next-post pull-right"><a href="../2019-05-17-spring-framework-Bean-Overview/"><span>spring framework The IoC Container</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://sejoung.github.io/2019/05/2019-05-17-spring-framework-Dependencies/';
  this.page.identifier = '2019/05/2019-05-17-spring-framework-Dependencies/';
  this.page.title = 'spring framework The IoC Container';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'kimsejoung' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://kimsejoung.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2023 By sejoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="../../../js/third-party/anime.min.js"></script><script src="../../../js/third-party/jquery.min.js"></script><script src="../../../js/third-party/jquery.fancybox.min.js"></script><script src="../../../js/third-party/velocity.min.js"></script><script src="../../../js/third-party/velocity.ui.min.js"></script><script src="../../../js/utils.js?version=1.7.0"></script><script src="../../../js/fancybox.js?version=1.7.0"></script><script src="../../../js/sidebar.js?version=1.7.0"></script><script src="../../../js/copy.js?version=1.7.0"></script><script src="../../../js/fireworks.js?version=1.7.0"></script><script src="../../../js/transition.js?version=1.7.0"></script><script src="../../../js/scroll.js?version=1.7.0"></script><script src="../../../js/head.js?version=1.7.0"></script><script src="../../../js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>