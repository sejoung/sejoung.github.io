<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JEP 425: Virtual Threads (Preview)"><meta name="keywords" content="jdk 19,JEP 425,Virtual Threads (Preview)"><meta name="author" content="sejoung"><meta name="copyright" content="sejoung"><title>JEP 425: Virtual Threads (Preview) | 폭간의 기술블로그</title><link rel="shortcut icon" href="../../../my-favicon.ico"><link rel="stylesheet" href="../../../css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4136060060870959"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NVRTGLD8RZ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NVRTGLD8RZ');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JEP-425-Virtual-Threads-Preview"><span class="toc-number">1.</span> <span class="toc-text">JEP 425: Virtual Threads (Preview)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">1.1.</span> <span class="toc-text">Summary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goals"><span class="toc-number">1.2.</span> <span class="toc-text">Goals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-Goals"><span class="toc-number">1.3.</span> <span class="toc-text">Non-Goals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-number">1.4.</span> <span class="toc-text">Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-thread-per-request-style-%EC%9A%94%EC%B2%AD%EB%8B%B9-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC"><span class="toc-number">1.4.1.</span> <span class="toc-text">The thread-per-request style (요청당 스레드 스타일)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Improving-scalability-with-the-asynchronous-style-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A1%9C-%ED%99%95%EC%9E%A5%EC%84%B1-%ED%96%A5%EC%83%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">Improving scalability with the asynchronous style (비동기 스타일로 확장성 향상)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preserving-the-thread-per-request-style-with-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A1%9C-%EC%9A%94%EC%B2%AD%EB%8B%B9-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%9C%A0%EC%A7%80"><span class="toc-number">1.4.3.</span> <span class="toc-text">Preserving the thread-per-request style with virtual threads (가상 스레드로 요청당 스레드 스타일 유지)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implications-of-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9D%98%EB%AF%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">Implications of virtual threads (가상 스레드의 의미)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Description"><span class="toc-number">1.5.</span> <span class="toc-text">Description</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-virtual-threads-vs-platform-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%8C%80-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%82%AC%EC%9A%A9"><span class="toc-number">1.5.1.</span> <span class="toc-text">Using virtual threads vs. platform threads (가상 스레드 대 플랫폼 스레드 사용)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-threads-are-a-preview-API-disabled-by-default-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%8A%94-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94%EB%90%9C-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0-API-%EC%9E%85%EB%8B%88%EB%8B%A4"><span class="toc-number">1.5.2.</span> <span class="toc-text">Virtual threads are a preview API, disabled by default (가상 스레드는 기본적으로 비활성화된 미리보기 API 입니다.)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Do-not-pool-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%ED%92%80%EB%A7%81%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%8C"><span class="toc-number">1.5.3.</span> <span class="toc-text">Do not pool virtual threads(가상 스레드를 풀링하지 않음)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observing-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EC%B0%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">Observing virtual threads(가상 스레드 관찰)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduling-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%98%88%EC%95%BD"><span class="toc-number">1.5.5.</span> <span class="toc-text">Scheduling virtual threads(가상 스레드 예약)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executing-virtual-threads-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%8B%A4%ED%96%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">Executing virtual threads(가상 스레드 실행)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-use-and-interaction-with-garbage-collection-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EB%B0%8F-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%88%98%EC%A7%91%EA%B3%BC%EC%9D%98-%EC%83%81%ED%98%B8-%EC%9E%91%EC%9A%A9"><span class="toc-number">1.5.7.</span> <span class="toc-text">Memory use and interaction with garbage collection(메모리 사용 및 가비지 수집과의 상호 작용)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Detailed-changes-%EC%84%B8%EB%B6%80-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD"><span class="toc-number">1.6.</span> <span class="toc-text">Detailed changes(세부 변경 사항)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Thread"><span class="toc-number">1.6.1.</span> <span class="toc-text">java.lang.Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-local-variables-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%A1%9C%EC%BB%AC-%EB%B3%80%EC%88%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">Thread-local variables(스레드 로컬 변수)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-concurrent"><span class="toc-number">1.6.3.</span> <span class="toc-text">java.util.concurrent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Networking"><span class="toc-number">1.6.4.</span> <span class="toc-text">Networking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-io"><span class="toc-number">1.6.5.</span> <span class="toc-text">java.io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Native-Interface-JNI"><span class="toc-number">1.6.6.</span> <span class="toc-text">Java Native Interface (JNI)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debugging"><span class="toc-number">1.6.7.</span> <span class="toc-text">Debugging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-Flight-Recorder-JFR"><span class="toc-number">1.6.8.</span> <span class="toc-text">JDK Flight Recorder (JFR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Management-Extensions-JMX"><span class="toc-number">1.6.9.</span> <span class="toc-text">Java Management Extensions (JMX)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-ThreadGroup"><span class="toc-number">1.6.10.</span> <span class="toc-text">java.lang.ThreadGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alternatives"><span class="toc-number">1.7.</span> <span class="toc-text">Alternatives</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing"><span class="toc-number">1.8.</span> <span class="toc-text">Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Risks-and-Assumptions"><span class="toc-number">1.9.</span> <span class="toc-text">Risks and Assumptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dependencies"><span class="toc-number">1.10.</span> <span class="toc-text">Dependencies</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EC%A1%B0"><span class="toc-number">2.</span> <span class="toc-text">참조</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/4936005?s=400&amp;u=a679b941fe377418e7e4efcf916c6a636d7178ee&amp;v=4"></div><div class="author-info__name text-center">sejoung</div><div class="author-info__description text-center">잘정리하자</div><div class="follow-button"><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/sejoung">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../archives"><span class="pull-left">Articles</span><span class="pull-right">870</span></a><a class="author-info-articles__tags article-meta" href="../../../tags"><span class="pull-left">Tags</span><span class="pull-right">916</span></a><a class="author-info-articles__categories article-meta" href="../../../categories"><span class="pull-left">Categories</span><span class="pull-right">82</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.naver.com/sanaes">naverblog</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.linkedin.com/in/sanaes/">linkedin</a><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.slideshare.net/sejoung">slideshare</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../index.html">폭간의 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/privacy">Privacy</a><a class="site-page" href="/about">About</a><a class="site-page" href="/contact">Contact</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">JEP 425: Virtual Threads (Preview)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="../../../categories/java/">java</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2023/04/2023-04-13-JEP_425/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="JEP-425-Virtual-Threads-Preview"><a href="#JEP-425-Virtual-Threads-Preview" class="headerlink" title="JEP 425: Virtual Threads (Preview)"></a>JEP 425: Virtual Threads (Preview)</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Java 플랫폼에 가상 스레드를 도입합니다.<br>가상 스레드는 처리량이 많은 동시 응용 프로그램을 작성, 유지 관리 및 관찰하는 노력을 크게 줄이는 경량 스레드입니다.<br>이것은 미리보기 API 입니다.</p>
<h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><ul>
<li>간단한 요청당 스레드 스타일로 작성된 서버 애플리케이션을 거의 최적의 하드웨어 활용으로 확장할 수 있습니다.</li>
<li>API를 사용하는 기존 코드를 활성화하여 java.lang.Thread최소한의 변경으로 가상 스레드를 채택합니다.</li>
<li>기존 JDK 도구를 사용하여 가상 스레드의 문제 해결, 디버깅 및 프로파일링을 쉽게 수행할 수 있습니다.</li>
</ul>
<h2 id="Non-Goals"><a href="#Non-Goals" class="headerlink" title="Non-Goals"></a>Non-Goals</h2><ul>
<li>전통적인 스레드 구현을 제거하거나 가상 스레드를 사용하도록 기존 애플리케이션을 자동으로 마이그레이션하는 것이 목표가 아닙니다.</li>
<li>Java의 기본 동시성 모델을 변경하는 것이 목표가 아닙니다.</li>
<li>Java 언어나 Java 라이브러리에서 새로운 데이터 병렬 구조를 제공하는 것이 목표가 아닙니다. Stream API는 대용량 데이터 세트를 병렬로 처리하는 데 선호되는 방법입니다.</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Java 개발자는 거의 30년 동안 동시 서버 응용 프로그램의 빌딩 블록으로 스레드에 의존해 왔습니다.<br>모든 메서드의 모든 명령문은 스레드 내에서 실행되며 Java는 다중 스레드이므로 한 번에 여러 스레드가 실행됩니다.<br>스레드는 Java의 동시성 단위입니다.이러한 다른 단위와 동시에 실행되는(거의 독립적인) 순차적 코드 조각입니다.<br>각 스레드는 로컬 변수를 저장하고 메서드 호출을 조정하는 스택과 상황이 잘못되었을 때 컨텍스트를 제공합니다.<br>동일한 스레드의 메서드에서 예외가 발생하고 포착되므로 개발자는 스레드의 스택 추적을 사용하여 무슨 일이 일어났는지 알아낼 수 있습니다.<br>스레드는 도구의 중심 개념이기도 합니다.<br>디버거는 스레드 메서드의 명령문을 단계별로 실행하고 프로파일러는 여러 스레드의 동작을 시각화하여 성능을 이해하는 데 도움을 줍니다.</p>
<h3 id="The-thread-per-request-style-요청당-스레드-스타일"><a href="#The-thread-per-request-style-요청당-스레드-스타일" class="headerlink" title="The thread-per-request style (요청당 스레드 스타일)"></a>The thread-per-request style (요청당 스레드 스타일)</h3><p>서버 응용 프로그램은 일반적으로 서로 독립적인 동시 사용자 요청을 처리하므로 응용 프로그램이 전체 기간 동안 해당 요청에 스레드를 전용하여 요청을 처리하는 것이 좋습니다.<br>이 요청당 스레드 스타일은 애플리케이션의 동시성 단위를 나타내기 위해 플랫폼의 동시성 단위를 사용하기 때문에 이해하기 쉽고, 프로그래밍하기 쉽고, 디버그 및 프로파일링하기 쉽습니다.</p>
<p>서버 응용 프로그램의 확장성은 대기 시간, 동시성 및 처리량과 관련된 Little의 법칙 에 따라 결정됩니다.<br>주어진 요청 처리 기간(즉, 대기 시간) 동안 응용 프로그램이 동시에 처리하는 요청 수(즉, 동시성)는 도착률(즉, 처리량)에 비례하여 증가합니다.<br>예를 들어 평균 대기 시간이 50ms인 애플리케이션이 10개의 요청을 동시에 처리하여 초당 200개의 요청 처리량을 달성한다고 가정합니다.<br>해당 애플리케이션이 초당 2000개의 요청 처리량으로 확장하려면 100개의 요청을 동시에 처리해야 합니다.<br>각 요청이 요청 기간 동안 스레드에서 처리되는 경우 애플리케이션이 이를 따라잡으려면 처리량이 증가함에 따라 스레드 수가 증가해야 합니다.</p>
<p>불행히도 사용 가능한 스레드의 수는 JDK가 운영 체제(OS) 스레드 주변의 래퍼로 스레드를 구현하기 때문에 제한됩니다.<br>OS 스레드는 비용이 많이 들기 때문에 스레드를 너무 많이 가질 수 없으므로 구현이 요청당 스레드 스타일에 적합하지 않습니다.<br>각 요청이 해당 기간 동안 스레드, 즉 OS 스레드를 사용하는 경우 CPU 또는 네트워크 연결과 같은 다른 리소스가 고갈되기 오래 전에 스레드 수가 제한 요소가 되는 경우가 많습니다.<br>JDK의 현재 스레드 구현은 애플리케이션의 처리량을 하드웨어가 지원할 수 있는 것보다 훨씬 낮은 수준으로 제한합니다.<br>이는 스레드가 풀링된 경우에도 발생합니다. 풀링은 새 스레드를 시작하는 높은 비용을 방지하는 데 도움이 되지만 총 스레드 수를 늘리지는 않기 때문입니다.</p>
<h3 id="Improving-scalability-with-the-asynchronous-style-비동기-스타일로-확장성-향상"><a href="#Improving-scalability-with-the-asynchronous-style-비동기-스타일로-확장성-향상" class="headerlink" title="Improving scalability with the asynchronous style (비동기 스타일로 확장성 향상)"></a>Improving scalability with the asynchronous style (비동기 스타일로 확장성 향상)</h3><p>하드웨어를 최대한 활용하고자 하는 일부 개발자는 스레드 공유 스타일을 선호하여 요청당 스레드 스타일을 포기했습니다.<br>하나의 스레드에서 처음부터 끝까지 요청을 처리하는 대신 요청 처리 코드는 스레드가 다른 요청을 처리할 수 있도록 I&#x2F;O 작업이 완료될 때까지 대기할 때 해당 스레드를 풀로 반환합니다.<br>코드가 I&#x2F;O를 기다릴 때가 아니라 계산을 수행할 때만 스레드를 유지하는 이 세분화된 스레드 공유는 많은 수의 스레드를 소비하지 않고도 많은 수의 동시 작업을 허용합니다.<br>이는 OS 스레드의 부족 으로 인한 처리량의 제한을 제거하지만 높은 비용이 듭니다.<br>I&#x2F;O 작업이 완료될 때까지 기다리지 않고 나중에 완료 신호를 콜백에 보내는 별도의 I&#x2F;O 메서드 집합을 사용하는 프로그래밍 스타일.<br>전용 스레드가 없으면 개발자는 요청 처리 논리를 일반적으로 람다 식으로 작성된 작은 단계로 분해한 다음 API를 사용하여 순차적 파이프라인으로 구성해야 합니다(예를 들어 CompletableFuture 또는 소위 “반응형” 프레임워크 참조 ) . ).<br>따라서 루프 및 블록과 같은 언어의 기본 순차 구성 연산자를 버립니다 try&#x2F;catch.</p>
<p>비동기 스타일에서는 요청의 각 단계가 다른 스레드에서 실행될 수 있으며 모든 스레드는 인터리브 방식으로 다른 요청에 속하는 단계를 실행합니다.<br>이는 프로그램 동작을 이해하는 데 깊은 영향을 미칩니다. 스택 추적은 사용 가능한 컨텍스트를 제공하지 않으며 디버거는 요청 처리 논리를 단계별로 실행할 수 없으며 프로파일러는 작업 비용을 호출자와 연결할 수 없습니다.<br>람다 식 구성은 짧은 파이프라인에서 데이터를 처리하기 위해 Java의 스트림 API를 사용할 때 관리할 수 있지만 애플리케이션의 모든 요청 처리 코드를 이 방식으로 작성해야 하는 경우 문제가 됩니다.<br>이 프로그래밍 스타일은 애플리케이션의 동시성 단위(비동기 파이프라인)가 더 이상 플랫폼의 동시성 단위가 아니기 때문에 Java 플랫폼과 상충됩니다.</p>
<h3 id="Preserving-the-thread-per-request-style-with-virtual-threads-가상-스레드로-요청당-스레드-스타일-유지"><a href="#Preserving-the-thread-per-request-style-with-virtual-threads-가상-스레드로-요청당-스레드-스타일-유지" class="headerlink" title="Preserving the thread-per-request style with virtual threads (가상 스레드로 요청당 스레드 스타일 유지)"></a>Preserving the thread-per-request style with virtual threads (가상 스레드로 요청당 스레드 스타일 유지)</h3><p>애플리케이션이 플랫폼과 조화를 이루면서 확장할 수 있도록 하려면 스레드를 보다 효율적으로 구현하여<br>요청당 스레드 스타일을 유지하기 위해 노력해야 스레드가 더 많아질 수 있습니다.<br>운영 체제는 다른 언어와 런타임이 다른 방식으로 스레드 스택을 사용하기 때문에 OS 스레드를 보다 효율적으로 구현할 수 없습니다.<br>그러나 Java 런타임이 OS 스레드에 대한 일대일 대응을 분리하는 방식으로 Java 스레드를 구현하는 것은 가능합니다.<br>운영 체제가 큰 가상 주소 공간을 제한된 양의 물리적 RAM에 매핑하여 메모리가 풍부한 것처럼 보이게 하는 것처럼<br>Java 런타임은 많은 수의 가상 스레드를 적은 수의 OS 스레드에 매핑하여 스레드가 많은 것처럼 보이게 할 수 있습니다.</p>
<p>가상 스레드는 특정 java.lang.ThreadOS 스레드에 연결되지 않은 인스턴스입니다.<br>대조적으로 플랫폼 스레드는 java.lang.Thread OS 스레드 주변의 얇은 래퍼로 전통적인 방식으로 구현된 인스턴스입니다.</p>
<p>요청당 스레드 스타일의 애플리케이션 코드는 전체 요청 기간 동안 가상 스레드에서 실행될 수 있지만<br>가상 스레드는 CPU에서 계산을 수행하는 동안에만 OS 스레드를 소비합니다. 결과는 투명하게 달성된다는 점을 제외하면 비동기식 스타일과 동일한 확장성입니다.<br>가상 스레드에서 실행 중인 코드가 java.*API, 런타임은 비차단 OS 호출을 수행하고 나중에 다시 시작할 수 있을 때까지<br>가상 스레드를 자동으로 일시 중단합니다. Java 개발자에게 가상 스레드는 생성 비용이 저렴하고 거의 무한대로 풍부한 스레드일 뿐입니다.<br>하드웨어 활용도는 최적에 가까워 높은 수준의 동시성과 결과적으로 높은 처리량을 허용하는 동시에 응용 프로그램은<br>Java 플랫폼 및 해당 도구의 다중 스레드 설계와 조화를 이룹니다.</p>
<h3 id="Implications-of-virtual-threads-가상-스레드의-의미"><a href="#Implications-of-virtual-threads-가상-스레드의-의미" class="headerlink" title="Implications of virtual threads (가상 스레드의 의미)"></a>Implications of virtual threads (가상 스레드의 의미)</h3><p>가상 스레드는 저렴하고 풍부하므로 풀링해서는 안 됩니다. 모든 애플리케이션 작업에 대해 새로운 가상 스레드를 생성해야 합니다.<br>따라서 대부분의 가상 스레드는 수명이 짧고 얕은 호출 스택을 가지며 단일 HTTP 클라이언트 호출 또는 단일 JDBC 쿼리만큼 적게 수행됩니다.<br>반대로 플랫폼 스레드는 무겁고 비용이 많이 들기 때문에 종종 풀링되어야 합니다.<br>수명이 길고 호출 스택이 깊으며 많은 작업 간에 공유되는 경향이 있습니다.</p>
<p>요약하면 가상 스레드는 하드웨어를 최적으로 활용하면서 Java 플랫폼의 설계와 조화를 이루는 안정적인 요청당 스레드 스타일을 유지합니다.<br>가상 스레드를 사용하는 데 새로운 개념을 학습할 필요는 없지만 오늘날의 높은 스레드 비용에 대처하기 위해 학습하지 않는 습관을 개발해야 할 수도 있습니다.<br>가상 스레드는 애플리케이션 개발자를 도울 뿐만 아니라 프레임워크 설계자가 확장성을 손상시키지 않으면서 플랫폼 설계와 호환되는 사용하기<br>쉬운 API를 제공하는 데도 도움이 됩니다.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>java.lang.Thread 오늘날 JDK의 모든 인스턴스는 플랫폼 스레드 입니다.<br>플랫폼 스레드는 기본 OS 스레드에서 Java 코드를 실행하고 코드의 전체 수명 동안 OS 스레드를 캡처합니다.<br>플랫폼 스레드 수는 OS 스레드 수로 제한됩니다.</p>
<p>가상 스레드는 java.lang.Thread 기본 OS 스레드에서 Java 코드를 실행하지만 코드의 전체 수명 동안 OS 스레드를 캡처하지 않는 인스턴스입니다.<br>이는 많은 가상 스레드가 동일한 OS 스레드에서 Java 코드를 실행하여 효과적으로 공유할 수 있음을 의미합니다.<br>플랫폼 스레드가 소중한 OS 스레드를 독점하는 반면 가상 스레드는 그렇지 않습니다.<br>가상 스레드의 수는 OS 스레드의 수보다 훨씬 클 수 있습니다.</p>
<p>가상 스레드는 OS가 아닌 JDK에서 제공하는 경량 스레드 구현입니다.<br>다른 다중 스레드 언어(예: Go의 고루틴 및 Erlang의 프로세스)에서 성공한 사용자 모드 스레드 의 한 형태입니다.<br>사용자 모드 스레드는 OS 스레드가 아직 성숙하고 널리 보급되지 않은 초기 Java 버전에서 소위 “그린 스레드” 로 기능하기도 했습니다.<br>그러나 Java의 그린 스레드는 모두 하나의 OS 스레드(M:1 스케줄링)를 공유했으며 결국 OS 스레드용 래퍼로 구현된 플랫폼 스레드(1:1 스케줄링)보다 성능이 뛰어났습니다.<br>가상 스레드는 M:N 스케줄링을 사용하는데, 여기서 많은 수(M)의 가상 스레드가 더 적은 수(N)의 OS 스레드에서 실행되도록 스케줄됩니다.</p>
<h3 id="Using-virtual-threads-vs-platform-threads-가상-스레드-대-플랫폼-스레드-사용"><a href="#Using-virtual-threads-vs-platform-threads-가상-스레드-대-플랫폼-스레드-사용" class="headerlink" title="Using virtual threads vs. platform threads (가상 스레드 대 플랫폼 스레드 사용)"></a>Using virtual threads vs. platform threads (가상 스레드 대 플랫폼 스레드 사용)</h3><p>개발자는 가상 스레드 또는 플랫폼 스레드를 사용할지 여부를 선택할 수 있습니다.<br>다음은 다수의 가상 스레드를 생성하는 예제 프로그램입니다.<br>프로그램은 먼저 제출된 각 작업에 대해 새 가상 스레드를 생성할 ExecutorService를 얻습니다.<br>그런 다음 10,000개의 작업을 제출하고 모두 완료될 때까지 기다립니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  <span class="comment">// executor.close() is called implicitly, and waits</span></span><br></pre></td></tr></table></figure>
<p>이 예제의 작업은 간단한 코드(1초 동안 절전 모드)이며 최신 하드웨어는 이러한 코드를 동시에 실행하는 10,000개의 가상 스레드를 쉽게 지원할 수 있습니다.<br>배후에서 JDK는 소수의 OS 스레드(아마도 하나 정도)에서 코드를 실행합니다.</p>
<p>이 프로그램 이 ExecutorService. Executors.newCachedThreadPool()는 ExecutorService 10,000개의 플랫폼 스레드와 10,000개의 OS 스레드를 생성하려고 시도하며<br>시스템과 운영 체제에 따라 프로그램이 충돌할 수 있습니다.</p>
<p>대신 프로그램이 ExecutorService 풀에서 플랫폼 스레드를 가져오는 Executors.newFixedThreadPool(200).<br>그러면 ExecutorService10,000개의 모든 작업에서 공유할 200개의 플랫폼 스레드가 생성되므로 많은 작업이 동시가 아닌 순차적으로 실행되고 프로그램을 완료하는 데<br>오랜 시간이 걸립니다. 이 프로그램의 경우 200개의 플랫폼 스레드가 있는 풀은 초당 200개의 작업 처리량만 달성할 수 있는 반면<br>가상 스레드는 초당 약 10,000개의 작업 처리량을 달성할 수 있습니다(충분한 워밍업 후).<br>또한 10_000예제 프로그램의 가 로 변경되면 1_000_000프로그램은 1,000,000개의 작업을 제출하고 동시에 실행되는 1,000,000개의 가상 스레드를 생성하며<br>(충분한 워밍업 후) 초당 약 1,000,000개의 작업 처리량을 달성합니다.</p>
<p>이 프로그램의 작업이 단순히 휴면 상태가 아니라 1초 동안 계산(예: 거대한 배열 정렬)을 수행했다면<br>가상 스레드이든 플랫폼 스레드든 프로세서 코어 수 이상으로 스레드 수를 늘리는 것은 도움이 되지 않습니다.<br>가상 스레드는 더 빠른 스레드가 아닙니다. 가상 스레드는 플랫폼 스레드보다 더 빠르게 코드를 실행하지 않습니다.<br>속도(낮은 대기 시간)가 아니라 확장성(높은 처리량)을 제공하기 위해 존재합니다.<br>플랫폼 스레드보다 더 많을 수 있으므로 리틀의 법칙에 따라 더 높은 처리량에 필요한 더 높은 동시성을 가능하게 합니다.</p>
<p>달리 말하면 가상 스레드는 다음과 같은 경우 애플리케이션 처리량을 크게 향상시킬 수 있습니다.</p>
<ul>
<li>동시 작업의 수가 많고(수천 개 이상),</li>
<li>이 경우 프로세서 코어보다 더 많은 스레드가 있으면 처리량을 향상시킬 수 없기 때문에 워크로드는 CPU에 제한되지 않습니다.</li>
</ul>
<p>가상 스레드는 이러한 응용 프로그램이 대기 시간의 대부분을 소비하는 많은 수의 동시 작업으로 구성되기 때문에<br>일반적인 서버 응용 프로그램의 처리량을 향상시키는 데 도움이 됩니다.</p>
<p>가상 스레드는 플랫폼 스레드가 실행할 수 있는 모든 코드를 실행할 수 있습니다.<br>특히 가상 스레드는 플랫폼 스레드와 마찬가지로 스레드 로컬 변수 및 스레드 중단을 지원합니다.<br>이는 요청을 처리하는 기존 Java 코드가 가상 스레드에서 쉽게 실행됨을 의미합니다. 많은 서버 프레임워크는 들어오는<br>모든 요청에 대해 새로운 가상 스레드를 시작하고 그 안에서 애플리케이션의 비즈니스 로직을 실행하여 이 작업을 자동으로 수행하도록 선택할 것입니다.</p>
<p>다음은 다른 두 서비스의 결과를 집계하는 서버 애플리케이션의 예입니다.<br>handle가상의 서버 프레임워크(표시되지 않음)는 각 요청에 대해 새로운 가상 스레드를 생성하고 해당 가상 스레드에서 애플리케이션의 코드를 실행합니다.<br>그러면 애플리케이션 코드는 두 개의 새 가상 스레드를 생성하여 ExecutorService 첫 번째 예와 동일한 방법으로 리소스를 동시에 가져옵니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">oid <span class="title function_">handle</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">url1</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">var</span> <span class="variable">url2</span> <span class="operator">=</span> ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">future1</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url1));</span><br><span class="line">        <span class="type">var</span> <span class="variable">future2</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url2));</span><br><span class="line">        response.send(future1.get() + future2.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        response.fail(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">String <span class="title function_">fetchURL</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> url.openStream()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(in.readAllBytes(), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>간단한 차단 코드가 있는 이와 같은 서버 응용 프로그램은 많은 수의 가상 스레드를 사용할 수 있기 때문에 잘 확장됩니다.</p>
<p>Executor.newVirtualThreadPerTaskExecutor() 가상 스레드를 생성하는 유일한 방법은 아닙니다.<br>아래에서 설명하는 새 java.lang.Thread.BuilderAPI는 가상 스레드를 만들고 시작할 수 있습니다.<br>또한 구조화된 동시성은 특히 이 서버 예제와 유사한 코드에서 가상 스레드를 생성하고 관리하기 위한 보다 강력한 API를 제공합니다.<br>이에 따라 스레드 간의 관계가 플랫폼과 해당 도구에 알려집니다.</p>
<h3 id="Virtual-threads-are-a-preview-API-disabled-by-default-가상-스레드는-기본적으로-비활성화된-미리보기-API-입니다"><a href="#Virtual-threads-are-a-preview-API-disabled-by-default-가상-스레드는-기본적으로-비활성화된-미리보기-API-입니다" class="headerlink" title="Virtual threads are a preview API, disabled by default (가상 스레드는 기본적으로 비활성화된 미리보기 API 입니다.)"></a>Virtual threads are a preview API, disabled by default (가상 스레드는 기본적으로 비활성화된 미리보기 API 입니다.)</h3><p>위의 프로그램은 이 Executors.newVirtualThreadPerTaskExecutor() 방법을 사용하므로 JDK 19에서 실행하려면 다음과 같이 미리 보기 API를 활성화해야 합니다.</p>
<ul>
<li>javac –release 19 –enable-preview Main.java 로 프로그램을 컴파일 하고 java –enable-preview 실행</li>
<li>소스 코드 런처를 사용할 때 java –source 19 –enable-preview Main.java; 로 프로그램을 실행하십시오 . 또는,</li>
<li>jshell을 사용할 때 로 시작하십시오 jshell –enable-preview.</li>
</ul>
<h3 id="Do-not-pool-virtual-threads-가상-스레드를-풀링하지-않음"><a href="#Do-not-pool-virtual-threads-가상-스레드를-풀링하지-않음" class="headerlink" title="Do not pool virtual threads(가상 스레드를 풀링하지 않음)"></a>Do not pool virtual threads(가상 스레드를 풀링하지 않음)</h3><p>ExecutorService 개발자는 일반적으로 응용 프로그램 코드를 기존 ExecutorService스레드 풀 기반 에서 작업당 가상 스레드로 마이그레이션합니다.<br>모든 리소스 풀과 마찬가지로 스레드 풀은 값비싼 리소스를 공유하기 위한 것이지만 가상 스레드는 비용이 많이 들지 않으며 풀링할 필요가 전혀 없습니다.</p>
<p>개발자는 때때로 스레드 풀을 사용하여 제한된 리소스에 대한 동시 액세스를 제한합니다.<br>예를 들어 서비스가 20개 이상의 동시 요청을 처리할 수 없는 경우 크기 20의 풀에 제출된 작업을 통해<br>서비스에 대한 모든 액세스를 수행하면 이를 보장할 수 있습니다.<br>플랫폼 스레드의 높은 비용으로 인해 스레드 풀이 유비쿼터스화되었기 때문에 이 관용구도 유비쿼터스가 되었지만<br>개발자는 동시성을 제한하기 위해 가상 스레드를 풀링하려는 유혹을 받아서는 안 됩니다.<br>제한된 리소스에 대한 액세스를 보호하기 위해 세마포어와 같이 해당 목적을 위해 특별히 설계된 구조를 사용해야 합니다.<br>이는 스레드 풀보다 더 효과적이고 편리하며 스레드 로컬 데이터가 실수로 한 작업에서 다른 작업으로 누출될 위험이 없기 때문에 더 안전합니다.</p>
<h3 id="Observing-virtual-threads-가상-스레드-관찰"><a href="#Observing-virtual-threads-가상-스레드-관찰" class="headerlink" title="Observing virtual threads(가상 스레드 관찰)"></a>Observing virtual threads(가상 스레드 관찰)</h3><p>명확한 코드를 작성하는 것이 전부는 아닙니다.<br>실행 중인 프로그램의 상태를 명확하게 표시하는 것도 문제 해결, 유지 관리 및 최적화에 필수적이며<br>JDK는 오랫동안 스레드를 디버그, 프로필 및 모니터링하는 메커니즘을 제공했습니다. 이러한 도구는 결국 java.lang.Thread.</p>
<p>Java 디버거는 가상 스레드를 단계별로 실행하고, 호출 스택을 표시하고, 스택 프레임의 변수를 검사할 수 있습니다.<br>JDK의 낮은 오버헤드 프로파일링 및 모니터링 메커니즘인 JFR(JDK Flight Recorder)은<br>애플리케이션 코드의 이벤트(예: 개체 할당 및 I&#x2F;O 작업)를 올바른 가상 스레드와 연결할 수 있습니다.<br>이러한 도구는 비동기 스타일로 작성된 애플리케이션에 대해 이러한 작업을 수행할 수 없습니다.<br>이 스타일에서 작업은 스레드와 관련이 없으므로 디버거는 작업의 상태를 표시하거나 조작할 수 없으며<br>프로파일러는 작업이 I&#x2F;O를 기다리는 데 소요되는 시간을 알 수 없습니다.</p>
<p>스레드 덤프는 요청당 스레드 스타일로 작성된 응용 프로그램 문제 해결을 위한 또 다른 인기 있는 도구입니다.<br>불행하게도  jstack 또는 jcmd 로 얻은 JDK의 기존 스레드 덤프는 단순한 스레드 목록을 제공합니다.<br>이는 수십 또는 수백 개의 플랫폼 스레드에 적합하지만 수천 또는 수백만 개의 가상 스레드에는 적합하지 않습니다.<br>따라서 가상 스레드를 포함하도록 기존의 스레드 덤프를 확장하지 않고 의미 있는 방식으로<br>모두 그룹화된 플랫폼 스레드와 함께 가상 스레드를 제공하기 위해 새로운 종류의 스레드 덤프를 도입할 것입니다.<br>프로그램이 구조화된 동시성을 사용할 때 스레드 간의 보다 풍부한 관계를 표시할 수 있습니다 .</p>
<p>많은 스레드를 시각화하고 분석하면 도구의 이점을 얻을 수 있으므로 는 일반 텍스트 외에도 JSON 형식으로 새 스레드 덤프를 내보낼 수 있습니다.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>ExecutorService 새 스레드 덤프 형식은 네트워크 I&#x2F;O 작업에서 차단된 가상 스레드와 위에 표시된<br>태스크당 새 스레드에 의해 생성된 가상 스레드를 나열합니다.<br>개체 주소, 잠금, JNI 통계, 힙 통계 및 기존 스레드 덤프에 표시되는 기타 정보는 포함되지 않습니다.<br>또한 많은 스레드를 나열해야 할 수 있으므로 새 스레드 덤프를 생성해도 응용 프로그램이 일시 중지되지 않습니다.</p>
<p>다음은 JSON 뷰어에서 렌더링된 위 의 두 번째 예와 유사한 애플리케이션에서 가져온 스레드 덤프의 예입니다 (확대하려면 클릭).</p>
<p>가상 스레드는 JDK에서 구현되고 특정 OS 스레드에 연결되지 않기 때문에 OS에서는 보이지 않으며 존재를 인식하지 못합니다.<br>OS 레벨 모니터링은 JDK 프로세스가 가상 스레드보다 적은 수의 OS 스레드를 사용함을 관찰합니다.</p>
<h3 id="Scheduling-virtual-threads-가상-스레드-예약"><a href="#Scheduling-virtual-threads-가상-스레드-예약" class="headerlink" title="Scheduling virtual threads(가상 스레드 예약)"></a>Scheduling virtual threads(가상 스레드 예약)</h3><p>유용한 작업을 수행하려면 스레드를 예약해야 합니다. 즉, 프로세서 코어에서 실행하도록 할당해야 합니다.<br>OS 스레드로 구현되는 플랫폼 스레드의 경우 JDK는 OS의 스케줄러에 의존합니다.<br>반대로 가상 스레드의 경우 JDK에는 자체 스케줄러가 있습니다.<br>가상 스레드를 프로세서에 직접 할당하는 대신 JDK의 스케줄러는 가상 스레드를 플랫폼 스레드에 할당합니다(앞서 언급한 가상 스레드의 M:N 스케줄링).<br>그런 다음 플랫폼 스레드는 평소와 같이 OS에 의해 예약됩니다.</p>
<p>ForkJoinPoolJDK의 가상 스레드 스케줄러는 FIFO 모드로 작동하는 작업 도용입니다.<br>스케줄러의 병렬성 은 가상 스레드 스케줄링을 위해 사용 가능한 플랫폼 스레드의 수입니다.<br>기본적으로 사용 가능한 프로세서 수와 동일 하지만 시스템 속성으로 조정할 수 있습니다<br>jdk.virtualThreadScheduler.parallelism. 이것은 예를 들어 병렬 스트림 구현에 사용되고<br>LIFO 모드에서 작동하는 공통 풀과 구별ForkJoinPool 된다는 점에 유의하십시오.</p>
<p>스케줄러가 가상 스레드를 할당하는 플랫폼 스레드를 가상 스레드의 캐리어 라고 합니다.<br>가상 스레드는 수명 동안 다른 캐리어에서 예약될 수 있습니다. 즉, 스케줄러는 가상 스레드와 특정 플랫폼 스레드 간의 선호도를 유지하지 않습니다.<br>Java 코드의 관점에서 실행 중인 가상 스레드는 현재 캐리어와 논리적으로 독립적입니다.</p>
<ul>
<li>캐리어의 ID는 가상 스레드에서 사용할 수 없습니다. 에서 반환되는 값은 Thread.currentThread()항상 가상 스레드 자체입니다.</li>
<li>캐리어와 가상 스레드의 스택 추적은 별개입니다. 가상 스레드에서 발생한 예외에는 캐리어의 스택 프레임이 포함되지 않습니다. 스레드 덤프는 캐리어의 스택 프레임을 가상 스레드의 스택에 표시하지 않으며 그 반대도 마찬가지입니다.</li>
<li>캐리어의 스레드 로컬 변수는 가상 스레드에서 사용할 수 없으며 그 반대도 마찬가지입니다.</li>
</ul>
<p>또한 Java 코드의 관점에서 볼 때 가상 스레드와 해당 캐리어가 일시적으로 OS 스레드를 공유한다는 사실은 보이지 않습니다.<br>반대로 네이티브 코드의 관점에서 볼 때 가상 스레드와 캐리어는 모두 동일한 네이티브 스레드에서 실행됩니다.<br>따라서 동일한 가상 스레드에서 여러 번 호출되는 네이티브 코드는 호출할 때마다 다른 OS 스레드 식별자를 관찰할 수 있습니다.</p>
<p>스케줄러는 현재 가상 스레드에 대한 시간 공유를 구현하지 않습니다. 시간 공유는 할당된 양의 CPU 시간을 사용한 스레드의 강제 선점입니다.<br>상대적으로 적은 수의 플랫폼 스레드가 있고 CPU 사용률이 100%일 때 시분할이 일부 작업의 대기 시간을 줄이는 데 효과적일 수 있지만<br>시분할이 백만 개의 가상 스레드에서만큼 효과적일지는 확실하지 않습니다.</p>
<h3 id="Executing-virtual-threads-가상-스레드-실행"><a href="#Executing-virtual-threads-가상-스레드-실행" class="headerlink" title="Executing virtual threads(가상 스레드 실행)"></a>Executing virtual threads(가상 스레드 실행)</h3><p>가상 스레드를 활용하기 위해 프로그램을 다시 작성할 필요는 없습니다.<br>가상 스레드는 응용 프로그램 코드가 명시적으로 제어를 스케줄러로 되돌려줄 것을 요구하거나 기대하지 않습니다.<br>즉, 가상 스레드는 협력적이 지 않습니다. 사용자 코드는 플랫폼 스레드가 프로세서 코어에 할당되는 방법 또는 시기에 대해 가정하는 것 이상으로<br>가상 스레드가 플랫폼 스레드에 할당되는 방법 또는 시기에 대해 가정해서는 안 됩니다.</p>
<p>가상 스레드에서 코드를 실행하기 위해 JDK의 가상 스레드 스케줄러는 가상 스레드를 플랫폼 스레드에 마운트하여<br>플랫폼 스레드에서 실행할 가상 스레드를 할당합니다.<br>이렇게 하면 플랫폼 스레드가 가상 스레드의 캐리어가 됩니다.<br>나중에 일부 코드를 실행한 후 가상 스레드는 캐리어에서 마운트 해제 할 수 있습니다.<br>이 시점에서 플랫폼 스레드는 사용 가능하므로 스케줄러가 다른 가상 스레드를 플랫폼에 마운트하여 다시 캐리어로 만들 수 있습니다.</p>
<p>일반적으로 가상 스레드는 I&#x2F;O 또는 JDK의 다른 차단 작업(예: BlockingQueue.take().<br>차단 작업이 완료될 준비가 되면(예: 소켓에 바이트가 수신됨) 스케줄러에 가상 스레드를 다시 제출하고 스케줄러는 가상 스레드를 캐리어에 탑재하여 실행을 재개합니다.</p>
<p>가상 스레드의 마운트 및 마운트 해제는 OS 스레드를 차단하지 않고 자주 투명하게 발생합니다.<br>예를 들어 이전에 표시된 서버 응용 프로그램에는 차단 작업에 대한 호출이 포함된 다음 코드 줄이 포함되어 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.send(future1.get() + future2.get());</span><br></pre></td></tr></table></figure>

<p>이러한 작업으로 인해 가상 스레드는 일반적으로 각 호출에 대해 한 번, send(…) 에서 get() I&#x2F;O를 수행하는 동안 여러 번 마운트 및 마운트 해제됩니다 </p>
<p>JDK에서 대부분의 차단 작업은 가상 스레드를 마운트 해제하여 캐리어와 기본 OS 스레드가 새로운 작업을 수행하도록 해제합니다.<br>그러나 JDK의 일부 차단 작업은 가상 스레드를 마운트 해제하지 않으므로 캐리어와 기본 OS 스레드를 모두 차단합니다.<br>이는 OS 수준(예: 많은 파일 시스템 작업) 또는 JDK 수준(예: Object.wait())의 제한 사항 때문입니다.<br>이러한 차단 작업을 구현하면 스케줄러의 병렬 처리를 일시적으로 확장하여 OS 스레드 캡처를 보상합니다.<br>결과적으로 스케줄러의 플랫폼 스레드 수가 ForkJoinPool일시적으로 사용 가능한 프로세서 수를 초과할 수 있습니다.<br>스케줄러가 사용할 수 있는 최대 플랫폼 스레드 수는 시스템 속성으로 조정할 수 있습니다 jdk.virtualThreadScheduler.maxPoolSize.</p>
<p>캐리어에 고정되어 있기 때문에 차단 작업 중에 가상 스레드를 마운트 해제할 수 없는 두 가지 시나리오가 있습니다 .</p>
<ul>
<li>블록이나 메서드 내에서 코드를 실행할 때 synchronized또는</li>
<li>native 메서드나 외부 함수를 실행할 때.</li>
</ul>
<p>고정은 응용 프로그램을 잘못 만들지는 않지만 확장성을 방해할 수 있습니다.<br>가상 스레드가 I&#x2F;O와 같은 차단 작업을 수행하거나 BlockingQueue.take()고정된 상태에서 작업이 지속되는 동안 해당 캐리어와 기본 OS 스레드가 차단됩니다.<br>오랜 기간 동안 빈번한 고정은 캐리어 캡처로 인해 애플리케이션의 확장성을 손상시킬 수 있습니다.</p>
<p>스케줄러는 병렬 처리를 확장하여 고정을 보상하지 않습니다.<br>대신 자주 synchronized실행되는 블록이나 메서드를 수정하여 빈번 하고<br>오래 지속되는 고정을 피하고 java.util.concurrent.locks.ReentrantLock대신 사용할 잠재적으로 긴 I&#x2F;O 작업을 보호하세요.<br>synchronized드물게 사용되거나(예: 시작 시에만 수행됨) 메모리 내 작업을 보호하는 블록 및 메서드를 교체할 필요가 없습니다.<br>항상 그렇듯이 잠금 정책을 간단하고 명확하게 유지하기 위해 노력하십시오.</p>
<p>synchronized새로운 진단 기능은 코드를 가상 스레드로 마이그레이션하고 java.util.concurrent 의 특정 용도를 잠금으로 대체해야 하는지 여부를 평가하는 데 도움이 됩니다.</p>
<ul>
<li>고정된 동안 스레드가 차단되면 JFR(JDK Flight Recorder) 이벤트가 발생합니다( JDK Flight Recorder 참조 ).</li>
<li>고정된 상태에서 스레드가 차단되면 시스템 속성이 jdk.tracePinnedThreads스택 추적을 트리거합니다. 함께 실행하면 -Djdk.tracePinnedThreads&#x3D;full고정된 상태에서 스레드가 차단될 때 전체 스택 추적이 인쇄되며 네이티브 프레임과 프레임이 모니터를 강조 표시합니다. 함께 실행하면 -Djdk.tracePinnedThreads&#x3D;short문제가 있는 프레임으로만 출력이 제한됩니다.</li>
</ul>
<p>향후 릴리스에서는 위의 첫 번째 제한 사항( 내부 고정)을 제거할 수 있습니다 synchronized.<br>네이티브 코드와의 적절한 상호 작용을 위해서는 두 번째 제한 사항이 필요합니다.</p>
<h3 id="Memory-use-and-interaction-with-garbage-collection-메모리-사용-및-가비지-수집과의-상호-작용"><a href="#Memory-use-and-interaction-with-garbage-collection-메모리-사용-및-가비지-수집과의-상호-작용" class="headerlink" title="Memory use and interaction with garbage collection(메모리 사용 및 가비지 수집과의 상호 작용)"></a>Memory use and interaction with garbage collection(메모리 사용 및 가비지 수집과의 상호 작용)</h3><p>가상 스레드의 스택은 Java의 가비지 수집된 힙에 스택 청크 개체 로 저장됩니다.<br>애플리케이션이 실행됨에 따라 스택이 확장 및 축소되어 메모리 효율성이 향상되고 임의 깊이의 스택(JVM의 구성된 플랫폼 스레드 스택 크기까지)을 수용할 수 있습니다.<br>이러한 효율성은 많은 수의 가상 스레드를 가능하게 하고 따라서 서버 애플리케이션에서 요청당 스레드 스타일의 지속적인 실행 가능성을 가능하게 합니다.</p>
<p>위의 두 번째 예 에서 가상의 프레임워크가 새 가상 스레드를 만들고 메서드를 호출하여 각 요청을 처리한다는 점을 상기하십시오 handle.<br>handle깊은 호출 스택의 끝에서 호출하더라도 (인증, 트랜잭션 등 이후) handle자체적으로 단기 작업만 수행하는 여러 가상 스레드를 생성합니다.<br>따라서 깊은 호출 스택이 있는 각 가상 스레드에 대해 적은 메모리를 사용하는 얕은 호출 스택이 있는 여러 가상 스레드가 있습니다.</p>
<p>가상 스레드에 필요한 힙 공간 및 가비지 수집기 활동의 양은 일반적으로 비동기 코드와 비교하기 어렵습니다.<br>백만 개의 가상 스레드에는 최소한 백만 개의 개체가 필요하지만 플랫폼 스레드 풀을 공유하는 백만 개의 작업도 마찬가지입니다.<br>또한 요청을 처리하는 애플리케이션 코드는 일반적으로 I&#x2F;O 작업 전반에 걸쳐 데이터를 유지합니다.<br>요청당 스레드 코드는 해당 데이터를 힙의 가상 스레드 스택에 저장되는 로컬 변수에 보관할 수 있는<br>반면, 비동기식 코드는 파이프라인의 한 단계에서 다음 단계로 전달되는 힙 개체에 동일한 데이터를 보관해야 합니다.<br>한편으로 가상 스레드에 필요한 스택 프레임 레이아웃은 압축 개체보다 더 낭비입니다.<br>반면에, 가상 스레드는 다양한 상황에서(낮은 수준의 GC 상호 작용에 따라) 스택을 변경하고 재사용할 수 있는<br>반면, 비동기 파이프라인은 항상 새 개체를 할당해야 하므로 가상 스레드는 더 적은 할당이 필요할 수 있습니다.<br>전반적으로 요청당 스레드 대 비동기 코드의 힙 소비 및 가비지 수집기 활동은 거의 유사해야 합니다.<br>시간이 지남에 따라 가상 스레드 스택의 내부 표현이 훨씬 더 간결해질 것으로 예상됩니다.</p>
<p>플랫폼 스레드 스택과 달리 가상 스레드 스택은 GC 루트가 아니므로 여기에 포함된 참조는 동시 힙 스캔을 수행하는 G1과 같은 가비지 수집기에 의한<br>top-the-world 일시 중지에서 순회되지 않습니다. BlockingQueue.take()이것은 또한 가상 스레드가 예를 들어 에서 차단되고 다른 스레드가<br>가상 스레드나 대기열에 대한 참조를 얻을 수 없는 경우 스레드가 가비지 수집될 수 있음을 의미합니다 . 중단되거나 차단 해제됩니다.<br>물론 가상 스레드는 실행 중이거나 차단되어 차단 해제될 수 있는 경우 가비지 수집되지 않습니다.</p>
<p>가상 스레드의 현재 제한 사항은 G1 GC가 거대한 스택 청크 개체를 지원하지 않는다는 것입니다.<br>가상 스레드의 스택이 영역 크기의 절반(512KB 정도로 작을 수 있음)에 도달하면 a가 StackOverflowError발생할 수 있습니다.</p>
<h2 id="Detailed-changes-세부-변경-사항"><a href="#Detailed-changes-세부-변경-사항" class="headerlink" title="Detailed changes(세부 변경 사항)"></a>Detailed changes(세부 변경 사항)</h2><ul>
<li>java.lang.Thread </li>
<li>스레드 로컬 변수 </li>
<li>java.util.concurrent </li>
<li>네트워킹 </li>
<li>java.io </li>
<li>자바 네이티브 인터페이스(JNI)</li>
<li>디버깅(JVM TI, JDWP 및 JDI)</li>
<li>JDK 비행 기록기(JFR)</li>
<li>JMX(Java 관리 확장)</li>
<li>java.lang.ThreadGroup</li>
</ul>
<h3 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h3><p>다음과 같이 API를 업데이트합니다 java.lang.Thread.</p>
<p>Thread.Builder, Thread.ofVirtual()및 은 Thread.ofPlatform()가상 및 플랫폼 스레드를 생성하는 새로운 API입니다. 예를 들어,<br><code>Thread thread = Thread.ofVirtual().name(&quot;duke&quot;).unstarted(runnable);</code><br>라는 새로운 시작되지 않은 가상 스레드를 생성합니다</p>
<p>Thread.startVirtualThread(Runnable)가상 스레드를 생성하고 시작하는 편리한 방법입니다.</p>
<p>A는 Thread.Builder스레드 또는 를 생성할 수 있으며 ThreadFactory, 그러면 동일한 속성을 가진 여러 스레드를 생성할 수 있습니다.</p>
<p>Thread.isVirtual()스레드가 가상 스레드인지 여부를 테스트합니다.</p>
<p>의 새로운 오버로드 Thread.join및 의 Thread.sleep인스턴스로 대기 및 절전 시간을 수락합니다 java.time.Duration.</p>
<p>새로운 최종 메서드는 Thread.threadId()스레드의 식별자를 반환합니다. 기존의 최종이 아닌 메서드는 Thread.getId()이제 더 이상 사용되지 않습니다.</p>
<p>Thread.getAllStackTraces()이제 모든 스레드가 아닌 모든 플랫폼 스레드의 맵을 반환합니다.</p>
<p>그렇지 않으면 API java.lang.Thread가 변경되지 않습니다.<br>클래스 에 의해 정의된 생성자는 Thread 이전과 같이 플랫폼 스레드를 생성합니다.<br>새로운 공개 생성자가 없습니다.</p>
<p>가상 스레드와 플랫폼 스레드 간의 주요 API 차이점은 다음과 같습니다.</p>
<p>공용 Thread생성자는 가상 스레드를 만들 수 없습니다.</p>
<p>가상 스레드는 항상 데몬 스레드입니다. 이 Thread.setDaemon(boolean)메서드는 가상 스레드를 데몬이 아닌 스레드로 변경할 수 없습니다.</p>
<p>가상 스레드는 의 고정 우선 순위를 갖습니다 Thread.NORM_PRIORITY. 이 Thread.setPriority(int)방법은 가상 스레드에 영향을 주지 않습니다.<br>이 제한 사항은 향후 릴리스에서 다시 검토될 수 있습니다.</p>
<p>가상 스레드는 스레드 그룹의 활성 구성원이 아닙니다.<br>가상 스레드에서 호출되면 Thread.getThreadGroup()이름이 있는 자리 표시자 스레드 그룹을 반환합니다 “VirtualThreads”.<br>API Thread.Builder는 가상 스레드의 스레드 그룹을 설정하는 방법을 정의하지 않습니다.</p>
<p>가상 스레드는 세트로 실행할 때 권한이 없습니다 SecurityManager.</p>
<p>stop()가상 스레드는 , suspend()또는 메서드를 지원하지 않습니다 resume(). 이러한 메서드는 가상 스레드에서 호출될 때 예외를 throw합니다.</p>
<h3 id="Thread-local-variables-스레드-로컬-변수"><a href="#Thread-local-variables-스레드-로컬-변수" class="headerlink" title="Thread-local variables(스레드 로컬 변수)"></a>Thread-local variables(스레드 로컬 변수)</h3><p>가상 스레드는 플랫폼 스레드와 마찬가지로 스레드 로컬 변수(ThreadLocal) 및 상속 가능한 스레드 로컬 변수(InheritableThreadLocal)를 지원하므로<br>스레드 로컬을 사용하는 기존 코드를 실행할 수 있습니다.<br>그러나 가상 스레드가 매우 많을 수 있으므로 신중하게 고려한 후 스레드 로컬을 사용하십시오.<br>특히 스레드 풀에서 동일한 스레드를 공유하는 여러 작업 간에 비용이 많이 드는 리소스를 풀링하기 위해 스레드 로컬을 사용하지 마십시오.<br>가상 스레드는 풀링되지 않아야 합니다. 각 스레드는 수명 기간 동안 단일 작업만 실행하도록 되어 있기 때문입니다.<br>java.base수백만 개의 스레드로 실행할 때 메모리 공간을 줄이기 위해 가상 스레드를 준비하기 위해 모듈 에서 스레드 로컬의 많은 사용을 제거했습니다 .</p>
<ul>
<li>API 는 스레드를 생성할 때 스레드 로컬을 옵트아웃하는 방법을Thread.Builder 정의합니다. </li>
<li>또한 상속 가능한 thread-locals 의 초기 값 상속을 거부하는 방법을 정의합니다.<br>스레드 로컬을 지원하지 않는 스레드에서 호출되면 초기 값을 반환하고 예외를 throw합니다.ThreadLocal.get()ThreadLocal.set(T)</li>
<li>레거시 컨텍스트 클래스 로더는 이제 상속 가능한 스레드 로컬처럼 작동하도록 지정되었습니다.<br>Thread.setContextClassLoader(ClassLoader)스레드 로컬을 지원하지 않는 스레드에서 호출되면 예외가 발생합니다 .</li>
</ul>
<p>범위 로컬 변수는 일부 사용 사례에서 스레드 로컬에 대한 더 나은 대안이 될 수 있습니다.</p>
<h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>잠금을 지원하는 원시 API는 java.util.concurrent.LockSupport이제 가상 스레드를 지원합니다.<br>가상 스레드를 파킹하면 다른 작업을 수행하기 위해 기본 플랫폼 스레드가 해제되고 가상 스레드를 파킹 해제하면 계속되도록 예약됩니다.<br>이 변경으로 LockSupport 이를 사용하는 모든 API(Locks, Semaphores, 차단 대기열 등)가 가상 스레드에서 호출될 때 정상적으로 파킹할 수 있습니다.</p>
<ul>
<li><p>Executors.newThreadPerTaskExecutor(ThreadFactory)각 작업에 대해 새 스레드를 생성하는 Executors.newVirtualThreadPerTaskExecutor()을 생성합니다.<br>ExecutorService이러한 메서드를 사용하면 스레드 풀 및 ExecutorService.</p>
</li>
<li><p>ExecutorService이제 extends AutoCloseable이므로 이 API를 위의 예와 같이 try-with-resource 구성과 함께 사용할 수 있습니다.</p>
</li>
<li><p>Future이제 완료된 작업의 결과 또는 예외를 가져오고 작업의 상태를 가져오는 메서드를 정의합니다.<br>이러한 추가 기능을 결합하면 개체를 스트림의 요소로 쉽게 사용할 수 있고 Future, 퓨처 스트림을 필터링하여 완료된 작업을 찾은 다음<br>이를 매핑하여 결과 스트림을 얻을 수 있습니다. 이러한 방법은 구조화된 동시성을 위해 제안된 API 추가에도 유용합니다.</p>
</li>
</ul>
<h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><p>java.net및 패키지 의 네트워킹 API 구현은 java.nio.channels이제 가상 스레드와 함께 작동합니다.<br>예를 들어 네트워크 연결 설정 또는 소켓에서 읽기를 차단하는 가상 스레드에 대한 작업은 다른 작업을 수행하기 위해 기본 플랫폼 스레드를 해제합니다.</p>
<p>중단 및 취소를 허용하기 위해 , java.net.Socket및 ServerSocket에 의해 정의된 차단 I&#x2F;O 메서드는 이제 가상 스레드에서 호출될 때<br>중단 가능DatagramSocket 하도록 지정됩니다. 소켓에서 차단된 가상 스레드를 중단하면 스레드가 언파킹되고 소켓이 닫힙니다.<br>에서 가져올 때 이러한 유형의 소켓에 대한 I&#x2F;O 작업 차단은 항상 인터럽트할 수 있으므로<br>이 변경 사항은 채널에서 가져올 때 해당 동작과 생성자로 생성될 때 이러한 API의 동작을 정렬합니다.InterruptibleChannel</p>
<h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><p>이 java.io패키지는 바이트 및 문자 스트림에 대한 API를 제공합니다.<br>이러한 API의 구현은 심하게 동기화되며 가상 스레드에서 사용될 때 고정을 방지하기 위해 변경이 필요합니다.</p>
<p>close()배경으로 바이트 지향 입력&#x2F;출력 스트림은 스레드로부터 안전하도록 지정되지 않았으며<br>스레드가 읽기 또는 쓰기 메서드에서 차단된 동안 호출될 때 예상되는 동작을 지정하지 않습니다.<br>대부분의 시나리오에서 여러 동시 스레드의 특정 입력 또는 출력 스트림을 사용하는 것은 의미가 없습니다.<br>문자 지향 리더&#x2F;라이터도 스레드로부터 안전하도록 지정되지 않았지만 하위 클래스에 대한 잠금 개체를 노출합니다.<br>고정 외에도 이러한 클래스의 동기화는 문제가 있고 일관성이 없습니다.<br>예를 들어 잠금 개체가 아닌 스트림 개체에서 사용 InputStreamReader하고 동기화하는 스트림 디코더 및 인코더입니다 .OutputStreamWriter</p>
<p>고정을 방지하기 위해 구현은 이제 다음과 같이 작동합니다.</p>
<ul>
<li><p>BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriterPrintStreamPrintWriter,<br>그리고 이제 직접 사용할 때 모니터가 아닌 명시적 잠금을 사용합니다 . 이러한 클래스는 하위 클래스로 분류될 때 이전과 같이 동기화됩니다.</p>
</li>
<li><p>InputStreamReader 에서 사용하는 스트림 디코더 및 인코더는 이제 OutputStreamWriter둘러싸는 InputStreamReader<br>또는 OutputStreamWriter 와 동일한 잠금을 사용합니다</p>
</li>
</ul>
<p>더 나아가 불필요한 잠금을 모두 제거하는 것은 이 JEP의 범위를 벗어납니다.</p>
<p>BufferedOutputStream또한 , BufferedWriter및 스트림 인코더 에서 사용하는 버퍼의 초기 크기는 OutputStreamWriter이제<br>힙에 많은 스트림 또는 작성자가 있을 때 메모리 사용량을 줄이기 위해 더 작아졌습니다. 소켓 연결에서 버퍼링된 스트림.</p>
<h3 id="Java-Native-Interface-JNI"><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface (JNI)"></a>Java Native Interface (JNI)</h3><p>IsVirtualThreadJNI는 개체가 가상 스레드인지 테스트하기 위해 하나의 새 함수를 정의합니다 .</p>
<p>그렇지 않으면 JNI 사양이 변경되지 않습니다.</p>
<h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>디버깅 아키텍처는 JVM TI(JVM Tool Interface), JDWP(Java Debug Wire Protocol) 및 JDI(Java Debug Interface)의 세 가지 인터페이스로 구성됩니다.<br>이제 세 가지 인터페이스 모두 가상 스레드를 지원합니다.</p>
<p>JVM TI 에 대한 업데이트는 다음과 같습니다.</p>
<ul>
<li><p>jthread(즉, 객체에 대한 JNI 참조 ) 로 호출되는 대부분의 함수는 Thread가상 스레드에 대한 참조로 호출될 수 있습니다.<br>소수의 함수, 즉 PopFrame, ForceEarlyReturn, StopThread, AgentStartFunction및 은 GetThreadCpuTime가상 스레드에서 지원되지 않습니다.<br>기능 SetLocal*은 중단점 또는 단일 단계 이벤트에서 일시 중단된 가상 스레드의 최상위 프레임에서 로컬 변수를 설정하는 것으로 제한됩니다.</p>
</li>
<li><p>이제 모든 스레드가 아닌 모든 플랫폼 스레드를 반환하도록 GetAllThreads및 함수 가 지정되었습니다.GetAllStackTraces</p>
</li>
<li><p>초기 VM 시작 또는 힙 반복 중에 게시된 이벤트를 제외한 모든 이벤트는 가상 스레드 컨텍스트에서 호출된 이벤트 콜백을 가질 수 있습니다.</p>
</li>
<li><p>일시 중단&#x2F;재개 구현을 사용하면 디버거에서 가상 스레드를 일시 중단 및 재개할 수 있으며 가상 스레드가 마운트될 때 플랫폼 스레드를 일시 중단할 수 있습니다.</p>
</li>
<li><p>새 기능인 은 can_support_virtual_threads에이전트가 가상 스레드의 스레드 시작 및 종료 이벤트를 보다 세밀하게 제어할 수 있도록 합니다.</p>
</li>
<li><p>새로운 기능은 가상 스레드의 대량 일시 중지 및 재개를 지원합니다. 여기에는 can_support_virtual_threads 기능이 필요합니다.</p>
</li>
</ul>
<p>기존 JVM TI 에이전트는 대부분 이전과 동일하게 작동하지만 가상 스레드에서 지원되지 않는 기능을 호출하는 경우 오류가 발생할 수 있습니다.<br>가상 스레드를 인식하지 못하는 에이전트가 가상 스레드를 사용하는 애플리케이션과 함께 사용되는 경우 이러한 오류가 발생합니다.<br>GetAllThreads플랫폼 스레드만 포함하는 배열을 반환하도록 변경하면 일부 에이전트에서 문제가 될 수 있습니다.<br>ThreadStart및 이벤트를 활성화하는 기존 에이전트는 ThreadEnd이러한 이벤트를 플랫폼 스레드로 제한하는 기능이 없기 때문에 성능 문제가 발생할 수 있습니다.</p>
<p>JDWP 에 대한 업데이트는 다음과 같습니다.</p>
<ul>
<li>새 명령을 사용하면 디버거가 스레드가 가상 스레드인지 테스트할 수 있습니다.</li>
<li>명령 의 새 수정자는 EventRequest디버거가 스레드 시작 및 종료 이벤트를 플랫폼 스레드로 제한할 수 있도록 합니다.</li>
</ul>
<p>JDI 에 대한 업데이트는 다음과 같습니다.</p>
<ul>
<li>com.sun.jdi.ThreadReference스레드가 가상 스레드인지 여부를 테스트하는 새로운 방법입니다</li>
<li>새로운 메서드는 플랫폼 스레드에 대한 요청에 대해 생성된 이벤트를 제한합니다 com.sun.jdi.request.ThreadStartRequest.com.sun.jdi.request.ThreadDeathRequest</li>
</ul>
<p>위에서 언급한 것처럼 가상 스레드는 스레드 그룹에서 활성 스레드로 간주되지 않습니다.<br>따라서 JVM TI 함수 GetThreadGroupChildren, JDWP 명령 ThreadGroupReference&#x2F;Children및 JDI 메서드 에서 반환된 스레드 목록<br>com.sun.jdi.ThreadGroupReference.threads()에는 플랫폼 스레드만 포함됩니다.</p>
<h3 id="JDK-Flight-Recorder-JFR"><a href="#JDK-Flight-Recorder-JFR" class="headerlink" title="JDK Flight Recorder (JFR)"></a>JDK Flight Recorder (JFR)</h3><p>JFR은 몇 가지 새로운 이벤트로 가상 스레드를 지원합니다.</p>
<ul>
<li>jdk.VirtualThreadStart가상 스레드 시작 및 종료를 나타 냅니다 jdk.VirtualThreadEnd. 이러한 이벤트는 기본적으로 비활성화되어 있습니다.</li>
<li>jdk.VirtualThreadPinned고정된 동안 즉, 플랫폼 스레드를 해제하지 않고 가상 스레드가 정지되었음을 나타냅니다( 토론 참조 ).<br>이 이벤트는 기본적으로 활성화되며 임계값은 20ms입니다.</li>
<li>jdk.VirtualThreadSubmitFailed리소스 문제로 인해 가상 스레드 시작 또는 언파킹이 실패했음을 나타냅니다. 이 이벤트는 기본적으로 활성화되어 있습니다.</li>
</ul>
<h3 id="Java-Management-Extensions-JMX"><a href="#Java-Management-Extensions-JMX" class="headerlink" title="Java Management Extensions (JMX)"></a>Java Management Extensions (JMX)</h3><p>java.lang.management.ThreadMXBean플랫폼 스레드의 모니터링 및 관리만 지원합니다.<br>이 findDeadlockedThreads()메서드는 교착 상태에 있는 플랫폼 스레드의 주기를 찾습니다.<br>교착 상태에 있는 가상 스레드의 주기는 찾지 않습니다.</p>
<p>의 새로운 메서드는 위에서com.sun.management.HotSpotDiagnosticsMXBean 설명한 새로운 스타일의 스레드 덤프를 생성합니다.<br>이 메서드는 로컬 또는 원격 JMX 도구에서 플랫폼을 통해 간접적으로 호출할 수도 있습니다 .MBeanServer</p>
<h3 id="java-lang-ThreadGroup"><a href="#java-lang-ThreadGroup" class="headerlink" title="java.lang.ThreadGroup"></a>java.lang.ThreadGroup</h3><p>java.lang.ThreadGroup최신 애플리케이션에서 거의 사용되지 않고 가상 스레드 그룹화에 적합하지 않은 스레드 그룹화를 위한 레거시 API입니다.<br>우리는 지금 그것을 더 이상 사용하지 않고 성능을 저하시키며 구조화된 동시성 의 일부로 미래에 새로운 스레드 구성 구조를 도입할 것으로 예상합니다 .</p>
<p>배경으로 ThreadGroupAPI는 Java 1.0부터 시작됩니다. 원래 그룹의 모든 스레드 중지와 같은 작업 제어 작업을 제공하기 위한 것이었습니다.<br>java.util.concurrent최신 코드는 Java 5에 도입된 패키지 의 스레드 풀 API를 사용할 가능성이 더 높습니다 ThreadGroup.<br>초기 Java 릴리스에서 애플릿의 격리를 지원했지만 Java 보안 아키텍처는 Java 1.2에서 크게 발전했으며 스레드 그룹은 더 이상 중요한 역할을 하지 않았습니다.<br>ThreadGroup진단 목적에도 유용하도록 의도되었지만 그 역할은 API를 포함하여 Java 5에 도입된 모니터링 및 관리 기능으로 대체되었습니다 java.lang.management.</p>
<p>현재 거의 관련이 없는 것 외에도 ThreadGroupAPI 및 구현에는 여러 가지 중요한 문제가 있습니다.</p>
<ul>
<li>스레드 그룹을 파괴하는 API 및 메커니즘에 결함이 있습니다.</li>
<li>API는 구현이 그룹의 모든 라이브 스레드에 대한 참조를 갖도록 요구합니다. 이는 스레드 생성, 스레드 시작 및 스레드 종료에 동기화 및 경합 오버헤드를 추가합니다.</li>
<li>API는 enumerate()본질적으로 정확성이 있는 메서드를 정의합니다.</li>
<li>API는 본질적으로 교착 상태가 발생 suspend()하기 쉽고 안전하지 않은 , resume()및 stop()메서드를 정의합니다.</li>
</ul>
<p>ThreadGroup이제 다음과 같이 지정, 더 이상 사용되지 않으며 성능이 저하됩니다.</p>
<ul>
<li>명시적으로 스레드 그룹을 제거하는 기능이 제거되었습니다. 최종적으로 더 이상 사용되지 않는 destroy()메서드는 아무 작업도 수행하지 않습니다.</li>
<li>데몬 스레드 그룹의 개념이 제거되었습니다. 최종적으로 더 이상 사용되지 않는 메서드에 의해 설정되고 검색된 데몬 상태가 setDaemon(boolean)무시 isDaemon()됩니다.</li>
<li>구현 시 더 이상 하위 그룹에 대한 강력한 참조를 유지하지 않습니다. 스레드 그룹은 이제 그룹에 활성 스레드가 없고 스레드 그룹을 활성 상태로 유지하는 다른 항목이 없을 때 가비지 수집 대상이 됩니다.</li>
<li>최종적으로 사용되지 않는 suspend(), resume()및 stop()메소드는 항상 예외를 발생시킵니다.</li>
</ul>
<h2 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h2><ul>
<li><p>계속해서 비동기 API를 사용합니다. 비동기식 API는 동기식 API와 통합하기 어렵고, 동일한 I&#x2F;O 작업의 두 가지 표현으로 분리된 세계를 생성하며,<br>문제 해결, 모니터링, 디버깅을 위한 컨텍스트로 플랫폼에서 사용할 수 있는 일련의 작업에 대한 통합 개념을 제공하지 않습니다. , 그리고 프로파일링 목적.</p>
</li>
<li><p>구문 스택리스 코루틴 (예: async&#x2F;await )을 Java 언어에 추가합니다 .<br>이들은 사용자 모드 스레드보다 구현하기 쉽고 일련의 작업 컨텍스트를 나타내는 통합 구조를 제공합니다.<br>그러나 그 구성은 새롭고 여러 측면에서 유사하지만 일부 미묘한 방식에서 다른 스레드와 별개입니다.<br>그것은 스레드용으로 설계된 API와 코루틴용으로 설계된 API 사이에서 세계를 분할하고 플랫폼 및 해당 도구의 모든 계층에 도입되는<br>새로운 스레드와 유사한 구성을 요구합니다.<br>이것은 생태계가 채택하는 데 더 오래 걸리며 사용자 모드 스레드만큼 플랫폼과 우아하고 조화롭지 않을 것입니다.</p>
</li>
</ul>
<p>구문적 코루틴을 채택한 대부분의 언어는 사용자 모드 스레드(예: Kotlin),<br>레거시 의미 체계 보장(예: 본질적으로 단일 스레드 JavaScript) 또는 언어별 기술적 제약(예: C++)을 구현할 수 없기 때문에 그렇게 했습니다. ).<br>이러한 제한은 Java에 적용되지 않습니다.</p>
<ul>
<li>java.lang.Thread_ Thread25년 동안 학급이 쌓아온 불필요한 짐을 버릴 수 있는 기회가 될 것이다.<br>우리는 이 접근 방식의 여러 변형을 탐색하고 프로토타입을 만들었지만 모든 경우에 기존 코드를 실행하는 방법에 대한 문제와 씨름했습니다.</li>
</ul>
<p>주된 문제는 이것이 Thread.currentThread()직간접적으로 기존 코드에 광범위하게 사용된다는 것입니다(예: 잠금 소유권 결정 또는 스레드 로컬 변수).<br>이 메서드는 현재 실행 스레드를 나타내는 개체를 반환해야 합니다. 사용자 모드 스레드를 나타내는 새 클래스를 도입한 경우 처럼 보이지만<br>사용자 모드 스레드 개체에 위임하는 currentThread()일종의 래퍼 개체를 반환해야 합니다 .Thread</p>
<p>두 개체가 현재 실행 스레드를 나타내는 것은 혼란스러울 수 있으므로 결국 이전 ThreadAPI를 유지하는 것이 큰 장애물이 아니라는 결론을 내렸습니다.<br>와 같은 몇 가지 방법을 제외하고 개발자는 API를 직접 currentThread()사용하는 경우가 거의 없습니다 .<br>Thread그들은 주로 ExecutorService. 시간이 지남에 따라 더 이상 사용되지 않는 메서드 를 사용하지 않고 제거하여 Thread클래스 및<br>관련 클래스 에서 불필요한 짐을 버릴 것입니다 .ThreadGroup</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><ul>
<li>기존 테스트는 여기에서 제안하는 변경 사항이 실행되는 다양한 구성 및 실행 모드에서 예기치 않은 회귀를 일으키지 않도록 합니다.</li>
<li>jtreg가상 스레드 컨텍스트에서 기존 테스트를 실행할 수 있도록 테스트 도구를 확장할 것입니다 . 이렇게 하면 많은 테스트의 두 가지 버전이 필요하지 않습니다.</li>
<li>새로운 테스트는 모든 신규 및 수정된 API와 가상 스레드를 지원하도록 변경된 모든 영역을 실행합니다.</li>
<li>새로운 스트레스 테스트는 안정성과 성능에 중요한 영역을 대상으로 합니다.</li>
<li>새로운 마이크로벤치마크는 성능이 중요한 영역을 대상으로 합니다.</li>
<li>대규모 테스트를 위해 Helidon 및 Jetty를 포함한 여러 기존 서버를 사용할 것입니다.</li>
</ul>
<h2 id="Risks-and-Assumptions"><a href="#Risks-and-Assumptions" class="headerlink" title="Risks and Assumptions"></a>Risks and Assumptions</h2><p>이 제안의 주요 위험은 기존 API 및 해당 구현의 변경으로 인한 호환성 위험입니다.</p>
<p>java.io.BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter, PrintStream및 클래스 에서 사용되는 내부(및 문서화되지 않은)<br>잠금 프로토콜에 대한 개정은 PrintWriterI&#x2F;O 메서드가 호출되는 스트림에서 동기화된다고 가정하는 코드에 영향을 줄 수 있습니다.<br>이러한 변경 사항은 이러한 클래스를 확장하고 슈퍼클래스에 의한 잠금을 가정하는 코드에 영향을 주지 않으며<br>해당 API에서 노출하는 잠금 개체를 확장 java.io.Reader하거나 사용하는 코드에도 영향을 주지 않습니다 .java.io.Writer</p>
<p>java.lang.ThreadGroup더 이상 스레드 그룹이 파괴 되는 것을 허용하지 않으며 더 이상 데몬<br>스레드 그룹 의 개념을 지원하지 않으며 해당 suspend(), resume()및 stop()메소드는 항상 예외를 발생시킵니다.</p>
<p>다음은 확장하는 코드에 영향을 미칠 수 있는 몇 가지 소스 비호환 API 변경 사항과 하나의 바이너리 비호환 변경 사항입니다 java.lang.Thread.</p>
<ul>
<li>기존 소스 파일의 코드가 확장되고 Thread하위 클래스의 메서드가 새 Thread메서드와 충돌하는 경우 파일은 변경 없이 컴파일되지 않습니다.</li>
<li>Thread.Builder중첩 인터페이스로 추가됩니다. 기존 소스 파일의 코드가 를 확장하고 라는<br>Thread클래스를 가져오고 Builder하위 클래스의 코드가 “빌더”를 단순 이름으로 참조하는 경우 파일은 변경 없이 컴파일되지 않습니다.</li>
<li>Thread.threadId()스레드의 식별자를 반환하는 최종 메서드로 추가됩니다. 기존 소스 파일의 코드가 확장되고<br>Thread하위 클래스가 매개 변수 없이 명명된 메서드를 선언하면 threadId컴파일되지 않습니다.<br>확장하는 기존 컴파일된 코드가 있고 하위 클래스가 반환 유형이 있고 매개 변수가 없는 Thread이름의 메서드를 정의하는 경우<br>하위 클래스가 로드되면 런타임에 throw됩니다.threadIdlongIncompatibleClassChangeError</li>
</ul>
<p>가상 스레드 또는 새 API를 활용하는 최신 코드와 기존 코드를 혼합할 때 플랫폼 스레드와 가상 스레드 간의 몇 가지 동작 차이가 관찰될 수 있습니다.</p>
<ul>
<li><p>이 Thread.setPriority(int)방법은 항상 우선 순위가 있는 가상 스레드에 영향을 주지 않습니다 Thread.NORM_PRIORITY.</p>
</li>
<li><p>이 Thread.setDaemon(boolean)메서드는 항상 데몬 스레드인 가상 스레드에 영향을 주지 않습니다.</p>
</li>
<li><p>스레드 . stop(), suspend()및 메서드는 가상 스레드에서 호출될 때 resume()발생합니다 .UnsupportedOperationException</p>
</li>
<li><p>API Thread는 스레드 로컬 변수를 지원하지 않는 스레드 생성을 지원합니다.<br>스레드 로컬을 지원하지 않는 스레드 컨텍스트에서 호출될 때 ThreadLocal.set(T)throw Thread.setContextClassLoader(ClassLoader)합니다<br>.UnsupportedOperationException</p>
</li>
<li><p>Thread.getAllStackTraces()이제 모든 스레드의 맵이 아닌 모든 플랫폼 스레드의 맵을 반환합니다.</p>
</li>
<li><p>java.net.Socket, ServerSocket및 에 의해 정의된 차단 I&#x2F;O 메서드는 DatagramSocket이제 가상 스레드 컨텍스트에서 호출될 때 인터럽트할 수 있습니다.<br>기존 코드는 소켓 작업에서 차단된 스레드가 중단되어 스레드를 깨우고 소켓을 닫을 때 중단될 수 있습니다.</p>
</li>
<li><p>가상 스레드는 의 활성 구성원이 아닙니다 ThreadGroup. Thread.getThreadGroup()가상 스레드에서 호출하면 “VirtualThreads” 비어 있는 더미 그룹이 반환됩니다.</p>
</li>
<li><p>가상 스레드는 세트로 실행할 때 권한이 없습니다 SecurityManager.</p>
</li>
<li><p>JVM TI에서 GetAllThreads및 GetAllStackTraces함수는 가상 스레드를 반환하지 않습니다.<br>ThreadStart및 이벤트를 활성화하는 기존 에이전트는 ThreadEnd 이벤트를 플랫폼 스레드로 제한하는 기능이 없기 때문에 성능 문제가 발생할 수 있습니다.</p>
</li>
<li><p>API java.lang.management.ThreadMXBean는 플랫폼 스레드의 모니터링 및 관리를 지원하지만 가상 스레드는 지원하지 않습니다.</p>
</li>
<li><p>플래그 -XX:+PreserveFramePointer는 가상 스레드 성능에 크게 부정적인 영향을 미칩니다.</p>
</li>
</ul>
<h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><ul>
<li><p>JDK 18의 JEP 416(Reimplement Core Reflection with Method Handles)은 VM 네이티브 리플렉션 구현을 제거했습니다.<br>이렇게 하면 메서드가 반사적으로 호출될 때 가상 스레드가 정상적으로 주차할 수 있습니다.</p>
</li>
<li><p>JDK 13의 JEP 353(레거시 소켓 API 재구현) 및 JDK 15의 JEP 373(레거시 DatagramSocket API 재구현)은java.net.Socket , ServerSocket및 의<br>구현을 DatagramSocket가상 스레드와 함께 사용하도록 설계된 새 구현으로 대체했습니다.</p>
</li>
<li><p>JDK 18의 JEP 418(Internet-Address Resolution SPI)은 호스트 이름 및 주소 조회를 위한 서비스 공급자 인터페이스를 정의했습니다.<br>이렇게 하면 타사 라이브러리가 java.net.InetAddress호스트 조회 중에 스레드를 고정하지 않는 대체 해결 프로그램을 구현할 수 있습니다.</p>
</li>
</ul>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><hr>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://openjdk.java.net/jeps/425">JEP_425</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../tags/jdk-19/">jdk 19</a><a class="post-meta__tags" href="../../../tags/JEP-425/">JEP 425</a><a class="post-meta__tags" href="../../../tags/Virtual-Threads-Preview/">Virtual Threads (Preview)</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../2023-04-24-The_Pragmatic_Programmer_02/"><i class="fa fa-chevron-left">  </i><span>실용주의 프로그래머 20주년 기념판 3장</span></a></div><div class="next-post pull-right"><a href="../2023-04-09-The_Pragmatic_Programmer_01/"><span>실용주의 프로그래머 20주년 기념판 1장 ~ 2장</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://sejoung.github.io/2023/04/2023-04-13-JEP_425/';
  this.page.identifier = '2023/04/2023-04-13-JEP_425/';
  this.page.title = 'JEP 425: Virtual Threads (Preview)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'kimsejoung' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://kimsejoung.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg/1024px-Van_Gogh_-_Terrasse_des_Caf%C3%A9s_an_der_Place_du_Forum_in_Arles_am_Abend1.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2026 By sejoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="../../../js/third-party/anime.min.js"></script><script src="../../../js/third-party/jquery.min.js"></script><script src="../../../js/third-party/jquery.fancybox.min.js"></script><script src="../../../js/third-party/velocity.min.js"></script><script src="../../../js/third-party/velocity.ui.min.js"></script><script src="../../../js/utils.js?version=1.7.0"></script><script src="../../../js/fancybox.js?version=1.7.0"></script><script src="../../../js/sidebar.js?version=1.7.0"></script><script src="../../../js/copy.js?version=1.7.0"></script><script src="../../../js/fireworks.js?version=1.7.0"></script><script src="../../../js/transition.js?version=1.7.0"></script><script src="../../../js/scroll.js?version=1.7.0"></script><script src="../../../js/head.js?version=1.7.0"></script><script src="../../../js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>