---
layout: post
title: "CHAPTER 2 리스트와 딕셔너리"
date: 2024-10-18 21:27 +0900
comments: true
tags: [ "파이썬 코딩의 기술", "Effective Python" ]
categories: [ "books" ]
sitemap:
    changefreq: daily
    priority: 1.0
---

# 2장 리스트와 딕셔너리
리스트는 아주 간편하며 다양한 문제를 해결하는데 사용
리스트를 자연스럽게 보완할수 있는 타입이 딕셔너리 타입이다

딕셔너리 타입은 일반적으로 해시 테이블이나 연관 배열이라고 부르는 데이터 구조 안에 값을 저장

## Better way 11 시퀀스를 슬라이싱하는 방법을 익혀라

* 슬라이싱 구문의 기본 형태는 리스트[시작:끝] 이다

```
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('가운데 2개:', a[3:5])
```

```
assert a[:5] == a[0:5]
assert a[5:] == a[5:len(a)]
```

* 슬라이싱한 결과는 완전히 새로운 리스트 원래 리스트는 그대로 유지 된다.
* 슬라이싱한 리스트를 변경해도 원래 리스트는 변경되지 않는다

* 슬라이싱 할때는 간결하게 하라 시작 인덱스에 0을 넣거나, 끝 인덱스에 시퀀스 길이를 넣지 말라


## Better way 12 스트라이드와 슬라이스를 한 식에 함께 사용하지 말라

* 파이썬은 리스트[시작:끝:증가값]으로 일정한 간격을 두고 슬라이싱을 할 수 있는 특별한 구문을 제공한다

* 슬라이스에 시작, 끝, 증가값을 함께 지정하면 코드의 의미를 혼동하기 쉽다
* 시작이나 끝 인덱스가 없는 슬라이스를 만들 때는 양수 증가값을 사용하라 가급적 음수 증가값을 피하라
* 한슬라이스 안에서 시작, 끝, 증가값을 함께 사용하지 말라 세 파라미터를 모두 써야 하는 경우 두번 대입을
    사용하거나 itertools.islice를 사용하라


## Better way 13 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라

```python

car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
car_ages_descending = sorted(car_ages, reverse=True)

```
아래 코드는 시작적으로 노이즈가 많다
그래서 인덱스에 대한 오류를 만들어 내기 쉽다
```python

oldest = car_ages_descending[0]
second_oldest = car_ages_descending[1]
ohers = car_ages_descending[2:]

```

이런 상황을 더 잘 다룰 수 있도록 파이썬은 별표식을 사용해 모든 값을 담는 언패킹을 할 수 있게 지원 한다

```python
oldest, second_oldest, *others = car_ages_descending

```

별표식은 다른 위치에도 쓸수 있다

```python
oldest, *others, youngest = car_ages_descending
*others, second_youngest, youngest = car_ages_descending
```
한 수준의 언패킹에 별표식 2개 이상 쓸수 없다

별표식은 항상 list 인스턴스가 된다

## Better way 14 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라

* 리스트 타입에 들어 있는 sort 메서드를 사용하면 원소 타입이 문자열 정수 튜플 등로가 같은 내장 타입인 경우 자연스러운 순서로 리스트의 원소를 정렬할 수 있다
* 원소 타입에 특별 메서드를 통해 자연스러운 순서가 정의되 있지 않으면 sort 메서드는 예외를 일으킨다
* sort 메서드에서 key 파라미터를 사용하면 리스트의 각 원소 대신 비교에 사용할 객체를 반환하는 도우미 함수를 제공할 수 있다
* key 함수에서 튜플을 반환하면 여러 정렬 기준을 하나로 역을수 있다


## Better way 15 딕셔너리 삽입 순서에 의존할 때는 조심하라

* 파이썬 3.6 이전에는 딕셔너리의 순서가 삽입 순서에 의존하지 않는다는 사실을 명시적으로 문서화하지 않았다
* 파이썬 3.7부터는 딕셔너리의 순서가 삽입 순서에 의존한다는 사실을 문서화했다
* 파이썬은 dict는 아니지만 딕셔너리와 비슷한 객체를 쉽게 만들 수 있게 해준다
* 딕셔너리와 비슷한 클래스를 조심스럽게 다루는 방법은 
  * dict 인스턴스의 삽입 순서에 의존하지 않는 방법
  * 실행 시점에 명시적으로 타입검사를 하는것
  * 타입 애너테이션과 정적 분석을 사용해 dict 값을 요구하는 법

## Better way 16 in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라
* 딕셔너리가 없는 경우를 처리하는 방법으로 in식을 사용하는 방법 keyError를 처리하는 방법으로 get을 사용하는 방법이 있다
* 카운터와 같이 기본적인 타입의 값이 들어가는 딕셔너리를 다룰 때는 get 메서드를 사용하는 것이 더 깔끔하다
* setdefault 메서드 대신 defaultdict를 사용하면 더 간결하게 딕셔너리를 다룰 수 있다

## Better way 17 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라
* 키로 어떤 값이 들어올지 모르는 딕셔너리를 관리해야 하는데 collections.defaultdict를 사용하면 편리하다
* 임의의 키가 들어 있는 딕셔너리가 여러분에게 전달됐고 그 딕셔너리가 어떻게 생성됐는지 모르는 경우, defaultdict를 사용하면 편리하다

## Better way 18 __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라
* 디폴드 값을 만드는 계산 비용이 높거나 만드는 과정에서 예외가 발생할 수 있는 상황에서는 dict의 setdefault 메서드를 사용하지 말라
* 디폴트 키를 만들때 어떤 키를 사용했는지 반드시 알아야 하는 상황이라면 직접 dict의 하위 클래스와 __missing__ 메서드를 정의하라

# 참조
-----

* [Effective Python 2nd 파이썬 코딩의 기술(개정2판) 똑똑하게 코딩하는 법](https://www.yes24.com/Product/Goods/94197582)
