---
layout: post
title: "켄트백의 구현패턴-메소드(1)"
date: 2020-01-02 17:42 +0900
comments: true
tags : ["켄트백의 구현패턴","Implementation Patterns","메소드"]
categories : ["books"]
sitemap :
  changefreq : daily
  priority : 1.0
---

## 메소드

로직은 하나의 덩어리가 아닌 여러 개의 메소드로 구성된다.
개념적으로 임의의 프로그램은 복잡한 제어 흐름이 들어 있는 커다란 루틴이라 볼수 있다.

가장 큰 문제는 코드를 읽기 어렵다는 것이다. 거대한 루틴으로 작성하면 코드 재사용이 어렵다.
프로그래밍 도중에 같은 기능을 구현하는 쪽을 분리하는 것도 어렵다.

프로그램 로직을 여러개의 메소드로 나누면 로직 간의 연관성을 나타낼수 있다.

메소드를 클래스로 나누고 클래스를 다시 패키지 단위로 나누면 더 많은 정보를 전달하게 된다.

장점

* 세부구현과 상관 없이 로직의 목적이 무엇인지 알수 있다.
* 메소드 이름만으로도 자신이 원하는 정보를 얻을 수 있다.
* 재사용 문제를 해결할수 있다.
* 로직을 메소드로 잘 나누기 위해서 시간,에너지,창조력이 필요하다.

프로그램을 메소드로 나누는데 신경 써야 할 요소로는 메소드의 크기, 목적, 이름 등이 있다.

메소드 관련 패턴

* 조합 메소드 - 다른 메소드에 대한 호출로 메소드를 작성
* 의도 제시형 이름 - 메소드가 의도하는 바를 나타내는 이름을 사용
* 메소드 가시성 - 메소드는 가급적 전용
* 메소드 객체 - 복잡한 메소드는 새로운 객체로 바꾼다.
* 오버라이드 메소드 - 특화를 나타내기 위해 오버라이드를 사용
* 오버로드 메소드 - 같은 연산에 대해 다른 인터페이스를 제공한다.
* 메소드 반환 타입 - 반환 타입에는 가급적 가장 일반적인 타입을 사용
* 메소드 주석 - 코드 자체에서 쉽게 얻을수 없는 정보는 주석을 통해 나타냄
* 도우미 메소드 - 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용
* 디버그 출력 메소드 - toString()을 사용해서 유용한 디버그 관련 정보를 출력
* 변환 - 객체 형변환은 명확하게 표현
* 변환 메소드 - 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공
* 변환 생성자 - 대부분의 변환에 대해서는 원복 객체를 인자로 취하는 변환될 객체의 생성자를 제공
* 생성 - 객체 생성을 명확히 표현
* 완결 생성자 - 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
* 공장 메소드 - 좀더 복잡한 객체를 생성할 때 생성자 대신 정적 메소드를 사용


# 참조
-----


