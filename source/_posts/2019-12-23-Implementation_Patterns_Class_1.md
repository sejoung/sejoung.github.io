---
layout: post
title: "켄트백의 구현패턴-클래스(1)"
date: 2019-12-23 15:33 +0900
comments: true
tags : ["켄트백의 구현패턴","Implementation Patterns","클래스"]
categories : ["books"]
sitemap :
  changefreq : daily
  priority : 1.0
---

## 클래스

플라톤은 현실 세계에 존재하는 것은 클래스의 인스턴스일 뿐이라고 이야기했다.

* 클래스 - "이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다."
* 단순한 상위클래스 이름 - 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다.
* 한정적 하위클래스 이름 - 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다.
* 추상 인터페이스 - 인터페이스와 구현을 분리
* 인터페이스 - 자주변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
* 버전 인터페이스 - 하위 인터페이스를 사용해 기존 인터페이스를 안전하게 확장
* 추상 클래스 - 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
* 값 객체 - 산술 값처럼 동작하는 객체를 사용한다.
* 특화 - 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
* 하위클래스 - 1차원적 변화는 하위클래스를 사용해서 표현한다.
* 구현자 - 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.
* 내부클래스 - 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아전용 클래스로 사용한다.
* 인스턴스별 행동 - 인스턴스에 따라 로직에 변화를 준다.
* 조건문 - 명시적 조건에 따라 로직에 변화를 준다.
* 위임 - 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다.
* 플러그인 선택자 - 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다.
* 익명 내부 클래스 - 필요한 메소드에서 한두 개의 메소드만 오버라이드 하는 객체를 만들어 사용한다.
* 라이브러리 클래스 - 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.

### 클래스

클래스를 사용하는 기본 이유는 데이터가 로직에 비해 빈번하게 변화가기 때문이다.

클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것이다. 클래스의 계층의 사용은 상위클래스의 코드를 모두 하위클래스에 붙여 넣는 것과 같다.

하위 클래스를 생성하는것은 상위클래스와 비슷하지만 약간 다르다

### 단순한 상위클래스 이름

좀더 정확한 의미를 전달하기 위해 몇개의 단어를 사용해야 하는 경우도 있는데 이러한 딜레마에서 벗어나는 방법은 메타포를 사용하는 것이다.
좋은 이름을 찾는것은 어려운일이다. 중욯나 클래스에 대해서는 한단어로 된 이름을 사용하는 것이 좋다.

### 한정적 하위클래스 이름

하위클래스 이름은 상위클래스와 유사점과 차이점을 나타내야 한다.
클래스의 이름은 코드의 내용을 반영해야 한다.

### 추상 인터페이스

인터페이스란 구현이 빠진 여러 연산의 집합

자바가 제공하는 추상 인터페이스에 대한 두가지 메커니즘인 상위클래스와 자바 인터페이스는 소프트웨어 수정시 서로 다른 형태로 비용이 발생한다.

### 인터페이스

인터페이스는 필드를 배제하고 연산만을 나타내므로 사용자는 구현이 변경되더라도 신경쓸 필요가 없다.

인터페이스를 사용해서 커뮤니케이션이 방해가 되는 한가지 요인이 있다면 모든 연산이 공용이어야 한다는 점이다.

### 추상 클래스

자바에서 추상 인터페이스와 실제 구현의 차이를 나타내는 다른 방법은 상위클래스를 사용하는 것이다.
여기서 상위클래스는 런타임에 어떤 하위클래스로 교체될지도 모른다는 의미에서 추상적이다.

인터페이스는 기본 구현을 사용할수 없지만 추상클래스는 기본구현을 사용할수 있다.
추상 클래스의 단점은 각 클래스가 단 1개의 상위클래스만을 지정할 수있다는 것이다.

### 버전 인터페이스

인터페이스를 사용하면 구현을 쉽게 바꿀 수 있지만 인터페이스 자체는 바꾸기 매우 어렵다.

그럴때는 확장을 한후에 instantsof를 통해 비교후 사용하는 방법을 추천한다.

### 값 객체

함수형 스타일 연산은 상태를 변화시키지 않고 새로운 값을 생성한다.
일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고 상황이 변하는 경우라면 상태를 사용하는 편이 낫다.

값 스타일 객체를 사용할 때의 문제점은 성능이다. 하지만 대부분의 프로그램은 전체 성능의 병목 지점이 아니므로 이 주장은 큰 설득력이 없다.

### 특화

가장 간단한 변형은 상태만 바꾸는 것이다.
가장 복잡한 변형은 로직 자체를 완전히 바꾸는 것이다. 

대부분의 브로그래밍은 두가지의 극단적 변형 사이에 존재한다.


# 참조
-----


