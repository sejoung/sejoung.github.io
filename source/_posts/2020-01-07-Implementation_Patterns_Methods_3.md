---
layout: post
title: "켄트백의 구현패턴-메소드(3)"
date: 2020-01-07 17:50 +0900
comments: true
tags : ["켄트백의 구현패턴","Implementation Patterns","메소드"]
categories : ["books"]
sitemap :
  changefreq : daily
  priority : 1.0
---

## 메소드

### 오버라이드

오버라이드를 사용하면 변형 메소드를 명확하게 표현할 수 있다
상위 클래스에서 메소드를 abstract로 선언 했다면 이는 하위클래스에서 연산을 특화하라는 뜻이다.

`super.method()` 이런식에 호출을 해서 사용할수있지만 하위 클래스의 같은 이름에 메소드에서만 사용하는 것이 좋다.

제어의 흐름을 재구성해서 더이상 하위클래스와 상위 클래스 사이에서 오가는 일이 없도록 하자

### 오버로드

서로 다른 파라미터를 사용해서 같은 메소드를 선언하면 이 메소드를 사용할 수있는 다양한 포멧이 존재한다는 의미

메소드 오버로드는 파라미터 타입만 다를 뿐 같은 연산을 수행해야 한다. 의도가 다르면 새로운 이름을 갖는 메소드를 사용하는 편이 좋다.

### 메소드 반환 타입

메소드 반환 타입은 메소드가 프로시저인지 특정 타입의 객체를 반환하는 함수인지 구별해준다.

함수를 작성할때는 의도를 나타내는 반환 타입을 사용하라.
반환 타입을 일반화하면 세부 구현을 숨길 수도 있다.

### 메소드 주석

코드만으로 분명하지 않은 정보는 주석을 사용해서 전달하라.
필요한 경우 java doc 주석을 사용해서 클래스와 메소드의 목적을 설명하라

주석을 작성하고 코드와 주석 간 일관성을 유지하기 위해서는 노력이 든다. 이러한 노력이 정당화될 수 있는 경우에만 주석을 사용하라.

자동화된 테스트를 사용하면 메소드 주석으로 표현할 수 없는 내용을 전달할수 있다.(예를 들면 잘못된 메소드 실행 순서라던지)

메소드 주석이 커뮤니케이션에 도움이 되는 최상의 선택이라면 좋은 주석을 작성하라.

### 도우미 메소드

조합 메소드를 사용하다보면 메소드가 필요해진다. 긴메소드를 여러게의 작은 메소드로 나누게 되면 짧은 도우미 메소드가 필요하다.

도우미 메소드는 보통 짧지만 어떤경우에는 아주 짧을 수도있다.

메소드 로직이 불명확해지는 경우에는 도우미 메소드를 제거하라.

도우미 메소드의 마지막 목정은 공용 구문을 제거하는 것이다.

### 디버그 출력 메소드

객체를 문자열로 나타내면 여러가지 좋은 점이 있다.

* 어떤 객체의 내용을 사용자에게 표현할때 편리
* 저장수 다시 읽어와서 사용하기에도 좋다
* 프로그래머에게 내부 구현을 표현 할 수도 있다.

toString()은 프로그래머에게 유용한 객체의 정보를 알려주기 위해서 사용하는 것이 좋다.

### 변환

변환 패턴의 목표는 프로그래머의 의도를 명확히 전달하는 것이다.

변환을 편리하게 표한 하기 위해 새로운 의존성을 만드는 것은 바람직하지 않다. 

변환의 구현은 완전히 다른 문제다. 기존 객체의 정보를 복사해서 새로운 타입의 객체를 생성할수도고
기존 객체에서 정보를 복사하지 않고 대상 객체에 대한 인터페이스를 구현할 수도 있다.
실제 변환을 하지않고 두 객체 간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드를 작성하는 것도 가능

### 변환 메소드

유사한 타입의 객체 간 변환을 표현하려 하고 필요한 변환의 수에 제한이 있다면 기존 객체의 메소드를 추가해서 변환 할수도 있다.

유사타입의 객체사이의 변환에서만 사용된다.

### 변환 생성자

변환 생성자는 원본 객체를 파라미터로 취해서 대상객체를 반환한다.
구상 클래스가 아닌 클래스를 반환해서 변환을 구현하고 싶다면 변환 생성자를 좀더 일반적인 타입으로 반환하는 공장 메소드로 표현할수 있다.

### 생성

약 50년전 프로그램은 코드와 데이터가 섞여 있는 커다란 덩어리

크기가 작은 프로그램은 큰 프로그램에 비해서 수정하기 쉽다.
프로그램 수정을 쉽게하기 위한 초기 전략은 커다란 프로그램을 수행하는 하나의 컴프터를 더작은 프로그램을 수행하는 여러개의 컴퓨터로 나누는 것이다.

의미 있는 객체 생성을 위해서 명롹하고 직접적인 표현과 유연성 사이에서 균형을 잡아야 한다.

### 완결 생성자

객체를 설정하는 방법이 여러가지라면 각 경우마다 제대로 된 객체를 반환하는 생성자를 제공하라.

생성자는 사용자를 구상 클래스로 안내해준다. 생성자를 호출하는 코드를 작성하면 바로 구상 클래스를 사용할 수 있다.

완결 생성자를 구현할 때는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 하도록하라 
앞으로 클래스를 수정하는 사람에게도 어떤부분이 변치 않는 부분인지 명확히 전달할 수 있다.

### 공장 메소드

객체 생성을 나타내는 다른 방법은 클래스의 정적 메소드를 사용하는것

### 내부공장

내부 공장은 게으른 초기화를 사용하는 경우 흔히 사용되는 패턴이다.


# 참조
-----


