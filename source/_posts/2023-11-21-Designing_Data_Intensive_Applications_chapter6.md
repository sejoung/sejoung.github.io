---
layout: post
title: "06장: 파티셔닝"
date: 2023-11-21 17:30 +0900
comments: true
tags : ["데이터 중심 애플리케이션 설계","Designing Data Intensive Applications"]
categories : ["books"]
sitemap :
  changefreq : daily
  priority : 1.0
---

# 분산 데이터
## 06장: 파티셔닝

데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다 이작업을 샤딩이라고도 한다

파티션을 나눌때 보통 각 데이터 단위가 하나의 파티션에 속한다

파티셔닝의 주된 이유 : 확장성

### 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.
각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장

한 노드에 여러 파티션을 저장할수도 있다.

### 키-값 데이터 파티셔닝

파티셔닝의 목적의 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.
파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 한다.
쏠림이 있으면 효과가 매우 떨어진다
불균형하게 부하가 높은 파티션을 핫스팟이라고 한다

핫스팟을 피하는 가장 단순한 방법은 레코드를 할당할 노드를 무작위로 선택하는것
하지만 단점이 있는데 어떤 레코드를 읽으려고 할때 해당 레코드가 어느 노드에 저장됐는지 알수없으므로 코든 노드에서 병렬적으로 질의를 실행해야 한다

* 키 범위 기준 파티셔닝
  * 각파티션에 연속된 범위의 키를 할당하는것
  * 키 범위 크기가 모두 동일할 필요는 없다
  * 데이터를 고르게 분산 시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다
  * 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다

* 키의 해시값 기준 파티셔닝
  * 쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는데 해시 함수를 사용한다
  * 좋은 해시함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다
  * 파티셔닝용 해시함수는 암호적으로 강력할 필요는 없다
  * 키를 파티션 사이에 균일하게 분산시키는데 좋다 파티션 경계는 크기가 동일하도록 나눌수도 있고 무작위에 가깝게 선택할 수도 있다 이런 기법을 일관성 해싱이라고 부른다
  * 카산드라는 두 가지 파티셔닝 전략 사이에 타협한다 복합 기본키를 지정
* 쏠린 작업부하와 핫스팟 완화
  * 유명인 문제
  * 간단한 해결책은 각키의 시작이나 끝에 임의의 숫자를 붙이는것 10진수 2개만 붙혀도 100개의 다른 키로 균등하게 분산
    * 요청수가 몰리는 소수의 키에만 적용
    * 어떤 키가 쪼개졌는지 추적할 방법도 있어야 된다


### 파티셔닝과 보조 색인

지금까지의 설명한 파티셔닝 방식은 키-값 데이터 모델에 의존한다
보조색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는 두가지 방법이 있다.

* 문서 기준 보조 색인 파티셔닝
  * 문서 ID 라고 부르는 고유 ID가 있고 해데이터베이스를 문서 ID 기준으로 파티셔닝 한다
  * 보조 색인을 만들어서 문서ID를 값으로 하는 색인을 따로 만든다
  * 지역 색인(local index)라고도 부른다
  * 지역 색인을 하기 위해서 모든 파티션에 질의를 보내서 얻은 결과를 모아야 된다
    * 스캐터/게더(scatter/gather)라고 부른다
* 용어 기준 보조 색인 파티셔닝
  * 모든 파티션의 데이터를 담당하는 전역 색인을 만들수도 있다
  * 용어기준으로 파티셔닝됐다(term-partitioned)라고 부른다
  * 읽기가 효율적이다
  * 전역 색인은 느리고 복잡하다
  * 비동기적으로 갱신됀다

### 파티션 재균형화

시간이 지나면 데이터 베이스에 변화가 생긴다
변화가 생기면 데이터와 요청이 한노드에서 다른노드로 옴겨져야 한다
이과정을 재균형화(rebalancing)라고 한다

재균형화의 기대값
* 부하가 클러스터내에 있는 노드에 균등하게 분배된다
* 재균형화 도중에도 데이터 베이스는 읽기 쓰기 요청을 받아들여야 한다
* 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옴겨지면 안된다

* 재균형화 전략
  * 쓰면 안되는 방법 : 해시값에 모드 N 연산을 실행(% 연산)
  * 파티션 갯수 고정
    * 전체 데이터셋의 크기 변동이 심하다면 적절한 파티션 개수를 정하기 어렵다
  * 동적 파티셔닝
    * 파티션의 크기가 넘어가면 파티션을 쪼개서 각각에 원래 파티션의 데이터 절반정도가 포함되게 한다 반대의 경우 합칠수도 있다
    * 파티션 갯수가 전체 데이터 용량에 맞춰 조정된다는 이점
    * 빈데이터 베이스는 파티션 경계를 어디로 정해야 되는지 정보가 없어서 하나의 파티션이라는 함정이 있다
      * 이문제를 해결하기 위해 사전분활(pre-splitting)이라는 방법을 사용한다
  * 노드 비례 파티셔닝
    * 노드당 할당되는 파티션 개수를 고정한다
    * 노드가 추가되면 고정된 갯수의 파티션을 무작위로 선택해 분할하고 각 분할 파티션의 절반은 그대로 두고 다른 절반은 새노드에 할당한다
    * 파티션의 경계를 무작위로 선택하려면 해시 기반 파티셔닝을 사용해야 한다
* 운영: 자동 재균형화와 수동 재균형화
  * 자동실행? 수동실행?
  * 완전 자동 재균형화
    * 유지보수에 손이 덜가서 편할수 있다
    * 예측이 어렵다
  * 완전수동 재균형화

### 요청 라우팅

서비스 찾기(service discovery) : 클라이언트가 요청을 보낼때 어떤 노드에 보낼지 알아야 한다

몽고 디비 : 설정서버(config server), 몽고스(mongos)

* 병렬 질의 실행
  * 대규모 병렬 처리(massively parallel processing, MPP)


### 정리

주요 파티셔닝 기법

* 키 법위 파티셔닝
* 해시 파티셔닝
* 문서 기준 파티셔닝
* 용어 기준 파티셔닝


# 참조
-----

* [데이터 중심 애플리케이션 설계](https://wikibook.co.kr/data-intensive-applications-ebook/)
