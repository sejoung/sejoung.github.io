---
layout: post
title: "Part 2 관리"
date: 2024-04-29 10:17 +0900
comments: true
tags: [ "켄트 벡의 Tidy First?", "켄트 벡", "Tidy First?" ]
categories: [ "books" ]
sitemap:
    changefreq: daily
    priority: 1.0
---

# Part 2 관리
## Chapter 16 코드 정리 구분
* 다양한 변경 필요성을 구분하지 않은 상태에서 변경 시도
* 동작 변경과 구조 변경
* 순서를 부여한 동작 변경과 구조 변경
* 별도의 pr 포함된 동작 변경과 구조 변경

## Chapter 17 연쇄적인 정리
* 보호 구분
  * 보호 구분을 통해 코드 정리를 진행하면 조건이 설명하는 도우미로 드러나거나 설명하는 변수 추출을 돕는 혜택을 얻는다
* 안 쓰는 코드
  * 코드를 읽는 순서에 맞춰 정렬하는 방법과 응집도를 높이는 배치가 보인다
* 대칭으로 맞추기
  * 대칭으로 맞추면 매우 유사한 코드들이 묶여진 순서대로 읽을수 있다
* 새로운 인터페이스로 기존 루틴 부르기
  * 하나를 정리하면 한 다발의 정리가 이러지고 뒤이어 각각의 정리가 또 다발로 이어짐
* 읽는 순서
  * 읽는 순서를 정리하면 대칭으로 맞출 기회가 생김
* 응집도를 높이는 배치
  * 응집도를 높이는 배치로 함께 묶인 요소는 하위 요소로 추출할 후보가 된다
* 설명하는 변수
  * 할당하는 문장에서 좌변이 설명하는 변수라면 그에 대응하는 우변은 설명하는 도우미 후보
* 설명하는 상수
  * 설명하는 상수 정리는 응집도를 높이는 배치를 이끔
* 명시적인 매개변수
  * 매개변수 집합을 묶어 객체로 만들고 코드를 옴길 수 있다
* 비슷한 코드끼리
* 도우미 추출
* 하나의 더미
* 설명하는 주석
* 불필요한 주석 지우기

## Chapter 18 코드 정리의 일괄 처리량
* 골디락스 딜레마(타협점을 찾아야 된다)
* 충돌
  * 일괄 처리하는 코드 정리 작업이 많을수록 통합 과정에서 지연 시간이 길어지고 코드 정리 작업이 다른 사람의 진행 중인 작업과 충돌할 가능성도 커진다
* 상호 작용
  * 코드 정리 사이에 상호작용이 있으면 병합 비용은 급격히 증가한다
* 추측
  * 한 번에 처리하는 코드 정리가 많을수록 자연스럽게 더 많은 코드를 정리하게 된다
* 실천하고 실험하세요 오류를 팀과 함께 검토
## Chapter 19 리듬
* 소프트웨어 설계는 프렉탁 이므로 설계는 크게도 작게도 할 수 있다
* 소프트웨어 설계는 길을 닦는 일의 성격이 매우 강함
* 동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있다
## Chapter 20 얽힘 풀기
* 코드 정리와 동작 변경 사이의 선후 문제는 보통 시간이 지나면 해결
## Chapter 21 코드 정리 시점
* 아예 안 한다면
  * 앞으로 다시는 코드를 변경하지 않을 때
  * 설계를 개선하더라도 배울것이 없을때
* 나중에 정리하기
  * 정리할 코드 분량이 많은데 보상이 바로 보이지 않을때
  * 코드 정리에 대한 보상이 잠재적일때
  * 작은 묶음으로 여러번에 나눠서 코드 정리를 할수 있을때
* 동작 변경 후에 코드 정리
  * 다음 코드 정리까지 기다릴수록 비용이 더 불어날때
  * 코드정리를 하지 않으면 일을 끝냈다는 느낌이 들지 않을때
* 코드 정리 후에 동작 변경
  * 코드 정리했을때 코드 이해가 쉬워지거나 동작변경이 쉬워질때
  * 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때


# 참조
-----

* [Tidy First?](https://www.yes24.com/Product/Goods/125921718)
